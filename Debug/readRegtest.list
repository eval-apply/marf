
readRegtest.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000c620  08000188  08000188  00010188  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000004  0800c7a8  0800c7a8  0001c7a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  0800c7ac  0800c7ac  0001c7ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  0800c7b4  0800c7b4  0001c7b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  0800c7b8  0800c7b8  0001c7b8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000698  20000000  0800c7bc  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ccmram       00000000  10000000  10000000  00020698  2**0
                  CONTENTS
  8 .bss          00000830  20000698  20000698  00020698  2**3
                  ALLOC
  9 ._user_heap_stack 00000400  20000ec8  20000ec8  00020698  2**0
                  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  00020698  2**0
                  CONTENTS, READONLY
 11 .debug_info   0001dea1  00000000  00000000  000206c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 00004f2d  00000000  00000000  0003e569  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000e268  00000000  00000000  00043496  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00000588  00000000  00000000  00051700  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   000093b0  00000000  00000000  00051c88  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00007e18  00000000  00000000  0005b038  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  00062e50  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00003bb8  00000000  00000000  00062ecc  2**2
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_ranges 00000050  00000000  00000000  00066a88  2**3
                  CONTENTS, READONLY, DEBUGGING
 20 .stab         00000024  00000000  00000000  00066ad8  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .stabstr      0000003f  00000000  00000000  00066afc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <__do_global_dtors_aux>:
 8000188:	b510      	push	{r4, lr}
 800018a:	4c05      	ldr	r4, [pc, #20]	; (80001a0 <__do_global_dtors_aux+0x18>)
 800018c:	7823      	ldrb	r3, [r4, #0]
 800018e:	b933      	cbnz	r3, 800019e <__do_global_dtors_aux+0x16>
 8000190:	4b04      	ldr	r3, [pc, #16]	; (80001a4 <__do_global_dtors_aux+0x1c>)
 8000192:	b113      	cbz	r3, 800019a <__do_global_dtors_aux+0x12>
 8000194:	4804      	ldr	r0, [pc, #16]	; (80001a8 <__do_global_dtors_aux+0x20>)
 8000196:	f3af 8000 	nop.w
 800019a:	2301      	movs	r3, #1
 800019c:	7023      	strb	r3, [r4, #0]
 800019e:	bd10      	pop	{r4, pc}
 80001a0:	20000698 	.word	0x20000698
 80001a4:	00000000 	.word	0x00000000
 80001a8:	0800c78c 	.word	0x0800c78c

080001ac <frame_dummy>:
 80001ac:	b508      	push	{r3, lr}
 80001ae:	4b03      	ldr	r3, [pc, #12]	; (80001bc <frame_dummy+0x10>)
 80001b0:	b11b      	cbz	r3, 80001ba <frame_dummy+0xe>
 80001b2:	4903      	ldr	r1, [pc, #12]	; (80001c0 <frame_dummy+0x14>)
 80001b4:	4803      	ldr	r0, [pc, #12]	; (80001c4 <frame_dummy+0x18>)
 80001b6:	f3af 8000 	nop.w
 80001ba:	bd08      	pop	{r3, pc}
 80001bc:	00000000 	.word	0x00000000
 80001c0:	2000069c 	.word	0x2000069c
 80001c4:	0800c78c 	.word	0x0800c78c

080001c8 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 80001c8:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 80001cc:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
 80001d0:	4b01      	ldr	r3, [pc, #4]	; (80001d8 <NVIC_PriorityGroupConfig+0x10>)
 80001d2:	60d8      	str	r0, [r3, #12]
 80001d4:	4770      	bx	lr
 80001d6:	bf00      	nop
 80001d8:	e000ed00 	.word	0xe000ed00

080001dc <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 80001dc:	78c3      	ldrb	r3, [r0, #3]
 80001de:	b95b      	cbnz	r3, 80001f8 <NVIC_Init+0x1c>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80001e0:	7803      	ldrb	r3, [r0, #0]
 80001e2:	095a      	lsrs	r2, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80001e4:	f003 031f 	and.w	r3, r3, #31
 80001e8:	2101      	movs	r1, #1
 80001ea:	fa01 f303 	lsl.w	r3, r1, r3
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80001ee:	3220      	adds	r2, #32
 80001f0:	4914      	ldr	r1, [pc, #80]	; (8000244 <NVIC_Init+0x68>)
 80001f2:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  }
}
 80001f6:	4770      	bx	lr
{
 80001f8:	b410      	push	{r4}
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 80001fa:	4b13      	ldr	r3, [pc, #76]	; (8000248 <NVIC_Init+0x6c>)
 80001fc:	68da      	ldr	r2, [r3, #12]
 80001fe:	43d2      	mvns	r2, r2
 8000200:	f3c2 2202 	ubfx	r2, r2, #8, #3
    tmppre = (0x4 - tmppriority);
 8000204:	f1c2 0304 	rsb	r3, r2, #4
 8000208:	b2dc      	uxtb	r4, r3
    tmpsub = tmpsub >> tmppriority;
 800020a:	210f      	movs	r1, #15
 800020c:	fa41 f202 	asr.w	r2, r1, r2
    tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8000210:	7843      	ldrb	r3, [r0, #1]
 8000212:	40a3      	lsls	r3, r4
 8000214:	b2db      	uxtb	r3, r3
    tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
 8000216:	7881      	ldrb	r1, [r0, #2]
 8000218:	400a      	ands	r2, r1
 800021a:	4313      	orrs	r3, r2
    tmppriority = tmppriority << 0x04;
 800021c:	011b      	lsls	r3, r3, #4
 800021e:	b2db      	uxtb	r3, r3
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8000220:	7802      	ldrb	r2, [r0, #0]
 8000222:	4908      	ldr	r1, [pc, #32]	; (8000244 <NVIC_Init+0x68>)
 8000224:	440a      	add	r2, r1
 8000226:	f882 3300 	strb.w	r3, [r2, #768]	; 0x300
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 800022a:	7803      	ldrb	r3, [r0, #0]
 800022c:	0958      	lsrs	r0, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800022e:	f003 031f 	and.w	r3, r3, #31
 8000232:	2201      	movs	r2, #1
 8000234:	fa02 f303 	lsl.w	r3, r2, r3
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8000238:	f841 3020 	str.w	r3, [r1, r0, lsl #2]
}
 800023c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000240:	4770      	bx	lr
 8000242:	bf00      	nop
 8000244:	e000e100 	.word	0xe000e100
 8000248:	e000ed00 	.word	0xe000ed00

0800024c <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 800024c:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 8000250:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8000254:	4301      	orrs	r1, r0
 8000256:	4b01      	ldr	r3, [pc, #4]	; (800025c <NVIC_SetVectorTable+0x10>)
 8000258:	6099      	str	r1, [r3, #8]
 800025a:	4770      	bx	lr
 800025c:	e000ed00 	.word	0xe000ed00

08000260 <NVIC_SystemLPConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8000260:	b929      	cbnz	r1, 800026e <NVIC_SystemLPConfig+0xe>
  {
    SCB->SCR |= LowPowerMode;
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8000262:	4a05      	ldr	r2, [pc, #20]	; (8000278 <NVIC_SystemLPConfig+0x18>)
 8000264:	6913      	ldr	r3, [r2, #16]
 8000266:	ea23 0000 	bic.w	r0, r3, r0
 800026a:	6110      	str	r0, [r2, #16]
 800026c:	4770      	bx	lr
    SCB->SCR |= LowPowerMode;
 800026e:	4b02      	ldr	r3, [pc, #8]	; (8000278 <NVIC_SystemLPConfig+0x18>)
 8000270:	691a      	ldr	r2, [r3, #16]
 8000272:	4310      	orrs	r0, r2
 8000274:	6118      	str	r0, [r3, #16]
 8000276:	4770      	bx	lr
 8000278:	e000ed00 	.word	0xe000ed00

0800027c <SysTick_CLKSourceConfig>:
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 800027c:	2804      	cmp	r0, #4
 800027e:	d005      	beq.n	800028c <SysTick_CLKSourceConfig+0x10>
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8000280:	4a05      	ldr	r2, [pc, #20]	; (8000298 <SysTick_CLKSourceConfig+0x1c>)
 8000282:	6813      	ldr	r3, [r2, #0]
 8000284:	f023 0304 	bic.w	r3, r3, #4
 8000288:	6013      	str	r3, [r2, #0]
 800028a:	4770      	bx	lr
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 800028c:	4a02      	ldr	r2, [pc, #8]	; (8000298 <SysTick_CLKSourceConfig+0x1c>)
 800028e:	6813      	ldr	r3, [r2, #0]
 8000290:	f043 0304 	orr.w	r3, r3, #4
 8000294:	6013      	str	r3, [r2, #0]
 8000296:	4770      	bx	lr
 8000298:	e000e010 	.word	0xe000e010

0800029c <ADC_DeInit>:
  *         values.
  * @param  None
  * @retval None
  */
void ADC_DeInit(void)
{
 800029c:	b508      	push	{r3, lr}
  /* Enable all ADCs reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, ENABLE);
 800029e:	2101      	movs	r1, #1
 80002a0:	f44f 7080 	mov.w	r0, #256	; 0x100
 80002a4:	f004 fb8e 	bl	80049c4 <RCC_APB2PeriphResetCmd>
  
  /* Release all ADCs from reset state */
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC, DISABLE);
 80002a8:	2100      	movs	r1, #0
 80002aa:	f44f 7080 	mov.w	r0, #256	; 0x100
 80002ae:	f004 fb89 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 80002b2:	bd08      	pop	{r3, pc}

080002b4 <ADC_Init>:
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 80002b4:	b410      	push	{r4}
  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfConversion));
  
  /*---------------------------- ADCx CR1 Configuration -----------------*/
  /* Get the ADCx CR1 value */
  tmpreg1 = ADCx->CR1;
 80002b6:	6843      	ldr	r3, [r0, #4]
  
  /* Clear RES and SCAN bits */
  tmpreg1 &= CR1_CLEAR_MASK;
 80002b8:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 80002bc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  
  /* Configure ADCx: scan conversion mode and resolution */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  /* Set RES bit according to ADC_Resolution value */ 
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 80002c0:	790c      	ldrb	r4, [r1, #4]
                                   ADC_InitStruct->ADC_Resolution);
 80002c2:	680a      	ldr	r2, [r1, #0]
  tmpreg1 |= (uint32_t)(((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8) | \
 80002c4:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
 80002c8:	4313      	orrs	r3, r2
  /* Write to ADCx CR1 */
  ADCx->CR1 = tmpreg1;
 80002ca:	6043      	str	r3, [r0, #4]
  /*---------------------------- ADCx CR2 Configuration -----------------*/
  /* Get the ADCx CR2 value */
  tmpreg1 = ADCx->CR2;
 80002cc:	6883      	ldr	r3, [r0, #8]
  
  /* Clear CONT, ALIGN, EXTEN and EXTSEL bits */
  tmpreg1 &= CR2_CLEAR_MASK;
 80002ce:	4a0c      	ldr	r2, [pc, #48]	; (8000300 <ADC_Init+0x4c>)
 80002d0:	401a      	ands	r2, r3
     continuous conversion mode */
  /* Set ALIGN bit according to ADC_DataAlign value */
  /* Set EXTEN bits according to ADC_ExternalTrigConvEdge value */ 
  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
  /* Set CONT bit according to ADC_ContinuousConvMode value */
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 80002d2:	690b      	ldr	r3, [r1, #16]
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 80002d4:	68cc      	ldr	r4, [r1, #12]
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 80002d6:	4323      	orrs	r3, r4
                        ADC_InitStruct->ADC_ExternalTrigConvEdge | \
 80002d8:	688c      	ldr	r4, [r1, #8]
                        ADC_InitStruct->ADC_ExternalTrigConv | 
 80002da:	4323      	orrs	r3, r4
                        ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 80002dc:	794c      	ldrb	r4, [r1, #5]
  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | \
 80002de:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
 80002e2:	4313      	orrs	r3, r2
                        
  /* Write to ADCx CR2 */
  ADCx->CR2 = tmpreg1;
 80002e4:	6083      	str	r3, [r0, #8]
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 80002e6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  
  /* Clear L bits */
  tmpreg1 &= SQR1_L_RESET;
 80002e8:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
  
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfConversion value */
  tmpreg2 |= (uint8_t)(ADC_InitStruct->ADC_NbrOfConversion - (uint8_t)1);
 80002ec:	7d0a      	ldrb	r2, [r1, #20]
 80002ee:	3a01      	subs	r2, #1
 80002f0:	b2d2      	uxtb	r2, r2
  tmpreg1 |= ((uint32_t)tmpreg2 << 20);
 80002f2:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
  
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1;
 80002f6:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 80002f8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80002fc:	4770      	bx	lr
 80002fe:	bf00      	nop
 8000300:	c0fff7fd 	.word	0xc0fff7fd

08000304 <ADC_StructInit>:
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;
 8000304:	2300      	movs	r3, #0
 8000306:	6003      	str	r3, [r0, #0]

  /* initialize the ADC_ScanConvMode member */
  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 8000308:	7103      	strb	r3, [r0, #4]

  /* Initialize the ADC_ContinuousConvMode member */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 800030a:	7143      	strb	r3, [r0, #5]

  /* Initialize the ADC_ExternalTrigConvEdge member */
  ADC_InitStruct->ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
 800030c:	6083      	str	r3, [r0, #8]

  /* Initialize the ADC_ExternalTrigConv member */
  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 800030e:	60c3      	str	r3, [r0, #12]

  /* Initialize the ADC_DataAlign member */
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 8000310:	6103      	str	r3, [r0, #16]

  /* Initialize the ADC_NbrOfConversion member */
  ADC_InitStruct->ADC_NbrOfConversion = 1;
 8000312:	2301      	movs	r3, #1
 8000314:	7503      	strb	r3, [r0, #20]
 8000316:	4770      	bx	lr

08000318 <ADC_CommonInit>:
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
  *         that contains the configuration information for  All ADCs peripherals.
  * @retval None
  */
void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 8000318:	b410      	push	{r4}
  assert_param(IS_ADC_PRESCALER(ADC_CommonInitStruct->ADC_Prescaler));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_SAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));
  /*---------------------------- ADC CCR Configuration -----------------*/
  /* Get the ADC CCR value */
  tmpreg1 = ADC->CCR;
 800031a:	4908      	ldr	r1, [pc, #32]	; (800033c <ADC_CommonInit+0x24>)
 800031c:	684b      	ldr	r3, [r1, #4]
  
  /* Clear MULTI, DELAY, DMA and ADCPRE bits */
  tmpreg1 &= CR_CLEAR_MASK;
 800031e:	4a08      	ldr	r2, [pc, #32]	; (8000340 <ADC_CommonInit+0x28>)
 8000320:	401a      	ands	r2, r3
     and DMA access mode for multimode */
  /* Set MULTI bits according to ADC_Mode value */
  /* Set ADCPRE bits according to ADC_Prescaler value */
  /* Set DMA bits according to ADC_DMAAccessMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8000322:	6803      	ldr	r3, [r0, #0]
                        ADC_CommonInitStruct->ADC_Prescaler | 
 8000324:	6844      	ldr	r4, [r0, #4]
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8000326:	4323      	orrs	r3, r4
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
 8000328:	6884      	ldr	r4, [r0, #8]
                        ADC_CommonInitStruct->ADC_Prescaler | 
 800032a:	4323      	orrs	r3, r4
                        ADC_CommonInitStruct->ADC_TwoSamplingDelay);
 800032c:	68c0      	ldr	r0, [r0, #12]
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
 800032e:	4303      	orrs	r3, r0
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8000330:	4313      	orrs	r3, r2
                        
  /* Write to ADC CCR */
  ADC->CCR = tmpreg1;
 8000332:	604b      	str	r3, [r1, #4]
}
 8000334:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000338:	4770      	bx	lr
 800033a:	bf00      	nop
 800033c:	40012300 	.word	0x40012300
 8000340:	fffc30e0 	.word	0xfffc30e0

08000344 <ADC_CommonStructInit>:
  * @retval None
  */
void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
 8000344:	2300      	movs	r3, #0
 8000346:	6003      	str	r3, [r0, #0]

  /* initialize the ADC_Prescaler member */
  ADC_CommonInitStruct->ADC_Prescaler = ADC_Prescaler_Div2;
 8000348:	6043      	str	r3, [r0, #4]

  /* Initialize the ADC_DMAAccessMode member */
  ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 800034a:	6083      	str	r3, [r0, #8]

  /* Initialize the ADC_TwoSamplingDelay member */
  ADC_CommonInitStruct->ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
 800034c:	60c3      	str	r3, [r0, #12]
 800034e:	4770      	bx	lr

08000350 <ADC_Cmd>:
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000350:	b921      	cbnz	r1, 800035c <ADC_Cmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
  }
  else
  {
    /* Disable the selected ADC peripheral */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_ADON);
 8000352:	6883      	ldr	r3, [r0, #8]
 8000354:	f023 0301 	bic.w	r3, r3, #1
 8000358:	6083      	str	r3, [r0, #8]
 800035a:	4770      	bx	lr
    ADCx->CR2 |= (uint32_t)ADC_CR2_ADON;
 800035c:	6883      	ldr	r3, [r0, #8]
 800035e:	f043 0301 	orr.w	r3, r3, #1
 8000362:	6083      	str	r3, [r0, #8]
 8000364:	4770      	bx	lr

08000366 <ADC_AnalogWatchdogCmd>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
  
  /* Get the old register value */
  tmpreg = ADCx->CR1;
 8000366:	6843      	ldr	r3, [r0, #4]
  
  /* Clear AWDEN, JAWDEN and AWDSGL bits */
  tmpreg &= CR1_AWDMode_RESET;
 8000368:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 800036c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  
  /* Set the analog watchdog enable mode */
  tmpreg |= ADC_AnalogWatchdog;
 8000370:	4319      	orrs	r1, r3
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
 8000372:	6041      	str	r1, [r0, #4]
 8000374:	4770      	bx	lr

08000376 <ADC_AnalogWatchdogThresholdsConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));
  
  /* Set the ADCx high threshold */
  ADCx->HTR = HighThreshold;
 8000376:	6241      	str	r1, [r0, #36]	; 0x24
  
  /* Set the ADCx low threshold */
  ADCx->LTR = LowThreshold;
 8000378:	6282      	str	r2, [r0, #40]	; 0x28
 800037a:	4770      	bx	lr

0800037c <ADC_AnalogWatchdogSingleChannelConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  
  /* Get the old register value */
  tmpreg = ADCx->CR1;
 800037c:	6843      	ldr	r3, [r0, #4]
  
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= CR1_AWDCH_RESET;
 800037e:	f023 031f 	bic.w	r3, r3, #31
  
  /* Set the Analog watchdog channel */
  tmpreg |= ADC_Channel;
 8000382:	4319      	orrs	r1, r3
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg;
 8000384:	6041      	str	r1, [r0, #4]
 8000386:	4770      	bx	lr

08000388 <ADC_TempSensorVrefintCmd>:
  */
void ADC_TempSensorVrefintCmd(FunctionalState NewState)                
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000388:	b928      	cbnz	r0, 8000396 <ADC_TempSensorVrefintCmd+0xe>
    ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
  }
  else
  {
    /* Disable the temperature sensor and Vrefint channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_TSVREFE);
 800038a:	4a06      	ldr	r2, [pc, #24]	; (80003a4 <ADC_TempSensorVrefintCmd+0x1c>)
 800038c:	6853      	ldr	r3, [r2, #4]
 800038e:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8000392:	6053      	str	r3, [r2, #4]
 8000394:	4770      	bx	lr
    ADC->CCR |= (uint32_t)ADC_CCR_TSVREFE;
 8000396:	4a03      	ldr	r2, [pc, #12]	; (80003a4 <ADC_TempSensorVrefintCmd+0x1c>)
 8000398:	6853      	ldr	r3, [r2, #4]
 800039a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800039e:	6053      	str	r3, [r2, #4]
 80003a0:	4770      	bx	lr
 80003a2:	bf00      	nop
 80003a4:	40012300 	.word	0x40012300

080003a8 <ADC_VBATCmd>:
  */
void ADC_VBATCmd(FunctionalState NewState)                             
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80003a8:	b928      	cbnz	r0, 80003b6 <ADC_VBATCmd+0xe>
    ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
  }
  else
  {
    /* Disable the VBAT channel*/
    ADC->CCR &= (uint32_t)(~ADC_CCR_VBATE);
 80003aa:	4a06      	ldr	r2, [pc, #24]	; (80003c4 <ADC_VBATCmd+0x1c>)
 80003ac:	6853      	ldr	r3, [r2, #4]
 80003ae:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 80003b2:	6053      	str	r3, [r2, #4]
 80003b4:	4770      	bx	lr
    ADC->CCR |= (uint32_t)ADC_CCR_VBATE;
 80003b6:	4a03      	ldr	r2, [pc, #12]	; (80003c4 <ADC_VBATCmd+0x1c>)
 80003b8:	6853      	ldr	r3, [r2, #4]
 80003ba:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80003be:	6053      	str	r3, [r2, #4]
 80003c0:	4770      	bx	lr
 80003c2:	bf00      	nop
 80003c4:	40012300 	.word	0x40012300

080003c8 <ADC_RegularChannelConfig>:
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 80003c8:	b470      	push	{r4, r5, r6}
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_REGULAR_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 80003ca:	2909      	cmp	r1, #9
 80003cc:	d91d      	bls.n	800040a <ADC_RegularChannelConfig+0x42>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 80003ce:	68c5      	ldr	r5, [r0, #12]
    
    /* Calculate the mask to clear */
    tmpreg2 = SMPR1_SMP_SET << (3 * (ADC_Channel - 10));
 80003d0:	f1a1 040a 	sub.w	r4, r1, #10
 80003d4:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80003d8:	2607      	movs	r6, #7
 80003da:	40a6      	lsls	r6, r4
    
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 80003dc:	ea25 0506 	bic.w	r5, r5, r6
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 80003e0:	fa03 f404 	lsl.w	r4, r3, r4
    
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 80003e4:	432c      	orrs	r4, r5
    
    /* Store the new register value */
    ADCx->SMPR1 = tmpreg1;
 80003e6:	60c4      	str	r4, [r0, #12]
    
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
  }
  /* For Rank 1 to 6 */
  if (Rank < 7)
 80003e8:	2a06      	cmp	r2, #6
 80003ea:	d91a      	bls.n	8000422 <ADC_RegularChannelConfig+0x5a>
    
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
  }
  /* For Rank 7 to 12 */
  else if (Rank < 13)
 80003ec:	2a0c      	cmp	r2, #12
 80003ee:	d926      	bls.n	800043e <ADC_RegularChannelConfig+0x76>
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 80003f0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    
    /* Calculate the mask to clear */
    tmpreg2 = SQR1_SQ_SET << (5 * (Rank - 13));
 80003f2:	3a0d      	subs	r2, #13
 80003f4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80003f8:	241f      	movs	r4, #31
 80003fa:	4094      	lsls	r4, r2
    
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80003fc:	ea23 0304 	bic.w	r3, r3, r4
    
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 8000400:	fa01 f202 	lsl.w	r2, r1, r2
    
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8000404:	431a      	orrs	r2, r3
    
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 8000406:	62c2      	str	r2, [r0, #44]	; 0x2c
  }
}
 8000408:	e017      	b.n	800043a <ADC_RegularChannelConfig+0x72>
    tmpreg1 = ADCx->SMPR2;
 800040a:	6905      	ldr	r5, [r0, #16]
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 800040c:	eb01 0641 	add.w	r6, r1, r1, lsl #1
 8000410:	2407      	movs	r4, #7
 8000412:	40b4      	lsls	r4, r6
    tmpreg1 &= ~tmpreg2;
 8000414:	ea25 0504 	bic.w	r5, r5, r4
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8000418:	fa03 f406 	lsl.w	r4, r3, r6
    tmpreg1 |= tmpreg2;
 800041c:	432c      	orrs	r4, r5
    ADCx->SMPR2 = tmpreg1;
 800041e:	6104      	str	r4, [r0, #16]
 8000420:	e7e2      	b.n	80003e8 <ADC_RegularChannelConfig+0x20>
    tmpreg1 = ADCx->SQR3;
 8000422:	6b43      	ldr	r3, [r0, #52]	; 0x34
    tmpreg2 = SQR3_SQ_SET << (5 * (Rank - 1));
 8000424:	3a01      	subs	r2, #1
 8000426:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800042a:	241f      	movs	r4, #31
 800042c:	4094      	lsls	r4, r2
    tmpreg1 &= ~tmpreg2;
 800042e:	ea23 0304 	bic.w	r3, r3, r4
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 8000432:	fa01 f202 	lsl.w	r2, r1, r2
    tmpreg1 |= tmpreg2;
 8000436:	431a      	orrs	r2, r3
    ADCx->SQR3 = tmpreg1;
 8000438:	6342      	str	r2, [r0, #52]	; 0x34
}
 800043a:	bc70      	pop	{r4, r5, r6}
 800043c:	4770      	bx	lr
    tmpreg1 = ADCx->SQR2;
 800043e:	6b03      	ldr	r3, [r0, #48]	; 0x30
    tmpreg2 = SQR2_SQ_SET << (5 * (Rank - 7));
 8000440:	3a07      	subs	r2, #7
 8000442:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8000446:	241f      	movs	r4, #31
 8000448:	4094      	lsls	r4, r2
    tmpreg1 &= ~tmpreg2;
 800044a:	ea23 0304 	bic.w	r3, r3, r4
    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 800044e:	fa01 f202 	lsl.w	r2, r1, r2
    tmpreg1 |= tmpreg2;
 8000452:	431a      	orrs	r2, r3
    ADCx->SQR2 = tmpreg1;
 8000454:	6302      	str	r2, [r0, #48]	; 0x30
 8000456:	e7f0      	b.n	800043a <ADC_RegularChannelConfig+0x72>

08000458 <ADC_SoftwareStartConv>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Enable the selected ADC conversion for regular group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_SWSTART;
 8000458:	6883      	ldr	r3, [r0, #8]
 800045a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800045e:	6083      	str	r3, [r0, #8]
 8000460:	4770      	bx	lr

08000462 <ADC_GetSoftwareStartConvStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Check the status of SWSTART bit */
  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
 8000462:	6883      	ldr	r3, [r0, #8]
 8000464:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8000468:	d101      	bne.n	800046e <ADC_GetSoftwareStartConvStatus+0xc>
    bitstatus = SET;
  }
  else
  {
    /* SWSTART bit is reset */
    bitstatus = RESET;
 800046a:	2000      	movs	r0, #0
  }
  
  /* Return the SWSTART bit status */
  return  bitstatus;
}
 800046c:	4770      	bx	lr
    bitstatus = SET;
 800046e:	2001      	movs	r0, #1
 8000470:	4770      	bx	lr

08000472 <ADC_EOCOnEachRegularChannelCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8000472:	b921      	cbnz	r1, 800047e <ADC_EOCOnEachRegularChannelCmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
  }
  else
  {
    /* Disable the selected ADC EOC rising on each regular channel conversion */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_EOCS);
 8000474:	6883      	ldr	r3, [r0, #8]
 8000476:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800047a:	6083      	str	r3, [r0, #8]
 800047c:	4770      	bx	lr
    ADCx->CR2 |= (uint32_t)ADC_CR2_EOCS;
 800047e:	6883      	ldr	r3, [r0, #8]
 8000480:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000484:	6083      	str	r3, [r0, #8]
 8000486:	4770      	bx	lr

08000488 <ADC_ContinuousModeCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8000488:	b921      	cbnz	r1, 8000494 <ADC_ContinuousModeCmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
  }
  else
  {
    /* Disable the selected ADC continuous conversion mode */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_CONT);
 800048a:	6883      	ldr	r3, [r0, #8]
 800048c:	f023 0302 	bic.w	r3, r3, #2
 8000490:	6083      	str	r3, [r0, #8]
 8000492:	4770      	bx	lr
    ADCx->CR2 |= (uint32_t)ADC_CR2_CONT;
 8000494:	6883      	ldr	r3, [r0, #8]
 8000496:	f043 0302 	orr.w	r3, r3, #2
 800049a:	6083      	str	r3, [r0, #8]
 800049c:	4770      	bx	lr

0800049e <ADC_DiscModeChannelCountConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  
  /* Get the old register value */
  tmpreg1 = ADCx->CR1;
 800049e:	6843      	ldr	r3, [r0, #4]
  
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= CR1_DISCNUM_RESET;
 80004a0:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
  
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
 80004a4:	3901      	subs	r1, #1
  tmpreg1 |= tmpreg2 << 13;
 80004a6:	ea43 3341 	orr.w	r3, r3, r1, lsl #13
  
  /* Store the new register value */
  ADCx->CR1 = tmpreg1;
 80004aa:	6043      	str	r3, [r0, #4]
 80004ac:	4770      	bx	lr

080004ae <ADC_DiscModeCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80004ae:	b921      	cbnz	r1, 80004ba <ADC_DiscModeCmd+0xc>
    ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_DISCEN);
 80004b0:	6843      	ldr	r3, [r0, #4]
 80004b2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80004b6:	6043      	str	r3, [r0, #4]
 80004b8:	4770      	bx	lr
    ADCx->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 80004ba:	6843      	ldr	r3, [r0, #4]
 80004bc:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80004c0:	6043      	str	r3, [r0, #4]
 80004c2:	4770      	bx	lr

080004c4 <ADC_GetConversionValue>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
 80004c4:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
 80004c6:	b280      	uxth	r0, r0
 80004c8:	4770      	bx	lr

080004ca <ADC_GetMultiModeConversionValue>:
  *           Data[31:16]: these bits contain alternatively the regular data of ADC2, ADC1 and ADC3.           
  */
uint32_t ADC_GetMultiModeConversionValue(void)
{
  /* Return the multi mode conversion value */
  return (*(__IO uint32_t *) CDR_ADDRESS);
 80004ca:	4b01      	ldr	r3, [pc, #4]	; (80004d0 <ADC_GetMultiModeConversionValue+0x6>)
 80004cc:	6818      	ldr	r0, [r3, #0]
}
 80004ce:	4770      	bx	lr
 80004d0:	40012308 	.word	0x40012308

080004d4 <ADC_DMACmd>:
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80004d4:	b921      	cbnz	r1, 80004e0 <ADC_DMACmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DMA);
 80004d6:	6883      	ldr	r3, [r0, #8]
 80004d8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80004dc:	6083      	str	r3, [r0, #8]
 80004de:	4770      	bx	lr
    ADCx->CR2 |= (uint32_t)ADC_CR2_DMA;
 80004e0:	6883      	ldr	r3, [r0, #8]
 80004e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80004e6:	6083      	str	r3, [r0, #8]
 80004e8:	4770      	bx	lr

080004ea <ADC_DMARequestAfterLastTransferCmd>:
void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80004ea:	b921      	cbnz	r1, 80004f6 <ADC_DMARequestAfterLastTransferCmd+0xc>
    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
  }
  else
  {
    /* Disable the selected ADC DMA request after last transfer */
    ADCx->CR2 &= (uint32_t)(~ADC_CR2_DDS);
 80004ec:	6883      	ldr	r3, [r0, #8]
 80004ee:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80004f2:	6083      	str	r3, [r0, #8]
 80004f4:	4770      	bx	lr
    ADCx->CR2 |= (uint32_t)ADC_CR2_DDS;
 80004f6:	6883      	ldr	r3, [r0, #8]
 80004f8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80004fc:	6083      	str	r3, [r0, #8]
 80004fe:	4770      	bx	lr

08000500 <ADC_MultiModeDMARequestAfterLastTransferCmd>:
  */
void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8000500:	b928      	cbnz	r0, 800050e <ADC_MultiModeDMARequestAfterLastTransferCmd+0xe>
    ADC->CCR |= (uint32_t)ADC_CCR_DDS;
  }
  else
  {
    /* Disable the selected ADC DMA request after last transfer */
    ADC->CCR &= (uint32_t)(~ADC_CCR_DDS);
 8000502:	4a06      	ldr	r2, [pc, #24]	; (800051c <ADC_MultiModeDMARequestAfterLastTransferCmd+0x1c>)
 8000504:	6853      	ldr	r3, [r2, #4]
 8000506:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800050a:	6053      	str	r3, [r2, #4]
 800050c:	4770      	bx	lr
    ADC->CCR |= (uint32_t)ADC_CCR_DDS;
 800050e:	4a03      	ldr	r2, [pc, #12]	; (800051c <ADC_MultiModeDMARequestAfterLastTransferCmd+0x1c>)
 8000510:	6853      	ldr	r3, [r2, #4]
 8000512:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000516:	6053      	str	r3, [r2, #4]
 8000518:	4770      	bx	lr
 800051a:	bf00      	nop
 800051c:	40012300 	.word	0x40012300

08000520 <ADC_InjectedChannelConfig>:
  *            @arg ADC_SampleTime_144Cycles: Sample time equal to 144 cycles	
  *            @arg ADC_SampleTime_480Cycles: Sample time equal to 480 cycles	
  * @retval None
  */
void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 8000520:	b470      	push	{r4, r5, r6}
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_INJECTED_RANK(Rank));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 8000522:	2909      	cmp	r1, #9
 8000524:	d81c      	bhi.n	8000560 <ADC_InjectedChannelConfig+0x40>
    ADCx->SMPR1 = tmpreg1;
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8000526:	6904      	ldr	r4, [r0, #16]
    /* Calculate the mask to clear */
    tmpreg2 = SMPR2_SMP_SET << (3 * ADC_Channel);
 8000528:	eb01 0641 	add.w	r6, r1, r1, lsl #1
 800052c:	2507      	movs	r5, #7
 800052e:	40b5      	lsls	r5, r6
    /* Clear the old sample time */
    tmpreg1 &= ~tmpreg2;
 8000530:	ea24 0405 	bic.w	r4, r4, r5
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 8000534:	40b3      	lsls	r3, r6
    /* Set the new sample time */
    tmpreg1 |= tmpreg2;
 8000536:	4323      	orrs	r3, r4
    /* Store the new register value */
    ADCx->SMPR2 = tmpreg1;
 8000538:	6103      	str	r3, [r0, #16]
  }
  /* Rank configuration */
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
 800053a:	6b84      	ldr	r4, [r0, #56]	; 0x38
  /* Get JL value: Number = JL+1 */
  tmpreg3 =  (tmpreg1 & JSQR_JL_SET)>> 20;
 800053c:	f3c4 5301 	ubfx	r3, r4, #20, #2
  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = JSQR_JSQ_SET << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 8000540:	1ad3      	subs	r3, r2, r3
 8000542:	b2db      	uxtb	r3, r3
 8000544:	3302      	adds	r3, #2
 8000546:	b2db      	uxtb	r3, r3
 8000548:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800054c:	221f      	movs	r2, #31
 800054e:	409a      	lsls	r2, r3
  /* Clear the old JSQx bits for the selected rank */
  tmpreg1 &= ~tmpreg2;
 8000550:	ea24 0402 	bic.w	r4, r4, r2
  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 8000554:	fa01 f303 	lsl.w	r3, r1, r3
  /* Set the JSQx bits for the selected rank */
  tmpreg1 |= tmpreg2;
 8000558:	431c      	orrs	r4, r3
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
 800055a:	6384      	str	r4, [r0, #56]	; 0x38
}
 800055c:	bc70      	pop	{r4, r5, r6}
 800055e:	4770      	bx	lr
    tmpreg1 = ADCx->SMPR1;
 8000560:	68c5      	ldr	r5, [r0, #12]
    tmpreg2 = SMPR1_SMP_SET << (3*(ADC_Channel - 10));
 8000562:	f1a1 040a 	sub.w	r4, r1, #10
 8000566:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 800056a:	2607      	movs	r6, #7
 800056c:	40a6      	lsls	r6, r4
    tmpreg1 &= ~tmpreg2;
 800056e:	ea25 0506 	bic.w	r5, r5, r6
    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
 8000572:	40a3      	lsls	r3, r4
    tmpreg1 |= tmpreg2;
 8000574:	432b      	orrs	r3, r5
    ADCx->SMPR1 = tmpreg1;
 8000576:	60c3      	str	r3, [r0, #12]
 8000578:	e7df      	b.n	800053a <ADC_InjectedChannelConfig+0x1a>

0800057a <ADC_InjectedSequencerLengthConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_LENGTH(Length));
  
  /* Get the old register value */
  tmpreg1 = ADCx->JSQR;
 800057a:	6b83      	ldr	r3, [r0, #56]	; 0x38
  
  /* Clear the old injected sequence length JL bits */
  tmpreg1 &= JSQR_JL_RESET;
 800057c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
  
  /* Set the injected sequence length JL bits */
  tmpreg2 = Length - 1; 
 8000580:	3901      	subs	r1, #1
  tmpreg1 |= tmpreg2 << 20;
 8000582:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
  
  /* Store the new register value */
  ADCx->JSQR = tmpreg1;
 8000586:	6383      	str	r3, [r0, #56]	; 0x38
 8000588:	4770      	bx	lr

0800058a <ADC_SetInjectedOffset>:
  * @param  Offset: the offset value for the selected ADC injected channel
  *          This parameter must be a 12bit value.
  * @retval None
  */
void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
{
 800058a:	b082      	sub	sp, #8
    __IO uint32_t tmp = 0;
 800058c:	2300      	movs	r3, #0
 800058e:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_OFFSET(Offset));
  
  tmp = (uint32_t)ADCx;
 8000590:	9001      	str	r0, [sp, #4]
  tmp += ADC_InjectedChannel;
 8000592:	9b01      	ldr	r3, [sp, #4]
 8000594:	4419      	add	r1, r3
 8000596:	9101      	str	r1, [sp, #4]
  
  /* Set the selected injected channel data offset */
 *(__IO uint32_t *) tmp = (uint32_t)Offset;
 8000598:	9b01      	ldr	r3, [sp, #4]
 800059a:	601a      	str	r2, [r3, #0]
}
 800059c:	b002      	add	sp, #8
 800059e:	4770      	bx	lr

080005a0 <ADC_ExternalTrigInjectedConvConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
  
  /* Get the old register value */
  tmpreg = ADCx->CR2;
 80005a0:	6883      	ldr	r3, [r0, #8]
  
  /* Clear the old external event selection for injected group */
  tmpreg &= CR2_JEXTSEL_RESET;
 80005a2:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
  
  /* Set the external event selection for injected group */
  tmpreg |= ADC_ExternalTrigInjecConv;
 80005a6:	4319      	orrs	r1, r3
  
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
 80005a8:	6081      	str	r1, [r0, #8]
 80005aa:	4770      	bx	lr

080005ac <ADC_ExternalTrigInjectedConvEdgeConfig>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_INJEC_TRIG_EDGE(ADC_ExternalTrigInjecConvEdge));
  /* Get the old register value */
  tmpreg = ADCx->CR2;
 80005ac:	6883      	ldr	r3, [r0, #8]
  /* Clear the old external trigger edge for injected group */
  tmpreg &= CR2_JEXTEN_RESET;
 80005ae:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
  /* Set the new external trigger edge for injected group */
  tmpreg |= ADC_ExternalTrigInjecConvEdge;
 80005b2:	4319      	orrs	r1, r3
  /* Store the new register value */
  ADCx->CR2 = tmpreg;
 80005b4:	6081      	str	r1, [r0, #8]
 80005b6:	4770      	bx	lr

080005b8 <ADC_SoftwareStartInjectedConv>:
void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Enable the selected ADC conversion for injected group */
  ADCx->CR2 |= (uint32_t)ADC_CR2_JSWSTART;
 80005b8:	6883      	ldr	r3, [r0, #8]
 80005ba:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80005be:	6083      	str	r3, [r0, #8]
 80005c0:	4770      	bx	lr

080005c2 <ADC_GetSoftwareStartInjectedConvCmdStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Check the status of JSWSTART bit */
  if ((ADCx->CR2 & ADC_CR2_JSWSTART) != (uint32_t)RESET)
 80005c2:	6883      	ldr	r3, [r0, #8]
 80005c4:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 80005c8:	d101      	bne.n	80005ce <ADC_GetSoftwareStartInjectedConvCmdStatus+0xc>
    bitstatus = SET;
  }
  else
  {
    /* JSWSTART bit is reset */
    bitstatus = RESET;
 80005ca:	2000      	movs	r0, #0
  }
  /* Return the JSWSTART bit status */
  return  bitstatus;
}
 80005cc:	4770      	bx	lr
    bitstatus = SET;
 80005ce:	2001      	movs	r0, #1
 80005d0:	4770      	bx	lr

080005d2 <ADC_AutoInjectedConvCmd>:
void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80005d2:	b921      	cbnz	r1, 80005de <ADC_AutoInjectedConvCmd+0xc>
    ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JAUTO);
 80005d4:	6843      	ldr	r3, [r0, #4]
 80005d6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80005da:	6043      	str	r3, [r0, #4]
 80005dc:	4770      	bx	lr
    ADCx->CR1 |= (uint32_t)ADC_CR1_JAUTO;
 80005de:	6843      	ldr	r3, [r0, #4]
 80005e0:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80005e4:	6043      	str	r3, [r0, #4]
 80005e6:	4770      	bx	lr

080005e8 <ADC_InjectedDiscModeCmd>:
void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80005e8:	b921      	cbnz	r1, 80005f4 <ADC_InjectedDiscModeCmd+0xc>
    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    ADCx->CR1 &= (uint32_t)(~ADC_CR1_JDISCEN);
 80005ea:	6843      	ldr	r3, [r0, #4]
 80005ec:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80005f0:	6043      	str	r3, [r0, #4]
 80005f2:	4770      	bx	lr
    ADCx->CR1 |= (uint32_t)ADC_CR1_JDISCEN;
 80005f4:	6843      	ldr	r3, [r0, #4]
 80005f6:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80005fa:	6043      	str	r3, [r0, #4]
 80005fc:	4770      	bx	lr

080005fe <ADC_GetInjectedConversionValue>:
  *            @arg ADC_InjectedChannel_3: Injected Channel3 selected
  *            @arg ADC_InjectedChannel_4: Injected Channel4 selected
  * @retval The Data conversion value.
  */
uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
{
 80005fe:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8000600:	2300      	movs	r3, #0
 8000602:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));

  tmp = (uint32_t)ADCx;
 8000604:	9001      	str	r0, [sp, #4]
  tmp += ADC_InjectedChannel + JDR_OFFSET;
 8000606:	9b01      	ldr	r3, [sp, #4]
 8000608:	4419      	add	r1, r3
 800060a:	3128      	adds	r1, #40	; 0x28
 800060c:	9101      	str	r1, [sp, #4]
  
  /* Returns the selected injected channel conversion data value */
  return (uint16_t) (*(__IO uint32_t*)  tmp); 
 800060e:	9b01      	ldr	r3, [sp, #4]
 8000610:	6818      	ldr	r0, [r3, #0]
}
 8000612:	b280      	uxth	r0, r0
 8000614:	b002      	add	sp, #8
 8000616:	4770      	bx	lr

08000618 <ADC_ITConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT)); 

  /* Get the ADC IT index */
  itmask = (uint8_t)ADC_IT;
 8000618:	b2c9      	uxtb	r1, r1
  itmask = (uint32_t)0x01 << itmask;    
 800061a:	2301      	movs	r3, #1
 800061c:	fa03 f101 	lsl.w	r1, r3, r1

  if (NewState != DISABLE)
 8000620:	b922      	cbnz	r2, 800062c <ADC_ITConfig+0x14>
    ADCx->CR1 |= itmask;
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->CR1 &= (~(uint32_t)itmask);
 8000622:	6843      	ldr	r3, [r0, #4]
 8000624:	ea23 0101 	bic.w	r1, r3, r1
 8000628:	6041      	str	r1, [r0, #4]
 800062a:	4770      	bx	lr
    ADCx->CR1 |= itmask;
 800062c:	6843      	ldr	r3, [r0, #4]
 800062e:	4319      	orrs	r1, r3
 8000630:	6041      	str	r1, [r0, #4]
 8000632:	4770      	bx	lr

08000634 <ADC_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));

  /* Check the status of the specified ADC flag */
  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
 8000634:	6803      	ldr	r3, [r0, #0]
 8000636:	4219      	tst	r1, r3
 8000638:	d101      	bne.n	800063e <ADC_GetFlagStatus+0xa>
    bitstatus = SET;
  }
  else
  {
    /* ADC_FLAG is reset */
    bitstatus = RESET;
 800063a:	2000      	movs	r0, #0
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
}
 800063c:	4770      	bx	lr
    bitstatus = SET;
 800063e:	2001      	movs	r0, #1
 8000640:	4770      	bx	lr

08000642 <ADC_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));

  /* Clear the selected ADC flags */
  ADCx->SR = ~(uint32_t)ADC_FLAG;
 8000642:	43c9      	mvns	r1, r1
 8000644:	6001      	str	r1, [r0, #0]
 8000646:	4770      	bx	lr

08000648 <ADC_GetITStatus>:
  *            @arg ADC_IT_JEOC: End of injected conversion interrupt mask
  *            @arg ADC_IT_OVR: Overrun interrupt mask                        
  * @retval The new state of ADC_IT (SET or RESET).
  */
ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
{
 8000648:	b410      	push	{r4}

  /* Get the ADC IT index */
  itmask = ADC_IT >> 8;

  /* Get the ADC_IT enable bit status */
  enablestatus = (ADCx->CR1 & ((uint32_t)0x01 << (uint8_t)ADC_IT)) ;
 800064a:	6842      	ldr	r2, [r0, #4]
 800064c:	b2cc      	uxtb	r4, r1
 800064e:	2301      	movs	r3, #1
 8000650:	40a3      	lsls	r3, r4
 8000652:	4013      	ands	r3, r2

  /* Check the status of the specified ADC interrupt */
  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
 8000654:	6802      	ldr	r2, [r0, #0]
 8000656:	ea12 2211 	ands.w	r2, r2, r1, lsr #8
 800065a:	d002      	beq.n	8000662 <ADC_GetITStatus+0x1a>
 800065c:	b92b      	cbnz	r3, 800066a <ADC_GetITStatus+0x22>
    bitstatus = SET;
  }
  else
  {
    /* ADC_IT is reset */
    bitstatus = RESET;
 800065e:	2000      	movs	r0, #0
 8000660:	e000      	b.n	8000664 <ADC_GetITStatus+0x1c>
 8000662:	2000      	movs	r0, #0
  }
  /* Return the ADC_IT status */
  return  bitstatus;
}
 8000664:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000668:	4770      	bx	lr
    bitstatus = SET;
 800066a:	2001      	movs	r0, #1
 800066c:	e7fa      	b.n	8000664 <ADC_GetITStatus+0x1c>

0800066e <ADC_ClearITPendingBit>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_IT(ADC_IT)); 
  /* Get the ADC IT index */
  itmask = (uint8_t)(ADC_IT >> 8);
  /* Clear the selected ADC interrupt pending bits */
  ADCx->SR = ~(uint32_t)itmask;
 800066e:	ea6f 2111 	mvn.w	r1, r1, lsr #8
 8000672:	6001      	str	r1, [r0, #0]
 8000674:	4770      	bx	lr
 8000676:	bf00      	nop

08000678 <CheckITStatus>:
  */
static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
{
  ITStatus pendingbitstatus = RESET;
  
  if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
 8000678:	4208      	tst	r0, r1
 800067a:	d101      	bne.n	8000680 <CheckITStatus+0x8>
    pendingbitstatus = SET;
  }
  else
  {
    /* CAN_IT is reset */
    pendingbitstatus = RESET;
 800067c:	2000      	movs	r0, #0
  }
  return pendingbitstatus;
}
 800067e:	4770      	bx	lr
    pendingbitstatus = SET;
 8000680:	2001      	movs	r0, #1
 8000682:	4770      	bx	lr

08000684 <CAN_DeInit>:
{
 8000684:	b508      	push	{r3, lr}
  if (CANx == CAN1)
 8000686:	4b0c      	ldr	r3, [pc, #48]	; (80006b8 <CAN_DeInit+0x34>)
 8000688:	4298      	cmp	r0, r3
 800068a:	d00a      	beq.n	80006a2 <CAN_DeInit+0x1e>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
 800068c:	2101      	movs	r1, #1
 800068e:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 8000692:	f004 f989 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
 8000696:	2100      	movs	r1, #0
 8000698:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 800069c:	f004 f984 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 80006a0:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
 80006a2:	2101      	movs	r1, #1
 80006a4:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 80006a8:	f004 f97e 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
 80006ac:	2100      	movs	r1, #0
 80006ae:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 80006b2:	f004 f979 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 80006b6:	bd08      	pop	{r3, pc}
 80006b8:	40006400 	.word	0x40006400

080006bc <CAN_Init>:
  CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
 80006bc:	6803      	ldr	r3, [r0, #0]
 80006be:	f023 0302 	bic.w	r3, r3, #2
 80006c2:	6003      	str	r3, [r0, #0]
  CANx->MCR |= CAN_MCR_INRQ ;
 80006c4:	6803      	ldr	r3, [r0, #0]
 80006c6:	f043 0301 	orr.w	r3, r3, #1
 80006ca:	6003      	str	r3, [r0, #0]
  uint32_t wait_ack = 0x00000000;
 80006cc:	2300      	movs	r3, #0
  while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 80006ce:	e000      	b.n	80006d2 <CAN_Init+0x16>
    wait_ack++;
 80006d0:	3301      	adds	r3, #1
  while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 80006d2:	6842      	ldr	r2, [r0, #4]
 80006d4:	f012 0f01 	tst.w	r2, #1
 80006d8:	d103      	bne.n	80006e2 <CAN_Init+0x26>
 80006da:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80006de:	4293      	cmp	r3, r2
 80006e0:	d1f6      	bne.n	80006d0 <CAN_Init+0x14>
  if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
 80006e2:	6843      	ldr	r3, [r0, #4]
 80006e4:	f013 0f01 	tst.w	r3, #1
 80006e8:	d06d      	beq.n	80007c6 <CAN_Init+0x10a>
    if (CAN_InitStruct->CAN_TTCM == ENABLE)
 80006ea:	798b      	ldrb	r3, [r1, #6]
 80006ec:	2b01      	cmp	r3, #1
 80006ee:	d03b      	beq.n	8000768 <CAN_Init+0xac>
      CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
 80006f0:	6803      	ldr	r3, [r0, #0]
 80006f2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80006f6:	6003      	str	r3, [r0, #0]
    if (CAN_InitStruct->CAN_ABOM == ENABLE)
 80006f8:	79cb      	ldrb	r3, [r1, #7]
 80006fa:	2b01      	cmp	r3, #1
 80006fc:	d039      	beq.n	8000772 <CAN_Init+0xb6>
      CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
 80006fe:	6803      	ldr	r3, [r0, #0]
 8000700:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000704:	6003      	str	r3, [r0, #0]
    if (CAN_InitStruct->CAN_AWUM == ENABLE)
 8000706:	7a0b      	ldrb	r3, [r1, #8]
 8000708:	2b01      	cmp	r3, #1
 800070a:	d037      	beq.n	800077c <CAN_Init+0xc0>
      CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
 800070c:	6803      	ldr	r3, [r0, #0]
 800070e:	f023 0320 	bic.w	r3, r3, #32
 8000712:	6003      	str	r3, [r0, #0]
    if (CAN_InitStruct->CAN_NART == ENABLE)
 8000714:	7a4b      	ldrb	r3, [r1, #9]
 8000716:	2b01      	cmp	r3, #1
 8000718:	d035      	beq.n	8000786 <CAN_Init+0xca>
      CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
 800071a:	6803      	ldr	r3, [r0, #0]
 800071c:	f023 0310 	bic.w	r3, r3, #16
 8000720:	6003      	str	r3, [r0, #0]
    if (CAN_InitStruct->CAN_RFLM == ENABLE)
 8000722:	7a8b      	ldrb	r3, [r1, #10]
 8000724:	2b01      	cmp	r3, #1
 8000726:	d033      	beq.n	8000790 <CAN_Init+0xd4>
      CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
 8000728:	6803      	ldr	r3, [r0, #0]
 800072a:	f023 0308 	bic.w	r3, r3, #8
 800072e:	6003      	str	r3, [r0, #0]
    if (CAN_InitStruct->CAN_TXFP == ENABLE)
 8000730:	7acb      	ldrb	r3, [r1, #11]
 8000732:	2b01      	cmp	r3, #1
 8000734:	d031      	beq.n	800079a <CAN_Init+0xde>
      CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
 8000736:	6803      	ldr	r3, [r0, #0]
 8000738:	f023 0304 	bic.w	r3, r3, #4
 800073c:	6003      	str	r3, [r0, #0]
    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 800073e:	788a      	ldrb	r2, [r1, #2]
                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
 8000740:	78cb      	ldrb	r3, [r1, #3]
 8000742:	061b      	lsls	r3, r3, #24
    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 8000744:	ea43 7382 	orr.w	r3, r3, r2, lsl #30
                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
 8000748:	790a      	ldrb	r2, [r1, #4]
                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
 800074a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
                ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
 800074e:	794a      	ldrb	r2, [r1, #5]
                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
 8000750:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
               ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
 8000754:	880a      	ldrh	r2, [r1, #0]
 8000756:	3a01      	subs	r2, #1
                ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
 8000758:	4313      	orrs	r3, r2
    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
 800075a:	61c3      	str	r3, [r0, #28]
    CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
 800075c:	6803      	ldr	r3, [r0, #0]
 800075e:	f023 0301 	bic.w	r3, r3, #1
 8000762:	6003      	str	r3, [r0, #0]
   wait_ack = 0;
 8000764:	2300      	movs	r3, #0
   while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 8000766:	e01e      	b.n	80007a6 <CAN_Init+0xea>
      CANx->MCR |= CAN_MCR_TTCM;
 8000768:	6803      	ldr	r3, [r0, #0]
 800076a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800076e:	6003      	str	r3, [r0, #0]
 8000770:	e7c2      	b.n	80006f8 <CAN_Init+0x3c>
      CANx->MCR |= CAN_MCR_ABOM;
 8000772:	6803      	ldr	r3, [r0, #0]
 8000774:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000778:	6003      	str	r3, [r0, #0]
 800077a:	e7c4      	b.n	8000706 <CAN_Init+0x4a>
      CANx->MCR |= CAN_MCR_AWUM;
 800077c:	6803      	ldr	r3, [r0, #0]
 800077e:	f043 0320 	orr.w	r3, r3, #32
 8000782:	6003      	str	r3, [r0, #0]
 8000784:	e7c6      	b.n	8000714 <CAN_Init+0x58>
      CANx->MCR |= CAN_MCR_NART;
 8000786:	6803      	ldr	r3, [r0, #0]
 8000788:	f043 0310 	orr.w	r3, r3, #16
 800078c:	6003      	str	r3, [r0, #0]
 800078e:	e7c8      	b.n	8000722 <CAN_Init+0x66>
      CANx->MCR |= CAN_MCR_RFLM;
 8000790:	6803      	ldr	r3, [r0, #0]
 8000792:	f043 0308 	orr.w	r3, r3, #8
 8000796:	6003      	str	r3, [r0, #0]
 8000798:	e7ca      	b.n	8000730 <CAN_Init+0x74>
      CANx->MCR |= CAN_MCR_TXFP;
 800079a:	6803      	ldr	r3, [r0, #0]
 800079c:	f043 0304 	orr.w	r3, r3, #4
 80007a0:	6003      	str	r3, [r0, #0]
 80007a2:	e7cc      	b.n	800073e <CAN_Init+0x82>
     wait_ack++;
 80007a4:	3301      	adds	r3, #1
   while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
 80007a6:	6842      	ldr	r2, [r0, #4]
 80007a8:	f012 0f01 	tst.w	r2, #1
 80007ac:	d003      	beq.n	80007b6 <CAN_Init+0xfa>
 80007ae:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80007b2:	4293      	cmp	r3, r2
 80007b4:	d1f6      	bne.n	80007a4 <CAN_Init+0xe8>
    if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
 80007b6:	6843      	ldr	r3, [r0, #4]
 80007b8:	f013 0f01 	tst.w	r3, #1
 80007bc:	d101      	bne.n	80007c2 <CAN_Init+0x106>
      InitStatus = CAN_InitStatus_Success ;
 80007be:	2001      	movs	r0, #1
}
 80007c0:	4770      	bx	lr
      InitStatus = CAN_InitStatus_Failed;
 80007c2:	2000      	movs	r0, #0
 80007c4:	4770      	bx	lr
    InitStatus = CAN_InitStatus_Failed;
 80007c6:	2000      	movs	r0, #0
 80007c8:	4770      	bx	lr

080007ca <CAN_FilterInit>:
{
 80007ca:	b470      	push	{r4, r5, r6}
  filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
 80007cc:	7a83      	ldrb	r3, [r0, #10]
 80007ce:	2201      	movs	r2, #1
 80007d0:	fa02 f303 	lsl.w	r3, r2, r3
  CAN1->FMR |= FMR_FINIT;
 80007d4:	4a3a      	ldr	r2, [pc, #232]	; (80008c0 <CAN_FilterInit+0xf6>)
 80007d6:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
 80007da:	f041 0101 	orr.w	r1, r1, #1
 80007de:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
  CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
 80007e2:	f8d2 421c 	ldr.w	r4, [r2, #540]	; 0x21c
 80007e6:	43d9      	mvns	r1, r3
 80007e8:	400c      	ands	r4, r1
 80007ea:	f8c2 421c 	str.w	r4, [r2, #540]	; 0x21c
  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
 80007ee:	7b02      	ldrb	r2, [r0, #12]
 80007f0:	b9b2      	cbnz	r2, 8000820 <CAN_FilterInit+0x56>
    CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
 80007f2:	4a33      	ldr	r2, [pc, #204]	; (80008c0 <CAN_FilterInit+0xf6>)
 80007f4:	f8d2 420c 	ldr.w	r4, [r2, #524]	; 0x20c
 80007f8:	400c      	ands	r4, r1
 80007fa:	f8c2 420c 	str.w	r4, [r2, #524]	; 0x20c
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 80007fe:	7a84      	ldrb	r4, [r0, #10]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
 8000800:	88c6      	ldrh	r6, [r0, #6]
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
 8000802:	8845      	ldrh	r5, [r0, #2]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
 8000804:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 8000808:	3448      	adds	r4, #72	; 0x48
 800080a:	f842 5034 	str.w	r5, [r2, r4, lsl #3]
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 800080e:	7a85      	ldrb	r5, [r0, #10]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 8000810:	8886      	ldrh	r6, [r0, #4]
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
 8000812:	8804      	ldrh	r4, [r0, #0]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 8000814:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 8000818:	3548      	adds	r5, #72	; 0x48
 800081a:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
 800081e:	6054      	str	r4, [r2, #4]
  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
 8000820:	7b02      	ldrb	r2, [r0, #12]
 8000822:	2a01      	cmp	r2, #1
 8000824:	d01f      	beq.n	8000866 <CAN_FilterInit+0x9c>
  if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
 8000826:	7ac2      	ldrb	r2, [r0, #11]
 8000828:	2a00      	cmp	r2, #0
 800082a:	d134      	bne.n	8000896 <CAN_FilterInit+0xcc>
    CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
 800082c:	4c24      	ldr	r4, [pc, #144]	; (80008c0 <CAN_FilterInit+0xf6>)
 800082e:	f8d4 2204 	ldr.w	r2, [r4, #516]	; 0x204
 8000832:	400a      	ands	r2, r1
 8000834:	f8c4 2204 	str.w	r2, [r4, #516]	; 0x204
  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
 8000838:	8902      	ldrh	r2, [r0, #8]
 800083a:	b92a      	cbnz	r2, 8000848 <CAN_FilterInit+0x7e>
    CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
 800083c:	4a20      	ldr	r2, [pc, #128]	; (80008c0 <CAN_FilterInit+0xf6>)
 800083e:	f8d2 4214 	ldr.w	r4, [r2, #532]	; 0x214
 8000842:	4021      	ands	r1, r4
 8000844:	f8c2 1214 	str.w	r1, [r2, #532]	; 0x214
  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
 8000848:	8902      	ldrh	r2, [r0, #8]
 800084a:	2a01      	cmp	r2, #1
 800084c:	d02a      	beq.n	80008a4 <CAN_FilterInit+0xda>
  if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
 800084e:	7b42      	ldrb	r2, [r0, #13]
 8000850:	2a01      	cmp	r2, #1
 8000852:	d02e      	beq.n	80008b2 <CAN_FilterInit+0xe8>
  CAN1->FMR &= ~FMR_FINIT;
 8000854:	4a1a      	ldr	r2, [pc, #104]	; (80008c0 <CAN_FilterInit+0xf6>)
 8000856:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 800085a:	f023 0301 	bic.w	r3, r3, #1
 800085e:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
 8000862:	bc70      	pop	{r4, r5, r6}
 8000864:	4770      	bx	lr
    CAN1->FS1R |= filter_number_bit_pos;
 8000866:	4a16      	ldr	r2, [pc, #88]	; (80008c0 <CAN_FilterInit+0xf6>)
 8000868:	f8d2 420c 	ldr.w	r4, [r2, #524]	; 0x20c
 800086c:	431c      	orrs	r4, r3
 800086e:	f8c2 420c 	str.w	r4, [r2, #524]	; 0x20c
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 8000872:	7a84      	ldrb	r4, [r0, #10]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
 8000874:	8806      	ldrh	r6, [r0, #0]
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
 8000876:	8845      	ldrh	r5, [r0, #2]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
 8000878:	ea45 4506 	orr.w	r5, r5, r6, lsl #16
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
 800087c:	3448      	adds	r4, #72	; 0x48
 800087e:	f842 5034 	str.w	r5, [r2, r4, lsl #3]
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 8000882:	7a85      	ldrb	r5, [r0, #10]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 8000884:	8886      	ldrh	r6, [r0, #4]
        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
 8000886:	88c4      	ldrh	r4, [r0, #6]
       ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
 8000888:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
 800088c:	3548      	adds	r5, #72	; 0x48
 800088e:	eb02 02c5 	add.w	r2, r2, r5, lsl #3
 8000892:	6054      	str	r4, [r2, #4]
 8000894:	e7c7      	b.n	8000826 <CAN_FilterInit+0x5c>
    CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
 8000896:	4c0a      	ldr	r4, [pc, #40]	; (80008c0 <CAN_FilterInit+0xf6>)
 8000898:	f8d4 2204 	ldr.w	r2, [r4, #516]	; 0x204
 800089c:	431a      	orrs	r2, r3
 800089e:	f8c4 2204 	str.w	r2, [r4, #516]	; 0x204
 80008a2:	e7c9      	b.n	8000838 <CAN_FilterInit+0x6e>
    CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
 80008a4:	4906      	ldr	r1, [pc, #24]	; (80008c0 <CAN_FilterInit+0xf6>)
 80008a6:	f8d1 2214 	ldr.w	r2, [r1, #532]	; 0x214
 80008aa:	431a      	orrs	r2, r3
 80008ac:	f8c1 2214 	str.w	r2, [r1, #532]	; 0x214
 80008b0:	e7cd      	b.n	800084e <CAN_FilterInit+0x84>
    CAN1->FA1R |= filter_number_bit_pos;
 80008b2:	4a03      	ldr	r2, [pc, #12]	; (80008c0 <CAN_FilterInit+0xf6>)
 80008b4:	f8d2 121c 	ldr.w	r1, [r2, #540]	; 0x21c
 80008b8:	430b      	orrs	r3, r1
 80008ba:	f8c2 321c 	str.w	r3, [r2, #540]	; 0x21c
 80008be:	e7c9      	b.n	8000854 <CAN_FilterInit+0x8a>
 80008c0:	40006400 	.word	0x40006400

080008c4 <CAN_StructInit>:
  CAN_InitStruct->CAN_TTCM = DISABLE;
 80008c4:	2300      	movs	r3, #0
 80008c6:	7183      	strb	r3, [r0, #6]
  CAN_InitStruct->CAN_ABOM = DISABLE;
 80008c8:	71c3      	strb	r3, [r0, #7]
  CAN_InitStruct->CAN_AWUM = DISABLE;
 80008ca:	7203      	strb	r3, [r0, #8]
  CAN_InitStruct->CAN_NART = DISABLE;
 80008cc:	7243      	strb	r3, [r0, #9]
  CAN_InitStruct->CAN_RFLM = DISABLE;
 80008ce:	7283      	strb	r3, [r0, #10]
  CAN_InitStruct->CAN_TXFP = DISABLE;
 80008d0:	72c3      	strb	r3, [r0, #11]
  CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
 80008d2:	7083      	strb	r3, [r0, #2]
  CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
 80008d4:	70c3      	strb	r3, [r0, #3]
  CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
 80008d6:	2303      	movs	r3, #3
 80008d8:	7103      	strb	r3, [r0, #4]
  CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
 80008da:	2302      	movs	r3, #2
 80008dc:	7143      	strb	r3, [r0, #5]
  CAN_InitStruct->CAN_Prescaler = 1;
 80008de:	2301      	movs	r3, #1
 80008e0:	8003      	strh	r3, [r0, #0]
 80008e2:	4770      	bx	lr

080008e4 <CAN_SlaveStartBank>:
  CAN1->FMR |= FMR_FINIT;
 80008e4:	4b0d      	ldr	r3, [pc, #52]	; (800091c <CAN_SlaveStartBank+0x38>)
 80008e6:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 80008ea:	f042 0201 	orr.w	r2, r2, #1
 80008ee:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
  CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
 80008f2:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 80008f6:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
 80008fa:	f022 020e 	bic.w	r2, r2, #14
 80008fe:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
  CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
 8000902:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8000906:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
 800090a:	f8c3 0200 	str.w	r0, [r3, #512]	; 0x200
  CAN1->FMR &= ~FMR_FINIT;
 800090e:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
 8000912:	f022 0201 	bic.w	r2, r2, #1
 8000916:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
 800091a:	4770      	bx	lr
 800091c:	40006400 	.word	0x40006400

08000920 <CAN_DBGFreeze>:
  if (NewState != DISABLE)
 8000920:	b921      	cbnz	r1, 800092c <CAN_DBGFreeze+0xc>
    CANx->MCR &= ~MCR_DBF;
 8000922:	6803      	ldr	r3, [r0, #0]
 8000924:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000928:	6003      	str	r3, [r0, #0]
 800092a:	4770      	bx	lr
    CANx->MCR |= MCR_DBF;
 800092c:	6803      	ldr	r3, [r0, #0]
 800092e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000932:	6003      	str	r3, [r0, #0]
 8000934:	4770      	bx	lr

08000936 <CAN_TTComModeCmd>:
  if (NewState != DISABLE)
 8000936:	b9b1      	cbnz	r1, 8000966 <CAN_TTComModeCmd+0x30>
    CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
 8000938:	6803      	ldr	r3, [r0, #0]
 800093a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800093e:	6003      	str	r3, [r0, #0]
    CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
 8000940:	f8d0 3184 	ldr.w	r3, [r0, #388]	; 0x184
 8000944:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000948:	f8c0 3184 	str.w	r3, [r0, #388]	; 0x184
    CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
 800094c:	f8d0 3194 	ldr.w	r3, [r0, #404]	; 0x194
 8000950:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000954:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194
    CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
 8000958:	f8d0 31a4 	ldr.w	r3, [r0, #420]	; 0x1a4
 800095c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000960:	f8c0 31a4 	str.w	r3, [r0, #420]	; 0x1a4
 8000964:	4770      	bx	lr
    CANx->MCR |= CAN_MCR_TTCM;
 8000966:	6803      	ldr	r3, [r0, #0]
 8000968:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800096c:	6003      	str	r3, [r0, #0]
    CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
 800096e:	f8d0 3184 	ldr.w	r3, [r0, #388]	; 0x184
 8000972:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000976:	f8c0 3184 	str.w	r3, [r0, #388]	; 0x184
    CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
 800097a:	f8d0 3194 	ldr.w	r3, [r0, #404]	; 0x194
 800097e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000982:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194
    CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
 8000986:	f8d0 31a4 	ldr.w	r3, [r0, #420]	; 0x1a4
 800098a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800098e:	f8c0 31a4 	str.w	r3, [r0, #420]	; 0x1a4
 8000992:	4770      	bx	lr

08000994 <CAN_Transmit>:
{
 8000994:	4603      	mov	r3, r0
  if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
 8000996:	6882      	ldr	r2, [r0, #8]
 8000998:	f012 6f80 	tst.w	r2, #67108864	; 0x4000000
 800099c:	d109      	bne.n	80009b2 <CAN_Transmit+0x1e>
  else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
 800099e:	6882      	ldr	r2, [r0, #8]
 80009a0:	f012 6f00 	tst.w	r2, #134217728	; 0x8000000
 80009a4:	d14e      	bne.n	8000a44 <CAN_Transmit+0xb0>
  else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
 80009a6:	6882      	ldr	r2, [r0, #8]
 80009a8:	f012 5f80 	tst.w	r2, #268435456	; 0x10000000
 80009ac:	d04c      	beq.n	8000a48 <CAN_Transmit+0xb4>
    transmit_mailbox = 2;
 80009ae:	2002      	movs	r0, #2
 80009b0:	e000      	b.n	80009b4 <CAN_Transmit+0x20>
    transmit_mailbox = 0;
 80009b2:	2000      	movs	r0, #0
  if (transmit_mailbox != CAN_TxStatus_NoMailBox)
 80009b4:	2804      	cmp	r0, #4
 80009b6:	d044      	beq.n	8000a42 <CAN_Transmit+0xae>
{
 80009b8:	b4f0      	push	{r4, r5, r6, r7}
    CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
 80009ba:	4605      	mov	r5, r0
 80009bc:	f100 0218 	add.w	r2, r0, #24
 80009c0:	0112      	lsls	r2, r2, #4
 80009c2:	589c      	ldr	r4, [r3, r2]
 80009c4:	f004 0401 	and.w	r4, r4, #1
 80009c8:	509c      	str	r4, [r3, r2]
    if (TxMessage->IDE == CAN_Id_Standard)
 80009ca:	7a0a      	ldrb	r2, [r1, #8]
 80009cc:	2a00      	cmp	r2, #0
 80009ce:	d13d      	bne.n	8000a4c <CAN_Transmit+0xb8>
      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
 80009d0:	f100 0218 	add.w	r2, r0, #24
 80009d4:	0112      	lsls	r2, r2, #4
 80009d6:	589c      	ldr	r4, [r3, r2]
 80009d8:	680f      	ldr	r7, [r1, #0]
                                                  TxMessage->RTR);
 80009da:	7a4e      	ldrb	r6, [r1, #9]
      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
 80009dc:	ea46 5647 	orr.w	r6, r6, r7, lsl #21
 80009e0:	4334      	orrs	r4, r6
 80009e2:	509c      	str	r4, [r3, r2]
    TxMessage->DLC &= (uint8_t)0x0000000F;
 80009e4:	7a8a      	ldrb	r2, [r1, #10]
 80009e6:	f002 020f 	and.w	r2, r2, #15
 80009ea:	728a      	strb	r2, [r1, #10]
    CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
 80009ec:	f105 0418 	add.w	r4, r5, #24
 80009f0:	0124      	lsls	r4, r4, #4
 80009f2:	191a      	adds	r2, r3, r4
 80009f4:	6856      	ldr	r6, [r2, #4]
 80009f6:	f026 060f 	bic.w	r6, r6, #15
 80009fa:	6056      	str	r6, [r2, #4]
    CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
 80009fc:	6856      	ldr	r6, [r2, #4]
 80009fe:	7a8f      	ldrb	r7, [r1, #10]
 8000a00:	433e      	orrs	r6, r7
 8000a02:	6056      	str	r6, [r2, #4]
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 8000a04:	7b8e      	ldrb	r6, [r1, #14]
                                             ((uint32_t)TxMessage->Data[2] << 16) |
 8000a06:	7b4a      	ldrb	r2, [r1, #13]
 8000a08:	0412      	lsls	r2, r2, #16
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 8000a0a:	ea42 6206 	orr.w	r2, r2, r6, lsl #24
                                             ((uint32_t)TxMessage->Data[1] << 8) | 
 8000a0e:	7b0e      	ldrb	r6, [r1, #12]
                                             ((uint32_t)TxMessage->Data[2] << 16) |
 8000a10:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
                                             ((uint32_t)TxMessage->Data[0]));
 8000a14:	7ace      	ldrb	r6, [r1, #11]
                                             ((uint32_t)TxMessage->Data[1] << 8) | 
 8000a16:	4332      	orrs	r2, r6
    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
 8000a18:	eb03 1505 	add.w	r5, r3, r5, lsl #4
 8000a1c:	f8c5 2188 	str.w	r2, [r5, #392]	; 0x188
    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 8000a20:	7c8e      	ldrb	r6, [r1, #18]
                                             ((uint32_t)TxMessage->Data[6] << 16) |
 8000a22:	7c4a      	ldrb	r2, [r1, #17]
 8000a24:	0412      	lsls	r2, r2, #16
    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 8000a26:	ea42 6206 	orr.w	r2, r2, r6, lsl #24
                                             ((uint32_t)TxMessage->Data[5] << 8) |
 8000a2a:	7c0e      	ldrb	r6, [r1, #16]
                                             ((uint32_t)TxMessage->Data[6] << 16) |
 8000a2c:	ea42 2206 	orr.w	r2, r2, r6, lsl #8
                                             ((uint32_t)TxMessage->Data[4]));
 8000a30:	7bc9      	ldrb	r1, [r1, #15]
                                             ((uint32_t)TxMessage->Data[5] << 8) |
 8000a32:	430a      	orrs	r2, r1
    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
 8000a34:	f8c5 218c 	str.w	r2, [r5, #396]	; 0x18c
    CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
 8000a38:	591a      	ldr	r2, [r3, r4]
 8000a3a:	f042 0201 	orr.w	r2, r2, #1
 8000a3e:	511a      	str	r2, [r3, r4]
}
 8000a40:	bcf0      	pop	{r4, r5, r6, r7}
 8000a42:	4770      	bx	lr
    transmit_mailbox = 1;
 8000a44:	2001      	movs	r0, #1
 8000a46:	e7b5      	b.n	80009b4 <CAN_Transmit+0x20>
    transmit_mailbox = CAN_TxStatus_NoMailBox;
 8000a48:	2004      	movs	r0, #4
 8000a4a:	e7b3      	b.n	80009b4 <CAN_Transmit+0x20>
      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
 8000a4c:	f100 0418 	add.w	r4, r0, #24
 8000a50:	0124      	lsls	r4, r4, #4
 8000a52:	591e      	ldr	r6, [r3, r4]
 8000a54:	684f      	ldr	r7, [r1, #4]
 8000a56:	ea42 02c7 	orr.w	r2, r2, r7, lsl #3
                                                  TxMessage->RTR);
 8000a5a:	7a4f      	ldrb	r7, [r1, #9]
                                                  TxMessage->IDE | \
 8000a5c:	433a      	orrs	r2, r7
      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
 8000a5e:	4332      	orrs	r2, r6
 8000a60:	511a      	str	r2, [r3, r4]
 8000a62:	e7bf      	b.n	80009e4 <CAN_Transmit+0x50>

08000a64 <CAN_TransmitStatus>:
  switch (TransmitMailbox)
 8000a64:	2901      	cmp	r1, #1
 8000a66:	d019      	beq.n	8000a9c <CAN_TransmitStatus+0x38>
 8000a68:	b119      	cbz	r1, 8000a72 <CAN_TransmitStatus+0xe>
 8000a6a:	2902      	cmp	r1, #2
 8000a6c:	d01a      	beq.n	8000aa4 <CAN_TransmitStatus+0x40>
      state = CAN_TxStatus_Failed;
 8000a6e:	2300      	movs	r3, #0
 8000a70:	e008      	b.n	8000a84 <CAN_TransmitStatus+0x20>
      state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
 8000a72:	6883      	ldr	r3, [r0, #8]
 8000a74:	f023 437b 	bic.w	r3, r3, #4211081216	; 0xfb000000
 8000a78:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
 8000a7c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8000a80:	f023 03fc 	bic.w	r3, r3, #252	; 0xfc
  switch (state)
 8000a84:	4a10      	ldr	r2, [pc, #64]	; (8000ac8 <CAN_TransmitStatus+0x64>)
 8000a86:	4293      	cmp	r3, r2
 8000a88:	d017      	beq.n	8000aba <CAN_TransmitStatus+0x56>
 8000a8a:	d913      	bls.n	8000ab4 <CAN_TransmitStatus+0x50>
 8000a8c:	4a0f      	ldr	r2, [pc, #60]	; (8000acc <CAN_TransmitStatus+0x68>)
 8000a8e:	4293      	cmp	r3, r2
 8000a90:	d015      	beq.n	8000abe <CAN_TransmitStatus+0x5a>
 8000a92:	4a0f      	ldr	r2, [pc, #60]	; (8000ad0 <CAN_TransmitStatus+0x6c>)
 8000a94:	4293      	cmp	r3, r2
 8000a96:	d114      	bne.n	8000ac2 <CAN_TransmitStatus+0x5e>
    case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
 8000a98:	2001      	movs	r0, #1
      break;
 8000a9a:	4770      	bx	lr
      state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
 8000a9c:	6882      	ldr	r2, [r0, #8]
 8000a9e:	4b0b      	ldr	r3, [pc, #44]	; (8000acc <CAN_TransmitStatus+0x68>)
 8000aa0:	4013      	ands	r3, r2
      break;
 8000aa2:	e7ef      	b.n	8000a84 <CAN_TransmitStatus+0x20>
      state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
 8000aa4:	6883      	ldr	r3, [r0, #8]
 8000aa6:	f023 436f 	bic.w	r3, r3, #4009754624	; 0xef000000
 8000aaa:	f423 037c 	bic.w	r3, r3, #16515072	; 0xfc0000
 8000aae:	0c1b      	lsrs	r3, r3, #16
 8000ab0:	041b      	lsls	r3, r3, #16
      break;
 8000ab2:	e7e7      	b.n	8000a84 <CAN_TransmitStatus+0x20>
  switch (state)
 8000ab4:	b92b      	cbnz	r3, 8000ac2 <CAN_TransmitStatus+0x5e>
    case (0x0): state = CAN_TxStatus_Pending;
 8000ab6:	2002      	movs	r0, #2
 8000ab8:	4770      	bx	lr
    case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
 8000aba:	2001      	movs	r0, #1
      break;
 8000abc:	4770      	bx	lr
    case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
 8000abe:	2001      	movs	r0, #1
      break;
 8000ac0:	4770      	bx	lr
     case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
 8000ac2:	2000      	movs	r0, #0
}
 8000ac4:	4770      	bx	lr
 8000ac6:	bf00      	nop
 8000ac8:	04000003 	.word	0x04000003
 8000acc:	08000300 	.word	0x08000300
 8000ad0:	10030000 	.word	0x10030000

08000ad4 <CAN_CancelTransmit>:
  switch (Mailbox)
 8000ad4:	2901      	cmp	r1, #1
 8000ad6:	d008      	beq.n	8000aea <CAN_CancelTransmit+0x16>
 8000ad8:	b111      	cbz	r1, 8000ae0 <CAN_CancelTransmit+0xc>
 8000ada:	2902      	cmp	r1, #2
 8000adc:	d00a      	beq.n	8000af4 <CAN_CancelTransmit+0x20>
 8000ade:	4770      	bx	lr
    case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
 8000ae0:	6883      	ldr	r3, [r0, #8]
 8000ae2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000ae6:	6083      	str	r3, [r0, #8]
      break;
 8000ae8:	4770      	bx	lr
    case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
 8000aea:	6883      	ldr	r3, [r0, #8]
 8000aec:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000af0:	6083      	str	r3, [r0, #8]
      break;
 8000af2:	4770      	bx	lr
    case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
 8000af4:	6883      	ldr	r3, [r0, #8]
 8000af6:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8000afa:	6083      	str	r3, [r0, #8]
 8000afc:	4770      	bx	lr

08000afe <CAN_Receive>:
{
 8000afe:	b410      	push	{r4}
  RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
 8000b00:	f101 031b 	add.w	r3, r1, #27
 8000b04:	011b      	lsls	r3, r3, #4
 8000b06:	58c3      	ldr	r3, [r0, r3]
 8000b08:	f003 0304 	and.w	r3, r3, #4
 8000b0c:	7213      	strb	r3, [r2, #8]
  if (RxMessage->IDE == CAN_Id_Standard)
 8000b0e:	2b00      	cmp	r3, #0
 8000b10:	d13c      	bne.n	8000b8c <CAN_Receive+0x8e>
    RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
 8000b12:	f101 031b 	add.w	r3, r1, #27
 8000b16:	011b      	lsls	r3, r3, #4
 8000b18:	58c3      	ldr	r3, [r0, r3]
 8000b1a:	0d5b      	lsrs	r3, r3, #21
 8000b1c:	6013      	str	r3, [r2, #0]
  RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
 8000b1e:	f101 031b 	add.w	r3, r1, #27
 8000b22:	011b      	lsls	r3, r3, #4
 8000b24:	18c4      	adds	r4, r0, r3
 8000b26:	58c3      	ldr	r3, [r0, r3]
 8000b28:	f003 0302 	and.w	r3, r3, #2
 8000b2c:	7253      	strb	r3, [r2, #9]
  RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
 8000b2e:	6863      	ldr	r3, [r4, #4]
 8000b30:	f003 030f 	and.w	r3, r3, #15
 8000b34:	7293      	strb	r3, [r2, #10]
  RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
 8000b36:	6863      	ldr	r3, [r4, #4]
 8000b38:	0a1b      	lsrs	r3, r3, #8
 8000b3a:	74d3      	strb	r3, [r2, #19]
  RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
 8000b3c:	eb00 1301 	add.w	r3, r0, r1, lsl #4
 8000b40:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
 8000b44:	72d4      	strb	r4, [r2, #11]
  RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
 8000b46:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
 8000b4a:	0a24      	lsrs	r4, r4, #8
 8000b4c:	7314      	strb	r4, [r2, #12]
  RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
 8000b4e:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
 8000b52:	0c24      	lsrs	r4, r4, #16
 8000b54:	7354      	strb	r4, [r2, #13]
  RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
 8000b56:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
 8000b5a:	0e24      	lsrs	r4, r4, #24
 8000b5c:	7394      	strb	r4, [r2, #14]
  RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
 8000b5e:	f8d3 41bc 	ldr.w	r4, [r3, #444]	; 0x1bc
 8000b62:	73d4      	strb	r4, [r2, #15]
  RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
 8000b64:	f8d3 41bc 	ldr.w	r4, [r3, #444]	; 0x1bc
 8000b68:	0a24      	lsrs	r4, r4, #8
 8000b6a:	7414      	strb	r4, [r2, #16]
  RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
 8000b6c:	f8d3 41bc 	ldr.w	r4, [r3, #444]	; 0x1bc
 8000b70:	0c24      	lsrs	r4, r4, #16
 8000b72:	7454      	strb	r4, [r2, #17]
  RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
 8000b74:	f8d3 31bc 	ldr.w	r3, [r3, #444]	; 0x1bc
 8000b78:	0e1b      	lsrs	r3, r3, #24
 8000b7a:	7493      	strb	r3, [r2, #18]
  if (FIFONumber == CAN_FIFO0)
 8000b7c:	b169      	cbz	r1, 8000b9a <CAN_Receive+0x9c>
    CANx->RF1R |= CAN_RF1R_RFOM1;
 8000b7e:	6903      	ldr	r3, [r0, #16]
 8000b80:	f043 0320 	orr.w	r3, r3, #32
 8000b84:	6103      	str	r3, [r0, #16]
}
 8000b86:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000b8a:	4770      	bx	lr
    RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
 8000b8c:	f101 031b 	add.w	r3, r1, #27
 8000b90:	011b      	lsls	r3, r3, #4
 8000b92:	58c3      	ldr	r3, [r0, r3]
 8000b94:	08db      	lsrs	r3, r3, #3
 8000b96:	6053      	str	r3, [r2, #4]
 8000b98:	e7c1      	b.n	8000b1e <CAN_Receive+0x20>
    CANx->RF0R |= CAN_RF0R_RFOM0;
 8000b9a:	68c3      	ldr	r3, [r0, #12]
 8000b9c:	f043 0320 	orr.w	r3, r3, #32
 8000ba0:	60c3      	str	r3, [r0, #12]
 8000ba2:	e7f0      	b.n	8000b86 <CAN_Receive+0x88>

08000ba4 <CAN_FIFORelease>:
  if (FIFONumber == CAN_FIFO0)
 8000ba4:	b121      	cbz	r1, 8000bb0 <CAN_FIFORelease+0xc>
    CANx->RF1R |= CAN_RF1R_RFOM1;
 8000ba6:	6903      	ldr	r3, [r0, #16]
 8000ba8:	f043 0320 	orr.w	r3, r3, #32
 8000bac:	6103      	str	r3, [r0, #16]
 8000bae:	4770      	bx	lr
    CANx->RF0R |= CAN_RF0R_RFOM0;
 8000bb0:	68c3      	ldr	r3, [r0, #12]
 8000bb2:	f043 0320 	orr.w	r3, r3, #32
 8000bb6:	60c3      	str	r3, [r0, #12]
 8000bb8:	4770      	bx	lr

08000bba <CAN_MessagePending>:
  if (FIFONumber == CAN_FIFO0)
 8000bba:	b119      	cbz	r1, 8000bc4 <CAN_MessagePending+0xa>
  else if (FIFONumber == CAN_FIFO1)
 8000bbc:	2901      	cmp	r1, #1
 8000bbe:	d005      	beq.n	8000bcc <CAN_MessagePending+0x12>
    message_pending = 0;
 8000bc0:	2000      	movs	r0, #0
}
 8000bc2:	4770      	bx	lr
    message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
 8000bc4:	68c0      	ldr	r0, [r0, #12]
 8000bc6:	f000 0003 	and.w	r0, r0, #3
 8000bca:	4770      	bx	lr
    message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
 8000bcc:	6900      	ldr	r0, [r0, #16]
 8000bce:	f000 0003 	and.w	r0, r0, #3
 8000bd2:	4770      	bx	lr

08000bd4 <CAN_OperatingModeRequest>:
  if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
 8000bd4:	b9b9      	cbnz	r1, 8000c06 <CAN_OperatingModeRequest+0x32>
    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
 8000bd6:	6803      	ldr	r3, [r0, #0]
 8000bd8:	f023 0303 	bic.w	r3, r3, #3
 8000bdc:	f043 0301 	orr.w	r3, r3, #1
 8000be0:	6003      	str	r3, [r0, #0]
  uint32_t timeout = INAK_TIMEOUT; 
 8000be2:	f64f 72ff 	movw	r2, #65535	; 0xffff
    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
 8000be6:	e000      	b.n	8000bea <CAN_OperatingModeRequest+0x16>
      timeout--;
 8000be8:	3a01      	subs	r2, #1
    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
 8000bea:	6843      	ldr	r3, [r0, #4]
 8000bec:	f003 0303 	and.w	r3, r3, #3
 8000bf0:	2b01      	cmp	r3, #1
 8000bf2:	d001      	beq.n	8000bf8 <CAN_OperatingModeRequest+0x24>
 8000bf4:	2a00      	cmp	r2, #0
 8000bf6:	d1f7      	bne.n	8000be8 <CAN_OperatingModeRequest+0x14>
    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
 8000bf8:	6843      	ldr	r3, [r0, #4]
 8000bfa:	f003 0303 	and.w	r3, r3, #3
 8000bfe:	2b01      	cmp	r3, #1
 8000c00:	d032      	beq.n	8000c68 <CAN_OperatingModeRequest+0x94>
      status = CAN_ModeStatus_Failed;
 8000c02:	2000      	movs	r0, #0
 8000c04:	4770      	bx	lr
  else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
 8000c06:	2901      	cmp	r1, #1
 8000c08:	d003      	beq.n	8000c12 <CAN_OperatingModeRequest+0x3e>
  else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
 8000c0a:	2902      	cmp	r1, #2
 8000c0c:	d015      	beq.n	8000c3a <CAN_OperatingModeRequest+0x66>
    status = CAN_ModeStatus_Failed;
 8000c0e:	2000      	movs	r0, #0
 8000c10:	4770      	bx	lr
    CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
 8000c12:	6803      	ldr	r3, [r0, #0]
 8000c14:	f023 0303 	bic.w	r3, r3, #3
 8000c18:	6003      	str	r3, [r0, #0]
  uint32_t timeout = INAK_TIMEOUT; 
 8000c1a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
 8000c1e:	e000      	b.n	8000c22 <CAN_OperatingModeRequest+0x4e>
      timeout--;
 8000c20:	3b01      	subs	r3, #1
    while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
 8000c22:	6842      	ldr	r2, [r0, #4]
 8000c24:	f012 0f03 	tst.w	r2, #3
 8000c28:	d001      	beq.n	8000c2e <CAN_OperatingModeRequest+0x5a>
 8000c2a:	2b00      	cmp	r3, #0
 8000c2c:	d1f8      	bne.n	8000c20 <CAN_OperatingModeRequest+0x4c>
    if ((CANx->MSR & CAN_MODE_MASK) != 0)
 8000c2e:	6843      	ldr	r3, [r0, #4]
 8000c30:	f013 0f03 	tst.w	r3, #3
 8000c34:	d01a      	beq.n	8000c6c <CAN_OperatingModeRequest+0x98>
      status = CAN_ModeStatus_Failed;
 8000c36:	2000      	movs	r0, #0
 8000c38:	4770      	bx	lr
    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
 8000c3a:	6803      	ldr	r3, [r0, #0]
 8000c3c:	f023 0303 	bic.w	r3, r3, #3
 8000c40:	f043 0302 	orr.w	r3, r3, #2
 8000c44:	6003      	str	r3, [r0, #0]
  uint32_t timeout = INAK_TIMEOUT; 
 8000c46:	f64f 72ff 	movw	r2, #65535	; 0xffff
    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
 8000c4a:	6843      	ldr	r3, [r0, #4]
 8000c4c:	f003 0303 	and.w	r3, r3, #3
 8000c50:	2b02      	cmp	r3, #2
 8000c52:	d002      	beq.n	8000c5a <CAN_OperatingModeRequest+0x86>
 8000c54:	b10a      	cbz	r2, 8000c5a <CAN_OperatingModeRequest+0x86>
      timeout--;
 8000c56:	3a01      	subs	r2, #1
 8000c58:	e7f7      	b.n	8000c4a <CAN_OperatingModeRequest+0x76>
    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
 8000c5a:	6843      	ldr	r3, [r0, #4]
 8000c5c:	f003 0303 	and.w	r3, r3, #3
 8000c60:	2b02      	cmp	r3, #2
 8000c62:	d005      	beq.n	8000c70 <CAN_OperatingModeRequest+0x9c>
      status = CAN_ModeStatus_Failed;
 8000c64:	2000      	movs	r0, #0
 8000c66:	4770      	bx	lr
      status = CAN_ModeStatus_Success;
 8000c68:	2001      	movs	r0, #1
 8000c6a:	4770      	bx	lr
      status = CAN_ModeStatus_Success;
 8000c6c:	2001      	movs	r0, #1
 8000c6e:	4770      	bx	lr
      status = CAN_ModeStatus_Success;
 8000c70:	2001      	movs	r0, #1
}
 8000c72:	4770      	bx	lr

08000c74 <CAN_Sleep>:
   CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
 8000c74:	6803      	ldr	r3, [r0, #0]
 8000c76:	f023 0303 	bic.w	r3, r3, #3
 8000c7a:	f043 0302 	orr.w	r3, r3, #2
 8000c7e:	6003      	str	r3, [r0, #0]
  if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
 8000c80:	6843      	ldr	r3, [r0, #4]
 8000c82:	f003 0303 	and.w	r3, r3, #3
 8000c86:	2b02      	cmp	r3, #2
 8000c88:	d001      	beq.n	8000c8e <CAN_Sleep+0x1a>
  uint8_t sleepstatus = CAN_Sleep_Failed;
 8000c8a:	2000      	movs	r0, #0
 8000c8c:	4770      	bx	lr
    sleepstatus =  CAN_Sleep_Ok;
 8000c8e:	2001      	movs	r0, #1
}
 8000c90:	4770      	bx	lr

08000c92 <CAN_WakeUp>:
  CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
 8000c92:	6803      	ldr	r3, [r0, #0]
 8000c94:	f023 0302 	bic.w	r3, r3, #2
 8000c98:	6003      	str	r3, [r0, #0]
  uint32_t wait_slak = SLAK_TIMEOUT;
 8000c9a:	f64f 73ff 	movw	r3, #65535	; 0xffff
  while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
 8000c9e:	e000      	b.n	8000ca2 <CAN_WakeUp+0x10>
   wait_slak--;
 8000ca0:	3b01      	subs	r3, #1
  while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
 8000ca2:	6842      	ldr	r2, [r0, #4]
 8000ca4:	f012 0f02 	tst.w	r2, #2
 8000ca8:	d001      	beq.n	8000cae <CAN_WakeUp+0x1c>
 8000caa:	2b00      	cmp	r3, #0
 8000cac:	d1f8      	bne.n	8000ca0 <CAN_WakeUp+0xe>
  if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
 8000cae:	6843      	ldr	r3, [r0, #4]
 8000cb0:	f013 0f02 	tst.w	r3, #2
 8000cb4:	d101      	bne.n	8000cba <CAN_WakeUp+0x28>
    wakeupstatus = CAN_WakeUp_Ok;
 8000cb6:	2001      	movs	r0, #1
}
 8000cb8:	4770      	bx	lr
  uint8_t wakeupstatus = CAN_WakeUp_Failed;
 8000cba:	2000      	movs	r0, #0
 8000cbc:	4770      	bx	lr

08000cbe <CAN_GetLastErrorCode>:
  errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
 8000cbe:	6980      	ldr	r0, [r0, #24]
}
 8000cc0:	f000 0070 	and.w	r0, r0, #112	; 0x70
 8000cc4:	4770      	bx	lr

08000cc6 <CAN_GetReceiveErrorCounter>:
  counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
 8000cc6:	6980      	ldr	r0, [r0, #24]
}
 8000cc8:	0e00      	lsrs	r0, r0, #24
 8000cca:	4770      	bx	lr

08000ccc <CAN_GetLSBTransmitErrorCounter>:
  counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
 8000ccc:	6980      	ldr	r0, [r0, #24]
}
 8000cce:	f3c0 4007 	ubfx	r0, r0, #16, #8
 8000cd2:	4770      	bx	lr

08000cd4 <CAN_ITConfig>:
  if (NewState != DISABLE)
 8000cd4:	b922      	cbnz	r2, 8000ce0 <CAN_ITConfig+0xc>
    CANx->IER &= ~CAN_IT;
 8000cd6:	6943      	ldr	r3, [r0, #20]
 8000cd8:	ea23 0101 	bic.w	r1, r3, r1
 8000cdc:	6141      	str	r1, [r0, #20]
 8000cde:	4770      	bx	lr
    CANx->IER |= CAN_IT;
 8000ce0:	6943      	ldr	r3, [r0, #20]
 8000ce2:	4319      	orrs	r1, r3
 8000ce4:	6141      	str	r1, [r0, #20]
 8000ce6:	4770      	bx	lr

08000ce8 <CAN_GetFlagStatus>:
  if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
 8000ce8:	f411 0f70 	tst.w	r1, #15728640	; 0xf00000
 8000cec:	d006      	beq.n	8000cfc <CAN_GetFlagStatus+0x14>
    if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8000cee:	6983      	ldr	r3, [r0, #24]
 8000cf0:	4019      	ands	r1, r3
 8000cf2:	f3c1 0113 	ubfx	r1, r1, #0, #20
 8000cf6:	b341      	cbz	r1, 8000d4a <CAN_GetFlagStatus+0x62>
      bitstatus = SET;
 8000cf8:	2001      	movs	r0, #1
 8000cfa:	4770      	bx	lr
  else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
 8000cfc:	f011 7f80 	tst.w	r1, #16777216	; 0x1000000
 8000d00:	d006      	beq.n	8000d10 <CAN_GetFlagStatus+0x28>
    if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8000d02:	6843      	ldr	r3, [r0, #4]
 8000d04:	4019      	ands	r1, r3
 8000d06:	f3c1 0113 	ubfx	r1, r1, #0, #20
 8000d0a:	b301      	cbz	r1, 8000d4e <CAN_GetFlagStatus+0x66>
      bitstatus = SET;
 8000d0c:	2001      	movs	r0, #1
 8000d0e:	4770      	bx	lr
  else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
 8000d10:	f011 6f00 	tst.w	r1, #134217728	; 0x8000000
 8000d14:	d006      	beq.n	8000d24 <CAN_GetFlagStatus+0x3c>
    if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8000d16:	6883      	ldr	r3, [r0, #8]
 8000d18:	4019      	ands	r1, r3
 8000d1a:	f3c1 0113 	ubfx	r1, r1, #0, #20
 8000d1e:	b1c1      	cbz	r1, 8000d52 <CAN_GetFlagStatus+0x6a>
      bitstatus = SET;
 8000d20:	2001      	movs	r0, #1
 8000d22:	4770      	bx	lr
  else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
 8000d24:	f011 7f00 	tst.w	r1, #33554432	; 0x2000000
 8000d28:	d006      	beq.n	8000d38 <CAN_GetFlagStatus+0x50>
    if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8000d2a:	68c3      	ldr	r3, [r0, #12]
 8000d2c:	4019      	ands	r1, r3
 8000d2e:	f3c1 0113 	ubfx	r1, r1, #0, #20
 8000d32:	b181      	cbz	r1, 8000d56 <CAN_GetFlagStatus+0x6e>
      bitstatus = SET;
 8000d34:	2001      	movs	r0, #1
 8000d36:	4770      	bx	lr
    if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
 8000d38:	6903      	ldr	r3, [r0, #16]
 8000d3a:	4019      	ands	r1, r3
 8000d3c:	f3c1 0113 	ubfx	r1, r1, #0, #20
 8000d40:	b909      	cbnz	r1, 8000d46 <CAN_GetFlagStatus+0x5e>
      bitstatus = RESET;
 8000d42:	2000      	movs	r0, #0
}
 8000d44:	4770      	bx	lr
      bitstatus = SET;
 8000d46:	2001      	movs	r0, #1
 8000d48:	4770      	bx	lr
      bitstatus = RESET;
 8000d4a:	2000      	movs	r0, #0
 8000d4c:	4770      	bx	lr
      bitstatus = RESET;
 8000d4e:	2000      	movs	r0, #0
 8000d50:	4770      	bx	lr
      bitstatus = RESET;
 8000d52:	2000      	movs	r0, #0
 8000d54:	4770      	bx	lr
      bitstatus = RESET;
 8000d56:	2000      	movs	r0, #0
 8000d58:	4770      	bx	lr

08000d5a <CAN_ClearFlag>:
  if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
 8000d5a:	4b0c      	ldr	r3, [pc, #48]	; (8000d8c <CAN_ClearFlag+0x32>)
 8000d5c:	4299      	cmp	r1, r3
 8000d5e:	d00c      	beq.n	8000d7a <CAN_ClearFlag+0x20>
    flagtmp = CAN_FLAG & 0x000FFFFF;
 8000d60:	f3c1 0313 	ubfx	r3, r1, #0, #20
    if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
 8000d64:	f011 7f00 	tst.w	r1, #33554432	; 0x2000000
 8000d68:	d10a      	bne.n	8000d80 <CAN_ClearFlag+0x26>
    else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
 8000d6a:	f011 6f80 	tst.w	r1, #67108864	; 0x4000000
 8000d6e:	d109      	bne.n	8000d84 <CAN_ClearFlag+0x2a>
    else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
 8000d70:	f011 6f00 	tst.w	r1, #134217728	; 0x8000000
 8000d74:	d108      	bne.n	8000d88 <CAN_ClearFlag+0x2e>
      CANx->MSR = (uint32_t)(flagtmp);
 8000d76:	6043      	str	r3, [r0, #4]
 8000d78:	4770      	bx	lr
    CANx->ESR = (uint32_t)RESET;
 8000d7a:	2300      	movs	r3, #0
 8000d7c:	6183      	str	r3, [r0, #24]
 8000d7e:	4770      	bx	lr
      CANx->RF0R = (uint32_t)(flagtmp);
 8000d80:	60c3      	str	r3, [r0, #12]
 8000d82:	4770      	bx	lr
      CANx->RF1R = (uint32_t)(flagtmp);
 8000d84:	6103      	str	r3, [r0, #16]
 8000d86:	4770      	bx	lr
      CANx->TSR = (uint32_t)(flagtmp);
 8000d88:	6083      	str	r3, [r0, #8]
 8000d8a:	4770      	bx	lr
 8000d8c:	30f00070 	.word	0x30f00070

08000d90 <CAN_GetITStatus>:
{
 8000d90:	b508      	push	{r3, lr}
 if((CANx->IER & CAN_IT) != RESET)
 8000d92:	6943      	ldr	r3, [r0, #20]
 8000d94:	420b      	tst	r3, r1
 8000d96:	d06d      	beq.n	8000e74 <CAN_GetITStatus+0xe4>
    switch (CAN_IT)
 8000d98:	2940      	cmp	r1, #64	; 0x40
 8000d9a:	d04d      	beq.n	8000e38 <CAN_GetITStatus+0xa8>
 8000d9c:	d911      	bls.n	8000dc2 <CAN_GetITStatus+0x32>
 8000d9e:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8000da2:	d062      	beq.n	8000e6a <CAN_GetITStatus+0xda>
 8000da4:	d821      	bhi.n	8000dea <CAN_GetITStatus+0x5a>
 8000da6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8000daa:	d054      	beq.n	8000e56 <CAN_GetITStatus+0xc6>
 8000dac:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8000db0:	d056      	beq.n	8000e60 <CAN_GetITStatus+0xd0>
 8000db2:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8000db6:	d10d      	bne.n	8000dd4 <CAN_GetITStatus+0x44>
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
 8000db8:	6980      	ldr	r0, [r0, #24]
 8000dba:	2101      	movs	r1, #1
 8000dbc:	f7ff fc5c 	bl	8000678 <CheckITStatus>
        break;
 8000dc0:	bd08      	pop	{r3, pc}
    switch (CAN_IT)
 8000dc2:	2904      	cmp	r1, #4
 8000dc4:	d024      	beq.n	8000e10 <CAN_GetITStatus+0x80>
 8000dc6:	d907      	bls.n	8000dd8 <CAN_GetITStatus+0x48>
 8000dc8:	2910      	cmp	r1, #16
 8000dca:	d02b      	beq.n	8000e24 <CAN_GetITStatus+0x94>
 8000dcc:	2920      	cmp	r1, #32
 8000dce:	d02e      	beq.n	8000e2e <CAN_GetITStatus+0x9e>
 8000dd0:	2908      	cmp	r1, #8
 8000dd2:	d022      	beq.n	8000e1a <CAN_GetITStatus+0x8a>
        itstatus = RESET;
 8000dd4:	2000      	movs	r0, #0
}
 8000dd6:	bd08      	pop	{r3, pc}
    switch (CAN_IT)
 8000dd8:	2901      	cmp	r1, #1
 8000dda:	d014      	beq.n	8000e06 <CAN_GetITStatus+0x76>
 8000ddc:	2902      	cmp	r1, #2
 8000dde:	d1f9      	bne.n	8000dd4 <CAN_GetITStatus+0x44>
        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
 8000de0:	68c0      	ldr	r0, [r0, #12]
 8000de2:	2103      	movs	r1, #3
 8000de4:	f7ff fc48 	bl	8000678 <CheckITStatus>
        break;
 8000de8:	bd08      	pop	{r3, pc}
    switch (CAN_IT)
 8000dea:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
 8000dee:	d028      	beq.n	8000e42 <CAN_GetITStatus+0xb2>
 8000df0:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
 8000df4:	d02a      	beq.n	8000e4c <CAN_GetITStatus+0xbc>
 8000df6:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8000dfa:	d1eb      	bne.n	8000dd4 <CAN_GetITStatus+0x44>
        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
 8000dfc:	6840      	ldr	r0, [r0, #4]
 8000dfe:	2104      	movs	r1, #4
 8000e00:	f7ff fc3a 	bl	8000678 <CheckITStatus>
        break;
 8000e04:	bd08      	pop	{r3, pc}
        itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
 8000e06:	6880      	ldr	r0, [r0, #8]
 8000e08:	491b      	ldr	r1, [pc, #108]	; (8000e78 <CAN_GetITStatus+0xe8>)
 8000e0a:	f7ff fc35 	bl	8000678 <CheckITStatus>
        break;
 8000e0e:	bd08      	pop	{r3, pc}
        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
 8000e10:	68c0      	ldr	r0, [r0, #12]
 8000e12:	2108      	movs	r1, #8
 8000e14:	f7ff fc30 	bl	8000678 <CheckITStatus>
        break;
 8000e18:	bd08      	pop	{r3, pc}
        itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
 8000e1a:	68c0      	ldr	r0, [r0, #12]
 8000e1c:	2110      	movs	r1, #16
 8000e1e:	f7ff fc2b 	bl	8000678 <CheckITStatus>
        break;
 8000e22:	bd08      	pop	{r3, pc}
        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
 8000e24:	6900      	ldr	r0, [r0, #16]
 8000e26:	2103      	movs	r1, #3
 8000e28:	f7ff fc26 	bl	8000678 <CheckITStatus>
        break;
 8000e2c:	bd08      	pop	{r3, pc}
        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
 8000e2e:	6900      	ldr	r0, [r0, #16]
 8000e30:	2108      	movs	r1, #8
 8000e32:	f7ff fc21 	bl	8000678 <CheckITStatus>
        break;
 8000e36:	bd08      	pop	{r3, pc}
        itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
 8000e38:	6900      	ldr	r0, [r0, #16]
 8000e3a:	2110      	movs	r1, #16
 8000e3c:	f7ff fc1c 	bl	8000678 <CheckITStatus>
        break;
 8000e40:	bd08      	pop	{r3, pc}
        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
 8000e42:	6840      	ldr	r0, [r0, #4]
 8000e44:	2108      	movs	r1, #8
 8000e46:	f7ff fc17 	bl	8000678 <CheckITStatus>
        break;
 8000e4a:	bd08      	pop	{r3, pc}
        itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
 8000e4c:	6840      	ldr	r0, [r0, #4]
 8000e4e:	2110      	movs	r1, #16
 8000e50:	f7ff fc12 	bl	8000678 <CheckITStatus>
        break;
 8000e54:	bd08      	pop	{r3, pc}
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
 8000e56:	6980      	ldr	r0, [r0, #24]
 8000e58:	2102      	movs	r1, #2
 8000e5a:	f7ff fc0d 	bl	8000678 <CheckITStatus>
        break;
 8000e5e:	bd08      	pop	{r3, pc}
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
 8000e60:	6980      	ldr	r0, [r0, #24]
 8000e62:	2104      	movs	r1, #4
 8000e64:	f7ff fc08 	bl	8000678 <CheckITStatus>
        break;
 8000e68:	bd08      	pop	{r3, pc}
        itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
 8000e6a:	6980      	ldr	r0, [r0, #24]
 8000e6c:	2170      	movs	r1, #112	; 0x70
 8000e6e:	f7ff fc03 	bl	8000678 <CheckITStatus>
        break;
 8000e72:	bd08      	pop	{r3, pc}
    itstatus  = RESET;
 8000e74:	2000      	movs	r0, #0
 8000e76:	bd08      	pop	{r3, pc}
 8000e78:	00010101 	.word	0x00010101

08000e7c <CAN_ClearITPendingBit>:
  switch (CAN_IT)
 8000e7c:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8000e80:	d03e      	beq.n	8000f00 <CAN_ClearITPendingBit+0x84>
 8000e82:	d911      	bls.n	8000ea8 <CAN_ClearITPendingBit+0x2c>
 8000e84:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8000e88:	d040      	beq.n	8000f0c <CAN_ClearITPendingBit+0x90>
 8000e8a:	d920      	bls.n	8000ece <CAN_ClearITPendingBit+0x52>
 8000e8c:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
 8000e90:	d030      	beq.n	8000ef4 <CAN_ClearITPendingBit+0x78>
 8000e92:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
 8000e96:	d030      	beq.n	8000efa <CAN_ClearITPendingBit+0x7e>
 8000e98:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8000e9c:	d103      	bne.n	8000ea6 <CAN_ClearITPendingBit+0x2a>
      CANx->ESR = RESET; 
 8000e9e:	2300      	movs	r3, #0
 8000ea0:	6183      	str	r3, [r0, #24]
      CANx->MSR = CAN_MSR_ERRI; 
 8000ea2:	2304      	movs	r3, #4
 8000ea4:	6043      	str	r3, [r0, #4]
 8000ea6:	4770      	bx	lr
  switch (CAN_IT)
 8000ea8:	2908      	cmp	r1, #8
 8000eaa:	d01d      	beq.n	8000ee8 <CAN_ClearITPendingBit+0x6c>
 8000eac:	d807      	bhi.n	8000ebe <CAN_ClearITPendingBit+0x42>
 8000eae:	2901      	cmp	r1, #1
 8000eb0:	d017      	beq.n	8000ee2 <CAN_ClearITPendingBit+0x66>
 8000eb2:	2904      	cmp	r1, #4
 8000eb4:	d102      	bne.n	8000ebc <CAN_ClearITPendingBit+0x40>
      CANx->RF0R = CAN_RF0R_FULL0; 
 8000eb6:	2308      	movs	r3, #8
 8000eb8:	60c3      	str	r3, [r0, #12]
      break;
 8000eba:	4770      	bx	lr
 8000ebc:	4770      	bx	lr
  switch (CAN_IT)
 8000ebe:	2920      	cmp	r1, #32
 8000ec0:	d015      	beq.n	8000eee <CAN_ClearITPendingBit+0x72>
 8000ec2:	2940      	cmp	r1, #64	; 0x40
 8000ec4:	d102      	bne.n	8000ecc <CAN_ClearITPendingBit+0x50>
      CANx->RF1R = CAN_RF1R_FOVR1; 
 8000ec6:	2310      	movs	r3, #16
 8000ec8:	6103      	str	r3, [r0, #16]
      break;
 8000eca:	4770      	bx	lr
 8000ecc:	4770      	bx	lr
  switch (CAN_IT)
 8000ece:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8000ed2:	d018      	beq.n	8000f06 <CAN_ClearITPendingBit+0x8a>
 8000ed4:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8000ed8:	d102      	bne.n	8000ee0 <CAN_ClearITPendingBit+0x64>
      CANx->MSR = CAN_MSR_ERRI; 
 8000eda:	2304      	movs	r3, #4
 8000edc:	6043      	str	r3, [r0, #4]
       break;
 8000ede:	4770      	bx	lr
 8000ee0:	4770      	bx	lr
      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
 8000ee2:	4b0d      	ldr	r3, [pc, #52]	; (8000f18 <CAN_ClearITPendingBit+0x9c>)
 8000ee4:	6083      	str	r3, [r0, #8]
      break;
 8000ee6:	4770      	bx	lr
      CANx->RF0R = CAN_RF0R_FOVR0; 
 8000ee8:	2310      	movs	r3, #16
 8000eea:	60c3      	str	r3, [r0, #12]
      break;
 8000eec:	4770      	bx	lr
      CANx->RF1R = CAN_RF1R_FULL1;  
 8000eee:	2308      	movs	r3, #8
 8000ef0:	6103      	str	r3, [r0, #16]
      break;
 8000ef2:	4770      	bx	lr
      CANx->MSR = CAN_MSR_WKUI;  
 8000ef4:	2308      	movs	r3, #8
 8000ef6:	6043      	str	r3, [r0, #4]
      break;
 8000ef8:	4770      	bx	lr
      CANx->MSR = CAN_MSR_SLAKI;   
 8000efa:	2310      	movs	r3, #16
 8000efc:	6043      	str	r3, [r0, #4]
      break;
 8000efe:	4770      	bx	lr
      CANx->MSR = CAN_MSR_ERRI;
 8000f00:	2304      	movs	r3, #4
 8000f02:	6043      	str	r3, [r0, #4]
      break;
 8000f04:	4770      	bx	lr
      CANx->MSR = CAN_MSR_ERRI; 
 8000f06:	2304      	movs	r3, #4
 8000f08:	6043      	str	r3, [r0, #4]
      break;
 8000f0a:	4770      	bx	lr
      CANx->ESR = RESET; 
 8000f0c:	2300      	movs	r3, #0
 8000f0e:	6183      	str	r3, [r0, #24]
      CANx->MSR = CAN_MSR_ERRI; 
 8000f10:	2304      	movs	r3, #4
 8000f12:	6043      	str	r3, [r0, #4]
      break;
 8000f14:	4770      	bx	lr
 8000f16:	bf00      	nop
 8000f18:	00010101 	.word	0x00010101

08000f1c <CRC_ResetDR>:
  * @retval None
  */
void CRC_ResetDR(void)
{
  /* Reset CRC generator */
  CRC->CR = CRC_CR_RESET;
 8000f1c:	2201      	movs	r2, #1
 8000f1e:	4b01      	ldr	r3, [pc, #4]	; (8000f24 <CRC_ResetDR+0x8>)
 8000f20:	609a      	str	r2, [r3, #8]
 8000f22:	4770      	bx	lr
 8000f24:	40023000 	.word	0x40023000

08000f28 <CRC_CalcCRC>:
  * @param  Data: data word(32-bit) to compute its CRC
  * @retval 32-bit CRC
  */
uint32_t CRC_CalcCRC(uint32_t Data)
{
  CRC->DR = Data;
 8000f28:	4b01      	ldr	r3, [pc, #4]	; (8000f30 <CRC_CalcCRC+0x8>)
 8000f2a:	6018      	str	r0, [r3, #0]
  
  return (CRC->DR);
 8000f2c:	6818      	ldr	r0, [r3, #0]
}
 8000f2e:	4770      	bx	lr
 8000f30:	40023000 	.word	0x40023000

08000f34 <CRC_CalcBlockCRC>:
  */
uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)
{
  uint32_t index = 0;
  
  for(index = 0; index < BufferLength; index++)
 8000f34:	2300      	movs	r3, #0
 8000f36:	428b      	cmp	r3, r1
 8000f38:	d20c      	bcs.n	8000f54 <CRC_CalcBlockCRC+0x20>
{
 8000f3a:	b410      	push	{r4}
  {
    CRC->DR = pBuffer[index];
 8000f3c:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 8000f40:	4a06      	ldr	r2, [pc, #24]	; (8000f5c <CRC_CalcBlockCRC+0x28>)
 8000f42:	6014      	str	r4, [r2, #0]
  for(index = 0; index < BufferLength; index++)
 8000f44:	3301      	adds	r3, #1
 8000f46:	428b      	cmp	r3, r1
 8000f48:	d3f8      	bcc.n	8000f3c <CRC_CalcBlockCRC+0x8>
  }
  return (CRC->DR);
 8000f4a:	4b04      	ldr	r3, [pc, #16]	; (8000f5c <CRC_CalcBlockCRC+0x28>)
 8000f4c:	6818      	ldr	r0, [r3, #0]
}
 8000f4e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000f52:	4770      	bx	lr
  return (CRC->DR);
 8000f54:	4b01      	ldr	r3, [pc, #4]	; (8000f5c <CRC_CalcBlockCRC+0x28>)
 8000f56:	6818      	ldr	r0, [r3, #0]
}
 8000f58:	4770      	bx	lr
 8000f5a:	bf00      	nop
 8000f5c:	40023000 	.word	0x40023000

08000f60 <CRC_GetCRC>:
  * @param  None
  * @retval 32-bit CRC
  */
uint32_t CRC_GetCRC(void)
{
  return (CRC->DR);
 8000f60:	4b01      	ldr	r3, [pc, #4]	; (8000f68 <CRC_GetCRC+0x8>)
 8000f62:	6818      	ldr	r0, [r3, #0]
}
 8000f64:	4770      	bx	lr
 8000f66:	bf00      	nop
 8000f68:	40023000 	.word	0x40023000

08000f6c <CRC_SetIDRegister>:
  * @param  IDValue: 8-bit value to be stored in the ID register 					
  * @retval None
  */
void CRC_SetIDRegister(uint8_t IDValue)
{
  CRC->IDR = IDValue;
 8000f6c:	4b01      	ldr	r3, [pc, #4]	; (8000f74 <CRC_SetIDRegister+0x8>)
 8000f6e:	7118      	strb	r0, [r3, #4]
 8000f70:	4770      	bx	lr
 8000f72:	bf00      	nop
 8000f74:	40023000 	.word	0x40023000

08000f78 <CRC_GetIDRegister>:
  * @param  None
  * @retval 8-bit value of the ID register 
  */
uint8_t CRC_GetIDRegister(void)
{
  return (CRC->IDR);
 8000f78:	4b01      	ldr	r3, [pc, #4]	; (8000f80 <CRC_GetIDRegister+0x8>)
 8000f7a:	7918      	ldrb	r0, [r3, #4]
}
 8000f7c:	4770      	bx	lr
 8000f7e:	bf00      	nop
 8000f80:	40023000 	.word	0x40023000

08000f84 <CRYP_DeInit>:
  * @brief  Deinitializes the CRYP peripheral registers to their default reset values
  * @param  None
  * @retval None
  */
void CRYP_DeInit(void)
{
 8000f84:	b508      	push	{r3, lr}
  /* Enable CRYP reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);
 8000f86:	2101      	movs	r1, #1
 8000f88:	2010      	movs	r0, #16
 8000f8a:	f003 fcf1 	bl	8004970 <RCC_AHB2PeriphResetCmd>

  /* Release CRYP from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
 8000f8e:	2100      	movs	r1, #0
 8000f90:	2010      	movs	r0, #16
 8000f92:	f003 fced 	bl	8004970 <RCC_AHB2PeriphResetCmd>
 8000f96:	bd08      	pop	{r3, pc}

08000f98 <CRYP_Init>:
  assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
  assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
  assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));

  /* Select Algorithm mode*/  
  CRYP->CR &= ~CRYP_CR_ALGOMODE;
 8000f98:	4b16      	ldr	r3, [pc, #88]	; (8000ff4 <CRYP_Init+0x5c>)
 8000f9a:	681a      	ldr	r2, [r3, #0]
 8000f9c:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 8000fa0:	f022 0238 	bic.w	r2, r2, #56	; 0x38
 8000fa4:	601a      	str	r2, [r3, #0]
  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
 8000fa6:	681a      	ldr	r2, [r3, #0]
 8000fa8:	6841      	ldr	r1, [r0, #4]
 8000faa:	430a      	orrs	r2, r1
 8000fac:	601a      	str	r2, [r3, #0]

  /* Select dataType */ 
  CRYP->CR &= ~CRYP_CR_DATATYPE;
 8000fae:	681a      	ldr	r2, [r3, #0]
 8000fb0:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8000fb4:	601a      	str	r2, [r3, #0]
  CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
 8000fb6:	681a      	ldr	r2, [r3, #0]
 8000fb8:	6881      	ldr	r1, [r0, #8]
 8000fba:	430a      	orrs	r2, r1
 8000fbc:	601a      	str	r2, [r3, #0]

  /* select Key size (used only with AES algorithm) */
  if ((CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_TDES_ECB) &&
 8000fbe:	6843      	ldr	r3, [r0, #4]
 8000fc0:	b173      	cbz	r3, 8000fe0 <CRYP_Init+0x48>
 8000fc2:	2b08      	cmp	r3, #8
 8000fc4:	d00c      	beq.n	8000fe0 <CRYP_Init+0x48>
      (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_TDES_CBC) &&
 8000fc6:	2b10      	cmp	r3, #16
 8000fc8:	d00a      	beq.n	8000fe0 <CRYP_Init+0x48>
      (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_DES_ECB) &&
 8000fca:	2b18      	cmp	r3, #24
 8000fcc:	d008      	beq.n	8000fe0 <CRYP_Init+0x48>
      (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_DES_CBC))
  {
    assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
    CRYP->CR &= ~CRYP_CR_KEYSIZE;
 8000fce:	4b09      	ldr	r3, [pc, #36]	; (8000ff4 <CRYP_Init+0x5c>)
 8000fd0:	681a      	ldr	r2, [r3, #0]
 8000fd2:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8000fd6:	601a      	str	r2, [r3, #0]
    CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be 
 8000fd8:	681a      	ldr	r2, [r3, #0]
 8000fda:	68c1      	ldr	r1, [r0, #12]
 8000fdc:	430a      	orrs	r2, r1
 8000fde:	601a      	str	r2, [r3, #0]
                                                  configured once the key has 
                                                  been prepared */
  }

  /* Select data Direction */ 
  CRYP->CR &= ~CRYP_CR_ALGODIR;
 8000fe0:	4b04      	ldr	r3, [pc, #16]	; (8000ff4 <CRYP_Init+0x5c>)
 8000fe2:	681a      	ldr	r2, [r3, #0]
 8000fe4:	f022 0204 	bic.w	r2, r2, #4
 8000fe8:	601a      	str	r2, [r3, #0]
  CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
 8000fea:	681a      	ldr	r2, [r3, #0]
 8000fec:	6801      	ldr	r1, [r0, #0]
 8000fee:	430a      	orrs	r2, r1
 8000ff0:	601a      	str	r2, [r3, #0]
 8000ff2:	4770      	bx	lr
 8000ff4:	50060000 	.word	0x50060000

08000ff8 <CRYP_StructInit>:
  * @retval None
  */
void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)
{
  /* Initialize the CRYP_AlgoDir member */
  CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 8000ff8:	2300      	movs	r3, #0
 8000ffa:	6003      	str	r3, [r0, #0]

  /* initialize the CRYP_AlgoMode member */
  CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
 8000ffc:	6043      	str	r3, [r0, #4]

  /* initialize the CRYP_DataType member */
  CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;
 8000ffe:	6083      	str	r3, [r0, #8]
  
  /* Initialize the CRYP_KeySize member */
  CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;
 8001000:	60c3      	str	r3, [r0, #12]
 8001002:	4770      	bx	lr

08001004 <CRYP_KeyInit>:
  * @retval None
  */
void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
{
  /* Key Initialisation */
  CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;
 8001004:	6802      	ldr	r2, [r0, #0]
 8001006:	4b08      	ldr	r3, [pc, #32]	; (8001028 <CRYP_KeyInit+0x24>)
 8001008:	621a      	str	r2, [r3, #32]
  CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;
 800100a:	6842      	ldr	r2, [r0, #4]
 800100c:	625a      	str	r2, [r3, #36]	; 0x24
  CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;
 800100e:	6882      	ldr	r2, [r0, #8]
 8001010:	629a      	str	r2, [r3, #40]	; 0x28
  CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;
 8001012:	68c2      	ldr	r2, [r0, #12]
 8001014:	62da      	str	r2, [r3, #44]	; 0x2c
  CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;
 8001016:	6902      	ldr	r2, [r0, #16]
 8001018:	631a      	str	r2, [r3, #48]	; 0x30
  CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;
 800101a:	6942      	ldr	r2, [r0, #20]
 800101c:	635a      	str	r2, [r3, #52]	; 0x34
  CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;
 800101e:	6982      	ldr	r2, [r0, #24]
 8001020:	639a      	str	r2, [r3, #56]	; 0x38
  CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;
 8001022:	69c2      	ldr	r2, [r0, #28]
 8001024:	63da      	str	r2, [r3, #60]	; 0x3c
 8001026:	4770      	bx	lr
 8001028:	50060000 	.word	0x50060000

0800102c <CRYP_KeyStructInit>:
  *         which will be initialized.
  * @retval None
  */
void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
{
  CRYP_KeyInitStruct->CRYP_Key0Left  = 0;
 800102c:	2300      	movs	r3, #0
 800102e:	6003      	str	r3, [r0, #0]
  CRYP_KeyInitStruct->CRYP_Key0Right = 0;
 8001030:	6043      	str	r3, [r0, #4]
  CRYP_KeyInitStruct->CRYP_Key1Left  = 0;
 8001032:	6083      	str	r3, [r0, #8]
  CRYP_KeyInitStruct->CRYP_Key1Right = 0;
 8001034:	60c3      	str	r3, [r0, #12]
  CRYP_KeyInitStruct->CRYP_Key2Left  = 0;
 8001036:	6103      	str	r3, [r0, #16]
  CRYP_KeyInitStruct->CRYP_Key2Right = 0;
 8001038:	6143      	str	r3, [r0, #20]
  CRYP_KeyInitStruct->CRYP_Key3Left  = 0;
 800103a:	6183      	str	r3, [r0, #24]
  CRYP_KeyInitStruct->CRYP_Key3Right = 0;
 800103c:	61c3      	str	r3, [r0, #28]
 800103e:	4770      	bx	lr

08001040 <CRYP_IVInit>:
  *         the configuration information for the CRYP Initialization Vectors(IV).
  * @retval None
  */
void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
{
  CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;
 8001040:	6802      	ldr	r2, [r0, #0]
 8001042:	4b04      	ldr	r3, [pc, #16]	; (8001054 <CRYP_IVInit+0x14>)
 8001044:	641a      	str	r2, [r3, #64]	; 0x40
  CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;
 8001046:	6842      	ldr	r2, [r0, #4]
 8001048:	645a      	str	r2, [r3, #68]	; 0x44
  CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;
 800104a:	6882      	ldr	r2, [r0, #8]
 800104c:	649a      	str	r2, [r3, #72]	; 0x48
  CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;
 800104e:	68c2      	ldr	r2, [r0, #12]
 8001050:	64da      	str	r2, [r3, #76]	; 0x4c
 8001052:	4770      	bx	lr
 8001054:	50060000 	.word	0x50060000

08001058 <CRYP_IVStructInit>:
  *         Vectors(IV) structure which will be initialized.
  * @retval None
  */
void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
{
  CRYP_IVInitStruct->CRYP_IV0Left  = 0;
 8001058:	2300      	movs	r3, #0
 800105a:	6003      	str	r3, [r0, #0]
  CRYP_IVInitStruct->CRYP_IV0Right = 0;
 800105c:	6043      	str	r3, [r0, #4]
  CRYP_IVInitStruct->CRYP_IV1Left  = 0;
 800105e:	6083      	str	r3, [r0, #8]
  CRYP_IVInitStruct->CRYP_IV1Right = 0;
 8001060:	60c3      	str	r3, [r0, #12]
 8001062:	4770      	bx	lr

08001064 <CRYP_PhaseConfig>:

  /* Check the parameter */
  assert_param(IS_CRYP_PHASE(CRYP_Phase));

  /* Get the CR register */
  tempcr = CRYP->CR;
 8001064:	4a03      	ldr	r2, [pc, #12]	; (8001074 <CRYP_PhaseConfig+0x10>)
 8001066:	6813      	ldr	r3, [r2, #0]
  
  /* Reset the phase configuration bits: GCMP_CCMPH */
  tempcr &= (uint32_t)(~CRYP_CR_GCM_CCMPH);
 8001068:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
  /* Set the selected phase */
  tempcr |= (uint32_t)CRYP_Phase;
 800106c:	4318      	orrs	r0, r3

  /* Set the CR register */ 
  CRYP->CR = tempcr;    
 800106e:	6010      	str	r0, [r2, #0]
 8001070:	4770      	bx	lr
 8001072:	bf00      	nop
 8001074:	50060000 	.word	0x50060000

08001078 <CRYP_FIFOFlush>:
  * @retval None
  */
void CRYP_FIFOFlush(void)
{
  /* Reset the read and write pointers of the FIFOs */
  CRYP->CR |= CRYP_CR_FFLUSH;
 8001078:	4a02      	ldr	r2, [pc, #8]	; (8001084 <CRYP_FIFOFlush+0xc>)
 800107a:	6813      	ldr	r3, [r2, #0]
 800107c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001080:	6013      	str	r3, [r2, #0]
 8001082:	4770      	bx	lr
 8001084:	50060000 	.word	0x50060000

08001088 <CRYP_Cmd>:
void CRYP_Cmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001088:	b928      	cbnz	r0, 8001096 <CRYP_Cmd+0xe>
    CRYP->CR |= CRYP_CR_CRYPEN;
  }
  else
  {
    /* Disable the Cryptographic processor */
    CRYP->CR &= ~CRYP_CR_CRYPEN;
 800108a:	4a06      	ldr	r2, [pc, #24]	; (80010a4 <CRYP_Cmd+0x1c>)
 800108c:	6813      	ldr	r3, [r2, #0]
 800108e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8001092:	6013      	str	r3, [r2, #0]
 8001094:	4770      	bx	lr
    CRYP->CR |= CRYP_CR_CRYPEN;
 8001096:	4a03      	ldr	r2, [pc, #12]	; (80010a4 <CRYP_Cmd+0x1c>)
 8001098:	6813      	ldr	r3, [r2, #0]
 800109a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800109e:	6013      	str	r3, [r2, #0]
 80010a0:	4770      	bx	lr
 80010a2:	bf00      	nop
 80010a4:	50060000 	.word	0x50060000

080010a8 <CRYP_DataIn>:
  * @param  Data: data to write in Data Input register
  * @retval None
  */
void CRYP_DataIn(uint32_t Data)
{
  CRYP->DR = Data;
 80010a8:	4b01      	ldr	r3, [pc, #4]	; (80010b0 <CRYP_DataIn+0x8>)
 80010aa:	6098      	str	r0, [r3, #8]
 80010ac:	4770      	bx	lr
 80010ae:	bf00      	nop
 80010b0:	50060000 	.word	0x50060000

080010b4 <CRYP_DataOut>:
  * @param  None
  * @retval Last data entered into the output FIFO.
  */
uint32_t CRYP_DataOut(void)
{
  return CRYP->DOUT;
 80010b4:	4b01      	ldr	r3, [pc, #4]	; (80010bc <CRYP_DataOut+0x8>)
 80010b6:	68d8      	ldr	r0, [r3, #12]
}
 80010b8:	4770      	bx	lr
 80010ba:	bf00      	nop
 80010bc:	50060000 	.word	0x50060000

080010c0 <CRYP_SaveContext>:
  *         contains the configuration information for the CRYP Keys.  
  * @retval None
  */
ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
                             CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
{
 80010c0:	b430      	push	{r4, r5}
 80010c2:	b082      	sub	sp, #8
  __IO uint32_t timeout = 0;
 80010c4:	2300      	movs	r3, #0
 80010c6:	9301      	str	r3, [sp, #4]
  uint32_t ckeckmask = 0, bitstatus;    
  ErrorStatus status = ERROR;

  /* Stop DMA transfers on the IN FIFO by clearing the DIEN bit in the CRYP_DMACR */
  CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DIEN;
 80010c8:	4b39      	ldr	r3, [pc, #228]	; (80011b0 <CRYP_SaveContext+0xf0>)
 80010ca:	691a      	ldr	r2, [r3, #16]
 80010cc:	f022 0201 	bic.w	r2, r2, #1
 80010d0:	611a      	str	r2, [r3, #16]
    
  /* Wait until both the IN and OUT FIFOs are empty  
    (IFEM=1 and OFNE=0 in the CRYP_SR register) and the 
     BUSY bit is cleared. */

  if ((CRYP->CR & (uint32_t)(CRYP_CR_ALGOMODE_TDES_ECB | CRYP_CR_ALGOMODE_TDES_CBC)) != (uint32_t)0 )/* TDES */
 80010d2:	681b      	ldr	r3, [r3, #0]
 80010d4:	f013 0f08 	tst.w	r3, #8
 80010d8:	d016      	beq.n	8001108 <CRYP_SaveContext+0x48>
  { 
    ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY ;
 80010da:	2511      	movs	r5, #17
    ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
  }           
   
  do 
  {
    bitstatus = CRYP->SR & ckeckmask;
 80010dc:	4b34      	ldr	r3, [pc, #208]	; (80011b0 <CRYP_SaveContext+0xf0>)
 80010de:	685a      	ldr	r2, [r3, #4]
 80010e0:	402a      	ands	r2, r5
    timeout++;
 80010e2:	9b01      	ldr	r3, [sp, #4]
 80010e4:	3301      	adds	r3, #1
 80010e6:	9301      	str	r3, [sp, #4]
  }
  while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
 80010e8:	9c01      	ldr	r4, [sp, #4]
 80010ea:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80010ee:	429c      	cmp	r4, r3
 80010f0:	d001      	beq.n	80010f6 <CRYP_SaveContext+0x36>
 80010f2:	2a01      	cmp	r2, #1
 80010f4:	d1f2      	bne.n	80010dc <CRYP_SaveContext+0x1c>
     
  if ((CRYP->SR & ckeckmask) != CRYP_SR_IFEM)
 80010f6:	4b2e      	ldr	r3, [pc, #184]	; (80011b0 <CRYP_SaveContext+0xf0>)
 80010f8:	685b      	ldr	r3, [r3, #4]
 80010fa:	401d      	ands	r5, r3
 80010fc:	2d01      	cmp	r5, #1
 80010fe:	d005      	beq.n	800110c <CRYP_SaveContext+0x4c>
  {
    status = ERROR;
 8001100:	2000      	movs	r0, #0
     
    status = SUCCESS;
  }

   return status;
}
 8001102:	b002      	add	sp, #8
 8001104:	bc30      	pop	{r4, r5}
 8001106:	4770      	bx	lr
    ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
 8001108:	2515      	movs	r5, #21
 800110a:	e7e7      	b.n	80010dc <CRYP_SaveContext+0x1c>
    CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DOEN;
 800110c:	4b28      	ldr	r3, [pc, #160]	; (80011b0 <CRYP_SaveContext+0xf0>)
 800110e:	691a      	ldr	r2, [r3, #16]
 8001110:	f022 0202 	bic.w	r2, r2, #2
 8001114:	611a      	str	r2, [r3, #16]
    CRYP->CR &= ~(uint32_t)CRYP_CR_CRYPEN;
 8001116:	681a      	ldr	r2, [r3, #0]
 8001118:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800111c:	601a      	str	r2, [r3, #0]
    CRYP_ContextSave->CR_CurrentConfig  = CRYP->CR & (CRYP_CR_GCM_CCMPH |
 800111e:	681a      	ldr	r2, [r3, #0]
 8001120:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8001124:	f422 0274 	bic.w	r2, r2, #15990784	; 0xf40000
 8001128:	f422 427c 	bic.w	r2, r2, #64512	; 0xfc00
 800112c:	f022 0203 	bic.w	r2, r2, #3
 8001130:	6002      	str	r2, [r0, #0]
    CRYP_ContextSave->CRYP_IV0LR = CRYP->IV0LR;
 8001132:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001134:	6042      	str	r2, [r0, #4]
    CRYP_ContextSave->CRYP_IV0RR = CRYP->IV0RR;
 8001136:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001138:	6082      	str	r2, [r0, #8]
    CRYP_ContextSave->CRYP_IV1LR = CRYP->IV1LR;
 800113a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800113c:	60c2      	str	r2, [r0, #12]
    CRYP_ContextSave->CRYP_IV1RR = CRYP->IV1RR;
 800113e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001140:	6102      	str	r2, [r0, #16]
    CRYP_ContextSave->CRYP_K0LR = CRYP_KeyInitStruct->CRYP_Key0Left; 
 8001142:	680a      	ldr	r2, [r1, #0]
 8001144:	6142      	str	r2, [r0, #20]
    CRYP_ContextSave->CRYP_K0RR = CRYP_KeyInitStruct->CRYP_Key0Right; 
 8001146:	684a      	ldr	r2, [r1, #4]
 8001148:	6182      	str	r2, [r0, #24]
    CRYP_ContextSave->CRYP_K1LR = CRYP_KeyInitStruct->CRYP_Key1Left; 
 800114a:	688a      	ldr	r2, [r1, #8]
 800114c:	61c2      	str	r2, [r0, #28]
    CRYP_ContextSave->CRYP_K1RR = CRYP_KeyInitStruct->CRYP_Key1Right; 
 800114e:	68ca      	ldr	r2, [r1, #12]
 8001150:	6202      	str	r2, [r0, #32]
    CRYP_ContextSave->CRYP_K2LR = CRYP_KeyInitStruct->CRYP_Key2Left; 
 8001152:	690a      	ldr	r2, [r1, #16]
 8001154:	6242      	str	r2, [r0, #36]	; 0x24
    CRYP_ContextSave->CRYP_K2RR = CRYP_KeyInitStruct->CRYP_Key2Right; 
 8001156:	694a      	ldr	r2, [r1, #20]
 8001158:	6282      	str	r2, [r0, #40]	; 0x28
    CRYP_ContextSave->CRYP_K3LR = CRYP_KeyInitStruct->CRYP_Key3Left; 
 800115a:	698a      	ldr	r2, [r1, #24]
 800115c:	62c2      	str	r2, [r0, #44]	; 0x2c
    CRYP_ContextSave->CRYP_K3RR = CRYP_KeyInitStruct->CRYP_Key3Right; 
 800115e:	69ca      	ldr	r2, [r1, #28]
 8001160:	6302      	str	r2, [r0, #48]	; 0x30
    CRYP_ContextSave->CRYP_CSGCMCCMR[0] = CRYP->CSGCMCCM0R;
 8001162:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8001164:	6342      	str	r2, [r0, #52]	; 0x34
    CRYP_ContextSave->CRYP_CSGCMCCMR[1] = CRYP->CSGCMCCM1R;
 8001166:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8001168:	6382      	str	r2, [r0, #56]	; 0x38
    CRYP_ContextSave->CRYP_CSGCMCCMR[2] = CRYP->CSGCMCCM2R;
 800116a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800116c:	63c2      	str	r2, [r0, #60]	; 0x3c
    CRYP_ContextSave->CRYP_CSGCMCCMR[3] = CRYP->CSGCMCCM3R;
 800116e:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8001170:	6402      	str	r2, [r0, #64]	; 0x40
    CRYP_ContextSave->CRYP_CSGCMCCMR[4] = CRYP->CSGCMCCM4R;
 8001172:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8001174:	6442      	str	r2, [r0, #68]	; 0x44
    CRYP_ContextSave->CRYP_CSGCMCCMR[5] = CRYP->CSGCMCCM5R;
 8001176:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8001178:	6482      	str	r2, [r0, #72]	; 0x48
    CRYP_ContextSave->CRYP_CSGCMCCMR[6] = CRYP->CSGCMCCM6R;
 800117a:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800117c:	64c2      	str	r2, [r0, #76]	; 0x4c
    CRYP_ContextSave->CRYP_CSGCMCCMR[7] = CRYP->CSGCMCCM7R;
 800117e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8001180:	6502      	str	r2, [r0, #80]	; 0x50
    CRYP_ContextSave->CRYP_CSGCMR[0] = CRYP->CSGCM0R;
 8001182:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8001184:	6542      	str	r2, [r0, #84]	; 0x54
    CRYP_ContextSave->CRYP_CSGCMR[1] = CRYP->CSGCM1R;
 8001186:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8001188:	6582      	str	r2, [r0, #88]	; 0x58
    CRYP_ContextSave->CRYP_CSGCMR[2] = CRYP->CSGCM2R;
 800118a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800118c:	65c2      	str	r2, [r0, #92]	; 0x5c
    CRYP_ContextSave->CRYP_CSGCMR[3] = CRYP->CSGCM3R;
 800118e:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 8001190:	6602      	str	r2, [r0, #96]	; 0x60
    CRYP_ContextSave->CRYP_CSGCMR[4] = CRYP->CSGCM4R;
 8001192:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8001196:	6642      	str	r2, [r0, #100]	; 0x64
    CRYP_ContextSave->CRYP_CSGCMR[5] = CRYP->CSGCM5R;
 8001198:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 800119c:	6682      	str	r2, [r0, #104]	; 0x68
    CRYP_ContextSave->CRYP_CSGCMR[6] = CRYP->CSGCM6R;
 800119e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 80011a2:	66c2      	str	r2, [r0, #108]	; 0x6c
    CRYP_ContextSave->CRYP_CSGCMR[7] = CRYP->CSGCM7R;
 80011a4:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80011a8:	6703      	str	r3, [r0, #112]	; 0x70
    status = SUCCESS;
 80011aa:	2001      	movs	r0, #1
 80011ac:	e7a9      	b.n	8001102 <CRYP_SaveContext+0x42>
 80011ae:	bf00      	nop
 80011b0:	50060000 	.word	0x50060000

080011b4 <CRYP_RestoreContext>:
  */
void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)  
{

  /* Configure the processor with the saved configuration */
  CRYP->CR = CRYP_ContextRestore->CR_CurrentConfig;
 80011b4:	6802      	ldr	r2, [r0, #0]
 80011b6:	4b21      	ldr	r3, [pc, #132]	; (800123c <CRYP_RestoreContext+0x88>)
 80011b8:	601a      	str	r2, [r3, #0]

  /* restore The key value */
  CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; 
 80011ba:	6942      	ldr	r2, [r0, #20]
 80011bc:	621a      	str	r2, [r3, #32]
  CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;
 80011be:	6982      	ldr	r2, [r0, #24]
 80011c0:	625a      	str	r2, [r3, #36]	; 0x24
  CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;
 80011c2:	69c2      	ldr	r2, [r0, #28]
 80011c4:	629a      	str	r2, [r3, #40]	; 0x28
  CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;
 80011c6:	6a02      	ldr	r2, [r0, #32]
 80011c8:	62da      	str	r2, [r3, #44]	; 0x2c
  CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;
 80011ca:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80011cc:	631a      	str	r2, [r3, #48]	; 0x30
  CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;
 80011ce:	6a82      	ldr	r2, [r0, #40]	; 0x28
 80011d0:	635a      	str	r2, [r3, #52]	; 0x34
  CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;
 80011d2:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 80011d4:	639a      	str	r2, [r3, #56]	; 0x38
  CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;
 80011d6:	6b02      	ldr	r2, [r0, #48]	; 0x30
 80011d8:	63da      	str	r2, [r3, #60]	; 0x3c

  /* and the initialization vectors. */
  CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;
 80011da:	6842      	ldr	r2, [r0, #4]
 80011dc:	641a      	str	r2, [r3, #64]	; 0x40
  CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;
 80011de:	6882      	ldr	r2, [r0, #8]
 80011e0:	645a      	str	r2, [r3, #68]	; 0x44
  CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;
 80011e2:	68c2      	ldr	r2, [r0, #12]
 80011e4:	649a      	str	r2, [r3, #72]	; 0x48
  CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;
 80011e6:	6902      	ldr	r2, [r0, #16]
 80011e8:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Restore the content of context swap registers */
  CRYP->CSGCMCCM0R = CRYP_ContextRestore->CRYP_CSGCMCCMR[0];
 80011ea:	6b42      	ldr	r2, [r0, #52]	; 0x34
 80011ec:	651a      	str	r2, [r3, #80]	; 0x50
  CRYP->CSGCMCCM1R = CRYP_ContextRestore->CRYP_CSGCMCCMR[1];
 80011ee:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80011f0:	655a      	str	r2, [r3, #84]	; 0x54
  CRYP->CSGCMCCM2R = CRYP_ContextRestore->CRYP_CSGCMCCMR[2];
 80011f2:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 80011f4:	659a      	str	r2, [r3, #88]	; 0x58
  CRYP->CSGCMCCM3R = CRYP_ContextRestore->CRYP_CSGCMCCMR[3];
 80011f6:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80011f8:	65da      	str	r2, [r3, #92]	; 0x5c
  CRYP->CSGCMCCM4R = CRYP_ContextRestore->CRYP_CSGCMCCMR[4];
 80011fa:	6c42      	ldr	r2, [r0, #68]	; 0x44
 80011fc:	661a      	str	r2, [r3, #96]	; 0x60
  CRYP->CSGCMCCM5R = CRYP_ContextRestore->CRYP_CSGCMCCMR[5];
 80011fe:	6c82      	ldr	r2, [r0, #72]	; 0x48
 8001200:	665a      	str	r2, [r3, #100]	; 0x64
  CRYP->CSGCMCCM6R = CRYP_ContextRestore->CRYP_CSGCMCCMR[6];
 8001202:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
 8001204:	669a      	str	r2, [r3, #104]	; 0x68
  CRYP->CSGCMCCM7R = CRYP_ContextRestore->CRYP_CSGCMCCMR[7];
 8001206:	6d02      	ldr	r2, [r0, #80]	; 0x50
 8001208:	66da      	str	r2, [r3, #108]	; 0x6c
  
  CRYP->CSGCM0R = CRYP_ContextRestore->CRYP_CSGCMR[0];
 800120a:	6d42      	ldr	r2, [r0, #84]	; 0x54
 800120c:	671a      	str	r2, [r3, #112]	; 0x70
  CRYP->CSGCM1R = CRYP_ContextRestore->CRYP_CSGCMR[1];
 800120e:	6d82      	ldr	r2, [r0, #88]	; 0x58
 8001210:	675a      	str	r2, [r3, #116]	; 0x74
  CRYP->CSGCM2R = CRYP_ContextRestore->CRYP_CSGCMR[2];
 8001212:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 8001214:	679a      	str	r2, [r3, #120]	; 0x78
  CRYP->CSGCM3R = CRYP_ContextRestore->CRYP_CSGCMR[3];
 8001216:	6e02      	ldr	r2, [r0, #96]	; 0x60
 8001218:	67da      	str	r2, [r3, #124]	; 0x7c
  CRYP->CSGCM4R = CRYP_ContextRestore->CRYP_CSGCMR[4];
 800121a:	6e42      	ldr	r2, [r0, #100]	; 0x64
 800121c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  CRYP->CSGCM5R = CRYP_ContextRestore->CRYP_CSGCMR[5];
 8001220:	6e82      	ldr	r2, [r0, #104]	; 0x68
 8001222:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  CRYP->CSGCM6R = CRYP_ContextRestore->CRYP_CSGCMR[6];
 8001226:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 8001228:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  CRYP->CSGCM7R = CRYP_ContextRestore->CRYP_CSGCMR[7];
 800122c:	6f02      	ldr	r2, [r0, #112]	; 0x70
 800122e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  
  /* Enable the cryptographic processor */
  CRYP->CR |= CRYP_CR_CRYPEN;
 8001232:	681a      	ldr	r2, [r3, #0]
 8001234:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001238:	601a      	str	r2, [r3, #0]
 800123a:	4770      	bx	lr
 800123c:	50060000 	.word	0x50060000

08001240 <CRYP_DMACmd>:
{
  /* Check the parameters */
  assert_param(IS_CRYP_DMAREQ(CRYP_DMAReq));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001240:	b931      	cbnz	r1, 8001250 <CRYP_DMACmd+0x10>
    CRYP->DMACR |= CRYP_DMAReq;
  }
  else
  {
    /* Disable the selected CRYP DMA request */
    CRYP->DMACR &= (uint8_t)~CRYP_DMAReq;
 8001242:	4a06      	ldr	r2, [pc, #24]	; (800125c <CRYP_DMACmd+0x1c>)
 8001244:	6913      	ldr	r3, [r2, #16]
 8001246:	43c0      	mvns	r0, r0
 8001248:	b2c0      	uxtb	r0, r0
 800124a:	4018      	ands	r0, r3
 800124c:	6110      	str	r0, [r2, #16]
 800124e:	4770      	bx	lr
    CRYP->DMACR |= CRYP_DMAReq;
 8001250:	4b02      	ldr	r3, [pc, #8]	; (800125c <CRYP_DMACmd+0x1c>)
 8001252:	691a      	ldr	r2, [r3, #16]
 8001254:	4310      	orrs	r0, r2
 8001256:	6118      	str	r0, [r3, #16]
 8001258:	4770      	bx	lr
 800125a:	bf00      	nop
 800125c:	50060000 	.word	0x50060000

08001260 <CRYP_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_CRYP_CONFIG_IT(CRYP_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8001260:	b931      	cbnz	r1, 8001270 <CRYP_ITConfig+0x10>
    CRYP->IMSCR |= CRYP_IT;
  }
  else
  {
    /* Disable the selected CRYP interrupt */
    CRYP->IMSCR &= (uint8_t)~CRYP_IT;
 8001262:	4a06      	ldr	r2, [pc, #24]	; (800127c <CRYP_ITConfig+0x1c>)
 8001264:	6953      	ldr	r3, [r2, #20]
 8001266:	43c0      	mvns	r0, r0
 8001268:	b2c0      	uxtb	r0, r0
 800126a:	4018      	ands	r0, r3
 800126c:	6150      	str	r0, [r2, #20]
 800126e:	4770      	bx	lr
    CRYP->IMSCR |= CRYP_IT;
 8001270:	4b02      	ldr	r3, [pc, #8]	; (800127c <CRYP_ITConfig+0x1c>)
 8001272:	695a      	ldr	r2, [r3, #20]
 8001274:	4310      	orrs	r0, r2
 8001276:	6158      	str	r0, [r3, #20]
 8001278:	4770      	bx	lr
 800127a:	bf00      	nop
 800127c:	50060000 	.word	0x50060000

08001280 <CRYP_GetITStatus>:
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_CRYP_GET_IT(CRYP_IT));

  /* Check the status of the specified CRYP interrupt */
  if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)
 8001280:	4b03      	ldr	r3, [pc, #12]	; (8001290 <CRYP_GetITStatus+0x10>)
 8001282:	69db      	ldr	r3, [r3, #28]
 8001284:	4218      	tst	r0, r3
 8001286:	d101      	bne.n	800128c <CRYP_GetITStatus+0xc>
    bitstatus = SET;
  }
  else
  {
    /* CRYP_IT is reset */
    bitstatus = RESET;
 8001288:	2000      	movs	r0, #0
  }
  /* Return the CRYP_IT status */
  return bitstatus;
}
 800128a:	4770      	bx	lr
    bitstatus = SET;
 800128c:	2001      	movs	r0, #1
 800128e:	4770      	bx	lr
 8001290:	50060000 	.word	0x50060000

08001294 <CRYP_GetCmdStatus>:
  */
FunctionalState CRYP_GetCmdStatus(void)
{
  FunctionalState state = DISABLE;

  if ((CRYP->CR & CRYP_CR_CRYPEN) != 0)
 8001294:	4b04      	ldr	r3, [pc, #16]	; (80012a8 <CRYP_GetCmdStatus+0x14>)
 8001296:	681b      	ldr	r3, [r3, #0]
 8001298:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 800129c:	d101      	bne.n	80012a2 <CRYP_GetCmdStatus+0xe>
    state = ENABLE;
  }
  else
  {
    /* CRYPEN bit is reset */
    state = DISABLE;
 800129e:	2000      	movs	r0, #0
  }
  return state;
}
 80012a0:	4770      	bx	lr
    state = ENABLE;
 80012a2:	2001      	movs	r0, #1
 80012a4:	4770      	bx	lr
 80012a6:	bf00      	nop
 80012a8:	50060000 	.word	0x50060000

080012ac <CRYP_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));

  /* check if the FLAG is in RISR register */
  if ((CRYP_FLAG & FLAG_MASK) != 0x00) 
 80012ac:	f010 0f20 	tst.w	r0, #32
 80012b0:	d005      	beq.n	80012be <CRYP_GetFlagStatus+0x12>
  {
    tempreg = CRYP->RISR;
 80012b2:	4b05      	ldr	r3, [pc, #20]	; (80012c8 <CRYP_GetFlagStatus+0x1c>)
 80012b4:	699b      	ldr	r3, [r3, #24]
    tempreg = CRYP->SR;
  }


  /* Check the status of the specified CRYP flag */
  if ((tempreg & CRYP_FLAG ) != (uint8_t)RESET)
 80012b6:	4218      	tst	r0, r3
 80012b8:	d104      	bne.n	80012c4 <CRYP_GetFlagStatus+0x18>
    bitstatus = SET;
  }
  else
  {
    /* CRYP_FLAG is reset */
    bitstatus = RESET;
 80012ba:	2000      	movs	r0, #0
  }

  /* Return the CRYP_FLAG status */
  return  bitstatus;
}
 80012bc:	4770      	bx	lr
    tempreg = CRYP->SR;
 80012be:	4b02      	ldr	r3, [pc, #8]	; (80012c8 <CRYP_GetFlagStatus+0x1c>)
 80012c0:	685b      	ldr	r3, [r3, #4]
 80012c2:	e7f8      	b.n	80012b6 <CRYP_GetFlagStatus+0xa>
    bitstatus = SET;
 80012c4:	2001      	movs	r0, #1
 80012c6:	4770      	bx	lr
 80012c8:	50060000 	.word	0x50060000

080012cc <CRYP_AES_ECB>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_AES_ECB(uint8_t Mode, uint8_t* Key, uint16_t Keysize,
                         uint8_t* Input, uint32_t Ilength, uint8_t* Output)
{
 80012cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80012d0:	b08f      	sub	sp, #60	; 0x3c
 80012d2:	4681      	mov	r9, r0
 80012d4:	460d      	mov	r5, r1
 80012d6:	4616      	mov	r6, r2
 80012d8:	f8dd 8058 	ldr.w	r8, [sp, #88]	; 0x58
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
 80012dc:	2200      	movs	r2, #0
 80012de:	9201      	str	r2, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
 80012e0:	461c      	mov	r4, r3
  uint32_t outputaddr = (uint32_t)Output;
 80012e2:	9f17      	ldr	r7, [sp, #92]	; 0x5c
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 80012e4:	a802      	add	r0, sp, #8
 80012e6:	f7ff fea1 	bl	800102c <CRYP_KeyStructInit>

  switch(Keysize)
 80012ea:	2ec0      	cmp	r6, #192	; 0xc0
 80012ec:	d03a      	beq.n	8001364 <CRYP_AES_ECB+0x98>
 80012ee:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 80012f2:	d04d      	beq.n	8001390 <CRYP_AES_ECB+0xc4>
 80012f4:	2e80      	cmp	r6, #128	; 0x80
 80012f6:	d026      	beq.n	8001346 <CRYP_AES_ECB+0x7a>
    default:
    break;
  }

  /*------------------ AES Decryption ------------------*/
  if(Mode == MODE_DECRYPT) /* AES decryption */
 80012f8:	f1b9 0f00 	cmp.w	r9, #0
 80012fc:	d164      	bne.n	80013c8 <CRYP_AES_ECB+0xfc>
  {
    /* Flush IN/OUT FIFOs */
    CRYP_FIFOFlush();
 80012fe:	f7ff febb 	bl	8001078 <CRYP_FIFOFlush>

    /* Crypto Init for Key preparation for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 8001302:	2304      	movs	r3, #4
 8001304:	930a      	str	r3, [sp, #40]	; 0x28
    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
 8001306:	2338      	movs	r3, #56	; 0x38
 8001308:	930b      	str	r3, [sp, #44]	; 0x2c
    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
 800130a:	2300      	movs	r3, #0
 800130c:	930c      	str	r3, [sp, #48]	; 0x30
    CRYP_Init(&AES_CRYP_InitStructure);
 800130e:	a80a      	add	r0, sp, #40	; 0x28
 8001310:	f7ff fe42 	bl	8000f98 <CRYP_Init>

    /* Key Initialisation */
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 8001314:	a802      	add	r0, sp, #8
 8001316:	f7ff fe75 	bl	8001004 <CRYP_KeyInit>

    /* Enable Crypto processor */
    CRYP_Cmd(ENABLE);
 800131a:	2001      	movs	r0, #1
 800131c:	f7ff feb4 	bl	8001088 <CRYP_Cmd>

    /* wait until the Busy flag is RESET */
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 8001320:	2010      	movs	r0, #16
 8001322:	f7ff ffc3 	bl	80012ac <CRYP_GetFlagStatus>
 8001326:	4602      	mov	r2, r0
      counter++;
 8001328:	9b01      	ldr	r3, [sp, #4]
 800132a:	3301      	adds	r3, #1
 800132c:	9301      	str	r3, [sp, #4]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 800132e:	9b01      	ldr	r3, [sp, #4]
 8001330:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001334:	d001      	beq.n	800133a <CRYP_AES_ECB+0x6e>
 8001336:	2800      	cmp	r0, #0
 8001338:	d1f2      	bne.n	8001320 <CRYP_AES_ECB+0x54>

    if (busystatus != RESET)
 800133a:	2a00      	cmp	r2, #0
 800133c:	d15c      	bne.n	80013f8 <CRYP_AES_ECB+0x12c>
       status = ERROR;
    }
    else
    {
      /* Crypto Init for decryption process */  
      AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 800133e:	2304      	movs	r3, #4
 8001340:	930a      	str	r3, [sp, #40]	; 0x28
  ErrorStatus status = SUCCESS;
 8001342:	2601      	movs	r6, #1
 8001344:	e046      	b.n	80013d4 <CRYP_AES_ECB+0x108>
    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
 8001346:	2300      	movs	r3, #0
 8001348:	930d      	str	r3, [sp, #52]	; 0x34
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800134a:	682b      	ldr	r3, [r5, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
{
  uint32_t result;

  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
 800134c:	ba1b      	rev	r3, r3
 800134e:	9306      	str	r3, [sp, #24]
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001350:	686b      	ldr	r3, [r5, #4]
 8001352:	ba1b      	rev	r3, r3
 8001354:	9307      	str	r3, [sp, #28]
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001356:	68ab      	ldr	r3, [r5, #8]
 8001358:	ba1b      	rev	r3, r3
 800135a:	9308      	str	r3, [sp, #32]
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800135c:	68eb      	ldr	r3, [r5, #12]
 800135e:	ba1b      	rev	r3, r3
 8001360:	9309      	str	r3, [sp, #36]	; 0x24
    break;
 8001362:	e7c9      	b.n	80012f8 <CRYP_AES_ECB+0x2c>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
 8001364:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001368:	930d      	str	r3, [sp, #52]	; 0x34
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800136a:	682b      	ldr	r3, [r5, #0]
 800136c:	ba1b      	rev	r3, r3
 800136e:	9304      	str	r3, [sp, #16]
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8001370:	686b      	ldr	r3, [r5, #4]
 8001372:	ba1b      	rev	r3, r3
 8001374:	9305      	str	r3, [sp, #20]
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8001376:	68ab      	ldr	r3, [r5, #8]
 8001378:	ba1b      	rev	r3, r3
 800137a:	9306      	str	r3, [sp, #24]
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800137c:	68eb      	ldr	r3, [r5, #12]
 800137e:	ba1b      	rev	r3, r3
 8001380:	9307      	str	r3, [sp, #28]
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001382:	692b      	ldr	r3, [r5, #16]
 8001384:	ba1b      	rev	r3, r3
 8001386:	9308      	str	r3, [sp, #32]
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8001388:	696b      	ldr	r3, [r5, #20]
 800138a:	ba1b      	rev	r3, r3
 800138c:	9309      	str	r3, [sp, #36]	; 0x24
    break;
 800138e:	e7b3      	b.n	80012f8 <CRYP_AES_ECB+0x2c>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
 8001390:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001394:	930d      	str	r3, [sp, #52]	; 0x34
    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
 8001396:	682b      	ldr	r3, [r5, #0]
 8001398:	ba1b      	rev	r3, r3
 800139a:	9302      	str	r3, [sp, #8]
    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
 800139c:	686b      	ldr	r3, [r5, #4]
 800139e:	ba1b      	rev	r3, r3
 80013a0:	9303      	str	r3, [sp, #12]
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 80013a2:	68ab      	ldr	r3, [r5, #8]
 80013a4:	ba1b      	rev	r3, r3
 80013a6:	9304      	str	r3, [sp, #16]
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 80013a8:	68eb      	ldr	r3, [r5, #12]
 80013aa:	ba1b      	rev	r3, r3
 80013ac:	9305      	str	r3, [sp, #20]
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 80013ae:	692b      	ldr	r3, [r5, #16]
 80013b0:	ba1b      	rev	r3, r3
 80013b2:	9306      	str	r3, [sp, #24]
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 80013b4:	696b      	ldr	r3, [r5, #20]
 80013b6:	ba1b      	rev	r3, r3
 80013b8:	9307      	str	r3, [sp, #28]
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 80013ba:	69ab      	ldr	r3, [r5, #24]
 80013bc:	ba1b      	rev	r3, r3
 80013be:	9308      	str	r3, [sp, #32]
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 80013c0:	69eb      	ldr	r3, [r5, #28]
 80013c2:	ba1b      	rev	r3, r3
 80013c4:	9309      	str	r3, [sp, #36]	; 0x24
    break;
 80013c6:	e797      	b.n	80012f8 <CRYP_AES_ECB+0x2c>
  }
  /*------------------ AES Encryption ------------------*/
  else /* AES encryption */
  {

    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 80013c8:	a802      	add	r0, sp, #8
 80013ca:	f7ff fe1b 	bl	8001004 <CRYP_KeyInit>

    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
 80013ce:	2300      	movs	r3, #0
 80013d0:	930a      	str	r3, [sp, #40]	; 0x28
  ErrorStatus status = SUCCESS;
 80013d2:	2601      	movs	r6, #1
  }

  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_ECB;
 80013d4:	2320      	movs	r3, #32
 80013d6:	930b      	str	r3, [sp, #44]	; 0x2c
  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 80013d8:	2380      	movs	r3, #128	; 0x80
 80013da:	930c      	str	r3, [sp, #48]	; 0x30
  CRYP_Init(&AES_CRYP_InitStructure);
 80013dc:	a80a      	add	r0, sp, #40	; 0x28
 80013de:	f7ff fddb 	bl	8000f98 <CRYP_Init>

  /* Flush IN/OUT FIFOs */
  CRYP_FIFOFlush();
 80013e2:	f7ff fe49 	bl	8001078 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 80013e6:	2001      	movs	r0, #1
 80013e8:	f7ff fe4e 	bl	8001088 <CRYP_Cmd>

  if(CRYP_GetCmdStatus() == DISABLE)
 80013ec:	f7ff ff52 	bl	8001294 <CRYP_GetCmdStatus>
 80013f0:	2800      	cmp	r0, #0
 80013f2:	d03b      	beq.n	800146c <CRYP_AES_ECB+0x1a0>
 80013f4:	2500      	movs	r5, #0
 80013f6:	e004      	b.n	8001402 <CRYP_AES_ECB+0x136>
       status = ERROR;
 80013f8:	2600      	movs	r6, #0
 80013fa:	e7eb      	b.n	80013d4 <CRYP_AES_ECB+0x108>
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 80013fc:	b30a      	cbz	r2, 8001442 <CRYP_AES_ECB+0x176>
   {
       status = ERROR;
 80013fe:	2600      	movs	r6, #0
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 8001400:	3510      	adds	r5, #16
 8001402:	4545      	cmp	r5, r8
 8001404:	d22b      	bcs.n	800145e <CRYP_AES_ECB+0x192>
 8001406:	b356      	cbz	r6, 800145e <CRYP_AES_ECB+0x192>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001408:	6820      	ldr	r0, [r4, #0]
 800140a:	f7ff fe4d 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800140e:	6860      	ldr	r0, [r4, #4]
 8001410:	f7ff fe4a 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001414:	68a0      	ldr	r0, [r4, #8]
 8001416:	f7ff fe47 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800141a:	68e0      	ldr	r0, [r4, #12]
 800141c:	f7ff fe44 	bl	80010a8 <CRYP_DataIn>
    inputaddr+=4;
 8001420:	3410      	adds	r4, #16
    counter = 0;
 8001422:	2300      	movs	r3, #0
 8001424:	9301      	str	r3, [sp, #4]
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 8001426:	2010      	movs	r0, #16
 8001428:	f7ff ff40 	bl	80012ac <CRYP_GetFlagStatus>
 800142c:	4602      	mov	r2, r0
      counter++;
 800142e:	9b01      	ldr	r3, [sp, #4]
 8001430:	3301      	adds	r3, #1
 8001432:	9301      	str	r3, [sp, #4]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 8001434:	9b01      	ldr	r3, [sp, #4]
 8001436:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800143a:	d0df      	beq.n	80013fc <CRYP_AES_ECB+0x130>
 800143c:	2800      	cmp	r0, #0
 800143e:	d1f2      	bne.n	8001426 <CRYP_AES_ECB+0x15a>
 8001440:	e7dc      	b.n	80013fc <CRYP_AES_ECB+0x130>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001442:	f7ff fe37 	bl	80010b4 <CRYP_DataOut>
 8001446:	6038      	str	r0, [r7, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001448:	f7ff fe34 	bl	80010b4 <CRYP_DataOut>
 800144c:	6078      	str	r0, [r7, #4]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800144e:	f7ff fe31 	bl	80010b4 <CRYP_DataOut>
 8001452:	60b8      	str	r0, [r7, #8]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut(); 
 8001454:	f7ff fe2e 	bl	80010b4 <CRYP_DataOut>
 8001458:	60f8      	str	r0, [r7, #12]
      outputaddr+=4;
 800145a:	3710      	adds	r7, #16
 800145c:	e7d0      	b.n	8001400 <CRYP_AES_ECB+0x134>
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 800145e:	2000      	movs	r0, #0
 8001460:	f7ff fe12 	bl	8001088 <CRYP_Cmd>

  return status; 
}
 8001464:	4630      	mov	r0, r6
 8001466:	b00f      	add	sp, #60	; 0x3c
 8001468:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return(ERROR);
 800146c:	2600      	movs	r6, #0
 800146e:	e7f9      	b.n	8001464 <CRYP_AES_ECB+0x198>

08001470 <CRYP_AES_CBC>:
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_AES_CBC(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key,
                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
                         uint8_t *Output)
{
 8001470:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001474:	b092      	sub	sp, #72	; 0x48
 8001476:	4681      	mov	r9, r0
 8001478:	460e      	mov	r6, r1
 800147a:	4615      	mov	r5, r2
 800147c:	469a      	mov	sl, r3
 800147e:	f8dd 806c 	ldr.w	r8, [sp, #108]	; 0x6c
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 8001482:	2300      	movs	r3, #0
 8001484:	9301      	str	r3, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
 8001486:	9c1a      	ldr	r4, [sp, #104]	; 0x68
  uint32_t outputaddr = (uint32_t)Output;
 8001488:	9f1c      	ldr	r7, [sp, #112]	; 0x70
  uint32_t ivaddr = (uint32_t)InitVectors;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 800148a:	a806      	add	r0, sp, #24
 800148c:	f7ff fdce 	bl	800102c <CRYP_KeyStructInit>

  switch(Keysize)
 8001490:	f1ba 0fc0 	cmp.w	sl, #192	; 0xc0
 8001494:	d047      	beq.n	8001526 <CRYP_AES_CBC+0xb6>
 8001496:	f5ba 7f80 	cmp.w	sl, #256	; 0x100
 800149a:	d05a      	beq.n	8001552 <CRYP_AES_CBC+0xe2>
 800149c:	f1ba 0f80 	cmp.w	sl, #128	; 0x80
 80014a0:	d032      	beq.n	8001508 <CRYP_AES_CBC+0x98>
    default:
    break;
  }

  /* CRYP Initialization Vectors */
  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 80014a2:	6833      	ldr	r3, [r6, #0]
 80014a4:	ba1b      	rev	r3, r3
 80014a6:	9302      	str	r3, [sp, #8]
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 80014a8:	6873      	ldr	r3, [r6, #4]
 80014aa:	ba1b      	rev	r3, r3
 80014ac:	9303      	str	r3, [sp, #12]
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
 80014ae:	68b3      	ldr	r3, [r6, #8]
 80014b0:	ba1b      	rev	r3, r3
 80014b2:	9304      	str	r3, [sp, #16]
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
 80014b4:	68f3      	ldr	r3, [r6, #12]
 80014b6:	ba1b      	rev	r3, r3
 80014b8:	9305      	str	r3, [sp, #20]


  /*------------------ AES Decryption ------------------*/
  if(Mode == MODE_DECRYPT) /* AES decryption */
 80014ba:	f1b9 0f00 	cmp.w	r9, #0
 80014be:	d164      	bne.n	800158a <CRYP_AES_CBC+0x11a>
  {
    /* Flush IN/OUT FIFOs */
    CRYP_FIFOFlush();
 80014c0:	f7ff fdda 	bl	8001078 <CRYP_FIFOFlush>

    /* Crypto Init for Key preparation for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 80014c4:	2304      	movs	r3, #4
 80014c6:	930e      	str	r3, [sp, #56]	; 0x38
    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_Key;
 80014c8:	2338      	movs	r3, #56	; 0x38
 80014ca:	930f      	str	r3, [sp, #60]	; 0x3c
    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_32b;
 80014cc:	2300      	movs	r3, #0
 80014ce:	9310      	str	r3, [sp, #64]	; 0x40

    CRYP_Init(&AES_CRYP_InitStructure);
 80014d0:	a80e      	add	r0, sp, #56	; 0x38
 80014d2:	f7ff fd61 	bl	8000f98 <CRYP_Init>

    /* Key Initialisation */
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 80014d6:	a806      	add	r0, sp, #24
 80014d8:	f7ff fd94 	bl	8001004 <CRYP_KeyInit>

    /* Enable Crypto processor */
    CRYP_Cmd(ENABLE);
 80014dc:	2001      	movs	r0, #1
 80014de:	f7ff fdd3 	bl	8001088 <CRYP_Cmd>

    /* wait until the Busy flag is RESET */
    do
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 80014e2:	2010      	movs	r0, #16
 80014e4:	f7ff fee2 	bl	80012ac <CRYP_GetFlagStatus>
 80014e8:	4602      	mov	r2, r0
      counter++;
 80014ea:	9b01      	ldr	r3, [sp, #4]
 80014ec:	3301      	adds	r3, #1
 80014ee:	9301      	str	r3, [sp, #4]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 80014f0:	9b01      	ldr	r3, [sp, #4]
 80014f2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80014f6:	d001      	beq.n	80014fc <CRYP_AES_CBC+0x8c>
 80014f8:	2800      	cmp	r0, #0
 80014fa:	d1f2      	bne.n	80014e2 <CRYP_AES_CBC+0x72>

    if (busystatus != RESET)
 80014fc:	2a00      	cmp	r2, #0
 80014fe:	d15f      	bne.n	80015c0 <CRYP_AES_CBC+0x150>
       status = ERROR;
    }
    else
    {
      /* Crypto Init for decryption process */  
      AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 8001500:	2304      	movs	r3, #4
 8001502:	930e      	str	r3, [sp, #56]	; 0x38
  ErrorStatus status = SUCCESS;
 8001504:	2601      	movs	r6, #1
 8001506:	e046      	b.n	8001596 <CRYP_AES_CBC+0x126>
    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
 8001508:	2300      	movs	r3, #0
 800150a:	9311      	str	r3, [sp, #68]	; 0x44
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800150c:	682b      	ldr	r3, [r5, #0]
 800150e:	ba1b      	rev	r3, r3
 8001510:	930a      	str	r3, [sp, #40]	; 0x28
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001512:	686b      	ldr	r3, [r5, #4]
 8001514:	ba1b      	rev	r3, r3
 8001516:	930b      	str	r3, [sp, #44]	; 0x2c
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001518:	68ab      	ldr	r3, [r5, #8]
 800151a:	ba1b      	rev	r3, r3
 800151c:	930c      	str	r3, [sp, #48]	; 0x30
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800151e:	68eb      	ldr	r3, [r5, #12]
 8001520:	ba1b      	rev	r3, r3
 8001522:	930d      	str	r3, [sp, #52]	; 0x34
    break;
 8001524:	e7bd      	b.n	80014a2 <CRYP_AES_CBC+0x32>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
 8001526:	f44f 7380 	mov.w	r3, #256	; 0x100
 800152a:	9311      	str	r3, [sp, #68]	; 0x44
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800152c:	682b      	ldr	r3, [r5, #0]
 800152e:	ba1b      	rev	r3, r3
 8001530:	9308      	str	r3, [sp, #32]
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8001532:	686b      	ldr	r3, [r5, #4]
 8001534:	ba1b      	rev	r3, r3
 8001536:	9309      	str	r3, [sp, #36]	; 0x24
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8001538:	68ab      	ldr	r3, [r5, #8]
 800153a:	ba1b      	rev	r3, r3
 800153c:	930a      	str	r3, [sp, #40]	; 0x28
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800153e:	68eb      	ldr	r3, [r5, #12]
 8001540:	ba1b      	rev	r3, r3
 8001542:	930b      	str	r3, [sp, #44]	; 0x2c
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001544:	692b      	ldr	r3, [r5, #16]
 8001546:	ba1b      	rev	r3, r3
 8001548:	930c      	str	r3, [sp, #48]	; 0x30
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 800154a:	696b      	ldr	r3, [r5, #20]
 800154c:	ba1b      	rev	r3, r3
 800154e:	930d      	str	r3, [sp, #52]	; 0x34
    break;
 8001550:	e7a7      	b.n	80014a2 <CRYP_AES_CBC+0x32>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
 8001552:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001556:	9311      	str	r3, [sp, #68]	; 0x44
    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
 8001558:	682b      	ldr	r3, [r5, #0]
 800155a:	ba1b      	rev	r3, r3
 800155c:	9306      	str	r3, [sp, #24]
    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
 800155e:	686b      	ldr	r3, [r5, #4]
 8001560:	ba1b      	rev	r3, r3
 8001562:	9307      	str	r3, [sp, #28]
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 8001564:	68ab      	ldr	r3, [r5, #8]
 8001566:	ba1b      	rev	r3, r3
 8001568:	9308      	str	r3, [sp, #32]
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 800156a:	68eb      	ldr	r3, [r5, #12]
 800156c:	ba1b      	rev	r3, r3
 800156e:	9309      	str	r3, [sp, #36]	; 0x24
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8001570:	692b      	ldr	r3, [r5, #16]
 8001572:	ba1b      	rev	r3, r3
 8001574:	930a      	str	r3, [sp, #40]	; 0x28
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001576:	696b      	ldr	r3, [r5, #20]
 8001578:	ba1b      	rev	r3, r3
 800157a:	930b      	str	r3, [sp, #44]	; 0x2c
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800157c:	69ab      	ldr	r3, [r5, #24]
 800157e:	ba1b      	rev	r3, r3
 8001580:	930c      	str	r3, [sp, #48]	; 0x30
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8001582:	69eb      	ldr	r3, [r5, #28]
 8001584:	ba1b      	rev	r3, r3
 8001586:	930d      	str	r3, [sp, #52]	; 0x34
    break;
 8001588:	e78b      	b.n	80014a2 <CRYP_AES_CBC+0x32>
    }
  }
  /*------------------ AES Encryption ------------------*/
  else /* AES encryption */
  {
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 800158a:	a806      	add	r0, sp, #24
 800158c:	f7ff fd3a 	bl	8001004 <CRYP_KeyInit>

    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
 8001590:	2300      	movs	r3, #0
 8001592:	930e      	str	r3, [sp, #56]	; 0x38
  ErrorStatus status = SUCCESS;
 8001594:	2601      	movs	r6, #1
  }
  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CBC;
 8001596:	2328      	movs	r3, #40	; 0x28
 8001598:	930f      	str	r3, [sp, #60]	; 0x3c
  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800159a:	2380      	movs	r3, #128	; 0x80
 800159c:	9310      	str	r3, [sp, #64]	; 0x40
  CRYP_Init(&AES_CRYP_InitStructure);
 800159e:	a80e      	add	r0, sp, #56	; 0x38
 80015a0:	f7ff fcfa 	bl	8000f98 <CRYP_Init>

  /* CRYP Initialization Vectors */
  CRYP_IVInit(&AES_CRYP_IVInitStructure);
 80015a4:	a802      	add	r0, sp, #8
 80015a6:	f7ff fd4b 	bl	8001040 <CRYP_IVInit>

  /* Flush IN/OUT FIFOs */
  CRYP_FIFOFlush();
 80015aa:	f7ff fd65 	bl	8001078 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 80015ae:	2001      	movs	r0, #1
 80015b0:	f7ff fd6a 	bl	8001088 <CRYP_Cmd>

  if(CRYP_GetCmdStatus() == DISABLE)
 80015b4:	f7ff fe6e 	bl	8001294 <CRYP_GetCmdStatus>
 80015b8:	2800      	cmp	r0, #0
 80015ba:	d03b      	beq.n	8001634 <CRYP_AES_CBC+0x1c4>
 80015bc:	2500      	movs	r5, #0
 80015be:	e004      	b.n	80015ca <CRYP_AES_CBC+0x15a>
       status = ERROR;
 80015c0:	2600      	movs	r6, #0
 80015c2:	e7e8      	b.n	8001596 <CRYP_AES_CBC+0x126>
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 80015c4:	b30a      	cbz	r2, 800160a <CRYP_AES_CBC+0x19a>
   {
       status = ERROR;
 80015c6:	2600      	movs	r6, #0
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 80015c8:	3510      	adds	r5, #16
 80015ca:	4545      	cmp	r5, r8
 80015cc:	d22b      	bcs.n	8001626 <CRYP_AES_CBC+0x1b6>
 80015ce:	b356      	cbz	r6, 8001626 <CRYP_AES_CBC+0x1b6>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80015d0:	6820      	ldr	r0, [r4, #0]
 80015d2:	f7ff fd69 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80015d6:	6860      	ldr	r0, [r4, #4]
 80015d8:	f7ff fd66 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80015dc:	68a0      	ldr	r0, [r4, #8]
 80015de:	f7ff fd63 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80015e2:	68e0      	ldr	r0, [r4, #12]
 80015e4:	f7ff fd60 	bl	80010a8 <CRYP_DataIn>
    inputaddr+=4;
 80015e8:	3410      	adds	r4, #16
    counter = 0;
 80015ea:	2300      	movs	r3, #0
 80015ec:	9301      	str	r3, [sp, #4]
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 80015ee:	2010      	movs	r0, #16
 80015f0:	f7ff fe5c 	bl	80012ac <CRYP_GetFlagStatus>
 80015f4:	4602      	mov	r2, r0
      counter++;
 80015f6:	9b01      	ldr	r3, [sp, #4]
 80015f8:	3301      	adds	r3, #1
 80015fa:	9301      	str	r3, [sp, #4]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 80015fc:	9b01      	ldr	r3, [sp, #4]
 80015fe:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001602:	d0df      	beq.n	80015c4 <CRYP_AES_CBC+0x154>
 8001604:	2800      	cmp	r0, #0
 8001606:	d1f2      	bne.n	80015ee <CRYP_AES_CBC+0x17e>
 8001608:	e7dc      	b.n	80015c4 <CRYP_AES_CBC+0x154>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800160a:	f7ff fd53 	bl	80010b4 <CRYP_DataOut>
 800160e:	6038      	str	r0, [r7, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001610:	f7ff fd50 	bl	80010b4 <CRYP_DataOut>
 8001614:	6078      	str	r0, [r7, #4]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001616:	f7ff fd4d 	bl	80010b4 <CRYP_DataOut>
 800161a:	60b8      	str	r0, [r7, #8]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800161c:	f7ff fd4a 	bl	80010b4 <CRYP_DataOut>
 8001620:	60f8      	str	r0, [r7, #12]
      outputaddr+=4;
 8001622:	3710      	adds	r7, #16
 8001624:	e7d0      	b.n	80015c8 <CRYP_AES_CBC+0x158>
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 8001626:	2000      	movs	r0, #0
 8001628:	f7ff fd2e 	bl	8001088 <CRYP_Cmd>

  return status;
}
 800162c:	4630      	mov	r0, r6
 800162e:	b012      	add	sp, #72	; 0x48
 8001630:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return(ERROR);
 8001634:	2600      	movs	r6, #0
 8001636:	e7f9      	b.n	800162c <CRYP_AES_CBC+0x1bc>

08001638 <CRYP_AES_CTR>:
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_AES_CTR(uint8_t Mode, uint8_t InitVectors[16], uint8_t *Key, 
                         uint16_t Keysize, uint8_t *Input, uint32_t Ilength,
                         uint8_t *Output)
{
 8001638:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800163c:	b092      	sub	sp, #72	; 0x48
 800163e:	4681      	mov	r9, r0
 8001640:	460e      	mov	r6, r1
 8001642:	4615      	mov	r5, r2
 8001644:	469a      	mov	sl, r3
 8001646:	f8dd 806c 	ldr.w	r8, [sp, #108]	; 0x6c
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 800164a:	2300      	movs	r3, #0
 800164c:	9301      	str	r3, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
 800164e:	9c1a      	ldr	r4, [sp, #104]	; 0x68
  uint32_t outputaddr = (uint32_t)Output;
 8001650:	9f1c      	ldr	r7, [sp, #112]	; 0x70
  uint32_t ivaddr     = (uint32_t)InitVectors;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 8001652:	a806      	add	r0, sp, #24
 8001654:	f7ff fcea 	bl	800102c <CRYP_KeyStructInit>

  switch(Keysize)
 8001658:	f1ba 0fc0 	cmp.w	sl, #192	; 0xc0
 800165c:	d03e      	beq.n	80016dc <CRYP_AES_CTR+0xa4>
 800165e:	f5ba 7f80 	cmp.w	sl, #256	; 0x100
 8001662:	d051      	beq.n	8001708 <CRYP_AES_CTR+0xd0>
 8001664:	f1ba 0f80 	cmp.w	sl, #128	; 0x80
 8001668:	d029      	beq.n	80016be <CRYP_AES_CTR+0x86>
    break;
    default:
    break;
  }
  /* CRYP Initialization Vectors */
  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 800166a:	6833      	ldr	r3, [r6, #0]
 800166c:	ba1b      	rev	r3, r3
 800166e:	9302      	str	r3, [sp, #8]
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 8001670:	6873      	ldr	r3, [r6, #4]
 8001672:	ba1b      	rev	r3, r3
 8001674:	9303      	str	r3, [sp, #12]
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
 8001676:	68b3      	ldr	r3, [r6, #8]
 8001678:	ba1b      	rev	r3, r3
 800167a:	9304      	str	r3, [sp, #16]
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
 800167c:	68f3      	ldr	r3, [r6, #12]
 800167e:	ba1b      	rev	r3, r3
 8001680:	9305      	str	r3, [sp, #20]

  /* Key Initialisation */
  CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 8001682:	a806      	add	r0, sp, #24
 8001684:	f7ff fcbe 	bl	8001004 <CRYP_KeyInit>

  /*------------------ AES Decryption ------------------*/
  if(Mode == MODE_DECRYPT) /* AES decryption */
 8001688:	f1b9 0f00 	cmp.w	r9, #0
 800168c:	d158      	bne.n	8001740 <CRYP_AES_CTR+0x108>
  {
    /* Crypto Init for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 800168e:	2304      	movs	r3, #4
 8001690:	930e      	str	r3, [sp, #56]	; 0x38
  else /* AES encryption */
  {
    /* Crypto Init for Encryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
  }
  AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CTR;
 8001692:	2330      	movs	r3, #48	; 0x30
 8001694:	930f      	str	r3, [sp, #60]	; 0x3c
  AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 8001696:	2380      	movs	r3, #128	; 0x80
 8001698:	9310      	str	r3, [sp, #64]	; 0x40
  CRYP_Init(&AES_CRYP_InitStructure);
 800169a:	a80e      	add	r0, sp, #56	; 0x38
 800169c:	f7ff fc7c 	bl	8000f98 <CRYP_Init>

  /* CRYP Initialization Vectors */
  CRYP_IVInit(&AES_CRYP_IVInitStructure);
 80016a0:	a802      	add	r0, sp, #8
 80016a2:	f7ff fccd 	bl	8001040 <CRYP_IVInit>

  /* Flush IN/OUT FIFOs */
  CRYP_FIFOFlush();
 80016a6:	f7ff fce7 	bl	8001078 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 80016aa:	2001      	movs	r0, #1
 80016ac:	f7ff fcec 	bl	8001088 <CRYP_Cmd>

  if(CRYP_GetCmdStatus() == DISABLE)
 80016b0:	f7ff fdf0 	bl	8001294 <CRYP_GetCmdStatus>
 80016b4:	2800      	cmp	r0, #0
 80016b6:	d07e      	beq.n	80017b6 <CRYP_AES_CTR+0x17e>
 80016b8:	2500      	movs	r5, #0
 80016ba:	2601      	movs	r6, #1
 80016bc:	e046      	b.n	800174c <CRYP_AES_CTR+0x114>
    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
 80016be:	2300      	movs	r3, #0
 80016c0:	9311      	str	r3, [sp, #68]	; 0x44
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 80016c2:	682b      	ldr	r3, [r5, #0]
 80016c4:	ba1b      	rev	r3, r3
 80016c6:	930a      	str	r3, [sp, #40]	; 0x28
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 80016c8:	686b      	ldr	r3, [r5, #4]
 80016ca:	ba1b      	rev	r3, r3
 80016cc:	930b      	str	r3, [sp, #44]	; 0x2c
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 80016ce:	68ab      	ldr	r3, [r5, #8]
 80016d0:	ba1b      	rev	r3, r3
 80016d2:	930c      	str	r3, [sp, #48]	; 0x30
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 80016d4:	68eb      	ldr	r3, [r5, #12]
 80016d6:	ba1b      	rev	r3, r3
 80016d8:	930d      	str	r3, [sp, #52]	; 0x34
    break;
 80016da:	e7c6      	b.n	800166a <CRYP_AES_CTR+0x32>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
 80016dc:	f44f 7380 	mov.w	r3, #256	; 0x100
 80016e0:	9311      	str	r3, [sp, #68]	; 0x44
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 80016e2:	682b      	ldr	r3, [r5, #0]
 80016e4:	ba1b      	rev	r3, r3
 80016e6:	9308      	str	r3, [sp, #32]
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 80016e8:	686b      	ldr	r3, [r5, #4]
 80016ea:	ba1b      	rev	r3, r3
 80016ec:	9309      	str	r3, [sp, #36]	; 0x24
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 80016ee:	68ab      	ldr	r3, [r5, #8]
 80016f0:	ba1b      	rev	r3, r3
 80016f2:	930a      	str	r3, [sp, #40]	; 0x28
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 80016f4:	68eb      	ldr	r3, [r5, #12]
 80016f6:	ba1b      	rev	r3, r3
 80016f8:	930b      	str	r3, [sp, #44]	; 0x2c
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 80016fa:	692b      	ldr	r3, [r5, #16]
 80016fc:	ba1b      	rev	r3, r3
 80016fe:	930c      	str	r3, [sp, #48]	; 0x30
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8001700:	696b      	ldr	r3, [r5, #20]
 8001702:	ba1b      	rev	r3, r3
 8001704:	930d      	str	r3, [sp, #52]	; 0x34
    break;
 8001706:	e7b0      	b.n	800166a <CRYP_AES_CTR+0x32>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
 8001708:	f44f 7300 	mov.w	r3, #512	; 0x200
 800170c:	9311      	str	r3, [sp, #68]	; 0x44
    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
 800170e:	682b      	ldr	r3, [r5, #0]
 8001710:	ba1b      	rev	r3, r3
 8001712:	9306      	str	r3, [sp, #24]
    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
 8001714:	686b      	ldr	r3, [r5, #4]
 8001716:	ba1b      	rev	r3, r3
 8001718:	9307      	str	r3, [sp, #28]
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800171a:	68ab      	ldr	r3, [r5, #8]
 800171c:	ba1b      	rev	r3, r3
 800171e:	9308      	str	r3, [sp, #32]
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8001720:	68eb      	ldr	r3, [r5, #12]
 8001722:	ba1b      	rev	r3, r3
 8001724:	9309      	str	r3, [sp, #36]	; 0x24
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8001726:	692b      	ldr	r3, [r5, #16]
 8001728:	ba1b      	rev	r3, r3
 800172a:	930a      	str	r3, [sp, #40]	; 0x28
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800172c:	696b      	ldr	r3, [r5, #20]
 800172e:	ba1b      	rev	r3, r3
 8001730:	930b      	str	r3, [sp, #44]	; 0x2c
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001732:	69ab      	ldr	r3, [r5, #24]
 8001734:	ba1b      	rev	r3, r3
 8001736:	930c      	str	r3, [sp, #48]	; 0x30
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8001738:	69eb      	ldr	r3, [r5, #28]
 800173a:	ba1b      	rev	r3, r3
 800173c:	930d      	str	r3, [sp, #52]	; 0x34
    break;
 800173e:	e794      	b.n	800166a <CRYP_AES_CTR+0x32>
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 8001740:	2300      	movs	r3, #0
 8001742:	930e      	str	r3, [sp, #56]	; 0x38
 8001744:	e7a5      	b.n	8001692 <CRYP_AES_CTR+0x5a>
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 8001746:	b30a      	cbz	r2, 800178c <CRYP_AES_CTR+0x154>
   {
       status = ERROR;
 8001748:	2600      	movs	r6, #0
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=16)
 800174a:	3510      	adds	r5, #16
 800174c:	4545      	cmp	r5, r8
 800174e:	d22b      	bcs.n	80017a8 <CRYP_AES_CTR+0x170>
 8001750:	b356      	cbz	r6, 80017a8 <CRYP_AES_CTR+0x170>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001752:	6820      	ldr	r0, [r4, #0]
 8001754:	f7ff fca8 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001758:	6860      	ldr	r0, [r4, #4]
 800175a:	f7ff fca5 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800175e:	68a0      	ldr	r0, [r4, #8]
 8001760:	f7ff fca2 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001764:	68e0      	ldr	r0, [r4, #12]
 8001766:	f7ff fc9f 	bl	80010a8 <CRYP_DataIn>
    inputaddr+=4;
 800176a:	3410      	adds	r4, #16
    counter = 0;
 800176c:	2300      	movs	r3, #0
 800176e:	9301      	str	r3, [sp, #4]
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 8001770:	2010      	movs	r0, #16
 8001772:	f7ff fd9b 	bl	80012ac <CRYP_GetFlagStatus>
 8001776:	4602      	mov	r2, r0
      counter++;
 8001778:	9b01      	ldr	r3, [sp, #4]
 800177a:	3301      	adds	r3, #1
 800177c:	9301      	str	r3, [sp, #4]
    }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 800177e:	9b01      	ldr	r3, [sp, #4]
 8001780:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001784:	d0df      	beq.n	8001746 <CRYP_AES_CTR+0x10e>
 8001786:	2800      	cmp	r0, #0
 8001788:	d1f2      	bne.n	8001770 <CRYP_AES_CTR+0x138>
 800178a:	e7dc      	b.n	8001746 <CRYP_AES_CTR+0x10e>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800178c:	f7ff fc92 	bl	80010b4 <CRYP_DataOut>
 8001790:	6038      	str	r0, [r7, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001792:	f7ff fc8f 	bl	80010b4 <CRYP_DataOut>
 8001796:	6078      	str	r0, [r7, #4]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001798:	f7ff fc8c 	bl	80010b4 <CRYP_DataOut>
 800179c:	60b8      	str	r0, [r7, #8]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800179e:	f7ff fc89 	bl	80010b4 <CRYP_DataOut>
 80017a2:	60f8      	str	r0, [r7, #12]
      outputaddr+=4;
 80017a4:	3710      	adds	r7, #16
 80017a6:	e7d0      	b.n	800174a <CRYP_AES_CTR+0x112>
    }
  }
  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 80017a8:	2000      	movs	r0, #0
 80017aa:	f7ff fc6d 	bl	8001088 <CRYP_Cmd>

  return status;
}
 80017ae:	4630      	mov	r0, r6
 80017b0:	b012      	add	sp, #72	; 0x48
 80017b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return(ERROR);
 80017b6:	2600      	movs	r6, #0
 80017b8:	e7f9      	b.n	80017ae <CRYP_AES_CTR+0x176>

080017ba <CRYP_AES_GCM>:
ErrorStatus CRYP_AES_GCM(uint8_t Mode, uint8_t InitVectors[16],
                         uint8_t *Key, uint16_t Keysize,
                         uint8_t *Input, uint32_t ILength,
                         uint8_t *Header, uint32_t HLength,
                         uint8_t *Output, uint8_t *AuthTAG)
{
 80017ba:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80017be:	b097      	sub	sp, #92	; 0x5c
 80017c0:	9001      	str	r0, [sp, #4]
 80017c2:	4689      	mov	r9, r1
 80017c4:	4690      	mov	r8, r2
 80017c6:	469b      	mov	fp, r3
 80017c8:	9f21      	ldr	r7, [sp, #132]	; 0x84
 80017ca:	f8dd a08c 	ldr.w	sl, [sp, #140]	; 0x8c
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 80017ce:	2300      	movs	r3, #0
 80017d0:	9305      	str	r3, [sp, #20]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
 80017d2:	9c20      	ldr	r4, [sp, #128]	; 0x80
  uint32_t outputaddr = (uint32_t)Output;
 80017d4:	9e24      	ldr	r6, [sp, #144]	; 0x90
  uint32_t ivaddr     = (uint32_t)InitVectors;
  uint32_t headeraddr = (uint32_t)Header;
 80017d6:	9d22      	ldr	r5, [sp, #136]	; 0x88
  uint32_t tagaddr = (uint32_t)AuthTAG;
  uint64_t headerlength = HLength * 8;/* header length in bits */
 80017d8:	ea4f 03ca 	mov.w	r3, sl, lsl #3
 80017dc:	9302      	str	r3, [sp, #8]
  uint64_t inputlength = ILength * 8;/* input length in bits */
 80017de:	00fb      	lsls	r3, r7, #3
 80017e0:	9303      	str	r3, [sp, #12]
  uint32_t loopcounter = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 80017e2:	a80a      	add	r0, sp, #40	; 0x28
 80017e4:	f7ff fc22 	bl	800102c <CRYP_KeyStructInit>

  switch(Keysize)
 80017e8:	f1bb 0fc0 	cmp.w	fp, #192	; 0xc0
 80017ec:	d05f      	beq.n	80018ae <CRYP_AES_GCM+0xf4>
 80017ee:	f5bb 7f80 	cmp.w	fp, #256	; 0x100
 80017f2:	d078      	beq.n	80018e6 <CRYP_AES_GCM+0x12c>
 80017f4:	f1bb 0f80 	cmp.w	fp, #128	; 0x80
 80017f8:	d046      	beq.n	8001888 <CRYP_AES_GCM+0xce>
    default:
    break;
  }
  
  /* CRYP Initialization Vectors */
  AES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 80017fa:	f8d9 3000 	ldr.w	r3, [r9]
 80017fe:	ba1b      	rev	r3, r3
 8001800:	9306      	str	r3, [sp, #24]
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 8001802:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8001806:	ba1b      	rev	r3, r3
 8001808:	9307      	str	r3, [sp, #28]
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Left = __REV(*(uint32_t*)(ivaddr));
 800180a:	f8d9 3008 	ldr.w	r3, [r9, #8]
 800180e:	ba1b      	rev	r3, r3
 8001810:	9308      	str	r3, [sp, #32]
  ivaddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Right= __REV(*(uint32_t*)(ivaddr));
 8001812:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8001816:	ba1b      	rev	r3, r3
 8001818:	9309      	str	r3, [sp, #36]	; 0x24
  
  /*------------------ AES Encryption ------------------*/
  if(Mode == MODE_ENCRYPT) /* AES encryption */
 800181a:	9b01      	ldr	r3, [sp, #4]
 800181c:	2b01      	cmp	r3, #1
 800181e:	f000 8086 	beq.w	800192e <CRYP_AES_GCM+0x174>
  }
  /*------------------ AES Decryption ------------------*/
  else /* AES decryption */
  {
    /* Flush IN/OUT FIFOs */
    CRYP_FIFOFlush();
 8001822:	f7ff fc29 	bl	8001078 <CRYP_FIFOFlush>
    
    /* Key Initialisation */
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 8001826:	a80a      	add	r0, sp, #40	; 0x28
 8001828:	f7ff fbec 	bl	8001004 <CRYP_KeyInit>
    
    /* CRYP Initialization Vectors */
    CRYP_IVInit(&AES_CRYP_IVInitStructure);
 800182c:	a806      	add	r0, sp, #24
 800182e:	f7ff fc07 	bl	8001040 <CRYP_IVInit>
    
    /* Crypto Init for Key preparation for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 8001832:	2304      	movs	r3, #4
 8001834:	9312      	str	r3, [sp, #72]	; 0x48
    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
 8001836:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800183a:	9313      	str	r3, [sp, #76]	; 0x4c
    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800183c:	2380      	movs	r3, #128	; 0x80
 800183e:	9314      	str	r3, [sp, #80]	; 0x50
    CRYP_Init(&AES_CRYP_InitStructure);
 8001840:	a812      	add	r0, sp, #72	; 0x48
 8001842:	f7ff fba9 	bl	8000f98 <CRYP_Init>
    
    /***************************** Init phase *********************************/
    /* Select init phase */
    CRYP_PhaseConfig(CRYP_Phase_Init);
 8001846:	2000      	movs	r0, #0
 8001848:	f7ff fc0c 	bl	8001064 <CRYP_PhaseConfig>
    
    /* Enable Crypto processor */
    CRYP_Cmd(ENABLE);
 800184c:	2001      	movs	r0, #1
 800184e:	f7ff fc1b 	bl	8001088 <CRYP_Cmd>
    
    /* Wait for CRYPEN bit to be 0 */
    while(CRYP_GetCmdStatus() == ENABLE);
 8001852:	f7ff fd1f 	bl	8001294 <CRYP_GetCmdStatus>
 8001856:	2801      	cmp	r0, #1
 8001858:	d0fb      	beq.n	8001852 <CRYP_AES_GCM+0x98>
    
    /***************************** header phase *******************************/
    if(HLength != 0)
 800185a:	f1ba 0f00 	cmp.w	sl, #0
 800185e:	f040 8142 	bne.w	8001ae6 <CRYP_AES_GCM+0x32c>
  ErrorStatus status = SUCCESS;
 8001862:	2501      	movs	r5, #1
        status = ERROR;
      }
    }
    
    /**************************** payload phase *******************************/
    if(ILength != 0)
 8001864:	2f00      	cmp	r7, #0
 8001866:	f000 81b4 	beq.w	8001bd2 <CRYP_AES_GCM+0x418>
    {
      /* Select payload phase */
      CRYP_PhaseConfig(CRYP_Phase_Payload);
 800186a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800186e:	f7ff fbf9 	bl	8001064 <CRYP_PhaseConfig>

      /* Enable Crypto processor */
      CRYP_Cmd(ENABLE);
 8001872:	2001      	movs	r0, #1
 8001874:	f7ff fc08 	bl	8001088 <CRYP_Cmd>
      
      if(CRYP_GetCmdStatus() == DISABLE)
 8001878:	f7ff fd0c 	bl	8001294 <CRYP_GetCmdStatus>
 800187c:	2800      	cmp	r0, #0
 800187e:	f000 81e6 	beq.w	8001c4e <CRYP_AES_GCM+0x494>
 8001882:	f04f 0800 	mov.w	r8, #0
 8001886:	e17d      	b.n	8001b84 <CRYP_AES_GCM+0x3ca>
    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
 8001888:	2300      	movs	r3, #0
 800188a:	9315      	str	r3, [sp, #84]	; 0x54
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800188c:	f8d8 3000 	ldr.w	r3, [r8]
 8001890:	ba1b      	rev	r3, r3
 8001892:	930e      	str	r3, [sp, #56]	; 0x38
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001894:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8001898:	ba1b      	rev	r3, r3
 800189a:	930f      	str	r3, [sp, #60]	; 0x3c
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800189c:	f8d8 3008 	ldr.w	r3, [r8, #8]
 80018a0:	ba1b      	rev	r3, r3
 80018a2:	9310      	str	r3, [sp, #64]	; 0x40
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 80018a4:	f8d8 300c 	ldr.w	r3, [r8, #12]
 80018a8:	ba1b      	rev	r3, r3
 80018aa:	9311      	str	r3, [sp, #68]	; 0x44
    break;
 80018ac:	e7a5      	b.n	80017fa <CRYP_AES_GCM+0x40>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
 80018ae:	f44f 7380 	mov.w	r3, #256	; 0x100
 80018b2:	9315      	str	r3, [sp, #84]	; 0x54
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 80018b4:	f8d8 3000 	ldr.w	r3, [r8]
 80018b8:	ba1b      	rev	r3, r3
 80018ba:	930c      	str	r3, [sp, #48]	; 0x30
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 80018bc:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80018c0:	ba1b      	rev	r3, r3
 80018c2:	930d      	str	r3, [sp, #52]	; 0x34
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 80018c4:	f8d8 3008 	ldr.w	r3, [r8, #8]
 80018c8:	ba1b      	rev	r3, r3
 80018ca:	930e      	str	r3, [sp, #56]	; 0x38
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 80018cc:	f8d8 300c 	ldr.w	r3, [r8, #12]
 80018d0:	ba1b      	rev	r3, r3
 80018d2:	930f      	str	r3, [sp, #60]	; 0x3c
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 80018d4:	f8d8 3010 	ldr.w	r3, [r8, #16]
 80018d8:	ba1b      	rev	r3, r3
 80018da:	9310      	str	r3, [sp, #64]	; 0x40
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 80018dc:	f8d8 3014 	ldr.w	r3, [r8, #20]
 80018e0:	ba1b      	rev	r3, r3
 80018e2:	9311      	str	r3, [sp, #68]	; 0x44
    break;
 80018e4:	e789      	b.n	80017fa <CRYP_AES_GCM+0x40>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
 80018e6:	f44f 7300 	mov.w	r3, #512	; 0x200
 80018ea:	9315      	str	r3, [sp, #84]	; 0x54
    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
 80018ec:	f8d8 3000 	ldr.w	r3, [r8]
 80018f0:	ba1b      	rev	r3, r3
 80018f2:	930a      	str	r3, [sp, #40]	; 0x28
    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
 80018f4:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80018f8:	ba1b      	rev	r3, r3
 80018fa:	930b      	str	r3, [sp, #44]	; 0x2c
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 80018fc:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8001900:	ba1b      	rev	r3, r3
 8001902:	930c      	str	r3, [sp, #48]	; 0x30
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8001904:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8001908:	ba1b      	rev	r3, r3
 800190a:	930d      	str	r3, [sp, #52]	; 0x34
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 800190c:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8001910:	ba1b      	rev	r3, r3
 8001912:	930e      	str	r3, [sp, #56]	; 0x38
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001914:	f8d8 3014 	ldr.w	r3, [r8, #20]
 8001918:	ba1b      	rev	r3, r3
 800191a:	930f      	str	r3, [sp, #60]	; 0x3c
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 800191c:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8001920:	ba1b      	rev	r3, r3
 8001922:	9310      	str	r3, [sp, #64]	; 0x40
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8001924:	f8d8 301c 	ldr.w	r3, [r8, #28]
 8001928:	ba1b      	rev	r3, r3
 800192a:	9311      	str	r3, [sp, #68]	; 0x44
    break;
 800192c:	e765      	b.n	80017fa <CRYP_AES_GCM+0x40>
    CRYP_FIFOFlush();
 800192e:	f7ff fba3 	bl	8001078 <CRYP_FIFOFlush>
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 8001932:	a80a      	add	r0, sp, #40	; 0x28
 8001934:	f7ff fb66 	bl	8001004 <CRYP_KeyInit>
    CRYP_IVInit(&AES_CRYP_IVInitStructure);
 8001938:	a806      	add	r0, sp, #24
 800193a:	f7ff fb81 	bl	8001040 <CRYP_IVInit>
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 800193e:	f04f 0800 	mov.w	r8, #0
 8001942:	f8cd 8048 	str.w	r8, [sp, #72]	; 0x48
    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_GCM;
 8001946:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800194a:	9313      	str	r3, [sp, #76]	; 0x4c
    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 800194c:	2380      	movs	r3, #128	; 0x80
 800194e:	9314      	str	r3, [sp, #80]	; 0x50
    CRYP_Init(&AES_CRYP_InitStructure);
 8001950:	a812      	add	r0, sp, #72	; 0x48
 8001952:	f7ff fb21 	bl	8000f98 <CRYP_Init>
    CRYP_PhaseConfig(CRYP_Phase_Init);
 8001956:	4640      	mov	r0, r8
 8001958:	f7ff fb84 	bl	8001064 <CRYP_PhaseConfig>
    CRYP_Cmd(ENABLE);
 800195c:	2001      	movs	r0, #1
 800195e:	f7ff fb93 	bl	8001088 <CRYP_Cmd>
    while(CRYP_GetCmdStatus() == ENABLE)
 8001962:	f7ff fc97 	bl	8001294 <CRYP_GetCmdStatus>
 8001966:	2801      	cmp	r0, #1
 8001968:	d0fb      	beq.n	8001962 <CRYP_AES_GCM+0x1a8>
    if(HLength != 0)
 800196a:	f1ba 0f00 	cmp.w	sl, #0
 800196e:	d112      	bne.n	8001996 <CRYP_AES_GCM+0x1dc>
  ErrorStatus status = SUCCESS;
 8001970:	2501      	movs	r5, #1
    if(ILength != 0)
 8001972:	2f00      	cmp	r7, #0
 8001974:	f000 8085 	beq.w	8001a82 <CRYP_AES_GCM+0x2c8>
      CRYP_PhaseConfig(CRYP_Phase_Payload);
 8001978:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800197c:	f7ff fb72 	bl	8001064 <CRYP_PhaseConfig>
      CRYP_Cmd(ENABLE);
 8001980:	2001      	movs	r0, #1
 8001982:	f7ff fb81 	bl	8001088 <CRYP_Cmd>
      if(CRYP_GetCmdStatus() == DISABLE)
 8001986:	f7ff fc85 	bl	8001294 <CRYP_GetCmdStatus>
 800198a:	2800      	cmp	r0, #0
 800198c:	f000 815b 	beq.w	8001c46 <CRYP_AES_GCM+0x48c>
 8001990:	f04f 0800 	mov.w	r8, #0
 8001994:	e04e      	b.n	8001a34 <CRYP_AES_GCM+0x27a>
      CRYP_PhaseConfig(CRYP_Phase_Header);
 8001996:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800199a:	f7ff fb63 	bl	8001064 <CRYP_PhaseConfig>
      CRYP_Cmd(ENABLE);
 800199e:	2001      	movs	r0, #1
 80019a0:	f7ff fb72 	bl	8001088 <CRYP_Cmd>
      if(CRYP_GetCmdStatus() == DISABLE)
 80019a4:	f7ff fc76 	bl	8001294 <CRYP_GetCmdStatus>
 80019a8:	2800      	cmp	r0, #0
 80019aa:	f000 814a 	beq.w	8001c42 <CRYP_AES_GCM+0x488>
 80019ae:	f04f 0800 	mov.w	r8, #0
 80019b2:	e013      	b.n	80019dc <CRYP_AES_GCM+0x222>
        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
 80019b4:	2001      	movs	r0, #1
 80019b6:	f7ff fc79 	bl	80012ac <CRYP_GetFlagStatus>
 80019ba:	2800      	cmp	r0, #0
 80019bc:	d0fa      	beq.n	80019b4 <CRYP_AES_GCM+0x1fa>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 80019be:	6828      	ldr	r0, [r5, #0]
 80019c0:	f7ff fb72 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 80019c4:	6868      	ldr	r0, [r5, #4]
 80019c6:	f7ff fb6f 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 80019ca:	68a8      	ldr	r0, [r5, #8]
 80019cc:	f7ff fb6c 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 80019d0:	68e8      	ldr	r0, [r5, #12]
 80019d2:	f7ff fb69 	bl	80010a8 <CRYP_DataIn>
        headeraddr+=4;
 80019d6:	3510      	adds	r5, #16
      for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
 80019d8:	f108 0810 	add.w	r8, r8, #16
 80019dc:	45d0      	cmp	r8, sl
 80019de:	d3e9      	bcc.n	80019b4 <CRYP_AES_GCM+0x1fa>
      counter = 0;
 80019e0:	2300      	movs	r3, #0
 80019e2:	9305      	str	r3, [sp, #20]
        busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 80019e4:	2010      	movs	r0, #16
 80019e6:	f7ff fc61 	bl	80012ac <CRYP_GetFlagStatus>
 80019ea:	4602      	mov	r2, r0
        counter++;
 80019ec:	9b05      	ldr	r3, [sp, #20]
 80019ee:	3301      	adds	r3, #1
 80019f0:	9305      	str	r3, [sp, #20]
      }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 80019f2:	9b05      	ldr	r3, [sp, #20]
 80019f4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80019f8:	d001      	beq.n	80019fe <CRYP_AES_GCM+0x244>
 80019fa:	2800      	cmp	r0, #0
 80019fc:	d1f2      	bne.n	80019e4 <CRYP_AES_GCM+0x22a>
      if (busystatus != RESET)
 80019fe:	b90a      	cbnz	r2, 8001a04 <CRYP_AES_GCM+0x24a>
  ErrorStatus status = SUCCESS;
 8001a00:	2501      	movs	r5, #1
 8001a02:	e7b6      	b.n	8001972 <CRYP_AES_GCM+0x1b8>
        status = ERROR;
 8001a04:	2500      	movs	r5, #0
 8001a06:	e7b4      	b.n	8001972 <CRYP_AES_GCM+0x1b8>
        if (busystatus != RESET)
 8001a08:	2a00      	cmp	r2, #0
 8001a0a:	d138      	bne.n	8001a7e <CRYP_AES_GCM+0x2c4>
          while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
 8001a0c:	2004      	movs	r0, #4
 8001a0e:	f7ff fc4d 	bl	80012ac <CRYP_GetFlagStatus>
 8001a12:	2800      	cmp	r0, #0
 8001a14:	d0fa      	beq.n	8001a0c <CRYP_AES_GCM+0x252>
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001a16:	f7ff fb4d 	bl	80010b4 <CRYP_DataOut>
 8001a1a:	6030      	str	r0, [r6, #0]
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001a1c:	f7ff fb4a 	bl	80010b4 <CRYP_DataOut>
 8001a20:	6070      	str	r0, [r6, #4]
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001a22:	f7ff fb47 	bl	80010b4 <CRYP_DataOut>
 8001a26:	60b0      	str	r0, [r6, #8]
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001a28:	f7ff fb44 	bl	80010b4 <CRYP_DataOut>
 8001a2c:	60f0      	str	r0, [r6, #12]
          outputaddr+=4;
 8001a2e:	3610      	adds	r6, #16
      for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
 8001a30:	f108 0810 	add.w	r8, r8, #16
 8001a34:	45b8      	cmp	r8, r7
 8001a36:	d224      	bcs.n	8001a82 <CRYP_AES_GCM+0x2c8>
 8001a38:	b31d      	cbz	r5, 8001a82 <CRYP_AES_GCM+0x2c8>
        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET)
 8001a3a:	2001      	movs	r0, #1
 8001a3c:	f7ff fc36 	bl	80012ac <CRYP_GetFlagStatus>
 8001a40:	2800      	cmp	r0, #0
 8001a42:	d0fa      	beq.n	8001a3a <CRYP_AES_GCM+0x280>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001a44:	6820      	ldr	r0, [r4, #0]
 8001a46:	f7ff fb2f 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001a4a:	6860      	ldr	r0, [r4, #4]
 8001a4c:	f7ff fb2c 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001a50:	68a0      	ldr	r0, [r4, #8]
 8001a52:	f7ff fb29 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001a56:	68e0      	ldr	r0, [r4, #12]
 8001a58:	f7ff fb26 	bl	80010a8 <CRYP_DataIn>
        inputaddr+=4;
 8001a5c:	3410      	adds	r4, #16
        counter = 0;
 8001a5e:	2300      	movs	r3, #0
 8001a60:	9305      	str	r3, [sp, #20]
          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 8001a62:	2010      	movs	r0, #16
 8001a64:	f7ff fc22 	bl	80012ac <CRYP_GetFlagStatus>
 8001a68:	4602      	mov	r2, r0
          counter++;
 8001a6a:	9b05      	ldr	r3, [sp, #20]
 8001a6c:	3301      	adds	r3, #1
 8001a6e:	9305      	str	r3, [sp, #20]
        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 8001a70:	9b05      	ldr	r3, [sp, #20]
 8001a72:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001a76:	d0c7      	beq.n	8001a08 <CRYP_AES_GCM+0x24e>
 8001a78:	2800      	cmp	r0, #0
 8001a7a:	d1f2      	bne.n	8001a62 <CRYP_AES_GCM+0x2a8>
 8001a7c:	e7c4      	b.n	8001a08 <CRYP_AES_GCM+0x24e>
          status = ERROR;
 8001a7e:	2500      	movs	r5, #0
 8001a80:	e7d6      	b.n	8001a30 <CRYP_AES_GCM+0x276>
    CRYP_PhaseConfig(CRYP_Phase_Final);
 8001a82:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 8001a86:	f7ff faed 	bl	8001064 <CRYP_PhaseConfig>
    CRYP_Cmd(ENABLE);
 8001a8a:	2001      	movs	r0, #1
 8001a8c:	f7ff fafc 	bl	8001088 <CRYP_Cmd>
    if(CRYP_GetCmdStatus() == DISABLE)
 8001a90:	f7ff fc00 	bl	8001294 <CRYP_GetCmdStatus>
 8001a94:	b908      	cbnz	r0, 8001a9a <CRYP_AES_GCM+0x2e0>
      return(ERROR);
 8001a96:	2500      	movs	r5, #0
 8001a98:	e0a6      	b.n	8001be8 <CRYP_AES_GCM+0x42e>
 8001a9a:	2300      	movs	r3, #0
 8001a9c:	ba18      	rev	r0, r3
    CRYP_DataIn(__REV(headerlength>>32));
 8001a9e:	f7ff fb03 	bl	80010a8 <CRYP_DataIn>
 8001aa2:	9b02      	ldr	r3, [sp, #8]
 8001aa4:	ba18      	rev	r0, r3
    CRYP_DataIn(__REV(headerlength));
 8001aa6:	f7ff faff 	bl	80010a8 <CRYP_DataIn>
 8001aaa:	2300      	movs	r3, #0
 8001aac:	ba18      	rev	r0, r3
    CRYP_DataIn(__REV(inputlength>>32));
 8001aae:	f7ff fafb 	bl	80010a8 <CRYP_DataIn>
 8001ab2:	9b03      	ldr	r3, [sp, #12]
 8001ab4:	ba18      	rev	r0, r3
    CRYP_DataIn(__REV(inputlength));
 8001ab6:	f7ff faf7 	bl	80010a8 <CRYP_DataIn>
    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET)
 8001aba:	2004      	movs	r0, #4
 8001abc:	f7ff fbf6 	bl	80012ac <CRYP_GetFlagStatus>
 8001ac0:	2800      	cmp	r0, #0
 8001ac2:	d0fa      	beq.n	8001aba <CRYP_AES_GCM+0x300>
    *(uint32_t*)(tagaddr) = CRYP_DataOut();
 8001ac4:	f7ff faf6 	bl	80010b4 <CRYP_DataOut>
 8001ac8:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8001aca:	6018      	str	r0, [r3, #0]
    *(uint32_t*)(tagaddr) = CRYP_DataOut();
 8001acc:	f7ff faf2 	bl	80010b4 <CRYP_DataOut>
 8001ad0:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8001ad2:	6058      	str	r0, [r3, #4]
    *(uint32_t*)(tagaddr) = CRYP_DataOut();
 8001ad4:	f7ff faee 	bl	80010b4 <CRYP_DataOut>
 8001ad8:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8001ada:	6098      	str	r0, [r3, #8]
    *(uint32_t*)(tagaddr) = CRYP_DataOut();
 8001adc:	f7ff faea 	bl	80010b4 <CRYP_DataOut>
 8001ae0:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8001ae2:	60d8      	str	r0, [r3, #12]
 8001ae4:	e0a9      	b.n	8001c3a <CRYP_AES_GCM+0x480>
      CRYP_PhaseConfig(CRYP_Phase_Header);
 8001ae6:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8001aea:	f7ff fabb 	bl	8001064 <CRYP_PhaseConfig>
      CRYP_Cmd(ENABLE);
 8001aee:	2001      	movs	r0, #1
 8001af0:	f7ff faca 	bl	8001088 <CRYP_Cmd>
      if(CRYP_GetCmdStatus() == DISABLE)
 8001af4:	f7ff fbce 	bl	8001294 <CRYP_GetCmdStatus>
 8001af8:	2800      	cmp	r0, #0
 8001afa:	f000 80a6 	beq.w	8001c4a <CRYP_AES_GCM+0x490>
 8001afe:	f04f 0800 	mov.w	r8, #0
 8001b02:	e013      	b.n	8001b2c <CRYP_AES_GCM+0x372>
        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET);
 8001b04:	2001      	movs	r0, #1
 8001b06:	f7ff fbd1 	bl	80012ac <CRYP_GetFlagStatus>
 8001b0a:	2800      	cmp	r0, #0
 8001b0c:	d0fa      	beq.n	8001b04 <CRYP_AES_GCM+0x34a>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 8001b0e:	6828      	ldr	r0, [r5, #0]
 8001b10:	f7ff faca 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 8001b14:	6868      	ldr	r0, [r5, #4]
 8001b16:	f7ff fac7 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 8001b1a:	68a8      	ldr	r0, [r5, #8]
 8001b1c:	f7ff fac4 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 8001b20:	68e8      	ldr	r0, [r5, #12]
 8001b22:	f7ff fac1 	bl	80010a8 <CRYP_DataIn>
        headeraddr+=4;
 8001b26:	3510      	adds	r5, #16
      for(loopcounter = 0; (loopcounter < HLength); loopcounter+=16)
 8001b28:	f108 0810 	add.w	r8, r8, #16
 8001b2c:	45d0      	cmp	r8, sl
 8001b2e:	d3e9      	bcc.n	8001b04 <CRYP_AES_GCM+0x34a>
      counter = 0;
 8001b30:	2300      	movs	r3, #0
 8001b32:	9305      	str	r3, [sp, #20]
        busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 8001b34:	2010      	movs	r0, #16
 8001b36:	f7ff fbb9 	bl	80012ac <CRYP_GetFlagStatus>
 8001b3a:	4602      	mov	r2, r0
        counter++;
 8001b3c:	9b05      	ldr	r3, [sp, #20]
 8001b3e:	3301      	adds	r3, #1
 8001b40:	9305      	str	r3, [sp, #20]
      }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 8001b42:	9b05      	ldr	r3, [sp, #20]
 8001b44:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001b48:	d001      	beq.n	8001b4e <CRYP_AES_GCM+0x394>
 8001b4a:	2800      	cmp	r0, #0
 8001b4c:	d1f2      	bne.n	8001b34 <CRYP_AES_GCM+0x37a>
      if (busystatus != RESET)
 8001b4e:	b90a      	cbnz	r2, 8001b54 <CRYP_AES_GCM+0x39a>
  ErrorStatus status = SUCCESS;
 8001b50:	2501      	movs	r5, #1
 8001b52:	e687      	b.n	8001864 <CRYP_AES_GCM+0xaa>
        status = ERROR;
 8001b54:	2500      	movs	r5, #0
 8001b56:	e685      	b.n	8001864 <CRYP_AES_GCM+0xaa>
        {
          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
          counter++;
        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));

        if (busystatus != RESET)
 8001b58:	2a00      	cmp	r2, #0
 8001b5a:	d138      	bne.n	8001bce <CRYP_AES_GCM+0x414>
          status = ERROR;
        }
        else
        {
          /* Wait until the OFNE flag is reset */
          while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET);
 8001b5c:	2004      	movs	r0, #4
 8001b5e:	f7ff fba5 	bl	80012ac <CRYP_GetFlagStatus>
 8001b62:	2800      	cmp	r0, #0
 8001b64:	d0fa      	beq.n	8001b5c <CRYP_AES_GCM+0x3a2>
          
          /* Read the Output block from the Output FIFO */
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001b66:	f7ff faa5 	bl	80010b4 <CRYP_DataOut>
 8001b6a:	6030      	str	r0, [r6, #0]
          outputaddr+=4;
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001b6c:	f7ff faa2 	bl	80010b4 <CRYP_DataOut>
 8001b70:	6070      	str	r0, [r6, #4]
          outputaddr+=4;
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001b72:	f7ff fa9f 	bl	80010b4 <CRYP_DataOut>
 8001b76:	60b0      	str	r0, [r6, #8]
          outputaddr+=4;
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8001b78:	f7ff fa9c 	bl	80010b4 <CRYP_DataOut>
 8001b7c:	60f0      	str	r0, [r6, #12]
          outputaddr+=4;
 8001b7e:	3610      	adds	r6, #16
      for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
 8001b80:	f108 0810 	add.w	r8, r8, #16
 8001b84:	45b8      	cmp	r8, r7
 8001b86:	d224      	bcs.n	8001bd2 <CRYP_AES_GCM+0x418>
 8001b88:	b31d      	cbz	r5, 8001bd2 <CRYP_AES_GCM+0x418>
        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET);
 8001b8a:	2001      	movs	r0, #1
 8001b8c:	f7ff fb8e 	bl	80012ac <CRYP_GetFlagStatus>
 8001b90:	2800      	cmp	r0, #0
 8001b92:	d0fa      	beq.n	8001b8a <CRYP_AES_GCM+0x3d0>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001b94:	6820      	ldr	r0, [r4, #0]
 8001b96:	f7ff fa87 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001b9a:	6860      	ldr	r0, [r4, #4]
 8001b9c:	f7ff fa84 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001ba0:	68a0      	ldr	r0, [r4, #8]
 8001ba2:	f7ff fa81 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 8001ba6:	68e0      	ldr	r0, [r4, #12]
 8001ba8:	f7ff fa7e 	bl	80010a8 <CRYP_DataIn>
        inputaddr+=4;
 8001bac:	3410      	adds	r4, #16
        counter = 0;
 8001bae:	2300      	movs	r3, #0
 8001bb0:	9305      	str	r3, [sp, #20]
          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 8001bb2:	2010      	movs	r0, #16
 8001bb4:	f7ff fb7a 	bl	80012ac <CRYP_GetFlagStatus>
 8001bb8:	4602      	mov	r2, r0
          counter++;
 8001bba:	9b05      	ldr	r3, [sp, #20]
 8001bbc:	3301      	adds	r3, #1
 8001bbe:	9305      	str	r3, [sp, #20]
        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 8001bc0:	9b05      	ldr	r3, [sp, #20]
 8001bc2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001bc6:	d0c7      	beq.n	8001b58 <CRYP_AES_GCM+0x39e>
 8001bc8:	2800      	cmp	r0, #0
 8001bca:	d1f2      	bne.n	8001bb2 <CRYP_AES_GCM+0x3f8>
 8001bcc:	e7c4      	b.n	8001b58 <CRYP_AES_GCM+0x39e>
          status = ERROR;
 8001bce:	2500      	movs	r5, #0
 8001bd0:	e7d6      	b.n	8001b80 <CRYP_AES_GCM+0x3c6>
      }
    }
    
    /***************************** final phase ********************************/
    /* Select final phase */
    CRYP_PhaseConfig(CRYP_Phase_Final);
 8001bd2:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 8001bd6:	f7ff fa45 	bl	8001064 <CRYP_PhaseConfig>

    /* Enable Crypto processor */
    CRYP_Cmd(ENABLE);
 8001bda:	2001      	movs	r0, #1
 8001bdc:	f7ff fa54 	bl	8001088 <CRYP_Cmd>
    
    if(CRYP_GetCmdStatus() == DISABLE)
 8001be0:	f7ff fb58 	bl	8001294 <CRYP_GetCmdStatus>
 8001be4:	b920      	cbnz	r0, 8001bf0 <CRYP_AES_GCM+0x436>
    {
      /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
         the CRYP peripheral (please check the device sales type. */
      return(ERROR);
 8001be6:	2500      	movs	r5, #0
  }
  /* Disable Crypto */
  CRYP_Cmd(DISABLE);

  return status;
}
 8001be8:	4628      	mov	r0, r5
 8001bea:	b017      	add	sp, #92	; 0x5c
 8001bec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001bf0:	2300      	movs	r3, #0
 8001bf2:	ba18      	rev	r0, r3
    CRYP_DataIn(__REV(headerlength>>32));
 8001bf4:	f7ff fa58 	bl	80010a8 <CRYP_DataIn>
 8001bf8:	9b02      	ldr	r3, [sp, #8]
 8001bfa:	ba18      	rev	r0, r3
    CRYP_DataIn(__REV(headerlength));
 8001bfc:	f7ff fa54 	bl	80010a8 <CRYP_DataIn>
 8001c00:	2300      	movs	r3, #0
 8001c02:	ba18      	rev	r0, r3
    CRYP_DataIn(__REV(inputlength>>32));
 8001c04:	f7ff fa50 	bl	80010a8 <CRYP_DataIn>
 8001c08:	9b03      	ldr	r3, [sp, #12]
 8001c0a:	ba18      	rev	r0, r3
    CRYP_DataIn(__REV(inputlength));
 8001c0c:	f7ff fa4c 	bl	80010a8 <CRYP_DataIn>
    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET);
 8001c10:	2004      	movs	r0, #4
 8001c12:	f7ff fb4b 	bl	80012ac <CRYP_GetFlagStatus>
 8001c16:	2800      	cmp	r0, #0
 8001c18:	d0fa      	beq.n	8001c10 <CRYP_AES_GCM+0x456>
    *(uint32_t*)(tagaddr) = CRYP_DataOut();
 8001c1a:	f7ff fa4b 	bl	80010b4 <CRYP_DataOut>
 8001c1e:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8001c20:	6018      	str	r0, [r3, #0]
    *(uint32_t*)(tagaddr) = CRYP_DataOut();
 8001c22:	f7ff fa47 	bl	80010b4 <CRYP_DataOut>
 8001c26:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8001c28:	6058      	str	r0, [r3, #4]
    *(uint32_t*)(tagaddr) = CRYP_DataOut();
 8001c2a:	f7ff fa43 	bl	80010b4 <CRYP_DataOut>
 8001c2e:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8001c30:	6098      	str	r0, [r3, #8]
    *(uint32_t*)(tagaddr) = CRYP_DataOut();
 8001c32:	f7ff fa3f 	bl	80010b4 <CRYP_DataOut>
 8001c36:	9b25      	ldr	r3, [sp, #148]	; 0x94
 8001c38:	60d8      	str	r0, [r3, #12]
  CRYP_Cmd(DISABLE);
 8001c3a:	2000      	movs	r0, #0
 8001c3c:	f7ff fa24 	bl	8001088 <CRYP_Cmd>
  return status;
 8001c40:	e7d2      	b.n	8001be8 <CRYP_AES_GCM+0x42e>
         return(ERROR);
 8001c42:	2500      	movs	r5, #0
 8001c44:	e7d0      	b.n	8001be8 <CRYP_AES_GCM+0x42e>
        return(ERROR);
 8001c46:	2500      	movs	r5, #0
 8001c48:	e7ce      	b.n	8001be8 <CRYP_AES_GCM+0x42e>
        return(ERROR);
 8001c4a:	2500      	movs	r5, #0
 8001c4c:	e7cc      	b.n	8001be8 <CRYP_AES_GCM+0x42e>
        return(ERROR);
 8001c4e:	2500      	movs	r5, #0
 8001c50:	e7ca      	b.n	8001be8 <CRYP_AES_GCM+0x42e>

08001c52 <CRYP_AES_CCM>:
                         uint8_t *Key, uint16_t Keysize,
                         uint8_t *Input, uint32_t ILength,
                         uint8_t *Header, uint32_t HLength, uint8_t *HBuffer,
                         uint8_t *Output,
                         uint8_t *AuthTAG, uint32_t TAGSize)
{
 8001c52:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001c56:	b0a3      	sub	sp, #140	; 0x8c
 8001c58:	9002      	str	r0, [sp, #8]
 8001c5a:	469a      	mov	sl, r3
 8001c5c:	f8bd 30b0 	ldrh.w	r3, [sp, #176]	; 0xb0
 8001c60:	9303      	str	r3, [sp, #12]
 8001c62:	f8dd 90b8 	ldr.w	r9, [sp, #184]	; 0xb8
 8001c66:	f8dd c0bc 	ldr.w	ip, [sp, #188]	; 0xbc
 8001c6a:	9d30      	ldr	r5, [sp, #192]	; 0xc0
 8001c6c:	f8dd e0c4 	ldr.w	lr, [sp, #196]	; 0xc4
  CRYP_InitTypeDef AES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef AES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef AES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 8001c70:	2300      	movs	r3, #0
 8001c72:	9311      	str	r3, [sp, #68]	; 0x44
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
 8001c74:	9c2d      	ldr	r4, [sp, #180]	; 0xb4
  uint32_t outputaddr = (uint32_t)Output;
 8001c76:	f8dd 80c8 	ldr.w	r8, [sp, #200]	; 0xc8
  uint32_t headeraddr = (uint32_t)Header;
 8001c7a:	4666      	mov	r6, ip
  uint32_t tagaddr = (uint32_t)AuthTAG;
 8001c7c:	f8dd b0cc 	ldr.w	fp, [sp, #204]	; 0xcc
  uint32_t headersize = HLength;
  uint32_t loopcounter = 0;
  uint32_t bufferidx = 0;
  uint8_t blockb0[16] = {0};/* Block B0 */
 8001c80:	a80d      	add	r0, sp, #52	; 0x34
 8001c82:	930d      	str	r3, [sp, #52]	; 0x34
 8001c84:	930e      	str	r3, [sp, #56]	; 0x38
 8001c86:	930f      	str	r3, [sp, #60]	; 0x3c
 8001c88:	9310      	str	r3, [sp, #64]	; 0x40
  uint8_t ctr[16] = {0}; /* Counter */
 8001c8a:	af09      	add	r7, sp, #36	; 0x24
 8001c8c:	9309      	str	r3, [sp, #36]	; 0x24
 8001c8e:	607b      	str	r3, [r7, #4]
 8001c90:	60bb      	str	r3, [r7, #8]
 8001c92:	60fb      	str	r3, [r7, #12]
  uint32_t temptag[4] = {0}; /* temporary TAG (MAC) */
 8001c94:	9305      	str	r3, [sp, #20]
 8001c96:	9306      	str	r3, [sp, #24]
 8001c98:	9307      	str	r3, [sp, #28]
 8001c9a:	9308      	str	r3, [sp, #32]
  uint32_t ctraddr = (uint32_t)ctr;
  uint32_t b0addr = (uint32_t)blockb0;
 8001c9c:	9001      	str	r0, [sp, #4]
  
  /************************ Formatting the header block ***********************/
  if(headersize != 0)
 8001c9e:	b355      	cbz	r5, 8001cf6 <CRYP_AES_CCM+0xa4>
  {
    /* Check that the associated data (or header) length is lower than 2^16 - 2^8 = 65536 - 256 = 65280 */
    if(headersize < 65280)
 8001ca0:	f5b5 4f7f 	cmp.w	r5, #65280	; 0xff00
 8001ca4:	d209      	bcs.n	8001cba <CRYP_AES_CCM+0x68>
    {
      HBuffer[bufferidx++] = (uint8_t) ((headersize >> 8) & 0xFF);
 8001ca6:	f3c5 2307 	ubfx	r3, r5, #8, #8
 8001caa:	f88e 3000 	strb.w	r3, [lr]
      HBuffer[bufferidx++] = (uint8_t) ((headersize) & 0xFF);
 8001cae:	f88e 5001 	strb.w	r5, [lr, #1]
      headersize += 2;
 8001cb2:	3502      	adds	r5, #2
      HBuffer[bufferidx++] = (uint8_t) ((headersize) & 0xFF);
 8001cb4:	2002      	movs	r0, #2
      HBuffer[bufferidx++] = headersize & 0x0000ff00;
      HBuffer[bufferidx++] = headersize & 0x000000ff;
      headersize += 6;
    }
    /* Copy the header buffer in internal buffer "HBuffer" */
    for(loopcounter = 0; loopcounter < headersize; loopcounter++)
 8001cb6:	2300      	movs	r3, #0
 8001cb8:	e017      	b.n	8001cea <CRYP_AES_CCM+0x98>
      HBuffer[bufferidx++] = 0xFF;
 8001cba:	23ff      	movs	r3, #255	; 0xff
 8001cbc:	f88e 3000 	strb.w	r3, [lr]
      HBuffer[bufferidx++] = 0xFE;
 8001cc0:	23fe      	movs	r3, #254	; 0xfe
 8001cc2:	f88e 3001 	strb.w	r3, [lr, #1]
      HBuffer[bufferidx++] = headersize & 0xff000000;
 8001cc6:	2300      	movs	r3, #0
 8001cc8:	f88e 3002 	strb.w	r3, [lr, #2]
      HBuffer[bufferidx++] = headersize & 0x00ff0000;
 8001ccc:	f88e 3003 	strb.w	r3, [lr, #3]
      HBuffer[bufferidx++] = headersize & 0x0000ff00;
 8001cd0:	f88e 3004 	strb.w	r3, [lr, #4]
      HBuffer[bufferidx++] = headersize & 0x000000ff;
 8001cd4:	f88e 5005 	strb.w	r5, [lr, #5]
      headersize += 6;
 8001cd8:	3506      	adds	r5, #6
      HBuffer[bufferidx++] = headersize & 0x000000ff;
 8001cda:	2006      	movs	r0, #6
 8001cdc:	e7eb      	b.n	8001cb6 <CRYP_AES_CCM+0x64>
    {
      HBuffer[bufferidx++] = Header[loopcounter];
 8001cde:	f81c 6003 	ldrb.w	r6, [ip, r3]
 8001ce2:	f80e 6000 	strb.w	r6, [lr, r0]
    for(loopcounter = 0; loopcounter < headersize; loopcounter++)
 8001ce6:	3301      	adds	r3, #1
      HBuffer[bufferidx++] = Header[loopcounter];
 8001ce8:	3001      	adds	r0, #1
    for(loopcounter = 0; loopcounter < headersize; loopcounter++)
 8001cea:	429d      	cmp	r5, r3
 8001cec:	d8f7      	bhi.n	8001cde <CRYP_AES_CCM+0x8c>
    }
    /* Check if the header size is modulo 16 */
    if ((headersize % 16) != 0)
 8001cee:	f015 0f0f 	tst.w	r5, #15
 8001cf2:	d124      	bne.n	8001d3e <CRYP_AES_CCM+0xec>
      }
      /* Set the header size to modulo 16 */
      headersize = ((headersize/16) + 1) * 16;
    }
    /* set the pointer headeraddr to HBuffer */
    headeraddr = (uint32_t)HBuffer;
 8001cf4:	4676      	mov	r6, lr
  }
  /************************* Formatting the block B0 **************************/
  if(headersize != 0)
 8001cf6:	b115      	cbz	r5, 8001cfe <CRYP_AES_CCM+0xac>
  {
    blockb0[0] = 0x40;
 8001cf8:	2340      	movs	r3, #64	; 0x40
 8001cfa:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
  }
  /* Flags byte */
  blockb0[0] |= 0u | (((( (uint8_t) TAGSize - 2) / 2) & 0x07 ) << 3 ) | ( ( (uint8_t) (15 - NonceSize) - 1) & 0x07);
 8001cfe:	f89d 30d0 	ldrb.w	r3, [sp, #208]	; 0xd0
 8001d02:	3b02      	subs	r3, #2
 8001d04:	eb03 73d3 	add.w	r3, r3, r3, lsr #31
 8001d08:	105b      	asrs	r3, r3, #1
 8001d0a:	00db      	lsls	r3, r3, #3
 8001d0c:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8001d10:	f1c2 000e 	rsb	r0, r2, #14
 8001d14:	f000 0007 	and.w	r0, r0, #7
 8001d18:	4303      	orrs	r3, r0
 8001d1a:	f89d 0034 	ldrb.w	r0, [sp, #52]	; 0x34
 8001d1e:	4303      	orrs	r3, r0
 8001d20:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
  
  for (loopcounter = 0; loopcounter < NonceSize; loopcounter++)
 8001d24:	2300      	movs	r3, #0
 8001d26:	e014      	b.n	8001d52 <CRYP_AES_CCM+0x100>
        HBuffer[loopcounter] = 0;
 8001d28:	2300      	movs	r3, #0
 8001d2a:	f80e 3000 	strb.w	r3, [lr, r0]
      for(loopcounter = headersize; loopcounter <= ((headersize/16) + 1) * 16; loopcounter++)
 8001d2e:	3001      	adds	r0, #1
 8001d30:	f025 030f 	bic.w	r3, r5, #15
 8001d34:	3310      	adds	r3, #16
 8001d36:	4298      	cmp	r0, r3
 8001d38:	d9f6      	bls.n	8001d28 <CRYP_AES_CCM+0xd6>
      headersize = ((headersize/16) + 1) * 16;
 8001d3a:	461d      	mov	r5, r3
 8001d3c:	e7da      	b.n	8001cf4 <CRYP_AES_CCM+0xa2>
 8001d3e:	4628      	mov	r0, r5
 8001d40:	e7f6      	b.n	8001d30 <CRYP_AES_CCM+0xde>
  {
    blockb0[loopcounter+1] = Nonce[loopcounter];
 8001d42:	1c58      	adds	r0, r3, #1
 8001d44:	f811 e003 	ldrb.w	lr, [r1, r3]
 8001d48:	ab22      	add	r3, sp, #136	; 0x88
 8001d4a:	4403      	add	r3, r0
 8001d4c:	f803 ec54 	strb.w	lr, [r3, #-84]
  for (loopcounter = 0; loopcounter < NonceSize; loopcounter++)
 8001d50:	4603      	mov	r3, r0
 8001d52:	4293      	cmp	r3, r2
 8001d54:	d3f5      	bcc.n	8001d42 <CRYP_AES_CCM+0xf0>
 8001d56:	e005      	b.n	8001d64 <CRYP_AES_CCM+0x112>
  }
  for ( ; loopcounter < 13; loopcounter++)
  {
    blockb0[loopcounter+1] = 0;
 8001d58:	3301      	adds	r3, #1
 8001d5a:	a922      	add	r1, sp, #136	; 0x88
 8001d5c:	4419      	add	r1, r3
 8001d5e:	2000      	movs	r0, #0
 8001d60:	f801 0c54 	strb.w	r0, [r1, #-84]
  for ( ; loopcounter < 13; loopcounter++)
 8001d64:	2b0c      	cmp	r3, #12
 8001d66:	d9f7      	bls.n	8001d58 <CRYP_AES_CCM+0x106>
  }
  
  blockb0[14] = ((ILength >> 8) & 0xFF);
 8001d68:	ea4f 2319 	mov.w	r3, r9, lsr #8
 8001d6c:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
  blockb0[15] = (ILength & 0xFF);
 8001d70:	f88d 9043 	strb.w	r9, [sp, #67]	; 0x43
     Bits 7 and 6 are reserved and shall be set to 0
     Bits 3, 4, and 5 shall also be set to 0, to ensure that all the counter blocks
     are distinct from B0
     Bits 0, 1, and 2 contain the same encoding of q as in B0
  */
  ctr[0] = blockb0[0] & 0x07;
 8001d74:	f89d 3034 	ldrb.w	r3, [sp, #52]	; 0x34
 8001d78:	f003 0307 	and.w	r3, r3, #7
 8001d7c:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
  /* byte 1 to NonceSize is the IV (Nonce) */
  for(loopcounter = 1; loopcounter < NonceSize + 1; loopcounter++)
 8001d80:	2301      	movs	r3, #1
 8001d82:	e006      	b.n	8001d92 <CRYP_AES_CCM+0x140>
  {
    ctr[loopcounter] = blockb0[loopcounter];
 8001d84:	a922      	add	r1, sp, #136	; 0x88
 8001d86:	4419      	add	r1, r3
 8001d88:	f811 0c54 	ldrb.w	r0, [r1, #-84]
 8001d8c:	f801 0c64 	strb.w	r0, [r1, #-100]
  for(loopcounter = 1; loopcounter < NonceSize + 1; loopcounter++)
 8001d90:	3301      	adds	r3, #1
 8001d92:	1c51      	adds	r1, r2, #1
 8001d94:	428b      	cmp	r3, r1
 8001d96:	d3f5      	bcc.n	8001d84 <CRYP_AES_CCM+0x132>
  }
  /* Set the LSB to 1 */
  ctr[15] |= 0x01;
 8001d98:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
 8001d9c:	f043 0301 	orr.w	r3, r3, #1
 8001da0:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
  
  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&AES_CRYP_KeyInitStructure);
 8001da4:	a816      	add	r0, sp, #88	; 0x58
 8001da6:	f7ff f941 	bl	800102c <CRYP_KeyStructInit>
  
  switch(Keysize)
 8001daa:	9b03      	ldr	r3, [sp, #12]
 8001dac:	2bc0      	cmp	r3, #192	; 0xc0
 8001dae:	d069      	beq.n	8001e84 <CRYP_AES_CCM+0x232>
 8001db0:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8001db4:	f000 8082 	beq.w	8001ebc <CRYP_AES_CCM+0x26a>
 8001db8:	2b80      	cmp	r3, #128	; 0x80
 8001dba:	d050      	beq.n	8001e5e <CRYP_AES_CCM+0x20c>
    default:
    break;
  }
  
  /* CRYP Initialization Vectors */
  AES_CRYP_IVInitStructure.CRYP_IV0Left = (__REV(*(uint32_t*)(ctraddr)));
 8001dbc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001dbe:	ba1b      	rev	r3, r3
 8001dc0:	9312      	str	r3, [sp, #72]	; 0x48
  ctraddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV0Right= (__REV(*(uint32_t*)(ctraddr)));
 8001dc2:	687b      	ldr	r3, [r7, #4]
 8001dc4:	ba1b      	rev	r3, r3
 8001dc6:	9313      	str	r3, [sp, #76]	; 0x4c
  ctraddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Left = (__REV(*(uint32_t*)(ctraddr)));
 8001dc8:	68bb      	ldr	r3, [r7, #8]
 8001dca:	ba1b      	rev	r3, r3
 8001dcc:	9314      	str	r3, [sp, #80]	; 0x50
  ctraddr+=4;
  AES_CRYP_IVInitStructure.CRYP_IV1Right= (__REV(*(uint32_t*)(ctraddr)));
 8001dce:	68fb      	ldr	r3, [r7, #12]
 8001dd0:	ba1b      	rev	r3, r3
 8001dd2:	9315      	str	r3, [sp, #84]	; 0x54
  
  /*------------------ AES Encryption ------------------*/
  if(Mode == MODE_ENCRYPT) /* AES encryption */
 8001dd4:	9b02      	ldr	r3, [sp, #8]
 8001dd6:	2b01      	cmp	r3, #1
 8001dd8:	f000 8094 	beq.w	8001f04 <CRYP_AES_CCM+0x2b2>
  }
  /*------------------ AES Decryption ------------------*/
  else /* AES decryption */
  {
    /* Flush IN/OUT FIFOs */
    CRYP_FIFOFlush();
 8001ddc:	f7ff f94c 	bl	8001078 <CRYP_FIFOFlush>
    
    /* Key Initialisation */
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 8001de0:	a816      	add	r0, sp, #88	; 0x58
 8001de2:	f7ff f90f 	bl	8001004 <CRYP_KeyInit>
    
    /* CRYP Initialization Vectors */
    CRYP_IVInit(&AES_CRYP_IVInitStructure);
 8001de6:	a812      	add	r0, sp, #72	; 0x48
 8001de8:	f7ff f92a 	bl	8001040 <CRYP_IVInit>
    
    /* Crypto Init for Key preparation for decryption process */
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 8001dec:	2304      	movs	r3, #4
 8001dee:	931e      	str	r3, [sp, #120]	; 0x78
    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
 8001df0:	f04f 1308 	mov.w	r3, #524296	; 0x80008
 8001df4:	931f      	str	r3, [sp, #124]	; 0x7c
    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 8001df6:	2380      	movs	r3, #128	; 0x80
 8001df8:	9320      	str	r3, [sp, #128]	; 0x80
    CRYP_Init(&AES_CRYP_InitStructure);
 8001dfa:	a81e      	add	r0, sp, #120	; 0x78
 8001dfc:	f7ff f8cc 	bl	8000f98 <CRYP_Init>
    
    /***************************** Init phase *********************************/
    /* Select init phase */
    CRYP_PhaseConfig(CRYP_Phase_Init);
 8001e00:	2000      	movs	r0, #0
 8001e02:	f7ff f92f 	bl	8001064 <CRYP_PhaseConfig>
    
    b0addr = (uint32_t)blockb0;
    /* Write the blockb0 block in the IN FIFO */
    CRYP_DataIn((*(uint32_t*)(b0addr)));
 8001e06:	980d      	ldr	r0, [sp, #52]	; 0x34
 8001e08:	f7ff f94e 	bl	80010a8 <CRYP_DataIn>
    b0addr+=4;
    CRYP_DataIn((*(uint32_t*)(b0addr)));
 8001e0c:	9b01      	ldr	r3, [sp, #4]
 8001e0e:	6858      	ldr	r0, [r3, #4]
 8001e10:	f7ff f94a 	bl	80010a8 <CRYP_DataIn>
    b0addr+=4;
    CRYP_DataIn((*(uint32_t*)(b0addr)));
 8001e14:	9a01      	ldr	r2, [sp, #4]
 8001e16:	6890      	ldr	r0, [r2, #8]
 8001e18:	f7ff f946 	bl	80010a8 <CRYP_DataIn>
    b0addr+=4;
    CRYP_DataIn((*(uint32_t*)(b0addr)));
 8001e1c:	9a01      	ldr	r2, [sp, #4]
 8001e1e:	68d0      	ldr	r0, [r2, #12]
 8001e20:	f7ff f942 	bl	80010a8 <CRYP_DataIn>
    
    /* Enable Crypto processor */
    CRYP_Cmd(ENABLE);
 8001e24:	2001      	movs	r0, #1
 8001e26:	f7ff f92f 	bl	8001088 <CRYP_Cmd>
    
    /* Wait for CRYPEN bit to be 0 */
    while(CRYP_GetCmdStatus() == ENABLE);
 8001e2a:	f7ff fa33 	bl	8001294 <CRYP_GetCmdStatus>
 8001e2e:	2801      	cmp	r0, #1
 8001e30:	d0fb      	beq.n	8001e2a <CRYP_AES_CCM+0x1d8>
    
    /***************************** header phase *******************************/
    if(headersize != 0)
 8001e32:	2d00      	cmp	r5, #0
 8001e34:	f040 814d 	bne.w	80020d2 <CRYP_AES_CCM+0x480>
  ErrorStatus status = SUCCESS;
 8001e38:	2501      	movs	r5, #1
        status = ERROR;
      }
    }
    
    /**************************** payload phase *******************************/
    if(ILength != 0)
 8001e3a:	f1b9 0f00 	cmp.w	r9, #0
 8001e3e:	f000 81c2 	beq.w	80021c6 <CRYP_AES_CCM+0x574>
    {
      /* Select payload phase */
      CRYP_PhaseConfig(CRYP_Phase_Payload);
 8001e42:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8001e46:	f7ff f90d 	bl	8001064 <CRYP_PhaseConfig>

      /* Enable Crypto processor */
      CRYP_Cmd(ENABLE);
 8001e4a:	2001      	movs	r0, #1
 8001e4c:	f7ff f91c 	bl	8001088 <CRYP_Cmd>
      
      if(CRYP_GetCmdStatus() == DISABLE)
 8001e50:	f7ff fa20 	bl	8001294 <CRYP_GetCmdStatus>
 8001e54:	2800      	cmp	r0, #0
 8001e56:	f000 81f8 	beq.w	800224a <CRYP_AES_CCM+0x5f8>
 8001e5a:	2600      	movs	r6, #0
 8001e5c:	e18c      	b.n	8002178 <CRYP_AES_CCM+0x526>
    AES_CRYP_InitStructure.CRYP_KeySize = CRYP_KeySize_128b;
 8001e5e:	2300      	movs	r3, #0
 8001e60:	9321      	str	r3, [sp, #132]	; 0x84
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8001e62:	f8da 3000 	ldr.w	r3, [sl]
 8001e66:	ba1b      	rev	r3, r3
 8001e68:	931a      	str	r3, [sp, #104]	; 0x68
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001e6a:	f8da 3004 	ldr.w	r3, [sl, #4]
 8001e6e:	ba1b      	rev	r3, r3
 8001e70:	931b      	str	r3, [sp, #108]	; 0x6c
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001e72:	f8da 3008 	ldr.w	r3, [sl, #8]
 8001e76:	ba1b      	rev	r3, r3
 8001e78:	931c      	str	r3, [sp, #112]	; 0x70
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8001e7a:	f8da 300c 	ldr.w	r3, [sl, #12]
 8001e7e:	ba1b      	rev	r3, r3
 8001e80:	931d      	str	r3, [sp, #116]	; 0x74
    break;
 8001e82:	e79b      	b.n	8001dbc <CRYP_AES_CCM+0x16a>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_192b;
 8001e84:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001e88:	9321      	str	r3, [sp, #132]	; 0x84
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 8001e8a:	f8da 3000 	ldr.w	r3, [sl]
 8001e8e:	ba1b      	rev	r3, r3
 8001e90:	9318      	str	r3, [sp, #96]	; 0x60
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8001e92:	f8da 3004 	ldr.w	r3, [sl, #4]
 8001e96:	ba1b      	rev	r3, r3
 8001e98:	9319      	str	r3, [sp, #100]	; 0x64
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8001e9a:	f8da 3008 	ldr.w	r3, [sl, #8]
 8001e9e:	ba1b      	rev	r3, r3
 8001ea0:	931a      	str	r3, [sp, #104]	; 0x68
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001ea2:	f8da 300c 	ldr.w	r3, [sl, #12]
 8001ea6:	ba1b      	rev	r3, r3
 8001ea8:	931b      	str	r3, [sp, #108]	; 0x6c
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001eaa:	f8da 3010 	ldr.w	r3, [sl, #16]
 8001eae:	ba1b      	rev	r3, r3
 8001eb0:	931c      	str	r3, [sp, #112]	; 0x70
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8001eb2:	f8da 3014 	ldr.w	r3, [sl, #20]
 8001eb6:	ba1b      	rev	r3, r3
 8001eb8:	931d      	str	r3, [sp, #116]	; 0x74
    break;
 8001eba:	e77f      	b.n	8001dbc <CRYP_AES_CCM+0x16a>
    AES_CRYP_InitStructure.CRYP_KeySize  = CRYP_KeySize_256b;
 8001ebc:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001ec0:	9321      	str	r3, [sp, #132]	; 0x84
    AES_CRYP_KeyInitStructure.CRYP_Key0Left = __REV(*(uint32_t*)(keyaddr));
 8001ec2:	f8da 3000 	ldr.w	r3, [sl]
 8001ec6:	ba1b      	rev	r3, r3
 8001ec8:	9316      	str	r3, [sp, #88]	; 0x58
    AES_CRYP_KeyInitStructure.CRYP_Key0Right= __REV(*(uint32_t*)(keyaddr));
 8001eca:	f8da 3004 	ldr.w	r3, [sl, #4]
 8001ece:	ba1b      	rev	r3, r3
 8001ed0:	9317      	str	r3, [sp, #92]	; 0x5c
    AES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 8001ed2:	f8da 3008 	ldr.w	r3, [sl, #8]
 8001ed6:	ba1b      	rev	r3, r3
 8001ed8:	9318      	str	r3, [sp, #96]	; 0x60
    AES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8001eda:	f8da 300c 	ldr.w	r3, [sl, #12]
 8001ede:	ba1b      	rev	r3, r3
 8001ee0:	9319      	str	r3, [sp, #100]	; 0x64
    AES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8001ee2:	f8da 3010 	ldr.w	r3, [sl, #16]
 8001ee6:	ba1b      	rev	r3, r3
 8001ee8:	931a      	str	r3, [sp, #104]	; 0x68
    AES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 8001eea:	f8da 3014 	ldr.w	r3, [sl, #20]
 8001eee:	ba1b      	rev	r3, r3
 8001ef0:	931b      	str	r3, [sp, #108]	; 0x6c
    AES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8001ef2:	f8da 3018 	ldr.w	r3, [sl, #24]
 8001ef6:	ba1b      	rev	r3, r3
 8001ef8:	931c      	str	r3, [sp, #112]	; 0x70
    AES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8001efa:	f8da 301c 	ldr.w	r3, [sl, #28]
 8001efe:	ba1b      	rev	r3, r3
 8001f00:	931d      	str	r3, [sp, #116]	; 0x74
    break;
 8001f02:	e75b      	b.n	8001dbc <CRYP_AES_CCM+0x16a>
    CRYP_FIFOFlush();
 8001f04:	f7ff f8b8 	bl	8001078 <CRYP_FIFOFlush>
    CRYP_KeyInit(&AES_CRYP_KeyInitStructure);
 8001f08:	a816      	add	r0, sp, #88	; 0x58
 8001f0a:	f7ff f87b 	bl	8001004 <CRYP_KeyInit>
    CRYP_IVInit(&AES_CRYP_IVInitStructure);
 8001f0e:	a812      	add	r0, sp, #72	; 0x48
 8001f10:	f7ff f896 	bl	8001040 <CRYP_IVInit>
    AES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 8001f14:	f04f 0a00 	mov.w	sl, #0
 8001f18:	f8cd a078 	str.w	sl, [sp, #120]	; 0x78
    AES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_AES_CCM;
 8001f1c:	f04f 1308 	mov.w	r3, #524296	; 0x80008
 8001f20:	931f      	str	r3, [sp, #124]	; 0x7c
    AES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 8001f22:	2380      	movs	r3, #128	; 0x80
 8001f24:	9320      	str	r3, [sp, #128]	; 0x80
    CRYP_Init(&AES_CRYP_InitStructure);
 8001f26:	a81e      	add	r0, sp, #120	; 0x78
 8001f28:	f7ff f836 	bl	8000f98 <CRYP_Init>
    CRYP_PhaseConfig(CRYP_Phase_Init);
 8001f2c:	4650      	mov	r0, sl
 8001f2e:	f7ff f899 	bl	8001064 <CRYP_PhaseConfig>
    CRYP_DataIn((*(uint32_t*)(b0addr)));
 8001f32:	980d      	ldr	r0, [sp, #52]	; 0x34
 8001f34:	f7ff f8b8 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn((*(uint32_t*)(b0addr)));
 8001f38:	9b01      	ldr	r3, [sp, #4]
 8001f3a:	6858      	ldr	r0, [r3, #4]
 8001f3c:	f7ff f8b4 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn((*(uint32_t*)(b0addr)));
 8001f40:	9a01      	ldr	r2, [sp, #4]
 8001f42:	6890      	ldr	r0, [r2, #8]
 8001f44:	f7ff f8b0 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn((*(uint32_t*)(b0addr)));
 8001f48:	9a01      	ldr	r2, [sp, #4]
 8001f4a:	68d0      	ldr	r0, [r2, #12]
 8001f4c:	f7ff f8ac 	bl	80010a8 <CRYP_DataIn>
    CRYP_Cmd(ENABLE);
 8001f50:	2001      	movs	r0, #1
 8001f52:	f7ff f899 	bl	8001088 <CRYP_Cmd>
    while(CRYP_GetCmdStatus() == ENABLE);
 8001f56:	f7ff f99d 	bl	8001294 <CRYP_GetCmdStatus>
 8001f5a:	2801      	cmp	r0, #1
 8001f5c:	d0fb      	beq.n	8001f56 <CRYP_AES_CCM+0x304>
    if(headersize != 0)
 8001f5e:	b995      	cbnz	r5, 8001f86 <CRYP_AES_CCM+0x334>
  ErrorStatus status = SUCCESS;
 8001f60:	2501      	movs	r5, #1
    if(ILength != 0)
 8001f62:	f1b9 0f00 	cmp.w	r9, #0
 8001f66:	f000 8088 	beq.w	800207a <CRYP_AES_CCM+0x428>
      CRYP_PhaseConfig(CRYP_Phase_Payload);
 8001f6a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8001f6e:	f7ff f879 	bl	8001064 <CRYP_PhaseConfig>
      CRYP_Cmd(ENABLE);
 8001f72:	2001      	movs	r0, #1
 8001f74:	f7ff f888 	bl	8001088 <CRYP_Cmd>
      if(CRYP_GetCmdStatus() == DISABLE)
 8001f78:	f7ff f98c 	bl	8001294 <CRYP_GetCmdStatus>
 8001f7c:	2800      	cmp	r0, #0
 8001f7e:	f000 8160 	beq.w	8002242 <CRYP_AES_CCM+0x5f0>
 8001f82:	2600      	movs	r6, #0
 8001f84:	e052      	b.n	800202c <CRYP_AES_CCM+0x3da>
      CRYP_PhaseConfig(CRYP_Phase_Header);
 8001f86:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8001f8a:	f7ff f86b 	bl	8001064 <CRYP_PhaseConfig>
      CRYP_Cmd(ENABLE);
 8001f8e:	2001      	movs	r0, #1
 8001f90:	f7ff f87a 	bl	8001088 <CRYP_Cmd>
      if(CRYP_GetCmdStatus() == DISABLE)
 8001f94:	f7ff f97e 	bl	8001294 <CRYP_GetCmdStatus>
 8001f98:	2800      	cmp	r0, #0
 8001f9a:	f000 8150 	beq.w	800223e <CRYP_AES_CCM+0x5ec>
 8001f9e:	f04f 0a00 	mov.w	sl, #0
 8001fa2:	e013      	b.n	8001fcc <CRYP_AES_CCM+0x37a>
        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET);
 8001fa4:	2001      	movs	r0, #1
 8001fa6:	f7ff f981 	bl	80012ac <CRYP_GetFlagStatus>
 8001faa:	2800      	cmp	r0, #0
 8001fac:	d0fa      	beq.n	8001fa4 <CRYP_AES_CCM+0x352>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 8001fae:	6830      	ldr	r0, [r6, #0]
 8001fb0:	f7ff f87a 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 8001fb4:	6870      	ldr	r0, [r6, #4]
 8001fb6:	f7ff f877 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 8001fba:	68b0      	ldr	r0, [r6, #8]
 8001fbc:	f7ff f874 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 8001fc0:	68f0      	ldr	r0, [r6, #12]
 8001fc2:	f7ff f871 	bl	80010a8 <CRYP_DataIn>
        headeraddr+=4;
 8001fc6:	3610      	adds	r6, #16
      for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
 8001fc8:	f10a 0a10 	add.w	sl, sl, #16
 8001fcc:	4555      	cmp	r5, sl
 8001fce:	d8e9      	bhi.n	8001fa4 <CRYP_AES_CCM+0x352>
      counter = 0;
 8001fd0:	2300      	movs	r3, #0
 8001fd2:	9311      	str	r3, [sp, #68]	; 0x44
        busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 8001fd4:	2010      	movs	r0, #16
 8001fd6:	f7ff f969 	bl	80012ac <CRYP_GetFlagStatus>
 8001fda:	4602      	mov	r2, r0
        counter++;
 8001fdc:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8001fde:	3301      	adds	r3, #1
 8001fe0:	9311      	str	r3, [sp, #68]	; 0x44
      }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 8001fe2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8001fe4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001fe8:	d001      	beq.n	8001fee <CRYP_AES_CCM+0x39c>
 8001fea:	2800      	cmp	r0, #0
 8001fec:	d1f2      	bne.n	8001fd4 <CRYP_AES_CCM+0x382>
      if (busystatus != RESET)
 8001fee:	b90a      	cbnz	r2, 8001ff4 <CRYP_AES_CCM+0x3a2>
  ErrorStatus status = SUCCESS;
 8001ff0:	2501      	movs	r5, #1
 8001ff2:	e7b6      	b.n	8001f62 <CRYP_AES_CCM+0x310>
        status = ERROR;
 8001ff4:	2500      	movs	r5, #0
 8001ff6:	e7b4      	b.n	8001f62 <CRYP_AES_CCM+0x310>
        if (busystatus != RESET)
 8001ff8:	2a00      	cmp	r2, #0
 8001ffa:	d13c      	bne.n	8002076 <CRYP_AES_CCM+0x424>
          while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET);
 8001ffc:	2004      	movs	r0, #4
 8001ffe:	f7ff f955 	bl	80012ac <CRYP_GetFlagStatus>
 8002002:	2800      	cmp	r0, #0
 8002004:	d0fa      	beq.n	8001ffc <CRYP_AES_CCM+0x3aa>
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8002006:	f7ff f855 	bl	80010b4 <CRYP_DataOut>
 800200a:	f8c8 0000 	str.w	r0, [r8]
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800200e:	f7ff f851 	bl	80010b4 <CRYP_DataOut>
 8002012:	f8c8 0004 	str.w	r0, [r8, #4]
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8002016:	f7ff f84d 	bl	80010b4 <CRYP_DataOut>
 800201a:	f8c8 0008 	str.w	r0, [r8, #8]
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800201e:	f7ff f849 	bl	80010b4 <CRYP_DataOut>
 8002022:	f8c8 000c 	str.w	r0, [r8, #12]
          outputaddr+=4;
 8002026:	f108 0810 	add.w	r8, r8, #16
      for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
 800202a:	3610      	adds	r6, #16
 800202c:	454e      	cmp	r6, r9
 800202e:	d224      	bcs.n	800207a <CRYP_AES_CCM+0x428>
 8002030:	b31d      	cbz	r5, 800207a <CRYP_AES_CCM+0x428>
        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET);
 8002032:	2001      	movs	r0, #1
 8002034:	f7ff f93a 	bl	80012ac <CRYP_GetFlagStatus>
 8002038:	2800      	cmp	r0, #0
 800203a:	d0fa      	beq.n	8002032 <CRYP_AES_CCM+0x3e0>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 800203c:	6820      	ldr	r0, [r4, #0]
 800203e:	f7ff f833 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 8002042:	6860      	ldr	r0, [r4, #4]
 8002044:	f7ff f830 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 8002048:	68a0      	ldr	r0, [r4, #8]
 800204a:	f7ff f82d 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 800204e:	68e0      	ldr	r0, [r4, #12]
 8002050:	f7ff f82a 	bl	80010a8 <CRYP_DataIn>
        inputaddr+=4;
 8002054:	3410      	adds	r4, #16
        counter = 0;
 8002056:	2300      	movs	r3, #0
 8002058:	9311      	str	r3, [sp, #68]	; 0x44
          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800205a:	2010      	movs	r0, #16
 800205c:	f7ff f926 	bl	80012ac <CRYP_GetFlagStatus>
 8002060:	4602      	mov	r2, r0
          counter++;
 8002062:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8002064:	3301      	adds	r3, #1
 8002066:	9311      	str	r3, [sp, #68]	; 0x44
        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 8002068:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800206a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800206e:	d0c3      	beq.n	8001ff8 <CRYP_AES_CCM+0x3a6>
 8002070:	2800      	cmp	r0, #0
 8002072:	d1f2      	bne.n	800205a <CRYP_AES_CCM+0x408>
 8002074:	e7c0      	b.n	8001ff8 <CRYP_AES_CCM+0x3a6>
          status = ERROR;
 8002076:	2500      	movs	r5, #0
 8002078:	e7d7      	b.n	800202a <CRYP_AES_CCM+0x3d8>
    CRYP_PhaseConfig(CRYP_Phase_Final);
 800207a:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 800207e:	f7fe fff1 	bl	8001064 <CRYP_PhaseConfig>
    CRYP_Cmd(ENABLE);
 8002082:	2001      	movs	r0, #1
 8002084:	f7ff f800 	bl	8001088 <CRYP_Cmd>
    if(CRYP_GetCmdStatus() == DISABLE)
 8002088:	f7ff f904 	bl	8001294 <CRYP_GetCmdStatus>
 800208c:	b908      	cbnz	r0, 8002092 <CRYP_AES_CCM+0x440>
      return(ERROR);
 800208e:	2500      	movs	r5, #0
 8002090:	e0a4      	b.n	80021dc <CRYP_AES_CCM+0x58a>
    CRYP_DataIn(*(uint32_t*)(ctraddr));
 8002092:	9809      	ldr	r0, [sp, #36]	; 0x24
 8002094:	f7ff f808 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(ctraddr));
 8002098:	6878      	ldr	r0, [r7, #4]
 800209a:	f7ff f805 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(ctraddr));
 800209e:	68b8      	ldr	r0, [r7, #8]
 80020a0:	f7ff f802 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
 80020a4:	68f8      	ldr	r0, [r7, #12]
 80020a6:	f020 7080 	bic.w	r0, r0, #16777216	; 0x1000000
 80020aa:	f7fe fffd 	bl	80010a8 <CRYP_DataIn>
    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET);
 80020ae:	2004      	movs	r0, #4
 80020b0:	f7ff f8fc 	bl	80012ac <CRYP_GetFlagStatus>
 80020b4:	2800      	cmp	r0, #0
 80020b6:	d0fa      	beq.n	80020ae <CRYP_AES_CCM+0x45c>
    temptag[0] = CRYP_DataOut();
 80020b8:	f7fe fffc 	bl	80010b4 <CRYP_DataOut>
 80020bc:	9005      	str	r0, [sp, #20]
    temptag[1] = CRYP_DataOut();
 80020be:	f7fe fff9 	bl	80010b4 <CRYP_DataOut>
 80020c2:	9006      	str	r0, [sp, #24]
    temptag[2] = CRYP_DataOut();
 80020c4:	f7fe fff6 	bl	80010b4 <CRYP_DataOut>
 80020c8:	9007      	str	r0, [sp, #28]
    temptag[3] = CRYP_DataOut();
 80020ca:	f7fe fff3 	bl	80010b4 <CRYP_DataOut>
 80020ce:	9008      	str	r0, [sp, #32]
 80020d0:	e0a7      	b.n	8002222 <CRYP_AES_CCM+0x5d0>
      CRYP_PhaseConfig(CRYP_Phase_Header);
 80020d2:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80020d6:	f7fe ffc5 	bl	8001064 <CRYP_PhaseConfig>
      CRYP_Cmd(ENABLE);
 80020da:	2001      	movs	r0, #1
 80020dc:	f7fe ffd4 	bl	8001088 <CRYP_Cmd>
      if(CRYP_GetCmdStatus() == DISABLE)
 80020e0:	f7ff f8d8 	bl	8001294 <CRYP_GetCmdStatus>
 80020e4:	2800      	cmp	r0, #0
 80020e6:	f000 80ae 	beq.w	8002246 <CRYP_AES_CCM+0x5f4>
 80020ea:	f04f 0a00 	mov.w	sl, #0
 80020ee:	e013      	b.n	8002118 <CRYP_AES_CCM+0x4c6>
        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET);
 80020f0:	2001      	movs	r0, #1
 80020f2:	f7ff f8db 	bl	80012ac <CRYP_GetFlagStatus>
 80020f6:	2800      	cmp	r0, #0
 80020f8:	d0fa      	beq.n	80020f0 <CRYP_AES_CCM+0x49e>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 80020fa:	6830      	ldr	r0, [r6, #0]
 80020fc:	f7fe ffd4 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 8002100:	6870      	ldr	r0, [r6, #4]
 8002102:	f7fe ffd1 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 8002106:	68b0      	ldr	r0, [r6, #8]
 8002108:	f7fe ffce 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(headeraddr));
 800210c:	68f0      	ldr	r0, [r6, #12]
 800210e:	f7fe ffcb 	bl	80010a8 <CRYP_DataIn>
        headeraddr+=4;
 8002112:	3610      	adds	r6, #16
      for(loopcounter = 0; (loopcounter < headersize); loopcounter+=16)
 8002114:	f10a 0a10 	add.w	sl, sl, #16
 8002118:	4555      	cmp	r5, sl
 800211a:	d8e9      	bhi.n	80020f0 <CRYP_AES_CCM+0x49e>
      counter = 0;
 800211c:	2300      	movs	r3, #0
 800211e:	9311      	str	r3, [sp, #68]	; 0x44
        busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 8002120:	2010      	movs	r0, #16
 8002122:	f7ff f8c3 	bl	80012ac <CRYP_GetFlagStatus>
 8002126:	4602      	mov	r2, r0
        counter++;
 8002128:	9b11      	ldr	r3, [sp, #68]	; 0x44
 800212a:	3301      	adds	r3, #1
 800212c:	9311      	str	r3, [sp, #68]	; 0x44
      }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 800212e:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8002130:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002134:	d001      	beq.n	800213a <CRYP_AES_CCM+0x4e8>
 8002136:	2800      	cmp	r0, #0
 8002138:	d1f2      	bne.n	8002120 <CRYP_AES_CCM+0x4ce>
      if (busystatus != RESET)
 800213a:	b90a      	cbnz	r2, 8002140 <CRYP_AES_CCM+0x4ee>
  ErrorStatus status = SUCCESS;
 800213c:	2501      	movs	r5, #1
 800213e:	e67c      	b.n	8001e3a <CRYP_AES_CCM+0x1e8>
        status = ERROR;
 8002140:	2500      	movs	r5, #0
 8002142:	e67a      	b.n	8001e3a <CRYP_AES_CCM+0x1e8>
        {
          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
          counter++;
        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));

        if (busystatus != RESET)
 8002144:	2a00      	cmp	r2, #0
 8002146:	d13c      	bne.n	80021c2 <CRYP_AES_CCM+0x570>
          status = ERROR;
        }
        else
        {
          /* Wait until the OFNE flag is reset */
          while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET);
 8002148:	2004      	movs	r0, #4
 800214a:	f7ff f8af 	bl	80012ac <CRYP_GetFlagStatus>
 800214e:	2800      	cmp	r0, #0
 8002150:	d0fa      	beq.n	8002148 <CRYP_AES_CCM+0x4f6>
          
          /* Read the Output block from the Output FIFO */
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8002152:	f7fe ffaf 	bl	80010b4 <CRYP_DataOut>
 8002156:	f8c8 0000 	str.w	r0, [r8]
          outputaddr+=4;
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800215a:	f7fe ffab 	bl	80010b4 <CRYP_DataOut>
 800215e:	f8c8 0004 	str.w	r0, [r8, #4]
          outputaddr+=4;
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8002162:	f7fe ffa7 	bl	80010b4 <CRYP_DataOut>
 8002166:	f8c8 0008 	str.w	r0, [r8, #8]
          outputaddr+=4;
          *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800216a:	f7fe ffa3 	bl	80010b4 <CRYP_DataOut>
 800216e:	f8c8 000c 	str.w	r0, [r8, #12]
          outputaddr+=4;
 8002172:	f108 0810 	add.w	r8, r8, #16
      for(loopcounter = 0; ((loopcounter < ILength) && (status != ERROR)); loopcounter+=16)
 8002176:	3610      	adds	r6, #16
 8002178:	454e      	cmp	r6, r9
 800217a:	d224      	bcs.n	80021c6 <CRYP_AES_CCM+0x574>
 800217c:	b31d      	cbz	r5, 80021c6 <CRYP_AES_CCM+0x574>
        while(CRYP_GetFlagStatus(CRYP_FLAG_IFEM) == RESET);
 800217e:	2001      	movs	r0, #1
 8002180:	f7ff f894 	bl	80012ac <CRYP_GetFlagStatus>
 8002184:	2800      	cmp	r0, #0
 8002186:	d0fa      	beq.n	800217e <CRYP_AES_CCM+0x52c>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 8002188:	6820      	ldr	r0, [r4, #0]
 800218a:	f7fe ff8d 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 800218e:	6860      	ldr	r0, [r4, #4]
 8002190:	f7fe ff8a 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 8002194:	68a0      	ldr	r0, [r4, #8]
 8002196:	f7fe ff87 	bl	80010a8 <CRYP_DataIn>
        CRYP_DataIn(*(uint32_t*)(inputaddr));
 800219a:	68e0      	ldr	r0, [r4, #12]
 800219c:	f7fe ff84 	bl	80010a8 <CRYP_DataIn>
        inputaddr+=4;
 80021a0:	3410      	adds	r4, #16
        counter = 0;
 80021a2:	2300      	movs	r3, #0
 80021a4:	9311      	str	r3, [sp, #68]	; 0x44
          busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 80021a6:	2010      	movs	r0, #16
 80021a8:	f7ff f880 	bl	80012ac <CRYP_GetFlagStatus>
 80021ac:	4602      	mov	r2, r0
          counter++;
 80021ae:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80021b0:	3301      	adds	r3, #1
 80021b2:	9311      	str	r3, [sp, #68]	; 0x44
        }while ((counter != AESBUSY_TIMEOUT) && (busystatus != RESET));
 80021b4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 80021b6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80021ba:	d0c3      	beq.n	8002144 <CRYP_AES_CCM+0x4f2>
 80021bc:	2800      	cmp	r0, #0
 80021be:	d1f2      	bne.n	80021a6 <CRYP_AES_CCM+0x554>
 80021c0:	e7c0      	b.n	8002144 <CRYP_AES_CCM+0x4f2>
          status = ERROR;
 80021c2:	2500      	movs	r5, #0
 80021c4:	e7d7      	b.n	8002176 <CRYP_AES_CCM+0x524>
      }
    }
    
    /***************************** final phase ********************************/
    /* Select final phase */
    CRYP_PhaseConfig(CRYP_Phase_Final);
 80021c6:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 80021ca:	f7fe ff4b 	bl	8001064 <CRYP_PhaseConfig>
    
    /* Enable Crypto processor */
    CRYP_Cmd(ENABLE);
 80021ce:	2001      	movs	r0, #1
 80021d0:	f7fe ff5a 	bl	8001088 <CRYP_Cmd>
    
    if(CRYP_GetCmdStatus() == DISABLE)
 80021d4:	f7ff f85e 	bl	8001294 <CRYP_GetCmdStatus>
 80021d8:	b920      	cbnz	r0, 80021e4 <CRYP_AES_CCM+0x592>
    {
      /* The CRYP peripheral clock is not enabled or the device doesn't embedd 
         the CRYP peripheral (please check the device sales type. */
      return(ERROR);
 80021da:	2500      	movs	r5, #0
  
  /* Disable Crypto */
  CRYP_Cmd(DISABLE);

  return status;
}
 80021dc:	4628      	mov	r0, r5
 80021de:	b023      	add	sp, #140	; 0x8c
 80021e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CRYP_DataIn(*(uint32_t*)(ctraddr));
 80021e4:	9809      	ldr	r0, [sp, #36]	; 0x24
 80021e6:	f7fe ff5f 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(ctraddr));
 80021ea:	6878      	ldr	r0, [r7, #4]
 80021ec:	f7fe ff5c 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(ctraddr));
 80021f0:	68b8      	ldr	r0, [r7, #8]
 80021f2:	f7fe ff59 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(ctraddr) & 0xfeffffff);
 80021f6:	68f8      	ldr	r0, [r7, #12]
 80021f8:	f020 7080 	bic.w	r0, r0, #16777216	; 0x1000000
 80021fc:	f7fe ff54 	bl	80010a8 <CRYP_DataIn>
    while(CRYP_GetFlagStatus(CRYP_FLAG_OFNE) == RESET);
 8002200:	2004      	movs	r0, #4
 8002202:	f7ff f853 	bl	80012ac <CRYP_GetFlagStatus>
 8002206:	2800      	cmp	r0, #0
 8002208:	d0fa      	beq.n	8002200 <CRYP_AES_CCM+0x5ae>
    temptag[0] = CRYP_DataOut();
 800220a:	f7fe ff53 	bl	80010b4 <CRYP_DataOut>
 800220e:	9005      	str	r0, [sp, #20]
    temptag[1] = CRYP_DataOut();
 8002210:	f7fe ff50 	bl	80010b4 <CRYP_DataOut>
 8002214:	9006      	str	r0, [sp, #24]
    temptag[2] = CRYP_DataOut();
 8002216:	f7fe ff4d 	bl	80010b4 <CRYP_DataOut>
 800221a:	9007      	str	r0, [sp, #28]
    temptag[3] = CRYP_DataOut();
 800221c:	f7fe ff4a 	bl	80010b4 <CRYP_DataOut>
 8002220:	9008      	str	r0, [sp, #32]
  for(loopcounter = 0; (loopcounter < TAGSize); loopcounter++)
 8002222:	2300      	movs	r3, #0
 8002224:	9934      	ldr	r1, [sp, #208]	; 0xd0
 8002226:	e004      	b.n	8002232 <CRYP_AES_CCM+0x5e0>
    *((uint8_t*)tagaddr+loopcounter) = *((uint8_t*)temptag+loopcounter);
 8002228:	aa05      	add	r2, sp, #20
 800222a:	5cd2      	ldrb	r2, [r2, r3]
 800222c:	f803 200b 	strb.w	r2, [r3, fp]
  for(loopcounter = 0; (loopcounter < TAGSize); loopcounter++)
 8002230:	3301      	adds	r3, #1
 8002232:	428b      	cmp	r3, r1
 8002234:	d3f8      	bcc.n	8002228 <CRYP_AES_CCM+0x5d6>
  CRYP_Cmd(DISABLE);
 8002236:	2000      	movs	r0, #0
 8002238:	f7fe ff26 	bl	8001088 <CRYP_Cmd>
  return status;
 800223c:	e7ce      	b.n	80021dc <CRYP_AES_CCM+0x58a>
         return(ERROR);
 800223e:	2500      	movs	r5, #0
 8002240:	e7cc      	b.n	80021dc <CRYP_AES_CCM+0x58a>
        return(ERROR);
 8002242:	2500      	movs	r5, #0
 8002244:	e7ca      	b.n	80021dc <CRYP_AES_CCM+0x58a>
        return(ERROR);
 8002246:	2500      	movs	r5, #0
 8002248:	e7c8      	b.n	80021dc <CRYP_AES_CCM+0x58a>
        return(ERROR);
 800224a:	2500      	movs	r5, #0
 800224c:	e7c6      	b.n	80021dc <CRYP_AES_CCM+0x58a>

0800224e <CRYP_DES_ECB>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_DES_ECB(uint8_t Mode, uint8_t Key[8], uint8_t *Input, 
                         uint32_t Ilength, uint8_t *Output)
{
 800224e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002252:	b08e      	sub	sp, #56	; 0x38
 8002254:	4606      	mov	r6, r0
 8002256:	460d      	mov	r5, r1
 8002258:	4698      	mov	r8, r3
  CRYP_InitTypeDef DES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
 800225a:	2300      	movs	r3, #0
 800225c:	9301      	str	r3, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
 800225e:	4614      	mov	r4, r2
  uint32_t outputaddr = (uint32_t)Output;
 8002260:	9f14      	ldr	r7, [sp, #80]	; 0x50
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
 8002262:	a802      	add	r0, sp, #8
 8002264:	f7fe fee2 	bl	800102c <CRYP_KeyStructInit>

  /* Crypto Init for Encryption process */
  if( Mode == MODE_ENCRYPT ) /* DES encryption */
 8002268:	2e01      	cmp	r6, #1
 800226a:	d01c      	beq.n	80022a6 <CRYP_DES_ECB+0x58>
  {
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
  }
  else/* if( Mode == MODE_DECRYPT )*/ /* DES decryption */
  {      
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
 800226c:	2304      	movs	r3, #4
 800226e:	930a      	str	r3, [sp, #40]	; 0x28
  }

  DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_ECB;
 8002270:	2310      	movs	r3, #16
 8002272:	930b      	str	r3, [sp, #44]	; 0x2c
  DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 8002274:	2380      	movs	r3, #128	; 0x80
 8002276:	930c      	str	r3, [sp, #48]	; 0x30
  CRYP_Init(&DES_CRYP_InitStructure);
 8002278:	a80a      	add	r0, sp, #40	; 0x28
 800227a:	f7fe fe8d 	bl	8000f98 <CRYP_Init>

  /* Key Initialisation */
  DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800227e:	682b      	ldr	r3, [r5, #0]
 8002280:	ba1b      	rev	r3, r3
 8002282:	9304      	str	r3, [sp, #16]
  keyaddr+=4;
  DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8002284:	686b      	ldr	r3, [r5, #4]
 8002286:	ba1b      	rev	r3, r3
 8002288:	9305      	str	r3, [sp, #20]
  CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
 800228a:	a802      	add	r0, sp, #8
 800228c:	f7fe feba 	bl	8001004 <CRYP_KeyInit>

  /* Flush IN/OUT FIFO */
  CRYP_FIFOFlush();
 8002290:	f7fe fef2 	bl	8001078 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 8002294:	2001      	movs	r0, #1
 8002296:	f7fe fef7 	bl	8001088 <CRYP_Cmd>

  if(CRYP_GetCmdStatus() == DISABLE)
 800229a:	f7fe fffb 	bl	8001294 <CRYP_GetCmdStatus>
 800229e:	b388      	cbz	r0, 8002304 <CRYP_DES_ECB+0xb6>
 80022a0:	2500      	movs	r5, #0
 80022a2:	2601      	movs	r6, #1
 80022a4:	e005      	b.n	80022b2 <CRYP_DES_ECB+0x64>
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
 80022a6:	2300      	movs	r3, #0
 80022a8:	930a      	str	r3, [sp, #40]	; 0x28
 80022aa:	e7e1      	b.n	8002270 <CRYP_DES_ECB+0x22>
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 80022ac:	b1da      	cbz	r2, 80022e6 <CRYP_DES_ECB+0x98>
   {
       status = ERROR;
 80022ae:	2600      	movs	r6, #0
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 80022b0:	3508      	adds	r5, #8
 80022b2:	4545      	cmp	r5, r8
 80022b4:	d21f      	bcs.n	80022f6 <CRYP_DES_ECB+0xa8>
 80022b6:	b1f6      	cbz	r6, 80022f6 <CRYP_DES_ECB+0xa8>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80022b8:	6820      	ldr	r0, [r4, #0]
 80022ba:	f7fe fef5 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 80022be:	6860      	ldr	r0, [r4, #4]
 80022c0:	f7fe fef2 	bl	80010a8 <CRYP_DataIn>
    inputaddr+=4;
 80022c4:	3408      	adds	r4, #8
    counter = 0;
 80022c6:	2300      	movs	r3, #0
 80022c8:	9301      	str	r3, [sp, #4]
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 80022ca:	2010      	movs	r0, #16
 80022cc:	f7fe ffee 	bl	80012ac <CRYP_GetFlagStatus>
 80022d0:	4602      	mov	r2, r0
      counter++;
 80022d2:	9b01      	ldr	r3, [sp, #4]
 80022d4:	3301      	adds	r3, #1
 80022d6:	9301      	str	r3, [sp, #4]
    }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
 80022d8:	9b01      	ldr	r3, [sp, #4]
 80022da:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80022de:	d0e5      	beq.n	80022ac <CRYP_DES_ECB+0x5e>
 80022e0:	2800      	cmp	r0, #0
 80022e2:	d1f2      	bne.n	80022ca <CRYP_DES_ECB+0x7c>
 80022e4:	e7e2      	b.n	80022ac <CRYP_DES_ECB+0x5e>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 80022e6:	f7fe fee5 	bl	80010b4 <CRYP_DataOut>
 80022ea:	6038      	str	r0, [r7, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 80022ec:	f7fe fee2 	bl	80010b4 <CRYP_DataOut>
 80022f0:	6078      	str	r0, [r7, #4]
      outputaddr+=4;
 80022f2:	3708      	adds	r7, #8
 80022f4:	e7dc      	b.n	80022b0 <CRYP_DES_ECB+0x62>
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 80022f6:	2000      	movs	r0, #0
 80022f8:	f7fe fec6 	bl	8001088 <CRYP_Cmd>

  return status; 
}
 80022fc:	4630      	mov	r0, r6
 80022fe:	b00e      	add	sp, #56	; 0x38
 8002300:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return(ERROR);
 8002304:	2600      	movs	r6, #0
 8002306:	e7f9      	b.n	80022fc <CRYP_DES_ECB+0xae>

08002308 <CRYP_DES_CBC>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_DES_CBC(uint8_t Mode, uint8_t Key[8], uint8_t InitVectors[8],
                         uint8_t *Input, uint32_t Ilength, uint8_t *Output)
{
 8002308:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800230c:	b093      	sub	sp, #76	; 0x4c
 800230e:	4681      	mov	r9, r0
 8002310:	460e      	mov	r6, r1
 8002312:	4615      	mov	r5, r2
 8002314:	f8dd 8068 	ldr.w	r8, [sp, #104]	; 0x68
  CRYP_InitTypeDef DES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef DES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef DES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 8002318:	2200      	movs	r2, #0
 800231a:	9201      	str	r2, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
 800231c:	461c      	mov	r4, r3
  uint32_t outputaddr = (uint32_t)Output;
 800231e:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
  uint32_t ivaddr     = (uint32_t)InitVectors;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&DES_CRYP_KeyInitStructure);
 8002320:	a806      	add	r0, sp, #24
 8002322:	f7fe fe83 	bl	800102c <CRYP_KeyStructInit>

  /* Crypto Init for Encryption process */
  if(Mode == MODE_ENCRYPT) /* DES encryption */
 8002326:	f1b9 0f01 	cmp.w	r9, #1
 800232a:	d025      	beq.n	8002378 <CRYP_DES_CBC+0x70>
  {
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
  }
  else /*if(Mode == MODE_DECRYPT)*/ /* DES decryption */
  {
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Decrypt;
 800232c:	2304      	movs	r3, #4
 800232e:	930e      	str	r3, [sp, #56]	; 0x38
  }

  DES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_DES_CBC;
 8002330:	2318      	movs	r3, #24
 8002332:	930f      	str	r3, [sp, #60]	; 0x3c
  DES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 8002334:	2380      	movs	r3, #128	; 0x80
 8002336:	9310      	str	r3, [sp, #64]	; 0x40
  CRYP_Init(&DES_CRYP_InitStructure);
 8002338:	a80e      	add	r0, sp, #56	; 0x38
 800233a:	f7fe fe2d 	bl	8000f98 <CRYP_Init>

  /* Key Initialisation */
  DES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800233e:	6833      	ldr	r3, [r6, #0]
 8002340:	ba1b      	rev	r3, r3
 8002342:	9308      	str	r3, [sp, #32]
  keyaddr+=4;
  DES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8002344:	6873      	ldr	r3, [r6, #4]
 8002346:	ba1b      	rev	r3, r3
 8002348:	9309      	str	r3, [sp, #36]	; 0x24
  CRYP_KeyInit(& DES_CRYP_KeyInitStructure);
 800234a:	a806      	add	r0, sp, #24
 800234c:	f7fe fe5a 	bl	8001004 <CRYP_KeyInit>

  /* Initialization Vectors */
  DES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 8002350:	682b      	ldr	r3, [r5, #0]
 8002352:	ba1b      	rev	r3, r3
 8002354:	9302      	str	r3, [sp, #8]
  ivaddr+=4;
  DES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 8002356:	686b      	ldr	r3, [r5, #4]
 8002358:	ba1b      	rev	r3, r3
 800235a:	9303      	str	r3, [sp, #12]
  CRYP_IVInit(&DES_CRYP_IVInitStructure);
 800235c:	a802      	add	r0, sp, #8
 800235e:	f7fe fe6f 	bl	8001040 <CRYP_IVInit>

  /* Flush IN/OUT FIFO */
  CRYP_FIFOFlush();
 8002362:	f7fe fe89 	bl	8001078 <CRYP_FIFOFlush>
  
  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 8002366:	2001      	movs	r0, #1
 8002368:	f7fe fe8e 	bl	8001088 <CRYP_Cmd>

  if(CRYP_GetCmdStatus() == DISABLE)
 800236c:	f7fe ff92 	bl	8001294 <CRYP_GetCmdStatus>
 8002370:	b388      	cbz	r0, 80023d6 <CRYP_DES_CBC+0xce>
 8002372:	2500      	movs	r5, #0
 8002374:	2601      	movs	r6, #1
 8002376:	e005      	b.n	8002384 <CRYP_DES_CBC+0x7c>
     DES_CRYP_InitStructure.CRYP_AlgoDir  = CRYP_AlgoDir_Encrypt;
 8002378:	2300      	movs	r3, #0
 800237a:	930e      	str	r3, [sp, #56]	; 0x38
 800237c:	e7d8      	b.n	8002330 <CRYP_DES_CBC+0x28>
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 800237e:	b1da      	cbz	r2, 80023b8 <CRYP_DES_CBC+0xb0>
   {
       status = ERROR;
 8002380:	2600      	movs	r6, #0
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 8002382:	3508      	adds	r5, #8
 8002384:	4545      	cmp	r5, r8
 8002386:	d21f      	bcs.n	80023c8 <CRYP_DES_CBC+0xc0>
 8002388:	b1f6      	cbz	r6, 80023c8 <CRYP_DES_CBC+0xc0>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800238a:	6820      	ldr	r0, [r4, #0]
 800238c:	f7fe fe8c 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8002390:	6860      	ldr	r0, [r4, #4]
 8002392:	f7fe fe89 	bl	80010a8 <CRYP_DataIn>
    inputaddr+=4;
 8002396:	3408      	adds	r4, #8
    counter = 0;
 8002398:	2300      	movs	r3, #0
 800239a:	9301      	str	r3, [sp, #4]
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800239c:	2010      	movs	r0, #16
 800239e:	f7fe ff85 	bl	80012ac <CRYP_GetFlagStatus>
 80023a2:	4602      	mov	r2, r0
      counter++;
 80023a4:	9b01      	ldr	r3, [sp, #4]
 80023a6:	3301      	adds	r3, #1
 80023a8:	9301      	str	r3, [sp, #4]
    }while ((counter != DESBUSY_TIMEOUT) && (busystatus != RESET));
 80023aa:	9b01      	ldr	r3, [sp, #4]
 80023ac:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80023b0:	d0e5      	beq.n	800237e <CRYP_DES_CBC+0x76>
 80023b2:	2800      	cmp	r0, #0
 80023b4:	d1f2      	bne.n	800239c <CRYP_DES_CBC+0x94>
 80023b6:	e7e2      	b.n	800237e <CRYP_DES_CBC+0x76>
    }
    else
    {
      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 80023b8:	f7fe fe7c 	bl	80010b4 <CRYP_DataOut>
 80023bc:	6038      	str	r0, [r7, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 80023be:	f7fe fe79 	bl	80010b4 <CRYP_DataOut>
 80023c2:	6078      	str	r0, [r7, #4]
      outputaddr+=4;
 80023c4:	3708      	adds	r7, #8
 80023c6:	e7dc      	b.n	8002382 <CRYP_DES_CBC+0x7a>
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 80023c8:	2000      	movs	r0, #0
 80023ca:	f7fe fe5d 	bl	8001088 <CRYP_Cmd>

  return status; 
}
 80023ce:	4630      	mov	r0, r6
 80023d0:	b013      	add	sp, #76	; 0x4c
 80023d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return(ERROR);
 80023d6:	2600      	movs	r6, #0
 80023d8:	e7f9      	b.n	80023ce <CRYP_DES_CBC+0xc6>

080023da <CRYP_TDES_ECB>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_TDES_ECB(uint8_t Mode, uint8_t Key[24], uint8_t *Input, 
                          uint32_t Ilength, uint8_t *Output)
{
 80023da:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80023de:	b08e      	sub	sp, #56	; 0x38
 80023e0:	4606      	mov	r6, r0
 80023e2:	460d      	mov	r5, r1
 80023e4:	4698      	mov	r8, r3
  CRYP_InitTypeDef TDES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
  __IO uint32_t counter = 0;
 80023e6:	2300      	movs	r3, #0
 80023e8:	9301      	str	r3, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
 80023ea:	4614      	mov	r4, r2
  uint32_t outputaddr = (uint32_t)Output;
 80023ec:	9f14      	ldr	r7, [sp, #80]	; 0x50
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
 80023ee:	a802      	add	r0, sp, #8
 80023f0:	f7fe fe1c 	bl	800102c <CRYP_KeyStructInit>

  /* Crypto Init for Encryption process */
  if(Mode == MODE_ENCRYPT) /* TDES encryption */
 80023f4:	2e01      	cmp	r6, #1
 80023f6:	d028      	beq.n	800244a <CRYP_TDES_ECB+0x70>
  {
     TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
  }
  else /*if(Mode == MODE_DECRYPT)*/ /* TDES decryption */
  {
     TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 80023f8:	2304      	movs	r3, #4
 80023fa:	930a      	str	r3, [sp, #40]	; 0x28
  }

  TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
 80023fc:	2300      	movs	r3, #0
 80023fe:	930b      	str	r3, [sp, #44]	; 0x2c
  TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 8002400:	2380      	movs	r3, #128	; 0x80
 8002402:	930c      	str	r3, [sp, #48]	; 0x30
  CRYP_Init(&TDES_CRYP_InitStructure);
 8002404:	a80a      	add	r0, sp, #40	; 0x28
 8002406:	f7fe fdc7 	bl	8000f98 <CRYP_Init>

  /* Key Initialisation */
  TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 800240a:	682b      	ldr	r3, [r5, #0]
 800240c:	ba1b      	rev	r3, r3
 800240e:	9304      	str	r3, [sp, #16]
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 8002410:	686b      	ldr	r3, [r5, #4]
 8002412:	ba1b      	rev	r3, r3
 8002414:	9305      	str	r3, [sp, #20]
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 8002416:	68ab      	ldr	r3, [r5, #8]
 8002418:	ba1b      	rev	r3, r3
 800241a:	9306      	str	r3, [sp, #24]
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 800241c:	68eb      	ldr	r3, [r5, #12]
 800241e:	ba1b      	rev	r3, r3
 8002420:	9307      	str	r3, [sp, #28]
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 8002422:	692b      	ldr	r3, [r5, #16]
 8002424:	ba1b      	rev	r3, r3
 8002426:	9308      	str	r3, [sp, #32]
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8002428:	696b      	ldr	r3, [r5, #20]
 800242a:	ba1b      	rev	r3, r3
 800242c:	9309      	str	r3, [sp, #36]	; 0x24
  CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
 800242e:	a802      	add	r0, sp, #8
 8002430:	f7fe fde8 	bl	8001004 <CRYP_KeyInit>

  /* Flush IN/OUT FIFO */
  CRYP_FIFOFlush();
 8002434:	f7fe fe20 	bl	8001078 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 8002438:	2001      	movs	r0, #1
 800243a:	f7fe fe25 	bl	8001088 <CRYP_Cmd>

  if(CRYP_GetCmdStatus() == DISABLE)
 800243e:	f7fe ff29 	bl	8001294 <CRYP_GetCmdStatus>
 8002442:	b388      	cbz	r0, 80024a8 <CRYP_TDES_ECB+0xce>
 8002444:	2500      	movs	r5, #0
 8002446:	2601      	movs	r6, #1
 8002448:	e005      	b.n	8002456 <CRYP_TDES_ECB+0x7c>
     TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 800244a:	2300      	movs	r3, #0
 800244c:	930a      	str	r3, [sp, #40]	; 0x28
 800244e:	e7d5      	b.n	80023fc <CRYP_TDES_ECB+0x22>
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 8002450:	b1da      	cbz	r2, 800248a <CRYP_TDES_ECB+0xb0>
    {
       status = ERROR;
 8002452:	2600      	movs	r6, #0
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 8002454:	3508      	adds	r5, #8
 8002456:	4545      	cmp	r5, r8
 8002458:	d21f      	bcs.n	800249a <CRYP_TDES_ECB+0xc0>
 800245a:	b1f6      	cbz	r6, 800249a <CRYP_TDES_ECB+0xc0>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800245c:	6820      	ldr	r0, [r4, #0]
 800245e:	f7fe fe23 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8002462:	6860      	ldr	r0, [r4, #4]
 8002464:	f7fe fe20 	bl	80010a8 <CRYP_DataIn>
    inputaddr+=4;
 8002468:	3408      	adds	r4, #8
    counter = 0;
 800246a:	2300      	movs	r3, #0
 800246c:	9301      	str	r3, [sp, #4]
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 800246e:	2010      	movs	r0, #16
 8002470:	f7fe ff1c 	bl	80012ac <CRYP_GetFlagStatus>
 8002474:	4602      	mov	r2, r0
      counter++;
 8002476:	9b01      	ldr	r3, [sp, #4]
 8002478:	3301      	adds	r3, #1
 800247a:	9301      	str	r3, [sp, #4]
    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));
 800247c:	9b01      	ldr	r3, [sp, #4]
 800247e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002482:	d0e5      	beq.n	8002450 <CRYP_TDES_ECB+0x76>
 8002484:	2800      	cmp	r0, #0
 8002486:	d1f2      	bne.n	800246e <CRYP_TDES_ECB+0x94>
 8002488:	e7e2      	b.n	8002450 <CRYP_TDES_ECB+0x76>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800248a:	f7fe fe13 	bl	80010b4 <CRYP_DataOut>
 800248e:	6038      	str	r0, [r7, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8002490:	f7fe fe10 	bl	80010b4 <CRYP_DataOut>
 8002494:	6078      	str	r0, [r7, #4]
      outputaddr+=4;
 8002496:	3708      	adds	r7, #8
 8002498:	e7dc      	b.n	8002454 <CRYP_TDES_ECB+0x7a>
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 800249a:	2000      	movs	r0, #0
 800249c:	f7fe fdf4 	bl	8001088 <CRYP_Cmd>

  return status; 
}
 80024a0:	4630      	mov	r0, r6
 80024a2:	b00e      	add	sp, #56	; 0x38
 80024a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return(ERROR);
 80024a8:	2600      	movs	r6, #0
 80024aa:	e7f9      	b.n	80024a0 <CRYP_TDES_ECB+0xc6>

080024ac <CRYP_TDES_CBC>:
  *          - SUCCESS: Operation done
  *          - ERROR: Operation failed
  */
ErrorStatus CRYP_TDES_CBC(uint8_t Mode, uint8_t Key[24], uint8_t InitVectors[8],
                          uint8_t *Input, uint32_t Ilength, uint8_t *Output)
{
 80024ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80024b0:	b093      	sub	sp, #76	; 0x4c
 80024b2:	4681      	mov	r9, r0
 80024b4:	460d      	mov	r5, r1
 80024b6:	4616      	mov	r6, r2
 80024b8:	f8dd 8068 	ldr.w	r8, [sp, #104]	; 0x68
  CRYP_InitTypeDef TDES_CRYP_InitStructure;
  CRYP_KeyInitTypeDef TDES_CRYP_KeyInitStructure;
  CRYP_IVInitTypeDef TDES_CRYP_IVInitStructure;
  __IO uint32_t counter = 0;
 80024bc:	2200      	movs	r2, #0
 80024be:	9201      	str	r2, [sp, #4]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
  uint32_t inputaddr  = (uint32_t)Input;
 80024c0:	461c      	mov	r4, r3
  uint32_t outputaddr = (uint32_t)Output;
 80024c2:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
  uint32_t ivaddr     = (uint32_t)InitVectors;
  uint32_t i = 0;

  /* Crypto structures initialisation*/
  CRYP_KeyStructInit(&TDES_CRYP_KeyInitStructure);
 80024c4:	a806      	add	r0, sp, #24
 80024c6:	f7fe fdb1 	bl	800102c <CRYP_KeyStructInit>

  /* Crypto Init for Encryption process */
  if(Mode == MODE_ENCRYPT) /* TDES encryption */
 80024ca:	f1b9 0f01 	cmp.w	r9, #1
 80024ce:	d031      	beq.n	8002534 <CRYP_TDES_CBC+0x88>
  {
    TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
  }
  else
  {
    TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Decrypt;
 80024d0:	2304      	movs	r3, #4
 80024d2:	930e      	str	r3, [sp, #56]	; 0x38
  }
  TDES_CRYP_InitStructure.CRYP_AlgoMode = CRYP_AlgoMode_TDES_CBC;
 80024d4:	2308      	movs	r3, #8
 80024d6:	930f      	str	r3, [sp, #60]	; 0x3c
  TDES_CRYP_InitStructure.CRYP_DataType = CRYP_DataType_8b;
 80024d8:	2380      	movs	r3, #128	; 0x80
 80024da:	9310      	str	r3, [sp, #64]	; 0x40

  CRYP_Init(&TDES_CRYP_InitStructure);
 80024dc:	a80e      	add	r0, sp, #56	; 0x38
 80024de:	f7fe fd5b 	bl	8000f98 <CRYP_Init>

  /* Key Initialisation */
  TDES_CRYP_KeyInitStructure.CRYP_Key1Left = __REV(*(uint32_t*)(keyaddr));
 80024e2:	682b      	ldr	r3, [r5, #0]
 80024e4:	ba1b      	rev	r3, r3
 80024e6:	9308      	str	r3, [sp, #32]
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key1Right= __REV(*(uint32_t*)(keyaddr));
 80024e8:	686b      	ldr	r3, [r5, #4]
 80024ea:	ba1b      	rev	r3, r3
 80024ec:	9309      	str	r3, [sp, #36]	; 0x24
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key2Left = __REV(*(uint32_t*)(keyaddr));
 80024ee:	68ab      	ldr	r3, [r5, #8]
 80024f0:	ba1b      	rev	r3, r3
 80024f2:	930a      	str	r3, [sp, #40]	; 0x28
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key2Right= __REV(*(uint32_t*)(keyaddr));
 80024f4:	68eb      	ldr	r3, [r5, #12]
 80024f6:	ba1b      	rev	r3, r3
 80024f8:	930b      	str	r3, [sp, #44]	; 0x2c
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Left = __REV(*(uint32_t*)(keyaddr));
 80024fa:	692b      	ldr	r3, [r5, #16]
 80024fc:	ba1b      	rev	r3, r3
 80024fe:	930c      	str	r3, [sp, #48]	; 0x30
  keyaddr+=4;
  TDES_CRYP_KeyInitStructure.CRYP_Key3Right= __REV(*(uint32_t*)(keyaddr));
 8002500:	696b      	ldr	r3, [r5, #20]
 8002502:	ba1b      	rev	r3, r3
 8002504:	930d      	str	r3, [sp, #52]	; 0x34
  CRYP_KeyInit(& TDES_CRYP_KeyInitStructure);
 8002506:	a806      	add	r0, sp, #24
 8002508:	f7fe fd7c 	bl	8001004 <CRYP_KeyInit>

  /* Initialization Vectors */
  TDES_CRYP_IVInitStructure.CRYP_IV0Left = __REV(*(uint32_t*)(ivaddr));
 800250c:	6833      	ldr	r3, [r6, #0]
 800250e:	ba1b      	rev	r3, r3
 8002510:	9302      	str	r3, [sp, #8]
  ivaddr+=4;
  TDES_CRYP_IVInitStructure.CRYP_IV0Right= __REV(*(uint32_t*)(ivaddr));
 8002512:	6873      	ldr	r3, [r6, #4]
 8002514:	ba1b      	rev	r3, r3
 8002516:	9303      	str	r3, [sp, #12]
  CRYP_IVInit(&TDES_CRYP_IVInitStructure);
 8002518:	a802      	add	r0, sp, #8
 800251a:	f7fe fd91 	bl	8001040 <CRYP_IVInit>

  /* Flush IN/OUT FIFO */
  CRYP_FIFOFlush();
 800251e:	f7fe fdab 	bl	8001078 <CRYP_FIFOFlush>

  /* Enable Crypto processor */
  CRYP_Cmd(ENABLE);
 8002522:	2001      	movs	r0, #1
 8002524:	f7fe fdb0 	bl	8001088 <CRYP_Cmd>

  if(CRYP_GetCmdStatus() == DISABLE)
 8002528:	f7fe feb4 	bl	8001294 <CRYP_GetCmdStatus>
 800252c:	b388      	cbz	r0, 8002592 <CRYP_TDES_CBC+0xe6>
 800252e:	2500      	movs	r5, #0
 8002530:	2601      	movs	r6, #1
 8002532:	e005      	b.n	8002540 <CRYP_TDES_CBC+0x94>
    TDES_CRYP_InitStructure.CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
 8002534:	2300      	movs	r3, #0
 8002536:	930e      	str	r3, [sp, #56]	; 0x38
 8002538:	e7cc      	b.n	80024d4 <CRYP_TDES_CBC+0x28>
    {
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
      counter++;
    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));

    if (busystatus != RESET)
 800253a:	b1da      	cbz	r2, 8002574 <CRYP_TDES_CBC+0xc8>
   {
       status = ERROR;
 800253c:	2600      	movs	r6, #0
  for(i=0; ((i<Ilength) && (status != ERROR)); i+=8)
 800253e:	3508      	adds	r5, #8
 8002540:	4545      	cmp	r5, r8
 8002542:	d21f      	bcs.n	8002584 <CRYP_TDES_CBC+0xd8>
 8002544:	b1f6      	cbz	r6, 8002584 <CRYP_TDES_CBC+0xd8>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 8002546:	6820      	ldr	r0, [r4, #0]
 8002548:	f7fe fdae 	bl	80010a8 <CRYP_DataIn>
    CRYP_DataIn(*(uint32_t*)(inputaddr));
 800254c:	6860      	ldr	r0, [r4, #4]
 800254e:	f7fe fdab 	bl	80010a8 <CRYP_DataIn>
    inputaddr+=4;
 8002552:	3408      	adds	r4, #8
    counter = 0;
 8002554:	2300      	movs	r3, #0
 8002556:	9301      	str	r3, [sp, #4]
      busystatus = CRYP_GetFlagStatus(CRYP_FLAG_BUSY);
 8002558:	2010      	movs	r0, #16
 800255a:	f7fe fea7 	bl	80012ac <CRYP_GetFlagStatus>
 800255e:	4602      	mov	r2, r0
      counter++;
 8002560:	9b01      	ldr	r3, [sp, #4]
 8002562:	3301      	adds	r3, #1
 8002564:	9301      	str	r3, [sp, #4]
    }while ((counter != TDESBUSY_TIMEOUT) && (busystatus != RESET));
 8002566:	9b01      	ldr	r3, [sp, #4]
 8002568:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800256c:	d0e5      	beq.n	800253a <CRYP_TDES_CBC+0x8e>
 800256e:	2800      	cmp	r0, #0
 8002570:	d1f2      	bne.n	8002558 <CRYP_TDES_CBC+0xac>
 8002572:	e7e2      	b.n	800253a <CRYP_TDES_CBC+0x8e>
    }
    else
    {

      /* Read the Output block from the Output FIFO */
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 8002574:	f7fe fd9e 	bl	80010b4 <CRYP_DataOut>
 8002578:	6038      	str	r0, [r7, #0]
      outputaddr+=4;
      *(uint32_t*)(outputaddr) = CRYP_DataOut();
 800257a:	f7fe fd9b 	bl	80010b4 <CRYP_DataOut>
 800257e:	6078      	str	r0, [r7, #4]
      outputaddr+=4;
 8002580:	3708      	adds	r7, #8
 8002582:	e7dc      	b.n	800253e <CRYP_TDES_CBC+0x92>
    }
  }

  /* Disable Crypto */
  CRYP_Cmd(DISABLE);
 8002584:	2000      	movs	r0, #0
 8002586:	f7fe fd7f 	bl	8001088 <CRYP_Cmd>

  return status; 
}
 800258a:	4630      	mov	r0, r6
 800258c:	b013      	add	sp, #76	; 0x4c
 800258e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return(ERROR);
 8002592:	2600      	movs	r6, #0
 8002594:	e7f9      	b.n	800258a <CRYP_TDES_CBC+0xde>
	...

08002598 <DAC_DeInit>:
  * @brief  Deinitializes the DAC peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void DAC_DeInit(void)
{
 8002598:	b508      	push	{r3, lr}
  /* Enable DAC reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
 800259a:	2101      	movs	r1, #1
 800259c:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 80025a0:	f002 fa02 	bl	80049a8 <RCC_APB1PeriphResetCmd>
  /* Release DAC from reset state */
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
 80025a4:	2100      	movs	r1, #0
 80025a6:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 80025aa:	f002 f9fd 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 80025ae:	bd08      	pop	{r3, pc}

080025b0 <DAC_Init>:
  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that contains
  *         the configuration information for the  specified DAC channel.
  * @retval None
  */
void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
{
 80025b0:	b430      	push	{r4, r5}
  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));

/*---------------------------- DAC CR Configuration --------------------------*/
  /* Get the DAC CR value */
  tmpreg1 = DAC->CR;
 80025b2:	4c0a      	ldr	r4, [pc, #40]	; (80025dc <DAC_Init+0x2c>)
 80025b4:	6822      	ldr	r2, [r4, #0]
  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
  tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
 80025b6:	f640 73fe 	movw	r3, #4094	; 0xffe
 80025ba:	4083      	lsls	r3, r0
 80025bc:	ea22 0203 	bic.w	r2, r2, r3
     wave generation, mask/amplitude for wave generation */
  /* Set TSELx and TENx bits according to DAC_Trigger value */
  /* Set WAVEx bits according to DAC_WaveGeneration value */
  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
  /* Set BOFFx bit according to DAC_OutputBuffer value */   
  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
 80025c0:	680b      	ldr	r3, [r1, #0]
 80025c2:	684d      	ldr	r5, [r1, #4]
 80025c4:	432b      	orrs	r3, r5
             DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | \
 80025c6:	688d      	ldr	r5, [r1, #8]
  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
 80025c8:	432b      	orrs	r3, r5
             DAC_InitStruct->DAC_OutputBuffer);
 80025ca:	68c9      	ldr	r1, [r1, #12]
  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
 80025cc:	430b      	orrs	r3, r1
  /* Calculate CR register value depending on DAC_Channel */
  tmpreg1 |= tmpreg2 << DAC_Channel;
 80025ce:	fa03 f000 	lsl.w	r0, r3, r0
 80025d2:	4310      	orrs	r0, r2
  /* Write to DAC CR */
  DAC->CR = tmpreg1;
 80025d4:	6020      	str	r0, [r4, #0]
}
 80025d6:	bc30      	pop	{r4, r5}
 80025d8:	4770      	bx	lr
 80025da:	bf00      	nop
 80025dc:	40007400 	.word	0x40007400

080025e0 <DAC_StructInit>:
  */
void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
{
/*--------------- Reset DAC init structure parameters values -----------------*/
  /* Initialize the DAC_Trigger member */
  DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
 80025e0:	2300      	movs	r3, #0
 80025e2:	6003      	str	r3, [r0, #0]
  /* Initialize the DAC_WaveGeneration member */
  DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
 80025e4:	6043      	str	r3, [r0, #4]
  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
  DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
 80025e6:	6083      	str	r3, [r0, #8]
  /* Initialize the DAC_OutputBuffer member */
  DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
 80025e8:	60c3      	str	r3, [r0, #12]
 80025ea:	4770      	bx	lr

080025ec <DAC_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80025ec:	b941      	cbnz	r1, 8002600 <DAC_Cmd+0x14>
    DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
  }
  else
  {
    /* Disable the selected DAC channel */
    DAC->CR &= (~(DAC_CR_EN1 << DAC_Channel));
 80025ee:	4908      	ldr	r1, [pc, #32]	; (8002610 <DAC_Cmd+0x24>)
 80025f0:	680b      	ldr	r3, [r1, #0]
 80025f2:	2201      	movs	r2, #1
 80025f4:	fa02 f000 	lsl.w	r0, r2, r0
 80025f8:	ea23 0000 	bic.w	r0, r3, r0
 80025fc:	6008      	str	r0, [r1, #0]
 80025fe:	4770      	bx	lr
    DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
 8002600:	4903      	ldr	r1, [pc, #12]	; (8002610 <DAC_Cmd+0x24>)
 8002602:	680b      	ldr	r3, [r1, #0]
 8002604:	2201      	movs	r2, #1
 8002606:	fa02 f000 	lsl.w	r0, r2, r0
 800260a:	4318      	orrs	r0, r3
 800260c:	6008      	str	r0, [r1, #0]
 800260e:	4770      	bx	lr
 8002610:	40007400 	.word	0x40007400

08002614 <DAC_SoftwareTriggerCmd>:
{
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002614:	b949      	cbnz	r1, 800262a <DAC_SoftwareTriggerCmd+0x16>
    DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
  }
  else
  {
    /* Disable software trigger for the selected DAC channel */
    DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
 8002616:	4909      	ldr	r1, [pc, #36]	; (800263c <DAC_SoftwareTriggerCmd+0x28>)
 8002618:	684b      	ldr	r3, [r1, #4]
 800261a:	0900      	lsrs	r0, r0, #4
 800261c:	2201      	movs	r2, #1
 800261e:	fa02 f000 	lsl.w	r0, r2, r0
 8002622:	ea23 0000 	bic.w	r0, r3, r0
 8002626:	6048      	str	r0, [r1, #4]
 8002628:	4770      	bx	lr
    DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
 800262a:	4904      	ldr	r1, [pc, #16]	; (800263c <DAC_SoftwareTriggerCmd+0x28>)
 800262c:	684b      	ldr	r3, [r1, #4]
 800262e:	0900      	lsrs	r0, r0, #4
 8002630:	2201      	movs	r2, #1
 8002632:	fa02 f000 	lsl.w	r0, r2, r0
 8002636:	4318      	orrs	r0, r3
 8002638:	6048      	str	r0, [r1, #4]
 800263a:	4770      	bx	lr
 800263c:	40007400 	.word	0x40007400

08002640 <DAC_DualSoftwareTriggerCmd>:
void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002640:	b928      	cbnz	r0, 800264e <DAC_DualSoftwareTriggerCmd+0xe>
    DAC->SWTRIGR |= DUAL_SWTRIG_SET;
  }
  else
  {
    /* Disable software trigger for both DAC channels */
    DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
 8002642:	4a06      	ldr	r2, [pc, #24]	; (800265c <DAC_DualSoftwareTriggerCmd+0x1c>)
 8002644:	6853      	ldr	r3, [r2, #4]
 8002646:	f023 0303 	bic.w	r3, r3, #3
 800264a:	6053      	str	r3, [r2, #4]
 800264c:	4770      	bx	lr
    DAC->SWTRIGR |= DUAL_SWTRIG_SET;
 800264e:	4a03      	ldr	r2, [pc, #12]	; (800265c <DAC_DualSoftwareTriggerCmd+0x1c>)
 8002650:	6853      	ldr	r3, [r2, #4]
 8002652:	f043 0303 	orr.w	r3, r3, #3
 8002656:	6053      	str	r3, [r2, #4]
 8002658:	4770      	bx	lr
 800265a:	bf00      	nop
 800265c:	40007400 	.word	0x40007400

08002660 <DAC_WaveGenerationCmd>:
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_WAVE(DAC_Wave)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002660:	b932      	cbnz	r2, 8002670 <DAC_WaveGenerationCmd+0x10>
    DAC->CR |= DAC_Wave << DAC_Channel;
  }
  else
  {
    /* Disable the selected wave generation for the selected DAC channel */
    DAC->CR &= ~(DAC_Wave << DAC_Channel);
 8002662:	4a06      	ldr	r2, [pc, #24]	; (800267c <DAC_WaveGenerationCmd+0x1c>)
 8002664:	6813      	ldr	r3, [r2, #0]
 8002666:	4081      	lsls	r1, r0
 8002668:	ea23 0101 	bic.w	r1, r3, r1
 800266c:	6011      	str	r1, [r2, #0]
 800266e:	4770      	bx	lr
    DAC->CR |= DAC_Wave << DAC_Channel;
 8002670:	4a02      	ldr	r2, [pc, #8]	; (800267c <DAC_WaveGenerationCmd+0x1c>)
 8002672:	6813      	ldr	r3, [r2, #0]
 8002674:	4081      	lsls	r1, r0
 8002676:	4319      	orrs	r1, r3
 8002678:	6011      	str	r1, [r2, #0]
 800267a:	4770      	bx	lr
 800267c:	40007400 	.word	0x40007400

08002680 <DAC_SetChannel1Data>:
  *            @arg DAC_Align_12b_R: 12bit right data alignment selected
  * @param  Data: Data to be loaded in the selected data holding register.
  * @retval None
  */
void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
{  
 8002680:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8002682:	2300      	movs	r3, #0
 8002684:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data));
  
  tmp = (uint32_t)DAC_BASE; 
 8002686:	4b05      	ldr	r3, [pc, #20]	; (800269c <DAC_SetChannel1Data+0x1c>)
 8002688:	9301      	str	r3, [sp, #4]
  tmp += DHR12R1_OFFSET + DAC_Align;
 800268a:	9b01      	ldr	r3, [sp, #4]
 800268c:	4418      	add	r0, r3
 800268e:	3008      	adds	r0, #8
 8002690:	9001      	str	r0, [sp, #4]

  /* Set the DAC channel1 selected data holding register */
  *(__IO uint32_t *) tmp = Data;
 8002692:	9b01      	ldr	r3, [sp, #4]
 8002694:	6019      	str	r1, [r3, #0]
}
 8002696:	b002      	add	sp, #8
 8002698:	4770      	bx	lr
 800269a:	bf00      	nop
 800269c:	40007400 	.word	0x40007400

080026a0 <DAC_SetChannel2Data>:
  *            @arg DAC_Align_12b_R: 12bit right data alignment selected
  * @param  Data: Data to be loaded in the selected data holding register.
  * @retval None
  */
void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
{
 80026a0:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 80026a2:	2300      	movs	r3, #0
 80026a4:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data));
  
  tmp = (uint32_t)DAC_BASE;
 80026a6:	4b05      	ldr	r3, [pc, #20]	; (80026bc <DAC_SetChannel2Data+0x1c>)
 80026a8:	9301      	str	r3, [sp, #4]
  tmp += DHR12R2_OFFSET + DAC_Align;
 80026aa:	9b01      	ldr	r3, [sp, #4]
 80026ac:	4418      	add	r0, r3
 80026ae:	3014      	adds	r0, #20
 80026b0:	9001      	str	r0, [sp, #4]

  /* Set the DAC channel2 selected data holding register */
  *(__IO uint32_t *)tmp = Data;
 80026b2:	9b01      	ldr	r3, [sp, #4]
 80026b4:	6019      	str	r1, [r3, #0]
}
 80026b6:	b002      	add	sp, #8
 80026b8:	4770      	bx	lr
 80026ba:	bf00      	nop
 80026bc:	40007400 	.word	0x40007400

080026c0 <DAC_SetDualChannelData>:
  assert_param(IS_DAC_ALIGN(DAC_Align));
  assert_param(IS_DAC_DATA(Data1));
  assert_param(IS_DAC_DATA(Data2));
  
  /* Calculate and set dual DAC data holding register value */
  if (DAC_Align == DAC_Align_8b_R)
 80026c0:	2808      	cmp	r0, #8
 80026c2:	d004      	beq.n	80026ce <DAC_SetDualChannelData+0xe>
  {
    data = ((uint32_t)Data2 << 8) | Data1; 
  }
  else
  {
    data = ((uint32_t)Data2 << 16) | Data1;
 80026c4:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  }
  
  tmp = (uint32_t)DAC_BASE;
  tmp += DHR12RD_OFFSET + DAC_Align;
 80026c8:	4b02      	ldr	r3, [pc, #8]	; (80026d4 <DAC_SetDualChannelData+0x14>)

  /* Set the dual DAC selected data holding register */
  *(__IO uint32_t *)tmp = data;
 80026ca:	50c2      	str	r2, [r0, r3]
 80026cc:	4770      	bx	lr
    data = ((uint32_t)Data2 << 8) | Data1; 
 80026ce:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 80026d2:	e7f9      	b.n	80026c8 <DAC_SetDualChannelData+0x8>
 80026d4:	40007420 	.word	0x40007420

080026d8 <DAC_GetDataOutputValue>:
  *            @arg DAC_Channel_1: DAC Channel1 selected
  *            @arg DAC_Channel_2: DAC Channel2 selected
  * @retval The selected DAC channel data output value.
  */
uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
{
 80026d8:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 80026da:	2300      	movs	r3, #0
 80026dc:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  
  tmp = (uint32_t) DAC_BASE ;
 80026de:	4b06      	ldr	r3, [pc, #24]	; (80026f8 <DAC_GetDataOutputValue+0x20>)
 80026e0:	9301      	str	r3, [sp, #4]
  tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
 80026e2:	9b01      	ldr	r3, [sp, #4]
 80026e4:	eb03 0090 	add.w	r0, r3, r0, lsr #2
 80026e8:	302c      	adds	r0, #44	; 0x2c
 80026ea:	9001      	str	r0, [sp, #4]
  
  /* Returns the DAC channel data output register value */
  return (uint16_t) (*(__IO uint32_t*) tmp);
 80026ec:	9b01      	ldr	r3, [sp, #4]
 80026ee:	6818      	ldr	r0, [r3, #0]
}
 80026f0:	b280      	uxth	r0, r0
 80026f2:	b002      	add	sp, #8
 80026f4:	4770      	bx	lr
 80026f6:	bf00      	nop
 80026f8:	40007400 	.word	0x40007400

080026fc <DAC_DMACmd>:
{
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80026fc:	b949      	cbnz	r1, 8002712 <DAC_DMACmd+0x16>
    DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
  }
  else
  {
    /* Disable the selected DAC channel DMA request */
    DAC->CR &= (~(DAC_CR_DMAEN1 << DAC_Channel));
 80026fe:	4909      	ldr	r1, [pc, #36]	; (8002724 <DAC_DMACmd+0x28>)
 8002700:	680b      	ldr	r3, [r1, #0]
 8002702:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002706:	fa02 f000 	lsl.w	r0, r2, r0
 800270a:	ea23 0000 	bic.w	r0, r3, r0
 800270e:	6008      	str	r0, [r1, #0]
 8002710:	4770      	bx	lr
    DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
 8002712:	4904      	ldr	r1, [pc, #16]	; (8002724 <DAC_DMACmd+0x28>)
 8002714:	680b      	ldr	r3, [r1, #0]
 8002716:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800271a:	fa02 f000 	lsl.w	r0, r2, r0
 800271e:	4318      	orrs	r0, r3
 8002720:	6008      	str	r0, [r1, #0]
 8002722:	4770      	bx	lr
 8002724:	40007400 	.word	0x40007400

08002728 <DAC_ITConfig>:
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_DAC_IT(DAC_IT)); 

  if (NewState != DISABLE)
 8002728:	b932      	cbnz	r2, 8002738 <DAC_ITConfig+0x10>
    DAC->CR |=  (DAC_IT << DAC_Channel);
  }
  else
  {
    /* Disable the selected DAC interrupts */
    DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));
 800272a:	4a06      	ldr	r2, [pc, #24]	; (8002744 <DAC_ITConfig+0x1c>)
 800272c:	6813      	ldr	r3, [r2, #0]
 800272e:	4081      	lsls	r1, r0
 8002730:	ea23 0101 	bic.w	r1, r3, r1
 8002734:	6011      	str	r1, [r2, #0]
 8002736:	4770      	bx	lr
    DAC->CR |=  (DAC_IT << DAC_Channel);
 8002738:	4a02      	ldr	r2, [pc, #8]	; (8002744 <DAC_ITConfig+0x1c>)
 800273a:	6813      	ldr	r3, [r2, #0]
 800273c:	4081      	lsls	r1, r0
 800273e:	4319      	orrs	r1, r3
 8002740:	6011      	str	r1, [r2, #0]
 8002742:	4770      	bx	lr
 8002744:	40007400 	.word	0x40007400

08002748 <DAC_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_FLAG(DAC_FLAG));

  /* Check the status of the specified DAC flag */
  if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)
 8002748:	4b04      	ldr	r3, [pc, #16]	; (800275c <DAC_GetFlagStatus+0x14>)
 800274a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800274c:	4081      	lsls	r1, r0
 800274e:	420b      	tst	r3, r1
 8002750:	d101      	bne.n	8002756 <DAC_GetFlagStatus+0xe>
    bitstatus = SET;
  }
  else
  {
    /* DAC_FLAG is reset */
    bitstatus = RESET;
 8002752:	2000      	movs	r0, #0
  }
  /* Return the DAC_FLAG status */
  return  bitstatus;
}
 8002754:	4770      	bx	lr
    bitstatus = SET;
 8002756:	2001      	movs	r0, #1
 8002758:	4770      	bx	lr
 800275a:	bf00      	nop
 800275c:	40007400 	.word	0x40007400

08002760 <DAC_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_FLAG(DAC_FLAG));

  /* Clear the selected DAC flags */
  DAC->SR = (DAC_FLAG << DAC_Channel);
 8002760:	4081      	lsls	r1, r0
 8002762:	4b01      	ldr	r3, [pc, #4]	; (8002768 <DAC_ClearFlag+0x8>)
 8002764:	6359      	str	r1, [r3, #52]	; 0x34
 8002766:	4770      	bx	lr
 8002768:	40007400 	.word	0x40007400

0800276c <DAC_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_IT(DAC_IT));

  /* Get the DAC_IT enable bit status */
  enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;
 800276c:	4a06      	ldr	r2, [pc, #24]	; (8002788 <DAC_GetITStatus+0x1c>)
 800276e:	6813      	ldr	r3, [r2, #0]
 8002770:	4081      	lsls	r1, r0
 8002772:	400b      	ands	r3, r1
  
  /* Check the status of the specified DAC interrupt */
  if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)
 8002774:	6b52      	ldr	r2, [r2, #52]	; 0x34
 8002776:	4211      	tst	r1, r2
 8002778:	d002      	beq.n	8002780 <DAC_GetITStatus+0x14>
 800277a:	b91b      	cbnz	r3, 8002784 <DAC_GetITStatus+0x18>
    bitstatus = SET;
  }
  else
  {
    /* DAC_IT is reset */
    bitstatus = RESET;
 800277c:	2000      	movs	r0, #0
 800277e:	4770      	bx	lr
 8002780:	2000      	movs	r0, #0
 8002782:	4770      	bx	lr
    bitstatus = SET;
 8002784:	2001      	movs	r0, #1
  }
  /* Return the DAC_IT status */
  return  bitstatus;
}
 8002786:	4770      	bx	lr
 8002788:	40007400 	.word	0x40007400

0800278c <DAC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_DAC_CHANNEL(DAC_Channel));
  assert_param(IS_DAC_IT(DAC_IT)); 

  /* Clear the selected DAC interrupt pending bits */
  DAC->SR = (DAC_IT << DAC_Channel);
 800278c:	4081      	lsls	r1, r0
 800278e:	4b01      	ldr	r3, [pc, #4]	; (8002794 <DAC_ClearITPendingBit+0x8>)
 8002790:	6359      	str	r1, [r3, #52]	; 0x34
 8002792:	4770      	bx	lr
 8002794:	40007400 	.word	0x40007400

08002798 <DBGMCU_GetREVID>:
  * @param  None
  * @retval Device revision identifier
  */
uint32_t DBGMCU_GetREVID(void)
{
   return(DBGMCU->IDCODE >> 16);
 8002798:	4b01      	ldr	r3, [pc, #4]	; (80027a0 <DBGMCU_GetREVID+0x8>)
 800279a:	6818      	ldr	r0, [r3, #0]
}
 800279c:	0c00      	lsrs	r0, r0, #16
 800279e:	4770      	bx	lr
 80027a0:	e0042000 	.word	0xe0042000

080027a4 <DBGMCU_GetDEVID>:
  * @param  None
  * @retval Device identifier
  */
uint32_t DBGMCU_GetDEVID(void)
{
   return(DBGMCU->IDCODE & IDCODE_DEVID_MASK);
 80027a4:	4b02      	ldr	r3, [pc, #8]	; (80027b0 <DBGMCU_GetDEVID+0xc>)
 80027a6:	6818      	ldr	r0, [r3, #0]
}
 80027a8:	f3c0 000b 	ubfx	r0, r0, #0, #12
 80027ac:	4770      	bx	lr
 80027ae:	bf00      	nop
 80027b0:	e0042000 	.word	0xe0042000

080027b4 <DBGMCU_Config>:
void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80027b4:	b929      	cbnz	r1, 80027c2 <DBGMCU_Config+0xe>
  {
    DBGMCU->CR |= DBGMCU_Periph;
  }
  else
  {
    DBGMCU->CR &= ~DBGMCU_Periph;
 80027b6:	4a05      	ldr	r2, [pc, #20]	; (80027cc <DBGMCU_Config+0x18>)
 80027b8:	6853      	ldr	r3, [r2, #4]
 80027ba:	ea23 0000 	bic.w	r0, r3, r0
 80027be:	6050      	str	r0, [r2, #4]
 80027c0:	4770      	bx	lr
    DBGMCU->CR |= DBGMCU_Periph;
 80027c2:	4a02      	ldr	r2, [pc, #8]	; (80027cc <DBGMCU_Config+0x18>)
 80027c4:	6853      	ldr	r3, [r2, #4]
 80027c6:	4318      	orrs	r0, r3
 80027c8:	6050      	str	r0, [r2, #4]
 80027ca:	4770      	bx	lr
 80027cc:	e0042000 	.word	0xe0042000

080027d0 <DBGMCU_APB1PeriphConfig>:
{
  /* Check the parameters */
  assert_param(IS_DBGMCU_APB1PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80027d0:	b929      	cbnz	r1, 80027de <DBGMCU_APB1PeriphConfig+0xe>
  {
    DBGMCU->APB1FZ |= DBGMCU_Periph;
  }
  else
  {
    DBGMCU->APB1FZ &= ~DBGMCU_Periph;
 80027d2:	4a05      	ldr	r2, [pc, #20]	; (80027e8 <DBGMCU_APB1PeriphConfig+0x18>)
 80027d4:	6893      	ldr	r3, [r2, #8]
 80027d6:	ea23 0000 	bic.w	r0, r3, r0
 80027da:	6090      	str	r0, [r2, #8]
 80027dc:	4770      	bx	lr
    DBGMCU->APB1FZ |= DBGMCU_Periph;
 80027de:	4a02      	ldr	r2, [pc, #8]	; (80027e8 <DBGMCU_APB1PeriphConfig+0x18>)
 80027e0:	6893      	ldr	r3, [r2, #8]
 80027e2:	4318      	orrs	r0, r3
 80027e4:	6090      	str	r0, [r2, #8]
 80027e6:	4770      	bx	lr
 80027e8:	e0042000 	.word	0xe0042000

080027ec <DBGMCU_APB2PeriphConfig>:
{
  /* Check the parameters */
  assert_param(IS_DBGMCU_APB2PERIPH(DBGMCU_Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80027ec:	b929      	cbnz	r1, 80027fa <DBGMCU_APB2PeriphConfig+0xe>
  {
    DBGMCU->APB2FZ |= DBGMCU_Periph;
  }
  else
  {
    DBGMCU->APB2FZ &= ~DBGMCU_Periph;
 80027ee:	4a05      	ldr	r2, [pc, #20]	; (8002804 <DBGMCU_APB2PeriphConfig+0x18>)
 80027f0:	68d3      	ldr	r3, [r2, #12]
 80027f2:	ea23 0000 	bic.w	r0, r3, r0
 80027f6:	60d0      	str	r0, [r2, #12]
 80027f8:	4770      	bx	lr
    DBGMCU->APB2FZ |= DBGMCU_Periph;
 80027fa:	4a02      	ldr	r2, [pc, #8]	; (8002804 <DBGMCU_APB2PeriphConfig+0x18>)
 80027fc:	68d3      	ldr	r3, [r2, #12]
 80027fe:	4318      	orrs	r0, r3
 8002800:	60d0      	str	r0, [r2, #12]
 8002802:	4770      	bx	lr
 8002804:	e0042000 	.word	0xe0042000

08002808 <DCMI_DeInit>:
  * @param  None
  * @retval None
  */
void DCMI_DeInit(void)
{
  DCMI->CR = 0x0;
 8002808:	4b05      	ldr	r3, [pc, #20]	; (8002820 <DCMI_DeInit+0x18>)
 800280a:	2200      	movs	r2, #0
 800280c:	601a      	str	r2, [r3, #0]
  DCMI->IER = 0x0;
 800280e:	60da      	str	r2, [r3, #12]
  DCMI->ICR = 0x1F;
 8002810:	211f      	movs	r1, #31
 8002812:	6159      	str	r1, [r3, #20]
  DCMI->ESCR = 0x0;
 8002814:	619a      	str	r2, [r3, #24]
  DCMI->ESUR = 0x0;
 8002816:	61da      	str	r2, [r3, #28]
  DCMI->CWSTRTR = 0x0;
 8002818:	621a      	str	r2, [r3, #32]
  DCMI->CWSIZER = 0x0;
 800281a:	625a      	str	r2, [r3, #36]	; 0x24
 800281c:	4770      	bx	lr
 800281e:	bf00      	nop
 8002820:	50050000 	.word	0x50050000

08002824 <DCMI_Init>:
  * @param  DCMI_InitStruct: pointer to a DCMI_InitTypeDef structure that contains 
  *         the configuration information for the DCMI.
  * @retval None
  */
void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct)
{
 8002824:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_DCMI_CAPTURE_RATE(DCMI_InitStruct->DCMI_CaptureRate));
  assert_param(IS_DCMI_EXTENDED_DATA(DCMI_InitStruct->DCMI_ExtendedDataMode));

  /* The DCMI configuration registers should be programmed correctly before 
  enabling the CR_ENABLE Bit and the CR_CAPTURE Bit */
  DCMI->CR &= ~(DCMI_CR_ENABLE | DCMI_CR_CAPTURE);
 8002826:	4a0f      	ldr	r2, [pc, #60]	; (8002864 <DCMI_Init+0x40>)
 8002828:	6813      	ldr	r3, [r2, #0]
 800282a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 800282e:	f023 0301 	bic.w	r3, r3, #1
 8002832:	6013      	str	r3, [r2, #0]
   
  /* Reset the old DCMI configuration */
  temp = DCMI->CR;
 8002834:	6813      	ldr	r3, [r2, #0]
  
  temp &= ~((uint32_t)DCMI_CR_CM     | DCMI_CR_ESS   | DCMI_CR_PCKPOL |
 8002836:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 800283a:	f023 0302 	bic.w	r3, r3, #2
                      DCMI_CR_HSPOL  | DCMI_CR_VSPOL | DCMI_CR_FCRC_0 | 
                      DCMI_CR_FCRC_1 | DCMI_CR_EDM_0 | DCMI_CR_EDM_1); 
                  
  /* Sets the new configuration of the DCMI peripheral */
  temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
 800283e:	f8b0 e000 	ldrh.w	lr, [r0]
                     DCMI_InitStruct->DCMI_SynchroMode |
 8002842:	f8b0 c002 	ldrh.w	ip, [r0, #2]
                     DCMI_InitStruct->DCMI_PCKPolarity |
 8002846:	8887      	ldrh	r7, [r0, #4]
                     DCMI_InitStruct->DCMI_VSPolarity |
 8002848:	88c6      	ldrh	r6, [r0, #6]
                     DCMI_InitStruct->DCMI_HSPolarity |
 800284a:	8905      	ldrh	r5, [r0, #8]
                     DCMI_InitStruct->DCMI_CaptureRate |
 800284c:	8944      	ldrh	r4, [r0, #10]
                     DCMI_InitStruct->DCMI_ExtendedDataMode);
 800284e:	8981      	ldrh	r1, [r0, #12]
                     DCMI_InitStruct->DCMI_CaptureRate |
 8002850:	ea4e 000c 	orr.w	r0, lr, ip
 8002854:	4338      	orrs	r0, r7
 8002856:	4330      	orrs	r0, r6
 8002858:	4328      	orrs	r0, r5
 800285a:	4320      	orrs	r0, r4
 800285c:	4301      	orrs	r1, r0
  temp |= ((uint32_t)DCMI_InitStruct->DCMI_CaptureMode |
 800285e:	430b      	orrs	r3, r1

  DCMI->CR = temp;                              
 8002860:	6013      	str	r3, [r2, #0]
 8002862:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002864:	50050000 	.word	0x50050000

08002868 <DCMI_StructInit>:
  * @retval None
  */
void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct)
{
  /* Set the default configuration */
  DCMI_InitStruct->DCMI_CaptureMode = DCMI_CaptureMode_Continuous;
 8002868:	2300      	movs	r3, #0
 800286a:	8003      	strh	r3, [r0, #0]
  DCMI_InitStruct->DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
 800286c:	8043      	strh	r3, [r0, #2]
  DCMI_InitStruct->DCMI_PCKPolarity = DCMI_PCKPolarity_Falling;
 800286e:	8083      	strh	r3, [r0, #4]
  DCMI_InitStruct->DCMI_VSPolarity = DCMI_VSPolarity_Low;
 8002870:	80c3      	strh	r3, [r0, #6]
  DCMI_InitStruct->DCMI_HSPolarity = DCMI_HSPolarity_Low;
 8002872:	8103      	strh	r3, [r0, #8]
  DCMI_InitStruct->DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;
 8002874:	8143      	strh	r3, [r0, #10]
  DCMI_InitStruct->DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;
 8002876:	8183      	strh	r3, [r0, #12]
 8002878:	4770      	bx	lr

0800287a <DCMI_CROPConfig>:
  * @retval None
  */
void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct)
{  
  /* Sets the CROP window coordinates */
  DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
 800287a:	8843      	ldrh	r3, [r0, #2]
                  ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalStartLine << 16));
 800287c:	8802      	ldrh	r2, [r0, #0]
  DCMI->CWSTRTR = (uint32_t)((uint32_t)DCMI_CROPInitStruct->DCMI_HorizontalOffsetCount |
 800287e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8002882:	4a04      	ldr	r2, [pc, #16]	; (8002894 <DCMI_CROPConfig+0x1a>)
 8002884:	6213      	str	r3, [r2, #32]

  /* Sets the CROP window size */
  DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
 8002886:	88c3      	ldrh	r3, [r0, #6]
                  ((uint32_t)DCMI_CROPInitStruct->DCMI_VerticalLineCount << 16));
 8002888:	8881      	ldrh	r1, [r0, #4]
  DCMI->CWSIZER = (uint32_t)(DCMI_CROPInitStruct->DCMI_CaptureCount |
 800288a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800288e:	6253      	str	r3, [r2, #36]	; 0x24
 8002890:	4770      	bx	lr
 8002892:	bf00      	nop
 8002894:	50050000 	.word	0x50050000

08002898 <DCMI_CROPCmd>:
void DCMI_CROPCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 8002898:	b928      	cbnz	r0, 80028a6 <DCMI_CROPCmd+0xe>
    DCMI->CR |= (uint32_t)DCMI_CR_CROP;
  }
  else
  {
    /* Disable the DCMI Crop feature */
    DCMI->CR &= ~(uint32_t)DCMI_CR_CROP;
 800289a:	4a06      	ldr	r2, [pc, #24]	; (80028b4 <DCMI_CROPCmd+0x1c>)
 800289c:	6813      	ldr	r3, [r2, #0]
 800289e:	f023 0304 	bic.w	r3, r3, #4
 80028a2:	6013      	str	r3, [r2, #0]
 80028a4:	4770      	bx	lr
    DCMI->CR |= (uint32_t)DCMI_CR_CROP;
 80028a6:	4a03      	ldr	r2, [pc, #12]	; (80028b4 <DCMI_CROPCmd+0x1c>)
 80028a8:	6813      	ldr	r3, [r2, #0]
 80028aa:	f043 0304 	orr.w	r3, r3, #4
 80028ae:	6013      	str	r3, [r2, #0]
 80028b0:	4770      	bx	lr
 80028b2:	bf00      	nop
 80028b4:	50050000 	.word	0x50050000

080028b8 <DCMI_SetEmbeddedSynchroCodes>:
  *         contains the embedded synchronization codes for the DCMI peripheral.
  * @retval None
  */
void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct)
{
  DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
 80028b8:	7803      	ldrb	r3, [r0, #0]
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
 80028ba:	7842      	ldrb	r2, [r0, #1]
  DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
 80028bc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineEndCode << 16)|
 80028c0:	7882      	ldrb	r2, [r0, #2]
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_LineStartCode << 8)|
 80028c2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
                          ((uint32_t)DCMI_CodesInitStruct->DCMI_FrameEndCode << 24));
 80028c6:	78c2      	ldrb	r2, [r0, #3]
  DCMI->ESCR = (uint32_t)(DCMI_CodesInitStruct->DCMI_FrameStartCode |
 80028c8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80028cc:	4a01      	ldr	r2, [pc, #4]	; (80028d4 <DCMI_SetEmbeddedSynchroCodes+0x1c>)
 80028ce:	6193      	str	r3, [r2, #24]
 80028d0:	4770      	bx	lr
 80028d2:	bf00      	nop
 80028d4:	50050000 	.word	0x50050000

080028d8 <DCMI_JPEGCmd>:
void DCMI_JPEGCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
 
  if (NewState != DISABLE)
 80028d8:	b928      	cbnz	r0, 80028e6 <DCMI_JPEGCmd+0xe>
    DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
  }
  else
  {
    /* Disable the DCMI JPEG format */
    DCMI->CR &= ~(uint32_t)DCMI_CR_JPEG;
 80028da:	4a06      	ldr	r2, [pc, #24]	; (80028f4 <DCMI_JPEGCmd+0x1c>)
 80028dc:	6813      	ldr	r3, [r2, #0]
 80028de:	f023 0308 	bic.w	r3, r3, #8
 80028e2:	6013      	str	r3, [r2, #0]
 80028e4:	4770      	bx	lr
    DCMI->CR |= (uint32_t)DCMI_CR_JPEG;
 80028e6:	4a03      	ldr	r2, [pc, #12]	; (80028f4 <DCMI_JPEGCmd+0x1c>)
 80028e8:	6813      	ldr	r3, [r2, #0]
 80028ea:	f043 0308 	orr.w	r3, r3, #8
 80028ee:	6013      	str	r3, [r2, #0]
 80028f0:	4770      	bx	lr
 80028f2:	bf00      	nop
 80028f4:	50050000 	.word	0x50050000

080028f8 <DCMI_Cmd>:
void DCMI_Cmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80028f8:	b928      	cbnz	r0, 8002906 <DCMI_Cmd+0xe>
    DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
  }
  else
  {
    /* Disable the DCMI by clearing ENABLE bit */
    DCMI->CR &= ~(uint32_t)DCMI_CR_ENABLE;
 80028fa:	4a06      	ldr	r2, [pc, #24]	; (8002914 <DCMI_Cmd+0x1c>)
 80028fc:	6813      	ldr	r3, [r2, #0]
 80028fe:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002902:	6013      	str	r3, [r2, #0]
 8002904:	4770      	bx	lr
    DCMI->CR |= (uint32_t)DCMI_CR_ENABLE;
 8002906:	4a03      	ldr	r2, [pc, #12]	; (8002914 <DCMI_Cmd+0x1c>)
 8002908:	6813      	ldr	r3, [r2, #0]
 800290a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800290e:	6013      	str	r3, [r2, #0]
 8002910:	4770      	bx	lr
 8002912:	bf00      	nop
 8002914:	50050000 	.word	0x50050000

08002918 <DCMI_CaptureCmd>:
void DCMI_CaptureCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 8002918:	b928      	cbnz	r0, 8002926 <DCMI_CaptureCmd+0xe>
    DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
  }
  else
  {
    /* Disable the DCMI Capture */
    DCMI->CR &= ~(uint32_t)DCMI_CR_CAPTURE;
 800291a:	4a06      	ldr	r2, [pc, #24]	; (8002934 <DCMI_CaptureCmd+0x1c>)
 800291c:	6813      	ldr	r3, [r2, #0]
 800291e:	f023 0301 	bic.w	r3, r3, #1
 8002922:	6013      	str	r3, [r2, #0]
 8002924:	4770      	bx	lr
    DCMI->CR |= (uint32_t)DCMI_CR_CAPTURE;
 8002926:	4a03      	ldr	r2, [pc, #12]	; (8002934 <DCMI_CaptureCmd+0x1c>)
 8002928:	6813      	ldr	r3, [r2, #0]
 800292a:	f043 0301 	orr.w	r3, r3, #1
 800292e:	6013      	str	r3, [r2, #0]
 8002930:	4770      	bx	lr
 8002932:	bf00      	nop
 8002934:	50050000 	.word	0x50050000

08002938 <DCMI_ReadData>:
  * @param  None 
  * @retval Data register value
  */
uint32_t DCMI_ReadData(void)
{
  return DCMI->DR;
 8002938:	4b01      	ldr	r3, [pc, #4]	; (8002940 <DCMI_ReadData+0x8>)
 800293a:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
 800293c:	4770      	bx	lr
 800293e:	bf00      	nop
 8002940:	50050000 	.word	0x50050000

08002944 <DCMI_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_DCMI_CONFIG_IT(DCMI_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8002944:	b931      	cbnz	r1, 8002954 <DCMI_ITConfig+0x10>
    DCMI->IER |= DCMI_IT;
  }
  else
  {
    /* Disable the Interrupt sources */
    DCMI->IER &= (uint16_t)(~DCMI_IT);
 8002946:	4a06      	ldr	r2, [pc, #24]	; (8002960 <DCMI_ITConfig+0x1c>)
 8002948:	68d3      	ldr	r3, [r2, #12]
 800294a:	43c0      	mvns	r0, r0
 800294c:	b280      	uxth	r0, r0
 800294e:	4018      	ands	r0, r3
 8002950:	60d0      	str	r0, [r2, #12]
 8002952:	4770      	bx	lr
    DCMI->IER |= DCMI_IT;
 8002954:	4b02      	ldr	r3, [pc, #8]	; (8002960 <DCMI_ITConfig+0x1c>)
 8002956:	68da      	ldr	r2, [r3, #12]
 8002958:	4310      	orrs	r0, r2
 800295a:	60d8      	str	r0, [r3, #12]
 800295c:	4770      	bx	lr
 800295e:	bf00      	nop
 8002960:	50050000 	.word	0x50050000

08002964 <DCMI_GetFlagStatus>:
  assert_param(IS_DCMI_GET_FLAG(DCMI_FLAG));
  
  /* Get the DCMI register index */
  dcmireg = (((uint16_t)DCMI_FLAG) >> 12);
  
  if (dcmireg == 0x00) /* The FLAG is in RISR register */
 8002964:	0b03      	lsrs	r3, r0, #12
 8002966:	d105      	bne.n	8002974 <DCMI_GetFlagStatus+0x10>
  {
    tempreg= DCMI->RISR;
 8002968:	4b07      	ldr	r3, [pc, #28]	; (8002988 <DCMI_GetFlagStatus+0x24>)
 800296a:	689b      	ldr	r3, [r3, #8]
  else /* The FLAG is in MISR register */
  {
    tempreg = DCMI->MISR;
  }
  
  if ((tempreg & DCMI_FLAG) != (uint16_t)RESET )
 800296c:	4218      	tst	r0, r3
 800296e:	d109      	bne.n	8002984 <DCMI_GetFlagStatus+0x20>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8002970:	2000      	movs	r0, #0
  }
  /* Return the DCMI_FLAG status */
  return  bitstatus;
}
 8002972:	4770      	bx	lr
  else if (dcmireg == 0x02) /* The FLAG is in SR register */
 8002974:	2b02      	cmp	r3, #2
 8002976:	d002      	beq.n	800297e <DCMI_GetFlagStatus+0x1a>
    tempreg = DCMI->MISR;
 8002978:	4b03      	ldr	r3, [pc, #12]	; (8002988 <DCMI_GetFlagStatus+0x24>)
 800297a:	691b      	ldr	r3, [r3, #16]
 800297c:	e7f6      	b.n	800296c <DCMI_GetFlagStatus+0x8>
    tempreg = DCMI->SR;
 800297e:	4b02      	ldr	r3, [pc, #8]	; (8002988 <DCMI_GetFlagStatus+0x24>)
 8002980:	685b      	ldr	r3, [r3, #4]
 8002982:	e7f3      	b.n	800296c <DCMI_GetFlagStatus+0x8>
    bitstatus = SET;
 8002984:	2001      	movs	r0, #1
 8002986:	4770      	bx	lr
 8002988:	50050000 	.word	0x50050000

0800298c <DCMI_ClearFlag>:
  assert_param(IS_DCMI_CLEAR_FLAG(DCMI_FLAG));
  
  /* Clear the flag by writing in the ICR register 1 in the corresponding 
  Flag position*/
  
  DCMI->ICR = DCMI_FLAG;
 800298c:	4b01      	ldr	r3, [pc, #4]	; (8002994 <DCMI_ClearFlag+0x8>)
 800298e:	6158      	str	r0, [r3, #20]
 8002990:	4770      	bx	lr
 8002992:	bf00      	nop
 8002994:	50050000 	.word	0x50050000

08002998 <DCMI_GetITStatus>:
  uint32_t itstatus = 0;
  
  /* Check the parameters */
  assert_param(IS_DCMI_GET_IT(DCMI_IT));
  
  itstatus = DCMI->MISR & DCMI_IT; /* Only masked interrupts are checked */
 8002998:	4b03      	ldr	r3, [pc, #12]	; (80029a8 <DCMI_GetITStatus+0x10>)
 800299a:	691b      	ldr	r3, [r3, #16]
  
  if ((itstatus != (uint16_t)RESET))
 800299c:	4203      	tst	r3, r0
 800299e:	d101      	bne.n	80029a4 <DCMI_GetITStatus+0xc>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 80029a0:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 80029a2:	4770      	bx	lr
    bitstatus = SET;
 80029a4:	2001      	movs	r0, #1
 80029a6:	4770      	bx	lr
 80029a8:	50050000 	.word	0x50050000

080029ac <DCMI_ClearITPendingBit>:
void DCMI_ClearITPendingBit(uint16_t DCMI_IT)
{
  /* Clear the interrupt pending Bit by writing in the ICR register 1 in the 
  corresponding pending Bit position*/
  
  DCMI->ICR = DCMI_IT;
 80029ac:	4b01      	ldr	r3, [pc, #4]	; (80029b4 <DCMI_ClearITPendingBit+0x8>)
 80029ae:	6158      	str	r0, [r3, #20]
 80029b0:	4770      	bx	lr
 80029b2:	bf00      	nop
 80029b4:	50050000 	.word	0x50050000

080029b8 <DMA_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Disable the selected DMAy Streamx */
  DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
 80029b8:	6803      	ldr	r3, [r0, #0]
 80029ba:	f023 0301 	bic.w	r3, r3, #1
 80029be:	6003      	str	r3, [r0, #0]

  /* Reset DMAy Streamx control register */
  DMAy_Streamx->CR  = 0;
 80029c0:	2300      	movs	r3, #0
 80029c2:	6003      	str	r3, [r0, #0]
  
  /* Reset DMAy Streamx Number of Data to Transfer register */
  DMAy_Streamx->NDTR = 0;
 80029c4:	6043      	str	r3, [r0, #4]
  
  /* Reset DMAy Streamx peripheral address register */
  DMAy_Streamx->PAR  = 0;
 80029c6:	6083      	str	r3, [r0, #8]
  
  /* Reset DMAy Streamx memory 0 address register */
  DMAy_Streamx->M0AR = 0;
 80029c8:	60c3      	str	r3, [r0, #12]

  /* Reset DMAy Streamx memory 1 address register */
  DMAy_Streamx->M1AR = 0;
 80029ca:	6103      	str	r3, [r0, #16]

  /* Reset DMAy Streamx FIFO control register */
  DMAy_Streamx->FCR = (uint32_t)0x00000021; 
 80029cc:	2321      	movs	r3, #33	; 0x21
 80029ce:	6143      	str	r3, [r0, #20]

  /* Reset interrupt pending bits for the selected stream */
  if (DMAy_Streamx == DMA1_Stream0)
 80029d0:	4b3c      	ldr	r3, [pc, #240]	; (8002ac4 <DMA_DeInit+0x10c>)
 80029d2:	4298      	cmp	r0, r3
 80029d4:	d02d      	beq.n	8002a32 <DMA_DeInit+0x7a>
  {
    /* Reset interrupt pending bits for DMA1 Stream0 */
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream1)
 80029d6:	4b3c      	ldr	r3, [pc, #240]	; (8002ac8 <DMA_DeInit+0x110>)
 80029d8:	4298      	cmp	r0, r3
 80029da:	d02e      	beq.n	8002a3a <DMA_DeInit+0x82>
  {
    /* Reset interrupt pending bits for DMA1 Stream1 */
    DMA1->LIFCR = DMA_Stream1_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream2)
 80029dc:	4b3b      	ldr	r3, [pc, #236]	; (8002acc <DMA_DeInit+0x114>)
 80029de:	4298      	cmp	r0, r3
 80029e0:	d030      	beq.n	8002a44 <DMA_DeInit+0x8c>
  {
    /* Reset interrupt pending bits for DMA1 Stream2 */
    DMA1->LIFCR = DMA_Stream2_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream3)
 80029e2:	4b3b      	ldr	r3, [pc, #236]	; (8002ad0 <DMA_DeInit+0x118>)
 80029e4:	4298      	cmp	r0, r3
 80029e6:	d032      	beq.n	8002a4e <DMA_DeInit+0x96>
  {
    /* Reset interrupt pending bits for DMA1 Stream3 */
    DMA1->LIFCR = DMA_Stream3_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream4)
 80029e8:	4b3a      	ldr	r3, [pc, #232]	; (8002ad4 <DMA_DeInit+0x11c>)
 80029ea:	4298      	cmp	r0, r3
 80029ec:	d034      	beq.n	8002a58 <DMA_DeInit+0xa0>
  {
    /* Reset interrupt pending bits for DMA1 Stream4 */
    DMA1->HIFCR = DMA_Stream4_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream5)
 80029ee:	4b3a      	ldr	r3, [pc, #232]	; (8002ad8 <DMA_DeInit+0x120>)
 80029f0:	4298      	cmp	r0, r3
 80029f2:	d035      	beq.n	8002a60 <DMA_DeInit+0xa8>
  {
    /* Reset interrupt pending bits for DMA1 Stream5 */
    DMA1->HIFCR = DMA_Stream5_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream6)
 80029f4:	4b39      	ldr	r3, [pc, #228]	; (8002adc <DMA_DeInit+0x124>)
 80029f6:	4298      	cmp	r0, r3
 80029f8:	d036      	beq.n	8002a68 <DMA_DeInit+0xb0>
  {
    /* Reset interrupt pending bits for DMA1 Stream6 */
    DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
  }
  else if (DMAy_Streamx == DMA1_Stream7)
 80029fa:	4b39      	ldr	r3, [pc, #228]	; (8002ae0 <DMA_DeInit+0x128>)
 80029fc:	4298      	cmp	r0, r3
 80029fe:	d037      	beq.n	8002a70 <DMA_DeInit+0xb8>
  {
    /* Reset interrupt pending bits for DMA1 Stream7 */
    DMA1->HIFCR = DMA_Stream7_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream0)
 8002a00:	4b38      	ldr	r3, [pc, #224]	; (8002ae4 <DMA_DeInit+0x12c>)
 8002a02:	4298      	cmp	r0, r3
 8002a04:	d039      	beq.n	8002a7a <DMA_DeInit+0xc2>
  {
    /* Reset interrupt pending bits for DMA2 Stream0 */
    DMA2->LIFCR = DMA_Stream0_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream1)
 8002a06:	4b38      	ldr	r3, [pc, #224]	; (8002ae8 <DMA_DeInit+0x130>)
 8002a08:	4298      	cmp	r0, r3
 8002a0a:	d03a      	beq.n	8002a82 <DMA_DeInit+0xca>
  {
    /* Reset interrupt pending bits for DMA2 Stream1 */
    DMA2->LIFCR = DMA_Stream1_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream2)
 8002a0c:	4b37      	ldr	r3, [pc, #220]	; (8002aec <DMA_DeInit+0x134>)
 8002a0e:	4298      	cmp	r0, r3
 8002a10:	d03c      	beq.n	8002a8c <DMA_DeInit+0xd4>
  {
    /* Reset interrupt pending bits for DMA2 Stream2 */
    DMA2->LIFCR = DMA_Stream2_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream3)
 8002a12:	4b37      	ldr	r3, [pc, #220]	; (8002af0 <DMA_DeInit+0x138>)
 8002a14:	4298      	cmp	r0, r3
 8002a16:	d03e      	beq.n	8002a96 <DMA_DeInit+0xde>
  {
    /* Reset interrupt pending bits for DMA2 Stream3 */
    DMA2->LIFCR = DMA_Stream3_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream4)
 8002a18:	4b36      	ldr	r3, [pc, #216]	; (8002af4 <DMA_DeInit+0x13c>)
 8002a1a:	4298      	cmp	r0, r3
 8002a1c:	d040      	beq.n	8002aa0 <DMA_DeInit+0xe8>
  {
    /* Reset interrupt pending bits for DMA2 Stream4 */
    DMA2->HIFCR = DMA_Stream4_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream5)
 8002a1e:	4b36      	ldr	r3, [pc, #216]	; (8002af8 <DMA_DeInit+0x140>)
 8002a20:	4298      	cmp	r0, r3
 8002a22:	d041      	beq.n	8002aa8 <DMA_DeInit+0xf0>
  {
    /* Reset interrupt pending bits for DMA2 Stream5 */
    DMA2->HIFCR = DMA_Stream5_IT_MASK;
  }
  else if (DMAy_Streamx == DMA2_Stream6)
 8002a24:	4b35      	ldr	r3, [pc, #212]	; (8002afc <DMA_DeInit+0x144>)
 8002a26:	4298      	cmp	r0, r3
 8002a28:	d042      	beq.n	8002ab0 <DMA_DeInit+0xf8>
    /* Reset interrupt pending bits for DMA2 Stream6 */
    DMA2->HIFCR = DMA_Stream6_IT_MASK;
  }
  else 
  {
    if (DMAy_Streamx == DMA2_Stream7)
 8002a2a:	4b35      	ldr	r3, [pc, #212]	; (8002b00 <DMA_DeInit+0x148>)
 8002a2c:	4298      	cmp	r0, r3
 8002a2e:	d043      	beq.n	8002ab8 <DMA_DeInit+0x100>
 8002a30:	4770      	bx	lr
    DMA1->LIFCR = DMA_Stream0_IT_MASK;
 8002a32:	223d      	movs	r2, #61	; 0x3d
 8002a34:	3b10      	subs	r3, #16
 8002a36:	609a      	str	r2, [r3, #8]
 8002a38:	4770      	bx	lr
    DMA1->LIFCR = DMA_Stream1_IT_MASK;
 8002a3a:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 8002a3e:	3b28      	subs	r3, #40	; 0x28
 8002a40:	609a      	str	r2, [r3, #8]
 8002a42:	4770      	bx	lr
    DMA1->LIFCR = DMA_Stream2_IT_MASK;
 8002a44:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 8002a48:	3b40      	subs	r3, #64	; 0x40
 8002a4a:	609a      	str	r2, [r3, #8]
 8002a4c:	4770      	bx	lr
    DMA1->LIFCR = DMA_Stream3_IT_MASK;
 8002a4e:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 8002a52:	3b58      	subs	r3, #88	; 0x58
 8002a54:	609a      	str	r2, [r3, #8]
 8002a56:	4770      	bx	lr
    DMA1->HIFCR = DMA_Stream4_IT_MASK;
 8002a58:	4a2a      	ldr	r2, [pc, #168]	; (8002b04 <DMA_DeInit+0x14c>)
 8002a5a:	3b70      	subs	r3, #112	; 0x70
 8002a5c:	60da      	str	r2, [r3, #12]
 8002a5e:	4770      	bx	lr
    DMA1->HIFCR = DMA_Stream5_IT_MASK;
 8002a60:	4a29      	ldr	r2, [pc, #164]	; (8002b08 <DMA_DeInit+0x150>)
 8002a62:	3b88      	subs	r3, #136	; 0x88
 8002a64:	60da      	str	r2, [r3, #12]
 8002a66:	4770      	bx	lr
    DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
 8002a68:	4a28      	ldr	r2, [pc, #160]	; (8002b0c <DMA_DeInit+0x154>)
 8002a6a:	3ba0      	subs	r3, #160	; 0xa0
 8002a6c:	60da      	str	r2, [r3, #12]
 8002a6e:	4770      	bx	lr
    DMA1->HIFCR = DMA_Stream7_IT_MASK;
 8002a70:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 8002a74:	3bb8      	subs	r3, #184	; 0xb8
 8002a76:	60da      	str	r2, [r3, #12]
 8002a78:	4770      	bx	lr
    DMA2->LIFCR = DMA_Stream0_IT_MASK;
 8002a7a:	223d      	movs	r2, #61	; 0x3d
 8002a7c:	3b10      	subs	r3, #16
 8002a7e:	609a      	str	r2, [r3, #8]
 8002a80:	4770      	bx	lr
    DMA2->LIFCR = DMA_Stream1_IT_MASK;
 8002a82:	f44f 6274 	mov.w	r2, #3904	; 0xf40
 8002a86:	3b28      	subs	r3, #40	; 0x28
 8002a88:	609a      	str	r2, [r3, #8]
 8002a8a:	4770      	bx	lr
    DMA2->LIFCR = DMA_Stream2_IT_MASK;
 8002a8c:	f44f 1274 	mov.w	r2, #3997696	; 0x3d0000
 8002a90:	3b40      	subs	r3, #64	; 0x40
 8002a92:	609a      	str	r2, [r3, #8]
 8002a94:	4770      	bx	lr
    DMA2->LIFCR = DMA_Stream3_IT_MASK;
 8002a96:	f04f 6274 	mov.w	r2, #255852544	; 0xf400000
 8002a9a:	3b58      	subs	r3, #88	; 0x58
 8002a9c:	609a      	str	r2, [r3, #8]
 8002a9e:	4770      	bx	lr
    DMA2->HIFCR = DMA_Stream4_IT_MASK;
 8002aa0:	4a18      	ldr	r2, [pc, #96]	; (8002b04 <DMA_DeInit+0x14c>)
 8002aa2:	3b70      	subs	r3, #112	; 0x70
 8002aa4:	60da      	str	r2, [r3, #12]
 8002aa6:	4770      	bx	lr
    DMA2->HIFCR = DMA_Stream5_IT_MASK;
 8002aa8:	4a17      	ldr	r2, [pc, #92]	; (8002b08 <DMA_DeInit+0x150>)
 8002aaa:	3b88      	subs	r3, #136	; 0x88
 8002aac:	60da      	str	r2, [r3, #12]
 8002aae:	4770      	bx	lr
    DMA2->HIFCR = DMA_Stream6_IT_MASK;
 8002ab0:	4a16      	ldr	r2, [pc, #88]	; (8002b0c <DMA_DeInit+0x154>)
 8002ab2:	3ba0      	subs	r3, #160	; 0xa0
 8002ab4:	60da      	str	r2, [r3, #12]
 8002ab6:	4770      	bx	lr
    {
      /* Reset interrupt pending bits for DMA2 Stream7 */
      DMA2->HIFCR = DMA_Stream7_IT_MASK;
 8002ab8:	f04f 523d 	mov.w	r2, #792723456	; 0x2f400000
 8002abc:	3bb8      	subs	r3, #184	; 0xb8
 8002abe:	60da      	str	r2, [r3, #12]
    }
  }
}
 8002ac0:	e7b6      	b.n	8002a30 <DMA_DeInit+0x78>
 8002ac2:	bf00      	nop
 8002ac4:	40026010 	.word	0x40026010
 8002ac8:	40026028 	.word	0x40026028
 8002acc:	40026040 	.word	0x40026040
 8002ad0:	40026058 	.word	0x40026058
 8002ad4:	40026070 	.word	0x40026070
 8002ad8:	40026088 	.word	0x40026088
 8002adc:	400260a0 	.word	0x400260a0
 8002ae0:	400260b8 	.word	0x400260b8
 8002ae4:	40026410 	.word	0x40026410
 8002ae8:	40026428 	.word	0x40026428
 8002aec:	40026440 	.word	0x40026440
 8002af0:	40026458 	.word	0x40026458
 8002af4:	40026470 	.word	0x40026470
 8002af8:	40026488 	.word	0x40026488
 8002afc:	400264a0 	.word	0x400264a0
 8002b00:	400264b8 	.word	0x400264b8
 8002b04:	2000003d 	.word	0x2000003d
 8002b08:	20000f40 	.word	0x20000f40
 8002b0c:	203d0000 	.word	0x203d0000

08002b10 <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
  *         the configuration information for the specified DMA Stream.  
  * @retval None
  */
void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
{
 8002b10:	b410      	push	{r4}
  assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
  assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));

  /*------------------------- DMAy Streamx CR Configuration ------------------*/
  /* Get the DMAy_Streamx CR value */
  tmpreg = DMAy_Streamx->CR;
 8002b12:	6803      	ldr	r3, [r0, #0]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8002b14:	4a13      	ldr	r2, [pc, #76]	; (8002b64 <DMA_Init+0x54>)
 8002b16:	401a      	ands	r2, r3
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set CIRC bit according to DMA_Mode value */
  /* Set PL bits according to DMA_Priority value */
  /* Set MBURST bits according to DMA_MemoryBurst value */
  /* Set PBURST bits according to DMA_PeripheralBurst value */
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8002b18:	680b      	ldr	r3, [r1, #0]
 8002b1a:	68cc      	ldr	r4, [r1, #12]
 8002b1c:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8002b1e:	694c      	ldr	r4, [r1, #20]
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8002b20:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8002b22:	698c      	ldr	r4, [r1, #24]
 8002b24:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8002b26:	69cc      	ldr	r4, [r1, #28]
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8002b28:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8002b2a:	6a0c      	ldr	r4, [r1, #32]
 8002b2c:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 8002b2e:	6a4c      	ldr	r4, [r1, #36]	; 0x24
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 8002b30:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 8002b32:	6a8c      	ldr	r4, [r1, #40]	; 0x28
 8002b34:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 8002b36:	6b4c      	ldr	r4, [r1, #52]	; 0x34
            DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
 8002b38:	4323      	orrs	r3, r4
            DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
 8002b3a:	6b8c      	ldr	r4, [r1, #56]	; 0x38
 8002b3c:	4323      	orrs	r3, r4
  tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
 8002b3e:	4313      	orrs	r3, r2

  /* Write to DMAy Streamx CR register */
  DMAy_Streamx->CR = tmpreg;
 8002b40:	6003      	str	r3, [r0, #0]

  /*------------------------- DMAy Streamx FCR Configuration -----------------*/
  /* Get the DMAy_Streamx FCR value */
  tmpreg = DMAy_Streamx->FCR;
 8002b42:	6943      	ldr	r3, [r0, #20]

  /* Clear DMDIS and FTH bits */
  tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8002b44:	f023 0307 	bic.w	r3, r3, #7

  /* Configure DMAy Streamx FIFO: 
    Set DMDIS bits according to DMA_FIFOMode value 
    Set FTH bits according to DMA_FIFOThreshold value */
  tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
 8002b48:	6aca      	ldr	r2, [r1, #44]	; 0x2c
 8002b4a:	6b0c      	ldr	r4, [r1, #48]	; 0x30
 8002b4c:	4322      	orrs	r2, r4
 8002b4e:	4313      	orrs	r3, r2

  /* Write to DMAy Streamx CR */
  DMAy_Streamx->FCR = tmpreg;
 8002b50:	6143      	str	r3, [r0, #20]

  /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
  /* Write to DMAy Streamx NDTR register */
  DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
 8002b52:	690b      	ldr	r3, [r1, #16]
 8002b54:	6043      	str	r3, [r0, #4]

  /*------------------------- DMAy Streamx PAR Configuration -----------------*/
  /* Write to DMAy Streamx PAR */
  DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 8002b56:	684b      	ldr	r3, [r1, #4]
 8002b58:	6083      	str	r3, [r0, #8]

  /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
  /* Write to DMAy Streamx M0AR */
  DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
 8002b5a:	688b      	ldr	r3, [r1, #8]
 8002b5c:	60c3      	str	r3, [r0, #12]
}
 8002b5e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002b62:	4770      	bx	lr
 8002b64:	f01c803f 	.word	0xf01c803f

08002b68 <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
  /*-------------- Reset DMA init structure parameters values ----------------*/
  /* Initialize the DMA_Channel member */
  DMA_InitStruct->DMA_Channel = 0;
 8002b68:	2300      	movs	r3, #0
 8002b6a:	6003      	str	r3, [r0, #0]

  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 8002b6c:	6043      	str	r3, [r0, #4]

  /* Initialize the DMA_Memory0BaseAddr member */
  DMA_InitStruct->DMA_Memory0BaseAddr = 0;
 8002b6e:	6083      	str	r3, [r0, #8]

  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
 8002b70:	60c3      	str	r3, [r0, #12]

  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 8002b72:	6103      	str	r3, [r0, #16]

  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8002b74:	6143      	str	r3, [r0, #20]

  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 8002b76:	6183      	str	r3, [r0, #24]

  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8002b78:	61c3      	str	r3, [r0, #28]

  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8002b7a:	6203      	str	r3, [r0, #32]

  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 8002b7c:	6243      	str	r3, [r0, #36]	; 0x24

  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 8002b7e:	6283      	str	r3, [r0, #40]	; 0x28

  /* Initialize the DMA_FIFOMode member */
  DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
 8002b80:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Initialize the DMA_FIFOThreshold member */
  DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
 8002b82:	6303      	str	r3, [r0, #48]	; 0x30

  /* Initialize the DMA_MemoryBurst member */
  DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
 8002b84:	6343      	str	r3, [r0, #52]	; 0x34

  /* Initialize the DMA_PeripheralBurst member */
  DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
 8002b86:	6383      	str	r3, [r0, #56]	; 0x38
 8002b88:	4770      	bx	lr

08002b8a <DMA_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002b8a:	b921      	cbnz	r1, 8002b96 <DMA_Cmd+0xc>
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
  }
  else
  {
    /* Disable the selected DMAy Streamx by clearing EN bit */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
 8002b8c:	6803      	ldr	r3, [r0, #0]
 8002b8e:	f023 0301 	bic.w	r3, r3, #1
 8002b92:	6003      	str	r3, [r0, #0]
 8002b94:	4770      	bx	lr
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
 8002b96:	6803      	ldr	r3, [r0, #0]
 8002b98:	f043 0301 	orr.w	r3, r3, #1
 8002b9c:	6003      	str	r3, [r0, #0]
 8002b9e:	4770      	bx	lr

08002ba0 <DMA_PeriphIncOffsetSizeConfig>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));

  /* Check the needed Peripheral increment offset */
  if(DMA_Pincos != DMA_PINCOS_Psize)
 8002ba0:	b921      	cbnz	r1, 8002bac <DMA_PeriphIncOffsetSizeConfig+0xc>
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
  }
  else
  {
    /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
 8002ba2:	6803      	ldr	r3, [r0, #0]
 8002ba4:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8002ba8:	6003      	str	r3, [r0, #0]
 8002baa:	4770      	bx	lr
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
 8002bac:	6803      	ldr	r3, [r0, #0]
 8002bae:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002bb2:	6003      	str	r3, [r0, #0]
 8002bb4:	4770      	bx	lr

08002bb6 <DMA_FlowControllerConfig>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));

  /* Check the needed flow controller  */
  if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
 8002bb6:	b921      	cbnz	r1, 8002bc2 <DMA_FlowControllerConfig+0xc>
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
  }
  else
  {
    /* Clear the PFCTRL bit: Memory is the flow controller */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
 8002bb8:	6803      	ldr	r3, [r0, #0]
 8002bba:	f023 0320 	bic.w	r3, r3, #32
 8002bbe:	6003      	str	r3, [r0, #0]
 8002bc0:	4770      	bx	lr
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
 8002bc2:	6803      	ldr	r3, [r0, #0]
 8002bc4:	f043 0320 	orr.w	r3, r3, #32
 8002bc8:	6003      	str	r3, [r0, #0]
 8002bca:	4770      	bx	lr

08002bcc <DMA_SetCurrDataCounter>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Write the number of data units to be transferred */
  DMAy_Streamx->NDTR = (uint16_t)Counter;
 8002bcc:	6041      	str	r1, [r0, #4]
 8002bce:	4770      	bx	lr

08002bd0 <DMA_GetCurrDataCounter>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Return the number of remaining data units for DMAy Streamx */
  return ((uint16_t)(DMAy_Streamx->NDTR));
 8002bd0:	6840      	ldr	r0, [r0, #4]
}
 8002bd2:	b280      	uxth	r0, r0
 8002bd4:	4770      	bx	lr

08002bd6 <DMA_DoubleBufferModeConfig>:
{  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));

  if (DMA_CurrentMemory != DMA_Memory_0)
 8002bd6:	b92a      	cbnz	r2, 8002be4 <DMA_DoubleBufferModeConfig+0xe>
    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
  }
  else
  {
    /* Set Memory 0 as current memory address */
    DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
 8002bd8:	6803      	ldr	r3, [r0, #0]
 8002bda:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8002bde:	6003      	str	r3, [r0, #0]
  }

  /* Write to DMAy Streamx M1AR */
  DMAy_Streamx->M1AR = Memory1BaseAddr;
 8002be0:	6101      	str	r1, [r0, #16]
 8002be2:	4770      	bx	lr
    DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
 8002be4:	6803      	ldr	r3, [r0, #0]
 8002be6:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8002bea:	6003      	str	r3, [r0, #0]
 8002bec:	e7f8      	b.n	8002be0 <DMA_DoubleBufferModeConfig+0xa>

08002bee <DMA_DoubleBufferModeCmd>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Configure the Double Buffer mode */
  if (NewState != DISABLE)
 8002bee:	b921      	cbnz	r1, 8002bfa <DMA_DoubleBufferModeCmd+0xc>
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
  }
  else
  {
    /* Disable the Double buffer mode */
    DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
 8002bf0:	6803      	ldr	r3, [r0, #0]
 8002bf2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8002bf6:	6003      	str	r3, [r0, #0]
 8002bf8:	4770      	bx	lr
    DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
 8002bfa:	6803      	ldr	r3, [r0, #0]
 8002bfc:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8002c00:	6003      	str	r3, [r0, #0]
 8002c02:	4770      	bx	lr

08002c04 <DMA_MemoryTargetConfig>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
    
  /* Check the Memory target to be configured */
  if (DMA_MemoryTarget != DMA_Memory_0)
 8002c04:	b90a      	cbnz	r2, 8002c0a <DMA_MemoryTargetConfig+0x6>
    DMAy_Streamx->M1AR = MemoryBaseAddr;    
  }  
  else
  {
    /* Write to DMAy Streamx M0AR */
    DMAy_Streamx->M0AR = MemoryBaseAddr;  
 8002c06:	60c1      	str	r1, [r0, #12]
 8002c08:	4770      	bx	lr
    DMAy_Streamx->M1AR = MemoryBaseAddr;    
 8002c0a:	6101      	str	r1, [r0, #16]
 8002c0c:	4770      	bx	lr

08002c0e <DMA_GetCurrentMemoryTarget>:
  
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  /* Get the current memory target */
  if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
 8002c0e:	6803      	ldr	r3, [r0, #0]
 8002c10:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 8002c14:	d101      	bne.n	8002c1a <DMA_GetCurrentMemoryTarget+0xc>
    tmp = 1;
  }  
  else
  {
    /* Current memory buffer used is Memory 0 */
    tmp = 0;    
 8002c16:	2000      	movs	r0, #0
  }
  return tmp;
}
 8002c18:	4770      	bx	lr
    tmp = 1;
 8002c1a:	2001      	movs	r0, #1
 8002c1c:	4770      	bx	lr

08002c1e <DMA_GetCmdStatus>:
  FunctionalState state = DISABLE;

  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));

  if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
 8002c1e:	6803      	ldr	r3, [r0, #0]
 8002c20:	f013 0f01 	tst.w	r3, #1
 8002c24:	d101      	bne.n	8002c2a <DMA_GetCmdStatus+0xc>
  }
  else
  {
    /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
        all transfers are complete) */
    state = DISABLE;
 8002c26:	2000      	movs	r0, #0
  }
  return state;
}
 8002c28:	4770      	bx	lr
    state = ENABLE;
 8002c2a:	2001      	movs	r0, #1
 8002c2c:	4770      	bx	lr

08002c2e <DMA_GetFIFOStatus>:
 
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  
  /* Get the FIFO level bits */
  tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
 8002c2e:	6940      	ldr	r0, [r0, #20]
  
  return tmpreg;
}
 8002c30:	f000 0038 	and.w	r0, r0, #56	; 0x38
 8002c34:	4770      	bx	lr

08002c36 <DMA_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_FLAG(DMA_FLAG));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8002c36:	4b0b      	ldr	r3, [pc, #44]	; (8002c64 <DMA_GetFlagStatus+0x2e>)
 8002c38:	4298      	cmp	r0, r3
 8002c3a:	d80d      	bhi.n	8002c58 <DMA_GetFlagStatus+0x22>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8002c3c:	f2a3 430f 	subw	r3, r3, #1039	; 0x40f
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if the flag is in HISR or LISR */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 8002c40:	f011 5f00 	tst.w	r1, #536870912	; 0x20000000
 8002c44:	d00a      	beq.n	8002c5c <DMA_GetFlagStatus+0x26>
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR;
 8002c46:	685b      	ldr	r3, [r3, #4]
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR;
  }   
 
  /* Mask the reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;
 8002c48:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 8002c4c:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082

  /* Check the status of the specified DMA flag */
  if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
 8002c50:	4219      	tst	r1, r3
 8002c52:	d105      	bne.n	8002c60 <DMA_GetFlagStatus+0x2a>
    bitstatus = SET;
  }
  else
  {
    /* DMA_FLAG is reset */
    bitstatus = RESET;
 8002c54:	2000      	movs	r0, #0
  }

  /* Return the DMA_FLAG status */
  return  bitstatus;
}
 8002c56:	4770      	bx	lr
    DMAy = DMA2; 
 8002c58:	4b03      	ldr	r3, [pc, #12]	; (8002c68 <DMA_GetFlagStatus+0x32>)
 8002c5a:	e7f1      	b.n	8002c40 <DMA_GetFlagStatus+0xa>
    tmpreg = DMAy->LISR;
 8002c5c:	681b      	ldr	r3, [r3, #0]
 8002c5e:	e7f3      	b.n	8002c48 <DMA_GetFlagStatus+0x12>
    bitstatus = SET;
 8002c60:	2001      	movs	r0, #1
 8002c62:	4770      	bx	lr
 8002c64:	4002640f 	.word	0x4002640f
 8002c68:	40026400 	.word	0x40026400

08002c6c <DMA_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8002c6c:	4b0a      	ldr	r3, [pc, #40]	; (8002c98 <DMA_ClearFlag+0x2c>)
 8002c6e:	4298      	cmp	r0, r3
 8002c70:	d80a      	bhi.n	8002c88 <DMA_ClearFlag+0x1c>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8002c72:	f2a3 430f 	subw	r3, r3, #1039	; 0x40f
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
 8002c76:	f011 5f00 	tst.w	r1, #536870912	; 0x20000000
 8002c7a:	d107      	bne.n	8002c8c <DMA_ClearFlag+0x20>
    DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
  }
  else 
  {
    /* Set DMAy LIFCR register clear flag bits */
    DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 8002c7c:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8002c80:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8002c84:	6099      	str	r1, [r3, #8]
 8002c86:	4770      	bx	lr
    DMAy = DMA2; 
 8002c88:	4b04      	ldr	r3, [pc, #16]	; (8002c9c <DMA_ClearFlag+0x30>)
 8002c8a:	e7f4      	b.n	8002c76 <DMA_ClearFlag+0xa>
    DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
 8002c8c:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8002c90:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8002c94:	60d9      	str	r1, [r3, #12]
 8002c96:	4770      	bx	lr
 8002c98:	4002640f 	.word	0x4002640f
 8002c9c:	40026400 	.word	0x40026400

08002ca0 <DMA_ITConfig>:
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* Check if the DMA_IT parameter contains a FIFO interrupt */
  if ((DMA_IT & DMA_IT_FE) != 0)
 8002ca0:	f011 0f80 	tst.w	r1, #128	; 0x80
 8002ca4:	d004      	beq.n	8002cb0 <DMA_ITConfig+0x10>
  {
    if (NewState != DISABLE)
 8002ca6:	b16a      	cbz	r2, 8002cc4 <DMA_ITConfig+0x24>
    {
      /* Enable the selected DMA FIFO interrupts */
      DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
 8002ca8:	6943      	ldr	r3, [r0, #20]
 8002caa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002cae:	6143      	str	r3, [r0, #20]
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
    }
  }

  /* Check if the DMA_IT parameter contains a Transfer interrupt */
  if (DMA_IT != DMA_IT_FE)
 8002cb0:	2980      	cmp	r1, #128	; 0x80
 8002cb2:	d006      	beq.n	8002cc2 <DMA_ITConfig+0x22>
  {
    if (NewState != DISABLE)
 8002cb4:	b95a      	cbnz	r2, 8002cce <DMA_ITConfig+0x2e>
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
    }
    else
    {
      /* Disable the selected DMA transfer interrupts */
      DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
 8002cb6:	6803      	ldr	r3, [r0, #0]
 8002cb8:	f001 011e 	and.w	r1, r1, #30
 8002cbc:	ea23 0101 	bic.w	r1, r3, r1
 8002cc0:	6001      	str	r1, [r0, #0]
 8002cc2:	4770      	bx	lr
      DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
 8002cc4:	6943      	ldr	r3, [r0, #20]
 8002cc6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002cca:	6143      	str	r3, [r0, #20]
 8002ccc:	e7f0      	b.n	8002cb0 <DMA_ITConfig+0x10>
      DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
 8002cce:	6803      	ldr	r3, [r0, #0]
 8002cd0:	f001 011e 	and.w	r1, r1, #30
 8002cd4:	4319      	orrs	r1, r3
 8002cd6:	6001      	str	r1, [r0, #0]
 8002cd8:	4770      	bx	lr

08002cda <DMA_GetITStatus>:
  *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
  *         Where x can be 0 to 7 to select the DMA Stream.
  * @retval The new state of DMA_IT (SET or RESET).
  */
ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
{
 8002cda:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_GET_IT(DMA_IT));
 
  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8002cdc:	4b14      	ldr	r3, [pc, #80]	; (8002d30 <DMA_GetITStatus+0x56>)
 8002cde:	4298      	cmp	r0, r3
 8002ce0:	d817      	bhi.n	8002d12 <DMA_GetITStatus+0x38>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8002ce2:	4c14      	ldr	r4, [pc, #80]	; (8002d34 <DMA_GetITStatus+0x5a>)
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if the interrupt enable bit is in the CR or FCR register */
  if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
 8002ce4:	f021 23f0 	bic.w	r3, r1, #4026593280	; 0xf000f000
 8002ce8:	f023 13c3 	bic.w	r3, r3, #12779715	; 0xc300c3
 8002cec:	b19b      	cbz	r3, 8002d16 <DMA_GetITStatus+0x3c>
  {
    /* Get the interrupt enable position mask in CR register */
    tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
 8002cee:	0aca      	lsrs	r2, r1, #11
 8002cf0:	f002 021e 	and.w	r2, r2, #30
    
    /* Check the enable bit in CR register */
    enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
 8002cf4:	6803      	ldr	r3, [r0, #0]
 8002cf6:	401a      	ands	r2, r3
    /* Check the enable bit in FCR register */
    enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
  }
 
  /* Check if the interrupt pending flag is in LISR or HISR */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 8002cf8:	f011 5f00 	tst.w	r1, #536870912	; 0x20000000
 8002cfc:	d00f      	beq.n	8002d1e <DMA_GetITStatus+0x44>
  {
    /* Get DMAy HISR register value */
    tmpreg = DMAy->HISR ;
 8002cfe:	6863      	ldr	r3, [r4, #4]
    /* Get DMAy LISR register value */
    tmpreg = DMAy->LISR ;
  } 

  /* mask all reserved bits */
  tmpreg &= (uint32_t)RESERVED_MASK;
 8002d00:	f023 23f0 	bic.w	r3, r3, #4026593280	; 0xf000f000
 8002d04:	f023 1382 	bic.w	r3, r3, #8519810	; 0x820082

  /* Check the status of the specified DMA interrupt */
  if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8002d08:	4219      	tst	r1, r3
 8002d0a:	d00a      	beq.n	8002d22 <DMA_GetITStatus+0x48>
 8002d0c:	b96a      	cbnz	r2, 8002d2a <DMA_GetITStatus+0x50>
    bitstatus = SET;
  }
  else
  {
    /* DMA_IT is reset */
    bitstatus = RESET;
 8002d0e:	2000      	movs	r0, #0
 8002d10:	e008      	b.n	8002d24 <DMA_GetITStatus+0x4a>
    DMAy = DMA2; 
 8002d12:	4c09      	ldr	r4, [pc, #36]	; (8002d38 <DMA_GetITStatus+0x5e>)
 8002d14:	e7e6      	b.n	8002ce4 <DMA_GetITStatus+0xa>
    enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
 8002d16:	6942      	ldr	r2, [r0, #20]
 8002d18:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8002d1c:	e7ec      	b.n	8002cf8 <DMA_GetITStatus+0x1e>
    tmpreg = DMAy->LISR ;
 8002d1e:	6823      	ldr	r3, [r4, #0]
 8002d20:	e7ee      	b.n	8002d00 <DMA_GetITStatus+0x26>
    bitstatus = RESET;
 8002d22:	2000      	movs	r0, #0
  }

  /* Return the DMA_IT status */
  return  bitstatus;
}
 8002d24:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002d28:	4770      	bx	lr
    bitstatus = SET;
 8002d2a:	2001      	movs	r0, #1
 8002d2c:	e7fa      	b.n	8002d24 <DMA_GetITStatus+0x4a>
 8002d2e:	bf00      	nop
 8002d30:	4002640f 	.word	0x4002640f
 8002d34:	40026000 	.word	0x40026000
 8002d38:	40026400 	.word	0x40026400

08002d3c <DMA_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
  assert_param(IS_DMA_CLEAR_IT(DMA_IT));

  /* Determine the DMA to which belongs the stream */
  if (DMAy_Streamx < DMA2_Stream0)
 8002d3c:	4b0a      	ldr	r3, [pc, #40]	; (8002d68 <DMA_ClearITPendingBit+0x2c>)
 8002d3e:	4298      	cmp	r0, r3
 8002d40:	d80a      	bhi.n	8002d58 <DMA_ClearITPendingBit+0x1c>
  {
    /* DMAy_Streamx belongs to DMA1 */
    DMAy = DMA1; 
 8002d42:	f2a3 430f 	subw	r3, r3, #1039	; 0x40f
    /* DMAy_Streamx belongs to DMA2 */
    DMAy = DMA2; 
  }

  /* Check if LIFCR or HIFCR register is targeted */
  if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
 8002d46:	f011 5f00 	tst.w	r1, #536870912	; 0x20000000
 8002d4a:	d107      	bne.n	8002d5c <DMA_ClearITPendingBit+0x20>
    DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
  }
  else 
  {
    /* Set DMAy LIFCR register clear interrupt bits */
    DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 8002d4c:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8002d50:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8002d54:	6099      	str	r1, [r3, #8]
 8002d56:	4770      	bx	lr
    DMAy = DMA2; 
 8002d58:	4b04      	ldr	r3, [pc, #16]	; (8002d6c <DMA_ClearITPendingBit+0x30>)
 8002d5a:	e7f4      	b.n	8002d46 <DMA_ClearITPendingBit+0xa>
    DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
 8002d5c:	f021 21f0 	bic.w	r1, r1, #4026593280	; 0xf000f000
 8002d60:	f021 1182 	bic.w	r1, r1, #8519810	; 0x820082
 8002d64:	60d9      	str	r1, [r3, #12]
 8002d66:	4770      	bx	lr
 8002d68:	4002640f 	.word	0x4002640f
 8002d6c:	40026400 	.word	0x40026400

08002d70 <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 8002d70:	4b04      	ldr	r3, [pc, #16]	; (8002d84 <EXTI_DeInit+0x14>)
 8002d72:	2200      	movs	r2, #0
 8002d74:	601a      	str	r2, [r3, #0]
  EXTI->EMR = 0x00000000;
 8002d76:	605a      	str	r2, [r3, #4]
  EXTI->RTSR = 0x00000000;
 8002d78:	609a      	str	r2, [r3, #8]
  EXTI->FTSR = 0x00000000;
 8002d7a:	60da      	str	r2, [r3, #12]
  EXTI->PR = 0x007FFFFF;
 8002d7c:	4a02      	ldr	r2, [pc, #8]	; (8002d88 <EXTI_DeInit+0x18>)
 8002d7e:	615a      	str	r2, [r3, #20]
 8002d80:	4770      	bx	lr
 8002d82:	bf00      	nop
 8002d84:	40013c00 	.word	0x40013c00
 8002d88:	007fffff 	.word	0x007fffff

08002d8c <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8002d8c:	7983      	ldrb	r3, [r0, #6]
 8002d8e:	2b00      	cmp	r3, #0
 8002d90:	d036      	beq.n	8002e00 <EXTI_Init+0x74>
{
 8002d92:	b410      	push	{r4}
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 8002d94:	4b20      	ldr	r3, [pc, #128]	; (8002e18 <EXTI_Init+0x8c>)
 8002d96:	681a      	ldr	r2, [r3, #0]
 8002d98:	6801      	ldr	r1, [r0, #0]
 8002d9a:	ea22 0201 	bic.w	r2, r2, r1
 8002d9e:	601a      	str	r2, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 8002da0:	685a      	ldr	r2, [r3, #4]
 8002da2:	6801      	ldr	r1, [r0, #0]
 8002da4:	ea22 0201 	bic.w	r2, r2, r1
 8002da8:	605a      	str	r2, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;
 8002daa:	7902      	ldrb	r2, [r0, #4]
 8002dac:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8002db0:	f502 329e 	add.w	r2, r2, #80896	; 0x13c00

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8002db4:	6811      	ldr	r1, [r2, #0]
 8002db6:	6804      	ldr	r4, [r0, #0]
 8002db8:	4321      	orrs	r1, r4
 8002dba:	6011      	str	r1, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 8002dbc:	689a      	ldr	r2, [r3, #8]
 8002dbe:	6801      	ldr	r1, [r0, #0]
 8002dc0:	ea22 0201 	bic.w	r2, r2, r1
 8002dc4:	609a      	str	r2, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 8002dc6:	68da      	ldr	r2, [r3, #12]
 8002dc8:	6801      	ldr	r1, [r0, #0]
 8002dca:	ea22 0201 	bic.w	r2, r2, r1
 8002dce:	60da      	str	r2, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 8002dd0:	7943      	ldrb	r3, [r0, #5]
 8002dd2:	2b10      	cmp	r3, #16
 8002dd4:	d00a      	beq.n	8002dec <EXTI_Init+0x60>
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
    }
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;
 8002dd6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002dda:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 8002dde:	681a      	ldr	r2, [r3, #0]
 8002de0:	6801      	ldr	r1, [r0, #0]
 8002de2:	430a      	orrs	r2, r1
 8002de4:	601a      	str	r2, [r3, #0]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 8002de6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002dea:	4770      	bx	lr
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 8002dec:	4b0a      	ldr	r3, [pc, #40]	; (8002e18 <EXTI_Init+0x8c>)
 8002dee:	689a      	ldr	r2, [r3, #8]
 8002df0:	6801      	ldr	r1, [r0, #0]
 8002df2:	430a      	orrs	r2, r1
 8002df4:	609a      	str	r2, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 8002df6:	68da      	ldr	r2, [r3, #12]
 8002df8:	6801      	ldr	r1, [r0, #0]
 8002dfa:	430a      	orrs	r2, r1
 8002dfc:	60da      	str	r2, [r3, #12]
 8002dfe:	e7f2      	b.n	8002de6 <EXTI_Init+0x5a>
    tmp += EXTI_InitStruct->EXTI_Mode;
 8002e00:	7903      	ldrb	r3, [r0, #4]
 8002e02:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002e06:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 8002e0a:	681a      	ldr	r2, [r3, #0]
 8002e0c:	6801      	ldr	r1, [r0, #0]
 8002e0e:	ea22 0201 	bic.w	r2, r2, r1
 8002e12:	601a      	str	r2, [r3, #0]
}
 8002e14:	4770      	bx	lr
 8002e16:	bf00      	nop
 8002e18:	40013c00 	.word	0x40013c00

08002e1c <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8002e1c:	2300      	movs	r3, #0
 8002e1e:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 8002e20:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 8002e22:	220c      	movs	r2, #12
 8002e24:	7142      	strb	r2, [r0, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 8002e26:	7183      	strb	r3, [r0, #6]
 8002e28:	4770      	bx	lr

08002e2a <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->SWIER |= EXTI_Line;
 8002e2a:	4a02      	ldr	r2, [pc, #8]	; (8002e34 <EXTI_GenerateSWInterrupt+0xa>)
 8002e2c:	6913      	ldr	r3, [r2, #16]
 8002e2e:	4318      	orrs	r0, r3
 8002e30:	6110      	str	r0, [r2, #16]
 8002e32:	4770      	bx	lr
 8002e34:	40013c00 	.word	0x40013c00

08002e38 <EXTI_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 8002e38:	4b03      	ldr	r3, [pc, #12]	; (8002e48 <EXTI_GetFlagStatus+0x10>)
 8002e3a:	695b      	ldr	r3, [r3, #20]
 8002e3c:	4203      	tst	r3, r0
 8002e3e:	d101      	bne.n	8002e44 <EXTI_GetFlagStatus+0xc>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8002e40:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 8002e42:	4770      	bx	lr
    bitstatus = SET;
 8002e44:	2001      	movs	r0, #1
 8002e46:	4770      	bx	lr
 8002e48:	40013c00 	.word	0x40013c00

08002e4c <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8002e4c:	4b01      	ldr	r3, [pc, #4]	; (8002e54 <EXTI_ClearFlag+0x8>)
 8002e4e:	6158      	str	r0, [r3, #20]
 8002e50:	4770      	bx	lr
 8002e52:	bf00      	nop
 8002e54:	40013c00 	.word	0x40013c00

08002e58 <EXTI_GetITStatus>:
  ITStatus bitstatus = RESET;
  uint32_t enablestatus = 0;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 8002e58:	4a06      	ldr	r2, [pc, #24]	; (8002e74 <EXTI_GetITStatus+0x1c>)
 8002e5a:	6813      	ldr	r3, [r2, #0]
 8002e5c:	4003      	ands	r3, r0
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8002e5e:	6952      	ldr	r2, [r2, #20]
 8002e60:	4210      	tst	r0, r2
 8002e62:	d002      	beq.n	8002e6a <EXTI_GetITStatus+0x12>
 8002e64:	b91b      	cbnz	r3, 8002e6e <EXTI_GetITStatus+0x16>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8002e66:	2000      	movs	r0, #0
 8002e68:	4770      	bx	lr
 8002e6a:	2000      	movs	r0, #0
 8002e6c:	4770      	bx	lr
    bitstatus = SET;
 8002e6e:	2001      	movs	r0, #1
  }
  return bitstatus;
}
 8002e70:	4770      	bx	lr
 8002e72:	bf00      	nop
 8002e74:	40013c00 	.word	0x40013c00

08002e78 <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8002e78:	4b01      	ldr	r3, [pc, #4]	; (8002e80 <EXTI_ClearITPendingBit+0x8>)
 8002e7a:	6158      	str	r0, [r3, #20]
 8002e7c:	4770      	bx	lr
 8002e7e:	bf00      	nop
 8002e80:	40013c00 	.word	0x40013c00

08002e84 <FLASH_SetLatency>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
  *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
 8002e84:	b2c0      	uxtb	r0, r0
 8002e86:	4b01      	ldr	r3, [pc, #4]	; (8002e8c <FLASH_SetLatency+0x8>)
 8002e88:	7018      	strb	r0, [r3, #0]
 8002e8a:	4770      	bx	lr
 8002e8c:	40023c00 	.word	0x40023c00

08002e90 <FLASH_PrefetchBufferCmd>:
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Enable or disable the Prefetch Buffer */
  if(NewState != DISABLE)
 8002e90:	b928      	cbnz	r0, 8002e9e <FLASH_PrefetchBufferCmd+0xe>
  {
    FLASH->ACR |= FLASH_ACR_PRFTEN;
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_PRFTEN);
 8002e92:	4a06      	ldr	r2, [pc, #24]	; (8002eac <FLASH_PrefetchBufferCmd+0x1c>)
 8002e94:	6813      	ldr	r3, [r2, #0]
 8002e96:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002e9a:	6013      	str	r3, [r2, #0]
 8002e9c:	4770      	bx	lr
    FLASH->ACR |= FLASH_ACR_PRFTEN;
 8002e9e:	4a03      	ldr	r2, [pc, #12]	; (8002eac <FLASH_PrefetchBufferCmd+0x1c>)
 8002ea0:	6813      	ldr	r3, [r2, #0]
 8002ea2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002ea6:	6013      	str	r3, [r2, #0]
 8002ea8:	4770      	bx	lr
 8002eaa:	bf00      	nop
 8002eac:	40023c00 	.word	0x40023c00

08002eb0 <FLASH_InstructionCacheCmd>:
void FLASH_InstructionCacheCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
 8002eb0:	b928      	cbnz	r0, 8002ebe <FLASH_InstructionCacheCmd+0xe>
  {
    FLASH->ACR |= FLASH_ACR_ICEN;
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_ICEN);
 8002eb2:	4a06      	ldr	r2, [pc, #24]	; (8002ecc <FLASH_InstructionCacheCmd+0x1c>)
 8002eb4:	6813      	ldr	r3, [r2, #0]
 8002eb6:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8002eba:	6013      	str	r3, [r2, #0]
 8002ebc:	4770      	bx	lr
    FLASH->ACR |= FLASH_ACR_ICEN;
 8002ebe:	4a03      	ldr	r2, [pc, #12]	; (8002ecc <FLASH_InstructionCacheCmd+0x1c>)
 8002ec0:	6813      	ldr	r3, [r2, #0]
 8002ec2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8002ec6:	6013      	str	r3, [r2, #0]
 8002ec8:	4770      	bx	lr
 8002eca:	bf00      	nop
 8002ecc:	40023c00 	.word	0x40023c00

08002ed0 <FLASH_DataCacheCmd>:
void FLASH_DataCacheCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if(NewState != DISABLE)
 8002ed0:	b928      	cbnz	r0, 8002ede <FLASH_DataCacheCmd+0xe>
  {
    FLASH->ACR |= FLASH_ACR_DCEN;
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_DCEN);
 8002ed2:	4a06      	ldr	r2, [pc, #24]	; (8002eec <FLASH_DataCacheCmd+0x1c>)
 8002ed4:	6813      	ldr	r3, [r2, #0]
 8002ed6:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8002eda:	6013      	str	r3, [r2, #0]
 8002edc:	4770      	bx	lr
    FLASH->ACR |= FLASH_ACR_DCEN;
 8002ede:	4a03      	ldr	r2, [pc, #12]	; (8002eec <FLASH_DataCacheCmd+0x1c>)
 8002ee0:	6813      	ldr	r3, [r2, #0]
 8002ee2:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8002ee6:	6013      	str	r3, [r2, #0]
 8002ee8:	4770      	bx	lr
 8002eea:	bf00      	nop
 8002eec:	40023c00 	.word	0x40023c00

08002ef0 <FLASH_InstructionCacheReset>:
  * @param  None
  * @retval None
  */
void FLASH_InstructionCacheReset(void)
{
  FLASH->ACR |= FLASH_ACR_ICRST;
 8002ef0:	4a02      	ldr	r2, [pc, #8]	; (8002efc <FLASH_InstructionCacheReset+0xc>)
 8002ef2:	6813      	ldr	r3, [r2, #0]
 8002ef4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8002ef8:	6013      	str	r3, [r2, #0]
 8002efa:	4770      	bx	lr
 8002efc:	40023c00 	.word	0x40023c00

08002f00 <FLASH_DataCacheReset>:
  * @param  None
  * @retval None
  */
void FLASH_DataCacheReset(void)
{
  FLASH->ACR |= FLASH_ACR_DCRST;
 8002f00:	4a02      	ldr	r2, [pc, #8]	; (8002f0c <FLASH_DataCacheReset+0xc>)
 8002f02:	6813      	ldr	r3, [r2, #0]
 8002f04:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8002f08:	6013      	str	r3, [r2, #0]
 8002f0a:	4770      	bx	lr
 8002f0c:	40023c00 	.word	0x40023c00

08002f10 <FLASH_Unlock>:
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
 8002f10:	4b05      	ldr	r3, [pc, #20]	; (8002f28 <FLASH_Unlock+0x18>)
 8002f12:	691b      	ldr	r3, [r3, #16]
 8002f14:	2b00      	cmp	r3, #0
 8002f16:	db00      	blt.n	8002f1a <FLASH_Unlock+0xa>
 8002f18:	4770      	bx	lr
  {
    /* Authorize the FLASH Registers access */
    FLASH->KEYR = FLASH_KEY1;
 8002f1a:	4b03      	ldr	r3, [pc, #12]	; (8002f28 <FLASH_Unlock+0x18>)
 8002f1c:	4a03      	ldr	r2, [pc, #12]	; (8002f2c <FLASH_Unlock+0x1c>)
 8002f1e:	605a      	str	r2, [r3, #4]
    FLASH->KEYR = FLASH_KEY2;
 8002f20:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
 8002f24:	605a      	str	r2, [r3, #4]
  }  
}
 8002f26:	e7f7      	b.n	8002f18 <FLASH_Unlock+0x8>
 8002f28:	40023c00 	.word	0x40023c00
 8002f2c:	45670123 	.word	0x45670123

08002f30 <FLASH_Lock>:
  * @retval None
  */
void FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 8002f30:	4a02      	ldr	r2, [pc, #8]	; (8002f3c <FLASH_Lock+0xc>)
 8002f32:	6913      	ldr	r3, [r2, #16]
 8002f34:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002f38:	6113      	str	r3, [r2, #16]
 8002f3a:	4770      	bx	lr
 8002f3c:	40023c00 	.word	0x40023c00

08002f40 <FLASH_OB_Unlock>:
  * @param  None
  * @retval None
  */
void FLASH_OB_Unlock(void)
{
  if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
 8002f40:	4b05      	ldr	r3, [pc, #20]	; (8002f58 <FLASH_OB_Unlock+0x18>)
 8002f42:	695b      	ldr	r3, [r3, #20]
 8002f44:	f013 0f01 	tst.w	r3, #1
 8002f48:	d005      	beq.n	8002f56 <FLASH_OB_Unlock+0x16>
  {
    /* Authorizes the Option Byte register programming */
    FLASH->OPTKEYR = FLASH_OPT_KEY1;
 8002f4a:	4b03      	ldr	r3, [pc, #12]	; (8002f58 <FLASH_OB_Unlock+0x18>)
 8002f4c:	4a03      	ldr	r2, [pc, #12]	; (8002f5c <FLASH_OB_Unlock+0x1c>)
 8002f4e:	609a      	str	r2, [r3, #8]
    FLASH->OPTKEYR = FLASH_OPT_KEY2;
 8002f50:	f102 3244 	add.w	r2, r2, #1145324612	; 0x44444444
 8002f54:	609a      	str	r2, [r3, #8]
 8002f56:	4770      	bx	lr
 8002f58:	40023c00 	.word	0x40023c00
 8002f5c:	08192a3b 	.word	0x08192a3b

08002f60 <FLASH_OB_Lock>:
  * @retval None
  */
void FLASH_OB_Lock(void)
{
  /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
  FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
 8002f60:	4a02      	ldr	r2, [pc, #8]	; (8002f6c <FLASH_OB_Lock+0xc>)
 8002f62:	6953      	ldr	r3, [r2, #20]
 8002f64:	f043 0301 	orr.w	r3, r3, #1
 8002f68:	6153      	str	r3, [r2, #20]
 8002f6a:	4770      	bx	lr
 8002f6c:	40023c00 	.word	0x40023c00

08002f70 <FLASH_OB_BORConfig>:
{
  /* Check the parameters */
  assert_param(IS_OB_BOR(OB_BOR));

  /* Set the BOR Level */
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
 8002f70:	4b04      	ldr	r3, [pc, #16]	; (8002f84 <FLASH_OB_BORConfig+0x14>)
 8002f72:	781a      	ldrb	r2, [r3, #0]
 8002f74:	f002 02f3 	and.w	r2, r2, #243	; 0xf3
 8002f78:	701a      	strb	r2, [r3, #0]
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
 8002f7a:	781a      	ldrb	r2, [r3, #0]
 8002f7c:	4310      	orrs	r0, r2
 8002f7e:	7018      	strb	r0, [r3, #0]
 8002f80:	4770      	bx	lr
 8002f82:	bf00      	nop
 8002f84:	40023c14 	.word	0x40023c14

08002f88 <FLASH_OB_GetUser>:
  *         and RST_STDBY(Bit2).
  */
uint8_t FLASH_OB_GetUser(void)
{
  /* Return the User Option Byte */
  return (uint8_t)(FLASH->OPTCR >> 5);
 8002f88:	4b02      	ldr	r3, [pc, #8]	; (8002f94 <FLASH_OB_GetUser+0xc>)
 8002f8a:	6958      	ldr	r0, [r3, #20]
}
 8002f8c:	f3c0 1047 	ubfx	r0, r0, #5, #8
 8002f90:	4770      	bx	lr
 8002f92:	bf00      	nop
 8002f94:	40023c00 	.word	0x40023c00

08002f98 <FLASH_OB_GetWRP>:
  * @retval The FLASH Write Protection  Option Bytes value
  */
uint16_t FLASH_OB_GetWRP(void)
{
  /* Return the FLASH write protection Register value */
  return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
 8002f98:	4b01      	ldr	r3, [pc, #4]	; (8002fa0 <FLASH_OB_GetWRP+0x8>)
 8002f9a:	8818      	ldrh	r0, [r3, #0]
}
 8002f9c:	b280      	uxth	r0, r0
 8002f9e:	4770      	bx	lr
 8002fa0:	40023c16 	.word	0x40023c16

08002fa4 <FLASH_OB_GetWRP1>:
  * @retval The FLASH Write Protection  Option Bytes value
  */
uint16_t FLASH_OB_GetWRP1(void)
{
  /* Return the FLASH write protection Register value */
  return (*(__IO uint16_t *)(OPTCR1_BYTE2_ADDRESS));
 8002fa4:	4b01      	ldr	r3, [pc, #4]	; (8002fac <FLASH_OB_GetWRP1+0x8>)
 8002fa6:	8818      	ldrh	r0, [r3, #0]
}
 8002fa8:	b280      	uxth	r0, r0
 8002faa:	4770      	bx	lr
 8002fac:	40023c1a 	.word	0x40023c1a

08002fb0 <FLASH_OB_GetRDP>:
  */
FlagStatus FLASH_OB_GetRDP(void)
{
  FlagStatus readstatus = RESET;

  if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
 8002fb0:	4b04      	ldr	r3, [pc, #16]	; (8002fc4 <FLASH_OB_GetRDP+0x14>)
 8002fb2:	781b      	ldrb	r3, [r3, #0]
 8002fb4:	b2db      	uxtb	r3, r3
 8002fb6:	2baa      	cmp	r3, #170	; 0xaa
 8002fb8:	d001      	beq.n	8002fbe <FLASH_OB_GetRDP+0xe>
  {
    readstatus = SET;
 8002fba:	2001      	movs	r0, #1
 8002fbc:	4770      	bx	lr
  }
  else
  {
    readstatus = RESET;
 8002fbe:	2000      	movs	r0, #0
  }
  return readstatus;
}
 8002fc0:	4770      	bx	lr
 8002fc2:	bf00      	nop
 8002fc4:	40023c15 	.word	0x40023c15

08002fc8 <FLASH_OB_GetBOR>:
  *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
  */
uint8_t FLASH_OB_GetBOR(void)
{
  /* Return the FLASH BOR level */
  return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
 8002fc8:	4b02      	ldr	r3, [pc, #8]	; (8002fd4 <FLASH_OB_GetBOR+0xc>)
 8002fca:	7818      	ldrb	r0, [r3, #0]
}
 8002fcc:	f000 000c 	and.w	r0, r0, #12
 8002fd0:	4770      	bx	lr
 8002fd2:	bf00      	nop
 8002fd4:	40023c14 	.word	0x40023c14

08002fd8 <FLASH_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_IT(FLASH_IT)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if(NewState != DISABLE)
 8002fd8:	b929      	cbnz	r1, 8002fe6 <FLASH_ITConfig+0xe>
    FLASH->CR |= FLASH_IT;
  }
  else
  {
    /* Disable the interrupt sources */
    FLASH->CR &= ~(uint32_t)FLASH_IT;
 8002fda:	4a05      	ldr	r2, [pc, #20]	; (8002ff0 <FLASH_ITConfig+0x18>)
 8002fdc:	6913      	ldr	r3, [r2, #16]
 8002fde:	ea23 0000 	bic.w	r0, r3, r0
 8002fe2:	6110      	str	r0, [r2, #16]
 8002fe4:	4770      	bx	lr
    FLASH->CR |= FLASH_IT;
 8002fe6:	4a02      	ldr	r2, [pc, #8]	; (8002ff0 <FLASH_ITConfig+0x18>)
 8002fe8:	6913      	ldr	r3, [r2, #16]
 8002fea:	4318      	orrs	r0, r3
 8002fec:	6110      	str	r0, [r2, #16]
 8002fee:	4770      	bx	lr
 8002ff0:	40023c00 	.word	0x40023c00

08002ff4 <FLASH_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));

  if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
 8002ff4:	4b03      	ldr	r3, [pc, #12]	; (8003004 <FLASH_GetFlagStatus+0x10>)
 8002ff6:	68db      	ldr	r3, [r3, #12]
 8002ff8:	4203      	tst	r3, r0
 8002ffa:	d101      	bne.n	8003000 <FLASH_GetFlagStatus+0xc>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8002ffc:	2000      	movs	r0, #0
  }
  /* Return the new state of FLASH_FLAG (SET or RESET) */
  return bitstatus; 
}
 8002ffe:	4770      	bx	lr
    bitstatus = SET;
 8003000:	2001      	movs	r0, #1
 8003002:	4770      	bx	lr
 8003004:	40023c00 	.word	0x40023c00

08003008 <FLASH_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 8003008:	4b01      	ldr	r3, [pc, #4]	; (8003010 <FLASH_ClearFlag+0x8>)
 800300a:	60d8      	str	r0, [r3, #12]
 800300c:	4770      	bx	lr
 800300e:	bf00      	nop
 8003010:	40023c00 	.word	0x40023c00

08003014 <FLASH_GetStatus>:
  */
FLASH_Status FLASH_GetStatus(void)
{
  FLASH_Status flashstatus = FLASH_COMPLETE;
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 8003014:	4b0e      	ldr	r3, [pc, #56]	; (8003050 <FLASH_GetStatus+0x3c>)
 8003016:	68db      	ldr	r3, [r3, #12]
 8003018:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 800301c:	d114      	bne.n	8003048 <FLASH_GetStatus+0x34>
  {
    flashstatus = FLASH_BUSY;
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
 800301e:	4b0c      	ldr	r3, [pc, #48]	; (8003050 <FLASH_GetStatus+0x3c>)
 8003020:	68db      	ldr	r3, [r3, #12]
 8003022:	f013 0f10 	tst.w	r3, #16
 8003026:	d001      	beq.n	800302c <FLASH_GetStatus+0x18>
    { 
      flashstatus = FLASH_ERROR_WRP;
 8003028:	2005      	movs	r0, #5
 800302a:	4770      	bx	lr
    }
    else
    {
      if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
 800302c:	4b08      	ldr	r3, [pc, #32]	; (8003050 <FLASH_GetStatus+0x3c>)
 800302e:	68db      	ldr	r3, [r3, #12]
 8003030:	f013 0fef 	tst.w	r3, #239	; 0xef
 8003034:	d001      	beq.n	800303a <FLASH_GetStatus+0x26>
      {
        flashstatus = FLASH_ERROR_PROGRAM; 
 8003036:	2006      	movs	r0, #6
 8003038:	4770      	bx	lr
      }
      else
      {
        if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
 800303a:	4b05      	ldr	r3, [pc, #20]	; (8003050 <FLASH_GetStatus+0x3c>)
 800303c:	68db      	ldr	r3, [r3, #12]
 800303e:	f013 0f02 	tst.w	r3, #2
 8003042:	d003      	beq.n	800304c <FLASH_GetStatus+0x38>
        {
          flashstatus = FLASH_ERROR_OPERATION;
 8003044:	2007      	movs	r0, #7
 8003046:	4770      	bx	lr
    flashstatus = FLASH_BUSY;
 8003048:	2001      	movs	r0, #1
 800304a:	4770      	bx	lr
        }
        else
        {
          flashstatus = FLASH_COMPLETE;
 800304c:	2008      	movs	r0, #8
      }
    }
  }
  /* Return the FLASH Status */
  return flashstatus;
}
 800304e:	4770      	bx	lr
 8003050:	40023c00 	.word	0x40023c00

08003054 <FLASH_WaitForLastOperation>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_WaitForLastOperation(void)
{ 
 8003054:	b500      	push	{lr}
 8003056:	b083      	sub	sp, #12
  __IO FLASH_Status status = FLASH_COMPLETE;
 8003058:	2308      	movs	r3, #8
 800305a:	f88d 3007 	strb.w	r3, [sp, #7]
   
  /* Check for the FLASH Status */
  status = FLASH_GetStatus();
 800305e:	f7ff ffd9 	bl	8003014 <FLASH_GetStatus>
 8003062:	f88d 0007 	strb.w	r0, [sp, #7]

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
 8003066:	e003      	b.n	8003070 <FLASH_WaitForLastOperation+0x1c>
  {
    status = FLASH_GetStatus();
 8003068:	f7ff ffd4 	bl	8003014 <FLASH_GetStatus>
 800306c:	f88d 0007 	strb.w	r0, [sp, #7]
  while(status == FLASH_BUSY)
 8003070:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003074:	b2db      	uxtb	r3, r3
 8003076:	2b01      	cmp	r3, #1
 8003078:	d0f6      	beq.n	8003068 <FLASH_WaitForLastOperation+0x14>
  }
  /* Return the operation status */
  return status;
 800307a:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 800307e:	b003      	add	sp, #12
 8003080:	f85d fb04 	ldr.w	pc, [sp], #4

08003084 <FLASH_EraseSector>:
{
 8003084:	b570      	push	{r4, r5, r6, lr}
 8003086:	4606      	mov	r6, r0
  if(VoltageRange == VoltageRange_1)
 8003088:	b149      	cbz	r1, 800309e <FLASH_EraseSector+0x1a>
  else if(VoltageRange == VoltageRange_2)
 800308a:	2901      	cmp	r1, #1
 800308c:	d00d      	beq.n	80030aa <FLASH_EraseSector+0x26>
  else if(VoltageRange == VoltageRange_3)
 800308e:	2902      	cmp	r1, #2
 8003090:	d002      	beq.n	8003098 <FLASH_EraseSector+0x14>
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 8003092:	f44f 7540 	mov.w	r5, #768	; 0x300
 8003096:	e003      	b.n	80030a0 <FLASH_EraseSector+0x1c>
    tmp_psize = FLASH_PSIZE_WORD;
 8003098:	f44f 7500 	mov.w	r5, #512	; 0x200
 800309c:	e000      	b.n	80030a0 <FLASH_EraseSector+0x1c>
     tmp_psize = FLASH_PSIZE_BYTE;
 800309e:	2500      	movs	r5, #0
  status = FLASH_WaitForLastOperation();
 80030a0:	f7ff ffd8 	bl	8003054 <FLASH_WaitForLastOperation>
  if(status == FLASH_COMPLETE)
 80030a4:	2808      	cmp	r0, #8
 80030a6:	d003      	beq.n	80030b0 <FLASH_EraseSector+0x2c>
}
 80030a8:	bd70      	pop	{r4, r5, r6, pc}
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 80030aa:	f44f 7580 	mov.w	r5, #256	; 0x100
 80030ae:	e7f7      	b.n	80030a0 <FLASH_EraseSector+0x1c>
    FLASH->CR &= CR_PSIZE_MASK;
 80030b0:	4c0f      	ldr	r4, [pc, #60]	; (80030f0 <FLASH_EraseSector+0x6c>)
 80030b2:	6923      	ldr	r3, [r4, #16]
 80030b4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80030b8:	6123      	str	r3, [r4, #16]
    FLASH->CR |= tmp_psize;
 80030ba:	6923      	ldr	r3, [r4, #16]
 80030bc:	431d      	orrs	r5, r3
 80030be:	6125      	str	r5, [r4, #16]
    FLASH->CR &= SECTOR_MASK;
 80030c0:	6923      	ldr	r3, [r4, #16]
 80030c2:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80030c6:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
 80030c8:	6923      	ldr	r3, [r4, #16]
 80030ca:	431e      	orrs	r6, r3
 80030cc:	f046 0602 	orr.w	r6, r6, #2
 80030d0:	6126      	str	r6, [r4, #16]
    FLASH->CR |= FLASH_CR_STRT;
 80030d2:	6923      	ldr	r3, [r4, #16]
 80030d4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80030d8:	6123      	str	r3, [r4, #16]
    status = FLASH_WaitForLastOperation();
 80030da:	f7ff ffbb 	bl	8003054 <FLASH_WaitForLastOperation>
    FLASH->CR &= (~FLASH_CR_SER);
 80030de:	6923      	ldr	r3, [r4, #16]
 80030e0:	f023 0302 	bic.w	r3, r3, #2
 80030e4:	6123      	str	r3, [r4, #16]
    FLASH->CR &= SECTOR_MASK; 
 80030e6:	6923      	ldr	r3, [r4, #16]
 80030e8:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80030ec:	6123      	str	r3, [r4, #16]
 80030ee:	e7db      	b.n	80030a8 <FLASH_EraseSector+0x24>
 80030f0:	40023c00 	.word	0x40023c00

080030f4 <FLASH_EraseAllSectors>:
{
 80030f4:	b510      	push	{r4, lr}
 80030f6:	4604      	mov	r4, r0
  status = FLASH_WaitForLastOperation();
 80030f8:	f7ff ffac 	bl	8003054 <FLASH_WaitForLastOperation>
  if(VoltageRange == VoltageRange_1)
 80030fc:	b14c      	cbz	r4, 8003112 <FLASH_EraseAllSectors+0x1e>
  else if(VoltageRange == VoltageRange_2)
 80030fe:	2c01      	cmp	r4, #1
 8003100:	d00b      	beq.n	800311a <FLASH_EraseAllSectors+0x26>
  else if(VoltageRange == VoltageRange_3)
 8003102:	2c02      	cmp	r4, #2
 8003104:	d002      	beq.n	800310c <FLASH_EraseAllSectors+0x18>
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 8003106:	f44f 7340 	mov.w	r3, #768	; 0x300
 800310a:	e003      	b.n	8003114 <FLASH_EraseAllSectors+0x20>
    tmp_psize = FLASH_PSIZE_WORD;
 800310c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003110:	e000      	b.n	8003114 <FLASH_EraseAllSectors+0x20>
     tmp_psize = FLASH_PSIZE_BYTE;
 8003112:	2300      	movs	r3, #0
  if(status == FLASH_COMPLETE)
 8003114:	2808      	cmp	r0, #8
 8003116:	d003      	beq.n	8003120 <FLASH_EraseAllSectors+0x2c>
}
 8003118:	bd10      	pop	{r4, pc}
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 800311a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800311e:	e7f9      	b.n	8003114 <FLASH_EraseAllSectors+0x20>
    FLASH->CR &= CR_PSIZE_MASK;
 8003120:	4c0b      	ldr	r4, [pc, #44]	; (8003150 <FLASH_EraseAllSectors+0x5c>)
 8003122:	6922      	ldr	r2, [r4, #16]
 8003124:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8003128:	6122      	str	r2, [r4, #16]
    FLASH->CR |= tmp_psize;
 800312a:	6922      	ldr	r2, [r4, #16]
 800312c:	4313      	orrs	r3, r2
 800312e:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_MER;
 8003130:	6923      	ldr	r3, [r4, #16]
 8003132:	f043 0304 	orr.w	r3, r3, #4
 8003136:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_STRT;
 8003138:	6923      	ldr	r3, [r4, #16]
 800313a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800313e:	6123      	str	r3, [r4, #16]
    status = FLASH_WaitForLastOperation();
 8003140:	f7ff ff88 	bl	8003054 <FLASH_WaitForLastOperation>
    FLASH->CR &= (~FLASH_CR_MER);
 8003144:	6923      	ldr	r3, [r4, #16]
 8003146:	f023 0304 	bic.w	r3, r3, #4
 800314a:	6123      	str	r3, [r4, #16]
 800314c:	e7e4      	b.n	8003118 <FLASH_EraseAllSectors+0x24>
 800314e:	bf00      	nop
 8003150:	40023c00 	.word	0x40023c00

08003154 <FLASH_ProgramDoubleWord>:
{
 8003154:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003156:	4605      	mov	r5, r0
 8003158:	4616      	mov	r6, r2
 800315a:	461f      	mov	r7, r3
  status = FLASH_WaitForLastOperation();
 800315c:	f7ff ff7a 	bl	8003054 <FLASH_WaitForLastOperation>
  if(status == FLASH_COMPLETE)
 8003160:	2808      	cmp	r0, #8
 8003162:	d000      	beq.n	8003166 <FLASH_ProgramDoubleWord+0x12>
}
 8003164:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    FLASH->CR &= CR_PSIZE_MASK;
 8003166:	4c0b      	ldr	r4, [pc, #44]	; (8003194 <FLASH_ProgramDoubleWord+0x40>)
 8003168:	6923      	ldr	r3, [r4, #16]
 800316a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800316e:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
 8003170:	6923      	ldr	r3, [r4, #16]
 8003172:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 8003176:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_PG;
 8003178:	6923      	ldr	r3, [r4, #16]
 800317a:	f043 0301 	orr.w	r3, r3, #1
 800317e:	6123      	str	r3, [r4, #16]
    *(__IO uint64_t*)Address = Data;
 8003180:	e9c5 6700 	strd	r6, r7, [r5]
    status = FLASH_WaitForLastOperation();
 8003184:	f7ff ff66 	bl	8003054 <FLASH_WaitForLastOperation>
    FLASH->CR &= (~FLASH_CR_PG);
 8003188:	6923      	ldr	r3, [r4, #16]
 800318a:	f023 0301 	bic.w	r3, r3, #1
 800318e:	6123      	str	r3, [r4, #16]
 8003190:	e7e8      	b.n	8003164 <FLASH_ProgramDoubleWord+0x10>
 8003192:	bf00      	nop
 8003194:	40023c00 	.word	0x40023c00

08003198 <FLASH_ProgramWord>:
{
 8003198:	b570      	push	{r4, r5, r6, lr}
 800319a:	4605      	mov	r5, r0
 800319c:	460e      	mov	r6, r1
  status = FLASH_WaitForLastOperation();
 800319e:	f7ff ff59 	bl	8003054 <FLASH_WaitForLastOperation>
  if(status == FLASH_COMPLETE)
 80031a2:	2808      	cmp	r0, #8
 80031a4:	d000      	beq.n	80031a8 <FLASH_ProgramWord+0x10>
}
 80031a6:	bd70      	pop	{r4, r5, r6, pc}
    FLASH->CR &= CR_PSIZE_MASK;
 80031a8:	4c0a      	ldr	r4, [pc, #40]	; (80031d4 <FLASH_ProgramWord+0x3c>)
 80031aa:	6923      	ldr	r3, [r4, #16]
 80031ac:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80031b0:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_PSIZE_WORD;
 80031b2:	6923      	ldr	r3, [r4, #16]
 80031b4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80031b8:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_PG;
 80031ba:	6923      	ldr	r3, [r4, #16]
 80031bc:	f043 0301 	orr.w	r3, r3, #1
 80031c0:	6123      	str	r3, [r4, #16]
    *(__IO uint32_t*)Address = Data;
 80031c2:	602e      	str	r6, [r5, #0]
    status = FLASH_WaitForLastOperation();
 80031c4:	f7ff ff46 	bl	8003054 <FLASH_WaitForLastOperation>
    FLASH->CR &= (~FLASH_CR_PG);
 80031c8:	6923      	ldr	r3, [r4, #16]
 80031ca:	f023 0301 	bic.w	r3, r3, #1
 80031ce:	6123      	str	r3, [r4, #16]
 80031d0:	e7e9      	b.n	80031a6 <FLASH_ProgramWord+0xe>
 80031d2:	bf00      	nop
 80031d4:	40023c00 	.word	0x40023c00

080031d8 <FLASH_ProgramHalfWord>:
{
 80031d8:	b570      	push	{r4, r5, r6, lr}
 80031da:	4605      	mov	r5, r0
 80031dc:	460e      	mov	r6, r1
  status = FLASH_WaitForLastOperation();
 80031de:	f7ff ff39 	bl	8003054 <FLASH_WaitForLastOperation>
  if(status == FLASH_COMPLETE)
 80031e2:	2808      	cmp	r0, #8
 80031e4:	d000      	beq.n	80031e8 <FLASH_ProgramHalfWord+0x10>
}
 80031e6:	bd70      	pop	{r4, r5, r6, pc}
    FLASH->CR &= CR_PSIZE_MASK;
 80031e8:	4c0a      	ldr	r4, [pc, #40]	; (8003214 <FLASH_ProgramHalfWord+0x3c>)
 80031ea:	6923      	ldr	r3, [r4, #16]
 80031ec:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80031f0:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_PSIZE_HALF_WORD;
 80031f2:	6923      	ldr	r3, [r4, #16]
 80031f4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80031f8:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_PG;
 80031fa:	6923      	ldr	r3, [r4, #16]
 80031fc:	f043 0301 	orr.w	r3, r3, #1
 8003200:	6123      	str	r3, [r4, #16]
    *(__IO uint16_t*)Address = Data;
 8003202:	802e      	strh	r6, [r5, #0]
    status = FLASH_WaitForLastOperation();
 8003204:	f7ff ff26 	bl	8003054 <FLASH_WaitForLastOperation>
    FLASH->CR &= (~FLASH_CR_PG);
 8003208:	6923      	ldr	r3, [r4, #16]
 800320a:	f023 0301 	bic.w	r3, r3, #1
 800320e:	6123      	str	r3, [r4, #16]
 8003210:	e7e9      	b.n	80031e6 <FLASH_ProgramHalfWord+0xe>
 8003212:	bf00      	nop
 8003214:	40023c00 	.word	0x40023c00

08003218 <FLASH_ProgramByte>:
{
 8003218:	b570      	push	{r4, r5, r6, lr}
 800321a:	4605      	mov	r5, r0
 800321c:	460e      	mov	r6, r1
  status = FLASH_WaitForLastOperation();
 800321e:	f7ff ff19 	bl	8003054 <FLASH_WaitForLastOperation>
  if(status == FLASH_COMPLETE)
 8003222:	2808      	cmp	r0, #8
 8003224:	d000      	beq.n	8003228 <FLASH_ProgramByte+0x10>
}
 8003226:	bd70      	pop	{r4, r5, r6, pc}
    FLASH->CR &= CR_PSIZE_MASK;
 8003228:	4c09      	ldr	r4, [pc, #36]	; (8003250 <FLASH_ProgramByte+0x38>)
 800322a:	6923      	ldr	r3, [r4, #16]
 800322c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8003230:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_PSIZE_BYTE;
 8003232:	6923      	ldr	r3, [r4, #16]
 8003234:	6123      	str	r3, [r4, #16]
    FLASH->CR |= FLASH_CR_PG;
 8003236:	6923      	ldr	r3, [r4, #16]
 8003238:	f043 0301 	orr.w	r3, r3, #1
 800323c:	6123      	str	r3, [r4, #16]
    *(__IO uint8_t*)Address = Data;
 800323e:	702e      	strb	r6, [r5, #0]
    status = FLASH_WaitForLastOperation();
 8003240:	f7ff ff08 	bl	8003054 <FLASH_WaitForLastOperation>
    FLASH->CR &= (~FLASH_CR_PG);
 8003244:	6923      	ldr	r3, [r4, #16]
 8003246:	f023 0301 	bic.w	r3, r3, #1
 800324a:	6123      	str	r3, [r4, #16]
 800324c:	e7eb      	b.n	8003226 <FLASH_ProgramByte+0xe>
 800324e:	bf00      	nop
 8003250:	40023c00 	.word	0x40023c00

08003254 <FLASH_OB_WRPConfig>:
{ 
 8003254:	b538      	push	{r3, r4, r5, lr}
 8003256:	4604      	mov	r4, r0
 8003258:	460d      	mov	r5, r1
  status = FLASH_WaitForLastOperation();
 800325a:	f7ff fefb 	bl	8003054 <FLASH_WaitForLastOperation>
  if(status == FLASH_COMPLETE)
 800325e:	2808      	cmp	r0, #8
 8003260:	d000      	beq.n	8003264 <FLASH_OB_WRPConfig+0x10>
 8003262:	bd38      	pop	{r3, r4, r5, pc}
    if(NewState != DISABLE)
 8003264:	b935      	cbnz	r5, 8003274 <FLASH_OB_WRPConfig+0x20>
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
 8003266:	4a07      	ldr	r2, [pc, #28]	; (8003284 <FLASH_OB_WRPConfig+0x30>)
 8003268:	8813      	ldrh	r3, [r2, #0]
 800326a:	b29b      	uxth	r3, r3
 800326c:	b2a4      	uxth	r4, r4
 800326e:	431c      	orrs	r4, r3
 8003270:	8014      	strh	r4, [r2, #0]
}
 8003272:	e7f6      	b.n	8003262 <FLASH_OB_WRPConfig+0xe>
      *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
 8003274:	4a03      	ldr	r2, [pc, #12]	; (8003284 <FLASH_OB_WRPConfig+0x30>)
 8003276:	8813      	ldrh	r3, [r2, #0]
 8003278:	b29b      	uxth	r3, r3
 800327a:	ea23 0404 	bic.w	r4, r3, r4
 800327e:	8014      	strh	r4, [r2, #0]
 8003280:	bd38      	pop	{r3, r4, r5, pc}
 8003282:	bf00      	nop
 8003284:	40023c16 	.word	0x40023c16

08003288 <FLASH_OB_WRP1Config>:
{ 
 8003288:	b538      	push	{r3, r4, r5, lr}
 800328a:	4604      	mov	r4, r0
 800328c:	460d      	mov	r5, r1
  status = FLASH_WaitForLastOperation();
 800328e:	f7ff fee1 	bl	8003054 <FLASH_WaitForLastOperation>
  if(status == FLASH_COMPLETE)
 8003292:	2808      	cmp	r0, #8
 8003294:	d000      	beq.n	8003298 <FLASH_OB_WRP1Config+0x10>
 8003296:	bd38      	pop	{r3, r4, r5, pc}
    if(NewState != DISABLE)
 8003298:	b935      	cbnz	r5, 80032a8 <FLASH_OB_WRP1Config+0x20>
      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
 800329a:	4a07      	ldr	r2, [pc, #28]	; (80032b8 <FLASH_OB_WRP1Config+0x30>)
 800329c:	8813      	ldrh	r3, [r2, #0]
 800329e:	b29b      	uxth	r3, r3
 80032a0:	b2a4      	uxth	r4, r4
 80032a2:	431c      	orrs	r4, r3
 80032a4:	8014      	strh	r4, [r2, #0]
}
 80032a6:	e7f6      	b.n	8003296 <FLASH_OB_WRP1Config+0xe>
      *(__IO uint16_t*)OPTCR1_BYTE2_ADDRESS &= (~OB_WRP);
 80032a8:	4a03      	ldr	r2, [pc, #12]	; (80032b8 <FLASH_OB_WRP1Config+0x30>)
 80032aa:	8813      	ldrh	r3, [r2, #0]
 80032ac:	b29b      	uxth	r3, r3
 80032ae:	ea23 0404 	bic.w	r4, r3, r4
 80032b2:	8014      	strh	r4, [r2, #0]
 80032b4:	bd38      	pop	{r3, r4, r5, pc}
 80032b6:	bf00      	nop
 80032b8:	40023c1a 	.word	0x40023c1a

080032bc <FLASH_OB_RDPConfig>:
{
 80032bc:	b510      	push	{r4, lr}
 80032be:	4604      	mov	r4, r0
  status = FLASH_WaitForLastOperation();
 80032c0:	f7ff fec8 	bl	8003054 <FLASH_WaitForLastOperation>
  if(status == FLASH_COMPLETE)
 80032c4:	2808      	cmp	r0, #8
 80032c6:	d000      	beq.n	80032ca <FLASH_OB_RDPConfig+0xe>
 80032c8:	bd10      	pop	{r4, pc}
    *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
 80032ca:	4b01      	ldr	r3, [pc, #4]	; (80032d0 <FLASH_OB_RDPConfig+0x14>)
 80032cc:	701c      	strb	r4, [r3, #0]
}
 80032ce:	e7fb      	b.n	80032c8 <FLASH_OB_RDPConfig+0xc>
 80032d0:	40023c15 	.word	0x40023c15

080032d4 <FLASH_OB_UserConfig>:
{
 80032d4:	b570      	push	{r4, r5, r6, lr}
 80032d6:	4604      	mov	r4, r0
 80032d8:	460e      	mov	r6, r1
 80032da:	4615      	mov	r5, r2
  status = FLASH_WaitForLastOperation();
 80032dc:	f7ff feba 	bl	8003054 <FLASH_WaitForLastOperation>
  if(status == FLASH_COMPLETE)
 80032e0:	2808      	cmp	r0, #8
 80032e2:	d000      	beq.n	80032e6 <FLASH_OB_UserConfig+0x12>
 80032e4:	bd70      	pop	{r4, r5, r6, pc}
    optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
 80032e6:	4b04      	ldr	r3, [pc, #16]	; (80032f8 <FLASH_OB_UserConfig+0x24>)
 80032e8:	7818      	ldrb	r0, [r3, #0]
 80032ea:	f000 000f 	and.w	r0, r0, #15
    *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
 80032ee:	4330      	orrs	r0, r6
 80032f0:	4328      	orrs	r0, r5
 80032f2:	4320      	orrs	r0, r4
 80032f4:	7018      	strb	r0, [r3, #0]
}
 80032f6:	e7f5      	b.n	80032e4 <FLASH_OB_UserConfig+0x10>
 80032f8:	40023c14 	.word	0x40023c14

080032fc <FLASH_OB_Launch>:
{
 80032fc:	b508      	push	{r3, lr}
  *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
 80032fe:	4a04      	ldr	r2, [pc, #16]	; (8003310 <FLASH_OB_Launch+0x14>)
 8003300:	7813      	ldrb	r3, [r2, #0]
 8003302:	f043 0302 	orr.w	r3, r3, #2
 8003306:	7013      	strb	r3, [r2, #0]
  status = FLASH_WaitForLastOperation();
 8003308:	f7ff fea4 	bl	8003054 <FLASH_WaitForLastOperation>
}
 800330c:	bd08      	pop	{r3, pc}
 800330e:	bf00      	nop
 8003310:	40023c14 	.word	0x40023c14

08003314 <FSMC_NORSRAMDeInit>:
{
  /* Check the parameter */
  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
  
  /* FSMC_Bank1_NORSRAM1 */
  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
 8003314:	4603      	mov	r3, r0
 8003316:	b188      	cbz	r0, 800333c <FSMC_NORSRAMDeInit+0x28>
    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
  }
  /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
  else
  {   
    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
 8003318:	f243 01d2 	movw	r1, #12498	; 0x30d2
 800331c:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 8003320:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
  }
  FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
 8003324:	1c58      	adds	r0, r3, #1
 8003326:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 800332a:	f04f 4120 	mov.w	r1, #2684354560	; 0xa0000000
 800332e:	f841 2020 	str.w	r2, [r1, r0, lsl #2]
  FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
 8003332:	f501 7182 	add.w	r1, r1, #260	; 0x104
 8003336:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 800333a:	4770      	bx	lr
    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
 800333c:	f243 01db 	movw	r1, #12507	; 0x30db
 8003340:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 8003344:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
 8003348:	e7ec      	b.n	8003324 <FSMC_NORSRAMDeInit+0x10>

0800334a <FSMC_NORSRAMInit>:
  *         that contains the configuration information for the FSMC NOR/SRAM 
  *         specified Banks.                       
  * @retval None
  */
void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{ 
 800334a:	b410      	push	{r4}
  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
  
  /* Bank1 NOR/SRAM control register configuration */ 
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 800334c:	6802      	ldr	r2, [r0, #0]
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
 800334e:	6843      	ldr	r3, [r0, #4]
            FSMC_NORSRAMInitStruct->FSMC_MemoryType |
 8003350:	6881      	ldr	r1, [r0, #8]
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
 8003352:	430b      	orrs	r3, r1
            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
 8003354:	68c1      	ldr	r1, [r0, #12]
            FSMC_NORSRAMInitStruct->FSMC_MemoryType |
 8003356:	430b      	orrs	r3, r1
            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
 8003358:	6901      	ldr	r1, [r0, #16]
            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
 800335a:	430b      	orrs	r3, r1
            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
 800335c:	6941      	ldr	r1, [r0, #20]
            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
 800335e:	430b      	orrs	r3, r1
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
 8003360:	6981      	ldr	r1, [r0, #24]
            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
 8003362:	430b      	orrs	r3, r1
            FSMC_NORSRAMInitStruct->FSMC_WrapMode |
 8003364:	69c1      	ldr	r1, [r0, #28]
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
 8003366:	430b      	orrs	r3, r1
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
 8003368:	6a01      	ldr	r1, [r0, #32]
            FSMC_NORSRAMInitStruct->FSMC_WrapMode |
 800336a:	430b      	orrs	r3, r1
            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
 800336c:	6a41      	ldr	r1, [r0, #36]	; 0x24
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
 800336e:	430b      	orrs	r3, r1
            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
 8003370:	6a81      	ldr	r1, [r0, #40]	; 0x28
            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
 8003372:	430b      	orrs	r3, r1
            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
 8003374:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
 8003376:	430b      	orrs	r3, r1
            FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
 8003378:	6b01      	ldr	r1, [r0, #48]	; 0x30
            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
 800337a:	430b      	orrs	r3, r1
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 800337c:	f04f 4120 	mov.w	r1, #2684354560	; 0xa0000000
 8003380:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
 8003384:	6883      	ldr	r3, [r0, #8]
 8003386:	2b08      	cmp	r3, #8
 8003388:	d025      	beq.n	80033d6 <FSMC_NORSRAMInit+0x8c>
  {
    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
  }
  /* Bank1 NOR/SRAM timing register configuration */
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
 800338a:	6801      	ldr	r1, [r0, #0]
 800338c:	3101      	adds	r1, #1
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
 800338e:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8003390:	6813      	ldr	r3, [r2, #0]
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
 8003392:	6854      	ldr	r4, [r2, #4]
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
 8003394:	ea43 1304 	orr.w	r3, r3, r4, lsl #4
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
 8003398:	6894      	ldr	r4, [r2, #8]
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
 800339a:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
 800339e:	68d4      	ldr	r4, [r2, #12]
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
 80033a0:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
 80033a4:	6914      	ldr	r4, [r2, #16]
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
 80033a6:	ea43 5304 	orr.w	r3, r3, r4, lsl #20
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
 80033aa:	6954      	ldr	r4, [r2, #20]
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
 80033ac:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
             FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
 80033b0:	6992      	ldr	r2, [r2, #24]
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
 80033b2:	4313      	orrs	r3, r2
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
 80033b4:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 80033b8:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
            
    
  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
  if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
 80033bc:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 80033be:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80033c2:	d012      	beq.n	80033ea <FSMC_NORSRAMInit+0xa0>
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
               FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
  }
  else
  {
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
 80033c4:	6802      	ldr	r2, [r0, #0]
 80033c6:	f06f 4170 	mvn.w	r1, #4026531840	; 0xf0000000
 80033ca:	4b12      	ldr	r3, [pc, #72]	; (8003414 <FSMC_NORSRAMInit+0xca>)
 80033cc:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  }
}
 80033d0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80033d4:	4770      	bx	lr
    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
 80033d6:	6801      	ldr	r1, [r0, #0]
 80033d8:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 80033dc:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 80033e0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80033e4:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 80033e8:	e7cf      	b.n	800338a <FSMC_NORSRAMInit+0x40>
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 80033ea:	6801      	ldr	r1, [r0, #0]
              (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
 80033ec:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80033ee:	6813      	ldr	r3, [r2, #0]
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
 80033f0:	6850      	ldr	r0, [r2, #4]
              (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
 80033f2:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
 80033f6:	6890      	ldr	r0, [r2, #8]
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
 80033f8:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
 80033fc:	6910      	ldr	r0, [r2, #16]
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
 80033fe:	ea43 5300 	orr.w	r3, r3, r0, lsl #20
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
 8003402:	6950      	ldr	r0, [r2, #20]
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
 8003404:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
               FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
 8003408:	6992      	ldr	r2, [r2, #24]
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
 800340a:	4313      	orrs	r3, r2
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 800340c:	4a01      	ldr	r2, [pc, #4]	; (8003414 <FSMC_NORSRAMInit+0xca>)
 800340e:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 8003412:	e7dd      	b.n	80033d0 <FSMC_NORSRAMInit+0x86>
 8003414:	a0000104 	.word	0xa0000104

08003418 <FSMC_NORSRAMStructInit>:
  * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef structure 
  *         which will be initialized.
  * @retval None
  */
void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{  
 8003418:	b410      	push	{r4}
  /* Reset NOR/SRAM Init structure parameters values */
  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
 800341a:	2300      	movs	r3, #0
 800341c:	6003      	str	r3, [r0, #0]
  FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
 800341e:	2202      	movs	r2, #2
 8003420:	6042      	str	r2, [r0, #4]
  FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
 8003422:	6083      	str	r3, [r0, #8]
  FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
 8003424:	60c3      	str	r3, [r0, #12]
  FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
 8003426:	6103      	str	r3, [r0, #16]
  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
 8003428:	6143      	str	r3, [r0, #20]
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
 800342a:	6183      	str	r3, [r0, #24]
  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
 800342c:	61c3      	str	r3, [r0, #28]
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
 800342e:	6203      	str	r3, [r0, #32]
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
 8003430:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8003434:	6242      	str	r2, [r0, #36]	; 0x24
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
 8003436:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800343a:	6282      	str	r2, [r0, #40]	; 0x28
  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
 800343c:	62c3      	str	r3, [r0, #44]	; 0x2c
  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
 800343e:	6303      	str	r3, [r0, #48]	; 0x30
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 8003440:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8003442:	220f      	movs	r2, #15
 8003444:	600a      	str	r2, [r1, #0]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
 8003446:	6b41      	ldr	r1, [r0, #52]	; 0x34
 8003448:	604a      	str	r2, [r1, #4]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
 800344a:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800344c:	21ff      	movs	r1, #255	; 0xff
 800344e:	60a1      	str	r1, [r4, #8]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
 8003450:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8003452:	60e2      	str	r2, [r4, #12]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
 8003454:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8003456:	6122      	str	r2, [r4, #16]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
 8003458:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800345a:	6162      	str	r2, [r4, #20]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
 800345c:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800345e:	61a3      	str	r3, [r4, #24]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 8003460:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8003462:	6022      	str	r2, [r4, #0]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
 8003464:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8003466:	6062      	str	r2, [r4, #4]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
 8003468:	6b84      	ldr	r4, [r0, #56]	; 0x38
 800346a:	60a1      	str	r1, [r4, #8]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
 800346c:	6b81      	ldr	r1, [r0, #56]	; 0x38
 800346e:	60ca      	str	r2, [r1, #12]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
 8003470:	6b81      	ldr	r1, [r0, #56]	; 0x38
 8003472:	610a      	str	r2, [r1, #16]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
 8003474:	6b81      	ldr	r1, [r0, #56]	; 0x38
 8003476:	614a      	str	r2, [r1, #20]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
 8003478:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800347a:	6193      	str	r3, [r2, #24]
}
 800347c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003480:	4770      	bx	lr

08003482 <FSMC_NORSRAMCmd>:
void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
{
  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003482:	b941      	cbnz	r1, 8003496 <FSMC_NORSRAMCmd+0x14>
    FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
  }
  else
  {
    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
 8003484:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 8003488:	f852 1020 	ldr.w	r1, [r2, r0, lsl #2]
 800348c:	4b06      	ldr	r3, [pc, #24]	; (80034a8 <FSMC_NORSRAMCmd+0x26>)
 800348e:	400b      	ands	r3, r1
 8003490:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 8003494:	4770      	bx	lr
    FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
 8003496:	f04f 4220 	mov.w	r2, #2684354560	; 0xa0000000
 800349a:	f852 3020 	ldr.w	r3, [r2, r0, lsl #2]
 800349e:	f043 0301 	orr.w	r3, r3, #1
 80034a2:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 80034a6:	4770      	bx	lr
 80034a8:	000ffffe 	.word	0x000ffffe

080034ac <FSMC_NANDDeInit>:
void FSMC_NANDDeInit(uint32_t FSMC_Bank)
{
  /* Check the parameter */
  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 80034ac:	2810      	cmp	r0, #16
 80034ae:	d009      	beq.n	80034c4 <FSMC_NANDDeInit+0x18>
  }
  /* FSMC_Bank3_NAND */  
  else
  {
    /* Set the FSMC_Bank3 registers to their reset values */
    FSMC_Bank3->PCR3 = 0x00000018;
 80034b0:	4b09      	ldr	r3, [pc, #36]	; (80034d8 <FSMC_NANDDeInit+0x2c>)
 80034b2:	2218      	movs	r2, #24
 80034b4:	601a      	str	r2, [r3, #0]
    FSMC_Bank3->SR3 = 0x00000040;
 80034b6:	2240      	movs	r2, #64	; 0x40
 80034b8:	605a      	str	r2, [r3, #4]
    FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
 80034ba:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
 80034be:	609a      	str	r2, [r3, #8]
    FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
 80034c0:	60da      	str	r2, [r3, #12]
 80034c2:	4770      	bx	lr
    FSMC_Bank2->PCR2 = 0x00000018;
 80034c4:	4b05      	ldr	r3, [pc, #20]	; (80034dc <FSMC_NANDDeInit+0x30>)
 80034c6:	2218      	movs	r2, #24
 80034c8:	601a      	str	r2, [r3, #0]
    FSMC_Bank2->SR2 = 0x00000040;
 80034ca:	2240      	movs	r2, #64	; 0x40
 80034cc:	605a      	str	r2, [r3, #4]
    FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
 80034ce:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
 80034d2:	609a      	str	r2, [r3, #8]
    FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
 80034d4:	60da      	str	r2, [r3, #12]
 80034d6:	4770      	bx	lr
 80034d8:	a0000080 	.word	0xa0000080
 80034dc:	a0000060 	.word	0xa0000060

080034e0 <FSMC_NANDInit>:
  * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef structure that
  *         contains the configuration information for the FSMC NAND specified Banks.                       
  * @retval None
  */
void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
{
 80034e0:	b430      	push	{r4, r5}
  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
 80034e2:	6843      	ldr	r3, [r0, #4]
            PCR_MEMORYTYPE_NAND |
            FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
 80034e4:	6882      	ldr	r2, [r0, #8]
            PCR_MEMORYTYPE_NAND |
 80034e6:	4313      	orrs	r3, r2
            FSMC_NANDInitStruct->FSMC_ECC |
 80034e8:	68c2      	ldr	r2, [r0, #12]
            FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
 80034ea:	4313      	orrs	r3, r2
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
 80034ec:	6902      	ldr	r2, [r0, #16]
            FSMC_NANDInitStruct->FSMC_ECC |
 80034ee:	4313      	orrs	r3, r2
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
 80034f0:	6942      	ldr	r2, [r0, #20]
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
 80034f2:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
 80034f6:	6982      	ldr	r2, [r0, #24]
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
 80034f8:	ea43 3342 	orr.w	r3, r3, r2, lsl #13
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
 80034fc:	f043 0308 	orr.w	r3, r3, #8
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 8003500:	69c1      	ldr	r1, [r0, #28]
 8003502:	680a      	ldr	r2, [r1, #0]
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 8003504:	684c      	ldr	r4, [r1, #4]
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 8003506:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800350a:	688c      	ldr	r4, [r1, #8]
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800350c:	ea42 4204 	orr.w	r2, r2, r4, lsl #16
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
 8003510:	68c9      	ldr	r1, [r1, #12]
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 8003512:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 8003516:	6a04      	ldr	r4, [r0, #32]
 8003518:	6822      	ldr	r2, [r4, #0]
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800351a:	6865      	ldr	r5, [r4, #4]
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800351c:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 8003520:	68a5      	ldr	r5, [r4, #8]
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 8003522:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
 8003526:	68e4      	ldr	r4, [r4, #12]
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 8003528:	ea42 6204 	orr.w	r2, r2, r4, lsl #24
  
  if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
 800352c:	6800      	ldr	r0, [r0, #0]
 800352e:	2810      	cmp	r0, #16
 8003530:	d005      	beq.n	800353e <FSMC_NANDInit+0x5e>
    FSMC_Bank2->PATT2 = tmppatt;
  }
  else
  {
    /* FSMC_Bank3_NAND registers configuration */
    FSMC_Bank3->PCR3 = tmppcr;
 8003532:	4805      	ldr	r0, [pc, #20]	; (8003548 <FSMC_NANDInit+0x68>)
 8003534:	6003      	str	r3, [r0, #0]
    FSMC_Bank3->PMEM3 = tmppmem;
 8003536:	6081      	str	r1, [r0, #8]
    FSMC_Bank3->PATT3 = tmppatt;
 8003538:	60c2      	str	r2, [r0, #12]
  }
}
 800353a:	bc30      	pop	{r4, r5}
 800353c:	4770      	bx	lr
    FSMC_Bank2->PCR2 = tmppcr;
 800353e:	4803      	ldr	r0, [pc, #12]	; (800354c <FSMC_NANDInit+0x6c>)
 8003540:	6003      	str	r3, [r0, #0]
    FSMC_Bank2->PMEM2 = tmppmem;
 8003542:	6081      	str	r1, [r0, #8]
    FSMC_Bank2->PATT2 = tmppatt;
 8003544:	60c2      	str	r2, [r0, #12]
 8003546:	e7f8      	b.n	800353a <FSMC_NANDInit+0x5a>
 8003548:	a0000080 	.word	0xa0000080
 800354c:	a0000060 	.word	0xa0000060

08003550 <FSMC_NANDStructInit>:
  * @retval None
  */
void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
{ 
  /* Reset NAND Init structure parameters values */
  FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
 8003550:	2310      	movs	r3, #16
 8003552:	6003      	str	r3, [r0, #0]
  FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
 8003554:	2300      	movs	r3, #0
 8003556:	6043      	str	r3, [r0, #4]
  FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
 8003558:	6083      	str	r3, [r0, #8]
  FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
 800355a:	60c3      	str	r3, [r0, #12]
  FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
 800355c:	6103      	str	r3, [r0, #16]
  FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
 800355e:	6143      	str	r3, [r0, #20]
  FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
 8003560:	6183      	str	r3, [r0, #24]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 8003562:	69c2      	ldr	r2, [r0, #28]
 8003564:	23fc      	movs	r3, #252	; 0xfc
 8003566:	6013      	str	r3, [r2, #0]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 8003568:	69c2      	ldr	r2, [r0, #28]
 800356a:	6053      	str	r3, [r2, #4]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 800356c:	69c2      	ldr	r2, [r0, #28]
 800356e:	6093      	str	r3, [r2, #8]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
 8003570:	69c2      	ldr	r2, [r0, #28]
 8003572:	60d3      	str	r3, [r2, #12]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 8003574:	6a02      	ldr	r2, [r0, #32]
 8003576:	6013      	str	r3, [r2, #0]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 8003578:	6a02      	ldr	r2, [r0, #32]
 800357a:	6053      	str	r3, [r2, #4]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 800357c:	6a02      	ldr	r2, [r0, #32]
 800357e:	6093      	str	r3, [r2, #8]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
 8003580:	6a02      	ldr	r2, [r0, #32]
 8003582:	60d3      	str	r3, [r2, #12]
 8003584:	4770      	bx	lr

08003586 <FSMC_NANDCmd>:
void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
{
  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003586:	b169      	cbz	r1, 80035a4 <FSMC_NANDCmd+0x1e>
  {
    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 8003588:	2810      	cmp	r0, #16
 800358a:	d005      	beq.n	8003598 <FSMC_NANDCmd+0x12>
    {
      FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
    }
    else
    {
      FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
 800358c:	4a0c      	ldr	r2, [pc, #48]	; (80035c0 <FSMC_NANDCmd+0x3a>)
 800358e:	6813      	ldr	r3, [r2, #0]
 8003590:	f043 0304 	orr.w	r3, r3, #4
 8003594:	6013      	str	r3, [r2, #0]
 8003596:	4770      	bx	lr
      FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
 8003598:	4a0a      	ldr	r2, [pc, #40]	; (80035c4 <FSMC_NANDCmd+0x3e>)
 800359a:	6813      	ldr	r3, [r2, #0]
 800359c:	f043 0304 	orr.w	r3, r3, #4
 80035a0:	6013      	str	r3, [r2, #0]
 80035a2:	4770      	bx	lr
    }
  }
  else
  {
    /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 80035a4:	2810      	cmp	r0, #16
 80035a6:	d005      	beq.n	80035b4 <FSMC_NANDCmd+0x2e>
    {
      FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
    }
    else
    {
      FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
 80035a8:	4a05      	ldr	r2, [pc, #20]	; (80035c0 <FSMC_NANDCmd+0x3a>)
 80035aa:	6811      	ldr	r1, [r2, #0]
 80035ac:	4b06      	ldr	r3, [pc, #24]	; (80035c8 <FSMC_NANDCmd+0x42>)
 80035ae:	400b      	ands	r3, r1
 80035b0:	6013      	str	r3, [r2, #0]
 80035b2:	4770      	bx	lr
      FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
 80035b4:	4a03      	ldr	r2, [pc, #12]	; (80035c4 <FSMC_NANDCmd+0x3e>)
 80035b6:	6811      	ldr	r1, [r2, #0]
 80035b8:	4b03      	ldr	r3, [pc, #12]	; (80035c8 <FSMC_NANDCmd+0x42>)
 80035ba:	400b      	ands	r3, r1
 80035bc:	6013      	str	r3, [r2, #0]
 80035be:	4770      	bx	lr
 80035c0:	a0000080 	.word	0xa0000080
 80035c4:	a0000060 	.word	0xa0000060
 80035c8:	000ffffb 	.word	0x000ffffb

080035cc <FSMC_NANDECCCmd>:
void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
{
  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80035cc:	b169      	cbz	r1, 80035ea <FSMC_NANDECCCmd+0x1e>
  {
    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 80035ce:	2810      	cmp	r0, #16
 80035d0:	d005      	beq.n	80035de <FSMC_NANDECCCmd+0x12>
    {
      FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
    }
    else
    {
      FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
 80035d2:	4a0d      	ldr	r2, [pc, #52]	; (8003608 <FSMC_NANDECCCmd+0x3c>)
 80035d4:	6813      	ldr	r3, [r2, #0]
 80035d6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80035da:	6013      	str	r3, [r2, #0]
 80035dc:	4770      	bx	lr
      FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
 80035de:	4a0b      	ldr	r2, [pc, #44]	; (800360c <FSMC_NANDECCCmd+0x40>)
 80035e0:	6813      	ldr	r3, [r2, #0]
 80035e2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80035e6:	6013      	str	r3, [r2, #0]
 80035e8:	4770      	bx	lr
    }
  }
  else
  {
    /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 80035ea:	2810      	cmp	r0, #16
 80035ec:	d005      	beq.n	80035fa <FSMC_NANDECCCmd+0x2e>
    {
      FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
    }
    else
    {
      FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
 80035ee:	4a06      	ldr	r2, [pc, #24]	; (8003608 <FSMC_NANDECCCmd+0x3c>)
 80035f0:	6811      	ldr	r1, [r2, #0]
 80035f2:	4b07      	ldr	r3, [pc, #28]	; (8003610 <FSMC_NANDECCCmd+0x44>)
 80035f4:	400b      	ands	r3, r1
 80035f6:	6013      	str	r3, [r2, #0]
 80035f8:	4770      	bx	lr
      FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
 80035fa:	4a04      	ldr	r2, [pc, #16]	; (800360c <FSMC_NANDECCCmd+0x40>)
 80035fc:	6811      	ldr	r1, [r2, #0]
 80035fe:	4b04      	ldr	r3, [pc, #16]	; (8003610 <FSMC_NANDECCCmd+0x44>)
 8003600:	400b      	ands	r3, r1
 8003602:	6013      	str	r3, [r2, #0]
 8003604:	4770      	bx	lr
 8003606:	bf00      	nop
 8003608:	a0000080 	.word	0xa0000080
 800360c:	a0000060 	.word	0xa0000060
 8003610:	000fffbf 	.word	0x000fffbf

08003614 <FSMC_GetECC>:
  */
uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
{
  uint32_t eccval = 0x00000000;
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 8003614:	2810      	cmp	r0, #16
 8003616:	d002      	beq.n	800361e <FSMC_GetECC+0xa>
    eccval = FSMC_Bank2->ECCR2;
  }
  else
  {
    /* Get the ECCR3 register value */
    eccval = FSMC_Bank3->ECCR3;
 8003618:	4b02      	ldr	r3, [pc, #8]	; (8003624 <FSMC_GetECC+0x10>)
 800361a:	6958      	ldr	r0, [r3, #20]
  }
  /* Return the error correction code value */
  return(eccval);
}
 800361c:	4770      	bx	lr
    eccval = FSMC_Bank2->ECCR2;
 800361e:	4b02      	ldr	r3, [pc, #8]	; (8003628 <FSMC_GetECC+0x14>)
 8003620:	6958      	ldr	r0, [r3, #20]
 8003622:	4770      	bx	lr
 8003624:	a0000080 	.word	0xa0000080
 8003628:	a0000060 	.word	0xa0000060

0800362c <FSMC_PCCARDDeInit>:
  * @retval None
  */
void FSMC_PCCARDDeInit(void)
{
  /* Set the FSMC_Bank4 registers to their reset values */
  FSMC_Bank4->PCR4 = 0x00000018; 
 800362c:	4b05      	ldr	r3, [pc, #20]	; (8003644 <FSMC_PCCARDDeInit+0x18>)
 800362e:	2218      	movs	r2, #24
 8003630:	601a      	str	r2, [r3, #0]
  FSMC_Bank4->SR4 = 0x00000000;	
 8003632:	2200      	movs	r2, #0
 8003634:	605a      	str	r2, [r3, #4]
  FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
 8003636:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
 800363a:	609a      	str	r2, [r3, #8]
  FSMC_Bank4->PATT4 = 0xFCFCFCFC;
 800363c:	60da      	str	r2, [r3, #12]
  FSMC_Bank4->PIO4 = 0xFCFCFCFC;
 800363e:	611a      	str	r2, [r3, #16]
 8003640:	4770      	bx	lr
 8003642:	bf00      	nop
 8003644:	a00000a0 	.word	0xa00000a0

08003648 <FSMC_PCCARDInit>:
  * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef structure
  *         that contains the configuration information for the FSMC PCCARD Bank.                       
  * @retval None
  */
void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
{
 8003648:	b410      	push	{r4}
  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
 800364a:	6803      	ldr	r3, [r0, #0]
                     FSMC_MemoryDataWidth_16b |  
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
 800364c:	6842      	ldr	r2, [r0, #4]
                     FSMC_MemoryDataWidth_16b |  
 800364e:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
 8003652:	6882      	ldr	r2, [r0, #8]
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
 8003654:	ea43 3342 	orr.w	r3, r3, r2, lsl #13
 8003658:	f043 0310 	orr.w	r3, r3, #16
  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
 800365c:	4a14      	ldr	r2, [pc, #80]	; (80036b0 <FSMC_PCCARDInit+0x68>)
 800365e:	6013      	str	r3, [r2, #0]
            
  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 8003660:	68c1      	ldr	r1, [r0, #12]
 8003662:	680b      	ldr	r3, [r1, #0]
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 8003664:	684c      	ldr	r4, [r1, #4]
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 8003666:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800366a:	688c      	ldr	r4, [r1, #8]
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800366c:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
 8003670:	68c9      	ldr	r1, [r1, #12]
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 8003672:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 8003676:	6093      	str	r3, [r2, #8]
            
  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 8003678:	6901      	ldr	r1, [r0, #16]
 800367a:	680b      	ldr	r3, [r1, #0]
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800367c:	684c      	ldr	r4, [r1, #4]
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800367e:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 8003682:	688c      	ldr	r4, [r1, #8]
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 8003684:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
 8003688:	68c9      	ldr	r1, [r1, #12]
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800368a:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800368e:	60d3      	str	r3, [r2, #12]
            
  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
 8003690:	6941      	ldr	r1, [r0, #20]
 8003692:	680b      	ldr	r3, [r1, #0]
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 8003694:	6848      	ldr	r0, [r1, #4]
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
 8003696:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800369a:	6888      	ldr	r0, [r1, #8]
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
 800369c:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
 80036a0:	68c9      	ldr	r1, [r1, #12]
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 80036a2:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
 80036a6:	6113      	str	r3, [r2, #16]
}
 80036a8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80036ac:	4770      	bx	lr
 80036ae:	bf00      	nop
 80036b0:	a00000a0 	.word	0xa00000a0

080036b4 <FSMC_PCCARDStructInit>:
  * @retval None
  */
void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
{
  /* Reset PCCARD Init structure parameters values */
  FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
 80036b4:	2300      	movs	r3, #0
 80036b6:	6003      	str	r3, [r0, #0]
  FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
 80036b8:	6043      	str	r3, [r0, #4]
  FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
 80036ba:	6083      	str	r3, [r0, #8]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80036bc:	68c2      	ldr	r2, [r0, #12]
 80036be:	23fc      	movs	r3, #252	; 0xfc
 80036c0:	6013      	str	r3, [r2, #0]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 80036c2:	68c2      	ldr	r2, [r0, #12]
 80036c4:	6053      	str	r3, [r2, #4]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 80036c6:	68c2      	ldr	r2, [r0, #12]
 80036c8:	6093      	str	r3, [r2, #8]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
 80036ca:	68c2      	ldr	r2, [r0, #12]
 80036cc:	60d3      	str	r3, [r2, #12]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80036ce:	6902      	ldr	r2, [r0, #16]
 80036d0:	6013      	str	r3, [r2, #0]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 80036d2:	6902      	ldr	r2, [r0, #16]
 80036d4:	6053      	str	r3, [r2, #4]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 80036d6:	6902      	ldr	r2, [r0, #16]
 80036d8:	6093      	str	r3, [r2, #8]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
 80036da:	6902      	ldr	r2, [r0, #16]
 80036dc:	60d3      	str	r3, [r2, #12]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80036de:	6942      	ldr	r2, [r0, #20]
 80036e0:	6013      	str	r3, [r2, #0]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 80036e2:	6942      	ldr	r2, [r0, #20]
 80036e4:	6053      	str	r3, [r2, #4]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 80036e6:	6942      	ldr	r2, [r0, #20]
 80036e8:	6093      	str	r3, [r2, #8]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
 80036ea:	6942      	ldr	r2, [r0, #20]
 80036ec:	60d3      	str	r3, [r2, #12]
 80036ee:	4770      	bx	lr

080036f0 <FSMC_PCCARDCmd>:
  */
void FSMC_PCCARDCmd(FunctionalState NewState)
{
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80036f0:	b928      	cbnz	r0, 80036fe <FSMC_PCCARDCmd+0xe>
    FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
  }
  else
  {
    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
 80036f2:	4a06      	ldr	r2, [pc, #24]	; (800370c <FSMC_PCCARDCmd+0x1c>)
 80036f4:	6811      	ldr	r1, [r2, #0]
 80036f6:	4b06      	ldr	r3, [pc, #24]	; (8003710 <FSMC_PCCARDCmd+0x20>)
 80036f8:	400b      	ands	r3, r1
 80036fa:	6013      	str	r3, [r2, #0]
 80036fc:	4770      	bx	lr
    FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
 80036fe:	4a03      	ldr	r2, [pc, #12]	; (800370c <FSMC_PCCARDCmd+0x1c>)
 8003700:	6813      	ldr	r3, [r2, #0]
 8003702:	f043 0304 	orr.w	r3, r3, #4
 8003706:	6013      	str	r3, [r2, #0]
 8003708:	4770      	bx	lr
 800370a:	bf00      	nop
 800370c:	a00000a0 	.word	0xa00000a0
 8003710:	000ffffb 	.word	0x000ffffb

08003714 <FSMC_ITConfig>:
{
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_IT(FSMC_IT));	
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003714:	b19a      	cbz	r2, 800373e <FSMC_ITConfig+0x2a>
  {
    /* Enable the selected FSMC_Bank2 interrupts */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 8003716:	2810      	cmp	r0, #16
 8003718:	d007      	beq.n	800372a <FSMC_ITConfig+0x16>
    {
      FSMC_Bank2->SR2 |= FSMC_IT;
    }
    /* Enable the selected FSMC_Bank3 interrupts */
    else if (FSMC_Bank == FSMC_Bank3_NAND)
 800371a:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 800371e:	d009      	beq.n	8003734 <FSMC_ITConfig+0x20>
      FSMC_Bank3->SR3 |= FSMC_IT;
    }
    /* Enable the selected FSMC_Bank4 interrupts */
    else
    {
      FSMC_Bank4->SR4 |= FSMC_IT;    
 8003720:	4a12      	ldr	r2, [pc, #72]	; (800376c <FSMC_ITConfig+0x58>)
 8003722:	6853      	ldr	r3, [r2, #4]
 8003724:	4319      	orrs	r1, r3
 8003726:	6051      	str	r1, [r2, #4]
 8003728:	4770      	bx	lr
      FSMC_Bank2->SR2 |= FSMC_IT;
 800372a:	4a11      	ldr	r2, [pc, #68]	; (8003770 <FSMC_ITConfig+0x5c>)
 800372c:	6853      	ldr	r3, [r2, #4]
 800372e:	4319      	orrs	r1, r3
 8003730:	6051      	str	r1, [r2, #4]
 8003732:	4770      	bx	lr
      FSMC_Bank3->SR3 |= FSMC_IT;
 8003734:	4a0f      	ldr	r2, [pc, #60]	; (8003774 <FSMC_ITConfig+0x60>)
 8003736:	6853      	ldr	r3, [r2, #4]
 8003738:	4319      	orrs	r1, r3
 800373a:	6051      	str	r1, [r2, #4]
 800373c:	4770      	bx	lr
    }
  }
  else
  {
    /* Disable the selected FSMC_Bank2 interrupts */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 800373e:	2810      	cmp	r0, #16
 8003740:	d008      	beq.n	8003754 <FSMC_ITConfig+0x40>
    {
      
      FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
    }
    /* Disable the selected FSMC_Bank3 interrupts */
    else if (FSMC_Bank == FSMC_Bank3_NAND)
 8003742:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 8003746:	d00b      	beq.n	8003760 <FSMC_ITConfig+0x4c>
      FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
    }
    /* Disable the selected FSMC_Bank4 interrupts */
    else
    {
      FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
 8003748:	4a08      	ldr	r2, [pc, #32]	; (800376c <FSMC_ITConfig+0x58>)
 800374a:	6853      	ldr	r3, [r2, #4]
 800374c:	ea23 0101 	bic.w	r1, r3, r1
 8003750:	6051      	str	r1, [r2, #4]
 8003752:	4770      	bx	lr
      FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
 8003754:	4a06      	ldr	r2, [pc, #24]	; (8003770 <FSMC_ITConfig+0x5c>)
 8003756:	6853      	ldr	r3, [r2, #4]
 8003758:	ea23 0101 	bic.w	r1, r3, r1
 800375c:	6051      	str	r1, [r2, #4]
 800375e:	4770      	bx	lr
      FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
 8003760:	4a04      	ldr	r2, [pc, #16]	; (8003774 <FSMC_ITConfig+0x60>)
 8003762:	6853      	ldr	r3, [r2, #4]
 8003764:	ea23 0101 	bic.w	r1, r3, r1
 8003768:	6051      	str	r1, [r2, #4]
 800376a:	4770      	bx	lr
 800376c:	a00000a0 	.word	0xa00000a0
 8003770:	a0000060 	.word	0xa0000060
 8003774:	a0000080 	.word	0xa0000080

08003778 <FSMC_GetFlagStatus>:
  
  /* Check the parameters */
  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 8003778:	2810      	cmp	r0, #16
 800377a:	d008      	beq.n	800378e <FSMC_GetFlagStatus+0x16>
  {
    tmpsr = FSMC_Bank2->SR2;
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 800377c:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 8003780:	d008      	beq.n	8003794 <FSMC_GetFlagStatus+0x1c>
    tmpsr = FSMC_Bank3->SR3;
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    tmpsr = FSMC_Bank4->SR4;
 8003782:	4b07      	ldr	r3, [pc, #28]	; (80037a0 <FSMC_GetFlagStatus+0x28>)
 8003784:	685b      	ldr	r3, [r3, #4]
  } 
  
  /* Get the flag status */
  if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
 8003786:	420b      	tst	r3, r1
 8003788:	d107      	bne.n	800379a <FSMC_GetFlagStatus+0x22>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 800378a:	2000      	movs	r0, #0
  }
  /* Return the flag status */
  return bitstatus;
}
 800378c:	4770      	bx	lr
    tmpsr = FSMC_Bank2->SR2;
 800378e:	4b05      	ldr	r3, [pc, #20]	; (80037a4 <FSMC_GetFlagStatus+0x2c>)
 8003790:	685b      	ldr	r3, [r3, #4]
 8003792:	e7f8      	b.n	8003786 <FSMC_GetFlagStatus+0xe>
    tmpsr = FSMC_Bank3->SR3;
 8003794:	4b04      	ldr	r3, [pc, #16]	; (80037a8 <FSMC_GetFlagStatus+0x30>)
 8003796:	685b      	ldr	r3, [r3, #4]
 8003798:	e7f5      	b.n	8003786 <FSMC_GetFlagStatus+0xe>
    bitstatus = SET;
 800379a:	2001      	movs	r0, #1
 800379c:	4770      	bx	lr
 800379e:	bf00      	nop
 80037a0:	a00000a0 	.word	0xa00000a0
 80037a4:	a0000060 	.word	0xa0000060
 80037a8:	a0000080 	.word	0xa0000080

080037ac <FSMC_ClearFlag>:
{
 /* Check the parameters */
  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
    
  if(FSMC_Bank == FSMC_Bank2_NAND)
 80037ac:	2810      	cmp	r0, #16
 80037ae:	d008      	beq.n	80037c2 <FSMC_ClearFlag+0x16>
  {
    FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 80037b0:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 80037b4:	d00b      	beq.n	80037ce <FSMC_ClearFlag+0x22>
    FSMC_Bank3->SR3 &= ~FSMC_FLAG;
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    FSMC_Bank4->SR4 &= ~FSMC_FLAG;
 80037b6:	4a09      	ldr	r2, [pc, #36]	; (80037dc <FSMC_ClearFlag+0x30>)
 80037b8:	6853      	ldr	r3, [r2, #4]
 80037ba:	ea23 0101 	bic.w	r1, r3, r1
 80037be:	6051      	str	r1, [r2, #4]
 80037c0:	4770      	bx	lr
    FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
 80037c2:	4a07      	ldr	r2, [pc, #28]	; (80037e0 <FSMC_ClearFlag+0x34>)
 80037c4:	6853      	ldr	r3, [r2, #4]
 80037c6:	ea23 0101 	bic.w	r1, r3, r1
 80037ca:	6051      	str	r1, [r2, #4]
 80037cc:	4770      	bx	lr
    FSMC_Bank3->SR3 &= ~FSMC_FLAG;
 80037ce:	4a05      	ldr	r2, [pc, #20]	; (80037e4 <FSMC_ClearFlag+0x38>)
 80037d0:	6853      	ldr	r3, [r2, #4]
 80037d2:	ea23 0101 	bic.w	r1, r3, r1
 80037d6:	6051      	str	r1, [r2, #4]
 80037d8:	4770      	bx	lr
 80037da:	bf00      	nop
 80037dc:	a00000a0 	.word	0xa00000a0
 80037e0:	a0000060 	.word	0xa0000060
 80037e4:	a0000080 	.word	0xa0000080

080037e8 <FSMC_GetITStatus>:
  
  /* Check the parameters */
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_GET_IT(FSMC_IT));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 80037e8:	2810      	cmp	r0, #16
 80037ea:	d00b      	beq.n	8003804 <FSMC_GetITStatus+0x1c>
  {
    tmpsr = FSMC_Bank2->SR2;
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 80037ec:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 80037f0:	d00b      	beq.n	800380a <FSMC_GetITStatus+0x22>
    tmpsr = FSMC_Bank3->SR3;
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    tmpsr = FSMC_Bank4->SR4;
 80037f2:	4b09      	ldr	r3, [pc, #36]	; (8003818 <FSMC_GetITStatus+0x30>)
 80037f4:	685b      	ldr	r3, [r3, #4]
  } 
  
  itstatus = tmpsr & FSMC_IT;
  
  itenable = tmpsr & (FSMC_IT >> 3);
 80037f6:	ea03 02d1 	and.w	r2, r3, r1, lsr #3
  if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
 80037fa:	420b      	tst	r3, r1
 80037fc:	d008      	beq.n	8003810 <FSMC_GetITStatus+0x28>
 80037fe:	b94a      	cbnz	r2, 8003814 <FSMC_GetITStatus+0x2c>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8003800:	2000      	movs	r0, #0
 8003802:	4770      	bx	lr
    tmpsr = FSMC_Bank2->SR2;
 8003804:	4b05      	ldr	r3, [pc, #20]	; (800381c <FSMC_GetITStatus+0x34>)
 8003806:	685b      	ldr	r3, [r3, #4]
 8003808:	e7f5      	b.n	80037f6 <FSMC_GetITStatus+0xe>
    tmpsr = FSMC_Bank3->SR3;
 800380a:	4b05      	ldr	r3, [pc, #20]	; (8003820 <FSMC_GetITStatus+0x38>)
 800380c:	685b      	ldr	r3, [r3, #4]
 800380e:	e7f2      	b.n	80037f6 <FSMC_GetITStatus+0xe>
    bitstatus = RESET;
 8003810:	2000      	movs	r0, #0
 8003812:	4770      	bx	lr
    bitstatus = SET;
 8003814:	2001      	movs	r0, #1
  }
  return bitstatus; 
}
 8003816:	4770      	bx	lr
 8003818:	a00000a0 	.word	0xa00000a0
 800381c:	a0000060 	.word	0xa0000060
 8003820:	a0000080 	.word	0xa0000080

08003824 <FSMC_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_IT(FSMC_IT));
    
  if(FSMC_Bank == FSMC_Bank2_NAND)
 8003824:	2810      	cmp	r0, #16
 8003826:	d008      	beq.n	800383a <FSMC_ClearITPendingBit+0x16>
  {
    FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 8003828:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 800382c:	d00b      	beq.n	8003846 <FSMC_ClearITPendingBit+0x22>
    FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
 800382e:	4a09      	ldr	r2, [pc, #36]	; (8003854 <FSMC_ClearITPendingBit+0x30>)
 8003830:	6853      	ldr	r3, [r2, #4]
 8003832:	ea23 01d1 	bic.w	r1, r3, r1, lsr #3
 8003836:	6051      	str	r1, [r2, #4]
 8003838:	4770      	bx	lr
    FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
 800383a:	4a07      	ldr	r2, [pc, #28]	; (8003858 <FSMC_ClearITPendingBit+0x34>)
 800383c:	6853      	ldr	r3, [r2, #4]
 800383e:	ea23 01d1 	bic.w	r1, r3, r1, lsr #3
 8003842:	6051      	str	r1, [r2, #4]
 8003844:	4770      	bx	lr
    FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
 8003846:	4a05      	ldr	r2, [pc, #20]	; (800385c <FSMC_ClearITPendingBit+0x38>)
 8003848:	6853      	ldr	r3, [r2, #4]
 800384a:	ea23 01d1 	bic.w	r1, r3, r1, lsr #3
 800384e:	6051      	str	r1, [r2, #4]
 8003850:	4770      	bx	lr
 8003852:	bf00      	nop
 8003854:	a00000a0 	.word	0xa00000a0
 8003858:	a0000060 	.word	0xa0000060
 800385c:	a0000080 	.word	0xa0000080

08003860 <GPIO_DeInit>:
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral for 
  *                STM32F40xx/41xx and STM32F427x/437x devices. 
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8003860:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 8003862:	4b37      	ldr	r3, [pc, #220]	; (8003940 <GPIO_DeInit+0xe0>)
 8003864:	4298      	cmp	r0, r3
 8003866:	d018      	beq.n	800389a <GPIO_DeInit+0x3a>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
 8003868:	4b36      	ldr	r3, [pc, #216]	; (8003944 <GPIO_DeInit+0xe4>)
 800386a:	4298      	cmp	r0, r3
 800386c:	d01e      	beq.n	80038ac <GPIO_DeInit+0x4c>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
 800386e:	4b36      	ldr	r3, [pc, #216]	; (8003948 <GPIO_DeInit+0xe8>)
 8003870:	4298      	cmp	r0, r3
 8003872:	d024      	beq.n	80038be <GPIO_DeInit+0x5e>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
 8003874:	4b35      	ldr	r3, [pc, #212]	; (800394c <GPIO_DeInit+0xec>)
 8003876:	4298      	cmp	r0, r3
 8003878:	d02a      	beq.n	80038d0 <GPIO_DeInit+0x70>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
 800387a:	4b35      	ldr	r3, [pc, #212]	; (8003950 <GPIO_DeInit+0xf0>)
 800387c:	4298      	cmp	r0, r3
 800387e:	d030      	beq.n	80038e2 <GPIO_DeInit+0x82>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
 8003880:	4b34      	ldr	r3, [pc, #208]	; (8003954 <GPIO_DeInit+0xf4>)
 8003882:	4298      	cmp	r0, r3
 8003884:	d036      	beq.n	80038f4 <GPIO_DeInit+0x94>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
 8003886:	4b34      	ldr	r3, [pc, #208]	; (8003958 <GPIO_DeInit+0xf8>)
 8003888:	4298      	cmp	r0, r3
 800388a:	d03c      	beq.n	8003906 <GPIO_DeInit+0xa6>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
 800388c:	4b33      	ldr	r3, [pc, #204]	; (800395c <GPIO_DeInit+0xfc>)
 800388e:	4298      	cmp	r0, r3
 8003890:	d042      	beq.n	8003918 <GPIO_DeInit+0xb8>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
  }
  else
  {
    if (GPIOx == GPIOI)
 8003892:	4b33      	ldr	r3, [pc, #204]	; (8003960 <GPIO_DeInit+0x100>)
 8003894:	4298      	cmp	r0, r3
 8003896:	d048      	beq.n	800392a <GPIO_DeInit+0xca>
 8003898:	bd08      	pop	{r3, pc}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 800389a:	2101      	movs	r1, #1
 800389c:	4608      	mov	r0, r1
 800389e:	f001 f859 	bl	8004954 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 80038a2:	2100      	movs	r1, #0
 80038a4:	2001      	movs	r0, #1
 80038a6:	f001 f855 	bl	8004954 <RCC_AHB1PeriphResetCmd>
 80038aa:	bd08      	pop	{r3, pc}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 80038ac:	2101      	movs	r1, #1
 80038ae:	2002      	movs	r0, #2
 80038b0:	f001 f850 	bl	8004954 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 80038b4:	2100      	movs	r1, #0
 80038b6:	2002      	movs	r0, #2
 80038b8:	f001 f84c 	bl	8004954 <RCC_AHB1PeriphResetCmd>
 80038bc:	bd08      	pop	{r3, pc}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 80038be:	2101      	movs	r1, #1
 80038c0:	2004      	movs	r0, #4
 80038c2:	f001 f847 	bl	8004954 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 80038c6:	2100      	movs	r1, #0
 80038c8:	2004      	movs	r0, #4
 80038ca:	f001 f843 	bl	8004954 <RCC_AHB1PeriphResetCmd>
 80038ce:	bd08      	pop	{r3, pc}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 80038d0:	2101      	movs	r1, #1
 80038d2:	2008      	movs	r0, #8
 80038d4:	f001 f83e 	bl	8004954 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 80038d8:	2100      	movs	r1, #0
 80038da:	2008      	movs	r0, #8
 80038dc:	f001 f83a 	bl	8004954 <RCC_AHB1PeriphResetCmd>
 80038e0:	bd08      	pop	{r3, pc}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 80038e2:	2101      	movs	r1, #1
 80038e4:	2010      	movs	r0, #16
 80038e6:	f001 f835 	bl	8004954 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 80038ea:	2100      	movs	r1, #0
 80038ec:	2010      	movs	r0, #16
 80038ee:	f001 f831 	bl	8004954 <RCC_AHB1PeriphResetCmd>
 80038f2:	bd08      	pop	{r3, pc}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 80038f4:	2101      	movs	r1, #1
 80038f6:	2020      	movs	r0, #32
 80038f8:	f001 f82c 	bl	8004954 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 80038fc:	2100      	movs	r1, #0
 80038fe:	2020      	movs	r0, #32
 8003900:	f001 f828 	bl	8004954 <RCC_AHB1PeriphResetCmd>
 8003904:	bd08      	pop	{r3, pc}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 8003906:	2101      	movs	r1, #1
 8003908:	2040      	movs	r0, #64	; 0x40
 800390a:	f001 f823 	bl	8004954 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 800390e:	2100      	movs	r1, #0
 8003910:	2040      	movs	r0, #64	; 0x40
 8003912:	f001 f81f 	bl	8004954 <RCC_AHB1PeriphResetCmd>
 8003916:	bd08      	pop	{r3, pc}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 8003918:	2101      	movs	r1, #1
 800391a:	2080      	movs	r0, #128	; 0x80
 800391c:	f001 f81a 	bl	8004954 <RCC_AHB1PeriphResetCmd>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 8003920:	2100      	movs	r1, #0
 8003922:	2080      	movs	r0, #128	; 0x80
 8003924:	f001 f816 	bl	8004954 <RCC_AHB1PeriphResetCmd>
 8003928:	bd08      	pop	{r3, pc}
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 800392a:	2101      	movs	r1, #1
 800392c:	f44f 7080 	mov.w	r0, #256	; 0x100
 8003930:	f001 f810 	bl	8004954 <RCC_AHB1PeriphResetCmd>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 8003934:	2100      	movs	r1, #0
 8003936:	f44f 7080 	mov.w	r0, #256	; 0x100
 800393a:	f001 f80b 	bl	8004954 <RCC_AHB1PeriphResetCmd>
    }
  }
}
 800393e:	e7ab      	b.n	8003898 <GPIO_DeInit+0x38>
 8003940:	40020000 	.word	0x40020000
 8003944:	40020400 	.word	0x40020400
 8003948:	40020800 	.word	0x40020800
 800394c:	40020c00 	.word	0x40020c00
 8003950:	40021000 	.word	0x40021000
 8003954:	40021400 	.word	0x40021400
 8003958:	40021800 	.word	0x40021800
 800395c:	40021c00 	.word	0x40021c00
 8003960:	40022000 	.word	0x40022000

08003964 <GPIO_Init>:
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8003964:	2300      	movs	r3, #0
 8003966:	2b0f      	cmp	r3, #15
 8003968:	d840      	bhi.n	80039ec <GPIO_Init+0x88>
{
 800396a:	b4f0      	push	{r4, r5, r6, r7}
 800396c:	e025      	b.n	80039ba <GPIO_Init+0x56>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800396e:	6884      	ldr	r4, [r0, #8]
 8003970:	4022      	ands	r2, r4
 8003972:	6082      	str	r2, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8003974:	6882      	ldr	r2, [r0, #8]
 8003976:	794c      	ldrb	r4, [r1, #5]
 8003978:	40ac      	lsls	r4, r5
 800397a:	4322      	orrs	r2, r4
 800397c:	6082      	str	r2, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 800397e:	6844      	ldr	r4, [r0, #4]
 8003980:	b29f      	uxth	r7, r3
 8003982:	2601      	movs	r6, #1
 8003984:	40be      	lsls	r6, r7
 8003986:	ea24 0406 	bic.w	r4, r4, r6
 800398a:	6044      	str	r4, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800398c:	6844      	ldr	r4, [r0, #4]
 800398e:	798a      	ldrb	r2, [r1, #6]
 8003990:	40ba      	lsls	r2, r7
 8003992:	b292      	uxth	r2, r2
 8003994:	4322      	orrs	r2, r4
 8003996:	6042      	str	r2, [r0, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8003998:	68c2      	ldr	r2, [r0, #12]
 800399a:	b29c      	uxth	r4, r3
 800399c:	0066      	lsls	r6, r4, #1
 800399e:	2403      	movs	r4, #3
 80039a0:	40b4      	lsls	r4, r6
 80039a2:	ea22 0204 	bic.w	r2, r2, r4
 80039a6:	60c2      	str	r2, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80039a8:	68c2      	ldr	r2, [r0, #12]
 80039aa:	79cc      	ldrb	r4, [r1, #7]
 80039ac:	fa04 f505 	lsl.w	r5, r4, r5
 80039b0:	4315      	orrs	r5, r2
 80039b2:	60c5      	str	r5, [r0, #12]
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80039b4:	3301      	adds	r3, #1
 80039b6:	2b0f      	cmp	r3, #15
 80039b8:	d816      	bhi.n	80039e8 <GPIO_Init+0x84>
    pos = ((uint32_t)0x01) << pinpos;
 80039ba:	2201      	movs	r2, #1
 80039bc:	409a      	lsls	r2, r3
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80039be:	680c      	ldr	r4, [r1, #0]
    if (currentpin == pos)
 80039c0:	43a2      	bics	r2, r4
 80039c2:	d1f7      	bne.n	80039b4 <GPIO_Init+0x50>
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80039c4:	6804      	ldr	r4, [r0, #0]
 80039c6:	005d      	lsls	r5, r3, #1
 80039c8:	2203      	movs	r2, #3
 80039ca:	40aa      	lsls	r2, r5
 80039cc:	43d2      	mvns	r2, r2
 80039ce:	4014      	ands	r4, r2
 80039d0:	6004      	str	r4, [r0, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80039d2:	6804      	ldr	r4, [r0, #0]
 80039d4:	790e      	ldrb	r6, [r1, #4]
 80039d6:	40ae      	lsls	r6, r5
 80039d8:	4334      	orrs	r4, r6
 80039da:	6004      	str	r4, [r0, #0]
      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80039dc:	790c      	ldrb	r4, [r1, #4]
 80039de:	3c01      	subs	r4, #1
 80039e0:	b2e4      	uxtb	r4, r4
 80039e2:	2c01      	cmp	r4, #1
 80039e4:	d8d8      	bhi.n	8003998 <GPIO_Init+0x34>
 80039e6:	e7c2      	b.n	800396e <GPIO_Init+0xa>
    }
  }
}
 80039e8:	bcf0      	pop	{r4, r5, r6, r7}
 80039ea:	4770      	bx	lr
 80039ec:	4770      	bx	lr

080039ee <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 80039ee:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80039f2:	6003      	str	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 80039f4:	2300      	movs	r3, #0
 80039f6:	7103      	strb	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 80039f8:	7143      	strb	r3, [r0, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 80039fa:	7183      	strb	r3, [r0, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 80039fc:	71c3      	strb	r3, [r0, #7]
 80039fe:	4770      	bx	lr

08003a00 <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8003a00:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0x00010000;
 8003a02:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8003a06:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 8003a08:	9b01      	ldr	r3, [sp, #4]
 8003a0a:	430b      	orrs	r3, r1
 8003a0c:	9301      	str	r3, [sp, #4]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8003a0e:	9b01      	ldr	r3, [sp, #4]
 8003a10:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 8003a12:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8003a14:	9b01      	ldr	r3, [sp, #4]
 8003a16:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8003a18:	69c3      	ldr	r3, [r0, #28]
 8003a1a:	9301      	str	r3, [sp, #4]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8003a1c:	69c3      	ldr	r3, [r0, #28]
 8003a1e:	9301      	str	r3, [sp, #4]
}
 8003a20:	b002      	add	sp, #8
 8003a22:	4770      	bx	lr

08003a24 <GPIO_ReadInputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8003a24:	6903      	ldr	r3, [r0, #16]
 8003a26:	4219      	tst	r1, r3
 8003a28:	d101      	bne.n	8003a2e <GPIO_ReadInputDataBit+0xa>
  {
    bitstatus = (uint8_t)Bit_SET;
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 8003a2a:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 8003a2c:	4770      	bx	lr
    bitstatus = (uint8_t)Bit_SET;
 8003a2e:	2001      	movs	r0, #1
 8003a30:	4770      	bx	lr

08003a32 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 8003a32:	6900      	ldr	r0, [r0, #16]
}
 8003a34:	b280      	uxth	r0, r0
 8003a36:	4770      	bx	lr

08003a38 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if (((GPIOx->ODR) & GPIO_Pin) != (uint32_t)Bit_RESET)
 8003a38:	6943      	ldr	r3, [r0, #20]
 8003a3a:	4219      	tst	r1, r3
 8003a3c:	d101      	bne.n	8003a42 <GPIO_ReadOutputDataBit+0xa>
  {
    bitstatus = (uint8_t)Bit_SET;
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 8003a3e:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 8003a40:	4770      	bx	lr
    bitstatus = (uint8_t)Bit_SET;
 8003a42:	2001      	movs	r0, #1
 8003a44:	4770      	bx	lr

08003a46 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 8003a46:	6940      	ldr	r0, [r0, #20]
}
 8003a48:	b280      	uxth	r0, r0
 8003a4a:	4770      	bx	lr

08003a4c <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 8003a4c:	8301      	strh	r1, [r0, #24]
 8003a4e:	4770      	bx	lr

08003a50 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 8003a50:	8341      	strh	r1, [r0, #26]
 8003a52:	4770      	bx	lr

08003a54 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 8003a54:	b90a      	cbnz	r2, 8003a5a <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRRL = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 8003a56:	8341      	strh	r1, [r0, #26]
 8003a58:	4770      	bx	lr
    GPIOx->BSRRL = GPIO_Pin;
 8003a5a:	8301      	strh	r1, [r0, #24]
 8003a5c:	4770      	bx	lr

08003a5e <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 8003a5e:	6141      	str	r1, [r0, #20]
 8003a60:	4770      	bx	lr

08003a62 <GPIO_ToggleBits>:
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 8003a62:	6943      	ldr	r3, [r0, #20]
 8003a64:	4059      	eors	r1, r3
 8003a66:	6141      	str	r1, [r0, #20]
 8003a68:	4770      	bx	lr

08003a6a <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13 
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8003a6a:	b430      	push	{r4, r5}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8003a6c:	f001 0307 	and.w	r3, r1, #7
 8003a70:	009b      	lsls	r3, r3, #2
 8003a72:	409a      	lsls	r2, r3
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8003a74:	08c9      	lsrs	r1, r1, #3
 8003a76:	3108      	adds	r1, #8
 8003a78:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
 8003a7c:	250f      	movs	r5, #15
 8003a7e:	fa05 f303 	lsl.w	r3, r5, r3
 8003a82:	ea24 0303 	bic.w	r3, r4, r3
 8003a86:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8003a8a:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
 8003a8e:	431a      	orrs	r2, r3
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8003a90:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
}
 8003a94:	bc30      	pop	{r4, r5}
 8003a96:	4770      	bx	lr

08003a98 <HASH_DeInit>:
  * @brief  De-initializes the HASH peripheral registers to their default reset values
  * @param  None
  * @retval None
  */
void HASH_DeInit(void)
{
 8003a98:	b508      	push	{r3, lr}
  /* Enable HASH reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
 8003a9a:	2101      	movs	r1, #1
 8003a9c:	2020      	movs	r0, #32
 8003a9e:	f000 ff67 	bl	8004970 <RCC_AHB2PeriphResetCmd>
  /* Release HASH from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
 8003aa2:	2100      	movs	r1, #0
 8003aa4:	2020      	movs	r0, #32
 8003aa6:	f000 ff63 	bl	8004970 <RCC_AHB2PeriphResetCmd>
 8003aaa:	bd08      	pop	{r3, pc}

08003aac <HASH_Init>:
  * @note   The field HASH_HMACKeyType in HASH_InitTypeDef must be filled only 
  *          if the algorithm mode is HMAC.       
  * @retval None
  */
void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
{
 8003aac:	b410      	push	{r4}
  assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
  assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
  assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
  
  /* Configure the Algorithm used, algorithm mode and the datatype */
  HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
 8003aae:	4a12      	ldr	r2, [pc, #72]	; (8003af8 <HASH_Init+0x4c>)
 8003ab0:	6813      	ldr	r3, [r2, #0]
 8003ab2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003ab6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8003aba:	6013      	str	r3, [r2, #0]
  HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
 8003abc:	6811      	ldr	r1, [r2, #0]
 8003abe:	6803      	ldr	r3, [r0, #0]
               HASH_InitStruct->HASH_DataType | \
 8003ac0:	6884      	ldr	r4, [r0, #8]
  HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
 8003ac2:	4323      	orrs	r3, r4
               HASH_InitStruct->HASH_AlgoMode);
 8003ac4:	6844      	ldr	r4, [r0, #4]
               HASH_InitStruct->HASH_DataType | \
 8003ac6:	4323      	orrs	r3, r4
  HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
 8003ac8:	430b      	orrs	r3, r1
 8003aca:	6013      	str	r3, [r2, #0]
  
  /* if algorithm mode is HMAC, set the Key */  
  if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
 8003acc:	6843      	ldr	r3, [r0, #4]
 8003ace:	2b40      	cmp	r3, #64	; 0x40
 8003ad0:	d007      	beq.n	8003ae2 <HASH_Init+0x36>
    HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
  }

  /* Reset the HASH processor core, so that the HASH will be ready to compute 
     the message digest of a new message */
  HASH->CR |= HASH_CR_INIT;  
 8003ad2:	4a09      	ldr	r2, [pc, #36]	; (8003af8 <HASH_Init+0x4c>)
 8003ad4:	6813      	ldr	r3, [r2, #0]
 8003ad6:	f043 0304 	orr.w	r3, r3, #4
 8003ada:	6013      	str	r3, [r2, #0]
}
 8003adc:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003ae0:	4770      	bx	lr
    HASH->CR &= ~HASH_CR_LKEY;
 8003ae2:	4613      	mov	r3, r2
 8003ae4:	6812      	ldr	r2, [r2, #0]
 8003ae6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003aea:	601a      	str	r2, [r3, #0]
    HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
 8003aec:	681a      	ldr	r2, [r3, #0]
 8003aee:	68c1      	ldr	r1, [r0, #12]
 8003af0:	430a      	orrs	r2, r1
 8003af2:	601a      	str	r2, [r3, #0]
 8003af4:	e7ed      	b.n	8003ad2 <HASH_Init+0x26>
 8003af6:	bf00      	nop
 8003af8:	50060400 	.word	0x50060400

08003afc <HASH_StructInit>:
  * @retval None
  */
void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
{
  /* Initialize the HASH_AlgoSelection member */
  HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
 8003afc:	2300      	movs	r3, #0
 8003afe:	6003      	str	r3, [r0, #0]

  /* Initialize the HASH_AlgoMode member */
  HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
 8003b00:	6043      	str	r3, [r0, #4]

  /* Initialize the HASH_DataType member */
  HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
 8003b02:	6083      	str	r3, [r0, #8]

  /* Initialize the HASH_HMACKeyType member */
  HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
 8003b04:	60c3      	str	r3, [r0, #12]
 8003b06:	4770      	bx	lr

08003b08 <HASH_Reset>:
  * @retval None
  */
void HASH_Reset(void)
{
  /* Reset the HASH processor core */
  HASH->CR |= HASH_CR_INIT;
 8003b08:	4a02      	ldr	r2, [pc, #8]	; (8003b14 <HASH_Reset+0xc>)
 8003b0a:	6813      	ldr	r3, [r2, #0]
 8003b0c:	f043 0304 	orr.w	r3, r3, #4
 8003b10:	6013      	str	r3, [r2, #0]
 8003b12:	4770      	bx	lr
 8003b14:	50060400 	.word	0x50060400

08003b18 <HASH_SetLastWordValidBitsNbr>:
{
  /* Check the parameters */
  assert_param(IS_HASH_VALIDBITSNUMBER(ValidNumber));
  
  /* Configure the Number of valid bits in last word of the message */
  HASH->STR &= ~(HASH_STR_NBW);
 8003b18:	4b04      	ldr	r3, [pc, #16]	; (8003b2c <HASH_SetLastWordValidBitsNbr+0x14>)
 8003b1a:	689a      	ldr	r2, [r3, #8]
 8003b1c:	f022 021f 	bic.w	r2, r2, #31
 8003b20:	609a      	str	r2, [r3, #8]
  HASH->STR |= ValidNumber;
 8003b22:	689a      	ldr	r2, [r3, #8]
 8003b24:	4310      	orrs	r0, r2
 8003b26:	6098      	str	r0, [r3, #8]
 8003b28:	4770      	bx	lr
 8003b2a:	bf00      	nop
 8003b2c:	50060400 	.word	0x50060400

08003b30 <HASH_DataIn>:
  * @retval None
  */
void HASH_DataIn(uint32_t Data)
{
  /* Write in the DIN register a new data */
  HASH->DIN = Data;
 8003b30:	4b01      	ldr	r3, [pc, #4]	; (8003b38 <HASH_DataIn+0x8>)
 8003b32:	6058      	str	r0, [r3, #4]
 8003b34:	4770      	bx	lr
 8003b36:	bf00      	nop
 8003b38:	50060400 	.word	0x50060400

08003b3c <HASH_GetInFIFOWordsNbr>:
  * @retval The value of words already pushed into the IN FIFO.
  */
uint8_t HASH_GetInFIFOWordsNbr(void)
{
  /* Return the value of NBW bits */
  return ((HASH->CR & HASH_CR_NBW) >> 8);
 8003b3c:	4b02      	ldr	r3, [pc, #8]	; (8003b48 <HASH_GetInFIFOWordsNbr+0xc>)
 8003b3e:	6818      	ldr	r0, [r3, #0]
}
 8003b40:	f3c0 2003 	ubfx	r0, r0, #8, #4
 8003b44:	4770      	bx	lr
 8003b46:	bf00      	nop
 8003b48:	50060400 	.word	0x50060400

08003b4c <HASH_GetDigest>:
  * @retval None
  */
void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest)
{
  /* Get the data field */
  HASH_MessageDigest->Data[0] = HASH->HR[0];
 8003b4c:	4b09      	ldr	r3, [pc, #36]	; (8003b74 <HASH_GetDigest+0x28>)
 8003b4e:	68da      	ldr	r2, [r3, #12]
 8003b50:	6002      	str	r2, [r0, #0]
  HASH_MessageDigest->Data[1] = HASH->HR[1];
 8003b52:	691a      	ldr	r2, [r3, #16]
 8003b54:	6042      	str	r2, [r0, #4]
  HASH_MessageDigest->Data[2] = HASH->HR[2];
 8003b56:	695a      	ldr	r2, [r3, #20]
 8003b58:	6082      	str	r2, [r0, #8]
  HASH_MessageDigest->Data[3] = HASH->HR[3];
 8003b5a:	699a      	ldr	r2, [r3, #24]
 8003b5c:	60c2      	str	r2, [r0, #12]
  HASH_MessageDigest->Data[4] = HASH->HR[4];
 8003b5e:	69db      	ldr	r3, [r3, #28]
 8003b60:	6103      	str	r3, [r0, #16]
  HASH_MessageDigest->Data[5] = HASH_DIGEST->HR[5];
 8003b62:	4b05      	ldr	r3, [pc, #20]	; (8003b78 <HASH_GetDigest+0x2c>)
 8003b64:	695a      	ldr	r2, [r3, #20]
 8003b66:	6142      	str	r2, [r0, #20]
  HASH_MessageDigest->Data[6] = HASH_DIGEST->HR[6];
 8003b68:	699a      	ldr	r2, [r3, #24]
 8003b6a:	6182      	str	r2, [r0, #24]
  HASH_MessageDigest->Data[7] = HASH_DIGEST->HR[7];
 8003b6c:	69db      	ldr	r3, [r3, #28]
 8003b6e:	61c3      	str	r3, [r0, #28]
 8003b70:	4770      	bx	lr
 8003b72:	bf00      	nop
 8003b74:	50060400 	.word	0x50060400
 8003b78:	50060710 	.word	0x50060710

08003b7c <HASH_StartDigest>:
  * @retval None
  */
void HASH_StartDigest(void)
{
  /* Start the Digest calculation */
  HASH->STR |= HASH_STR_DCAL;
 8003b7c:	4a02      	ldr	r2, [pc, #8]	; (8003b88 <HASH_StartDigest+0xc>)
 8003b7e:	6893      	ldr	r3, [r2, #8]
 8003b80:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003b84:	6093      	str	r3, [r2, #8]
 8003b86:	4770      	bx	lr
 8003b88:	50060400 	.word	0x50060400

08003b8c <HASH_SaveContext>:
void HASH_SaveContext(HASH_Context* HASH_ContextSave)
{
  uint8_t i = 0;
  
  /* save context registers */
  HASH_ContextSave->HASH_IMR = HASH->IMR;  
 8003b8c:	4b0b      	ldr	r3, [pc, #44]	; (8003bbc <HASH_SaveContext+0x30>)
 8003b8e:	6a1a      	ldr	r2, [r3, #32]
 8003b90:	6002      	str	r2, [r0, #0]
  HASH_ContextSave->HASH_STR = HASH->STR;      
 8003b92:	689a      	ldr	r2, [r3, #8]
 8003b94:	6042      	str	r2, [r0, #4]
  HASH_ContextSave->HASH_CR  = HASH->CR;     
 8003b96:	681b      	ldr	r3, [r3, #0]
 8003b98:	6083      	str	r3, [r0, #8]
  for(i=0; i<=53;i++)
 8003b9a:	2300      	movs	r3, #0
 8003b9c:	e00a      	b.n	8003bb4 <HASH_SaveContext+0x28>
  {
     HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
 8003b9e:	f103 013e 	add.w	r1, r3, #62	; 0x3e
 8003ba2:	4a06      	ldr	r2, [pc, #24]	; (8003bbc <HASH_SaveContext+0x30>)
 8003ba4:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
 8003ba8:	1c9a      	adds	r2, r3, #2
 8003baa:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8003bae:	6051      	str	r1, [r2, #4]
  for(i=0; i<=53;i++)
 8003bb0:	3301      	adds	r3, #1
 8003bb2:	b2db      	uxtb	r3, r3
 8003bb4:	2b35      	cmp	r3, #53	; 0x35
 8003bb6:	d9f2      	bls.n	8003b9e <HASH_SaveContext+0x12>
  }   
}
 8003bb8:	4770      	bx	lr
 8003bba:	bf00      	nop
 8003bbc:	50060400 	.word	0x50060400

08003bc0 <HASH_RestoreContext>:
void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
{
  uint8_t i = 0;
  
  /* restore context registers */
  HASH->IMR = HASH_ContextRestore->HASH_IMR;   
 8003bc0:	6802      	ldr	r2, [r0, #0]
 8003bc2:	4b0f      	ldr	r3, [pc, #60]	; (8003c00 <HASH_RestoreContext+0x40>)
 8003bc4:	621a      	str	r2, [r3, #32]
  HASH->STR = HASH_ContextRestore->HASH_STR;     
 8003bc6:	6842      	ldr	r2, [r0, #4]
 8003bc8:	609a      	str	r2, [r3, #8]
  HASH->CR = HASH_ContextRestore->HASH_CR;
 8003bca:	6882      	ldr	r2, [r0, #8]
 8003bcc:	601a      	str	r2, [r3, #0]
  
  /* Initialize the hash processor */
  HASH->CR |= HASH_CR_INIT; 
 8003bce:	681a      	ldr	r2, [r3, #0]
 8003bd0:	f042 0204 	orr.w	r2, r2, #4
 8003bd4:	601a      	str	r2, [r3, #0]
  
   /* continue restoring context registers */     
  for(i=0; i<=53;i++)
 8003bd6:	2300      	movs	r3, #0
 8003bd8:	2b35      	cmp	r3, #53	; 0x35
 8003bda:	d810      	bhi.n	8003bfe <HASH_RestoreContext+0x3e>
{
 8003bdc:	b410      	push	{r4}
  {
     HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
 8003bde:	1c9a      	adds	r2, r3, #2
 8003be0:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8003be4:	6854      	ldr	r4, [r2, #4]
 8003be6:	f103 013e 	add.w	r1, r3, #62	; 0x3e
 8003bea:	4a05      	ldr	r2, [pc, #20]	; (8003c00 <HASH_RestoreContext+0x40>)
 8003bec:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
  for(i=0; i<=53;i++)
 8003bf0:	3301      	adds	r3, #1
 8003bf2:	b2db      	uxtb	r3, r3
 8003bf4:	2b35      	cmp	r3, #53	; 0x35
 8003bf6:	d9f2      	bls.n	8003bde <HASH_RestoreContext+0x1e>
  }   
}
 8003bf8:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003bfc:	4770      	bx	lr
 8003bfe:	4770      	bx	lr
 8003c00:	50060400 	.word	0x50060400

08003c04 <HASH_AutoStartDigest>:
void HASH_AutoStartDigest(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003c04:	b928      	cbnz	r0, 8003c12 <HASH_AutoStartDigest+0xe>
    HASH->CR &= ~HASH_CR_MDMAT;
  }
  else
  {
    /* Disable the auto start of the final message digest at the end of DMA transfer */
    HASH->CR |= HASH_CR_MDMAT;
 8003c06:	4a06      	ldr	r2, [pc, #24]	; (8003c20 <HASH_AutoStartDigest+0x1c>)
 8003c08:	6813      	ldr	r3, [r2, #0]
 8003c0a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8003c0e:	6013      	str	r3, [r2, #0]
 8003c10:	4770      	bx	lr
    HASH->CR &= ~HASH_CR_MDMAT;
 8003c12:	4a03      	ldr	r2, [pc, #12]	; (8003c20 <HASH_AutoStartDigest+0x1c>)
 8003c14:	6813      	ldr	r3, [r2, #0]
 8003c16:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003c1a:	6013      	str	r3, [r2, #0]
 8003c1c:	4770      	bx	lr
 8003c1e:	bf00      	nop
 8003c20:	50060400 	.word	0x50060400

08003c24 <HASH_DMACmd>:
void HASH_DMACmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003c24:	b928      	cbnz	r0, 8003c32 <HASH_DMACmd+0xe>
    HASH->CR |= HASH_CR_DMAE;
  }
  else
  {
    /* Disable the HASH DMA request */
    HASH->CR &= ~HASH_CR_DMAE;
 8003c26:	4a06      	ldr	r2, [pc, #24]	; (8003c40 <HASH_DMACmd+0x1c>)
 8003c28:	6813      	ldr	r3, [r2, #0]
 8003c2a:	f023 0308 	bic.w	r3, r3, #8
 8003c2e:	6013      	str	r3, [r2, #0]
 8003c30:	4770      	bx	lr
    HASH->CR |= HASH_CR_DMAE;
 8003c32:	4a03      	ldr	r2, [pc, #12]	; (8003c40 <HASH_DMACmd+0x1c>)
 8003c34:	6813      	ldr	r3, [r2, #0]
 8003c36:	f043 0308 	orr.w	r3, r3, #8
 8003c3a:	6013      	str	r3, [r2, #0]
 8003c3c:	4770      	bx	lr
 8003c3e:	bf00      	nop
 8003c40:	50060400 	.word	0x50060400

08003c44 <HASH_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_HASH_IT(HASH_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003c44:	b929      	cbnz	r1, 8003c52 <HASH_ITConfig+0xe>
    HASH->IMR |= HASH_IT;
  }
  else
  {
    /* Disable the selected HASH interrupt */
    HASH->IMR &= (uint32_t)(~HASH_IT);
 8003c46:	4a05      	ldr	r2, [pc, #20]	; (8003c5c <HASH_ITConfig+0x18>)
 8003c48:	6a13      	ldr	r3, [r2, #32]
 8003c4a:	ea23 0000 	bic.w	r0, r3, r0
 8003c4e:	6210      	str	r0, [r2, #32]
 8003c50:	4770      	bx	lr
    HASH->IMR |= HASH_IT;
 8003c52:	4a02      	ldr	r2, [pc, #8]	; (8003c5c <HASH_ITConfig+0x18>)
 8003c54:	6a13      	ldr	r3, [r2, #32]
 8003c56:	4318      	orrs	r0, r3
 8003c58:	6210      	str	r0, [r2, #32]
 8003c5a:	4770      	bx	lr
 8003c5c:	50060400 	.word	0x50060400

08003c60 <HASH_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_HASH_GET_FLAG(HASH_FLAG));

  /* check if the FLAG is in CR register */
  if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint32_t)RESET ) 
 8003c60:	f410 5f80 	tst.w	r0, #4096	; 0x1000
 8003c64:	d005      	beq.n	8003c72 <HASH_GetFlagStatus+0x12>
  {
    tempreg = HASH->CR;
 8003c66:	4b05      	ldr	r3, [pc, #20]	; (8003c7c <HASH_GetFlagStatus+0x1c>)
 8003c68:	681b      	ldr	r3, [r3, #0]
  {
    tempreg = HASH->SR;
  }

  /* Check the status of the specified HASH flag */
  if ((tempreg & HASH_FLAG) != (uint32_t)RESET)
 8003c6a:	4203      	tst	r3, r0
 8003c6c:	d104      	bne.n	8003c78 <HASH_GetFlagStatus+0x18>
    bitstatus = SET;
  }
  else
  {
    /* HASH_FLAG is reset */
    bitstatus = RESET;
 8003c6e:	2000      	movs	r0, #0
  }

  /* Return the HASH_FLAG status */
  return  bitstatus;
}
 8003c70:	4770      	bx	lr
    tempreg = HASH->SR;
 8003c72:	4b02      	ldr	r3, [pc, #8]	; (8003c7c <HASH_GetFlagStatus+0x1c>)
 8003c74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003c76:	e7f8      	b.n	8003c6a <HASH_GetFlagStatus+0xa>
    bitstatus = SET;
 8003c78:	2001      	movs	r0, #1
 8003c7a:	4770      	bx	lr
 8003c7c:	50060400 	.word	0x50060400

08003c80 <HASH_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_HASH_CLEAR_FLAG(HASH_FLAG));
  
  /* Clear the selected HASH flags */
  HASH->SR = ~(uint32_t)HASH_FLAG;
 8003c80:	43c0      	mvns	r0, r0
 8003c82:	4b01      	ldr	r3, [pc, #4]	; (8003c88 <HASH_ClearFlag+0x8>)
 8003c84:	6258      	str	r0, [r3, #36]	; 0x24
 8003c86:	4770      	bx	lr
 8003c88:	50060400 	.word	0x50060400

08003c8c <HASH_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_HASH_GET_IT(HASH_IT));  


  /* Check the status of the specified HASH interrupt */
  tmpreg =  HASH->SR;
 8003c8c:	4a04      	ldr	r2, [pc, #16]	; (8003ca0 <HASH_GetITStatus+0x14>)
 8003c8e:	6a53      	ldr	r3, [r2, #36]	; 0x24

  if (((HASH->IMR & tmpreg) & HASH_IT) != RESET)
 8003c90:	6a12      	ldr	r2, [r2, #32]
 8003c92:	4013      	ands	r3, r2
 8003c94:	4203      	tst	r3, r0
 8003c96:	d101      	bne.n	8003c9c <HASH_GetITStatus+0x10>
    bitstatus = SET;
  }
  else
  {
    /* HASH_IT is reset */
    bitstatus = RESET;
 8003c98:	2000      	movs	r0, #0
  }
  /* Return the HASH_IT status */
  return bitstatus;
}
 8003c9a:	4770      	bx	lr
    bitstatus = SET;
 8003c9c:	2001      	movs	r0, #1
 8003c9e:	4770      	bx	lr
 8003ca0:	50060400 	.word	0x50060400

08003ca4 <HASH_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_HASH_IT(HASH_IT));

  /* Clear the selected HASH interrupt pending bit */
  HASH->SR = (uint32_t)(~HASH_IT);
 8003ca4:	43c0      	mvns	r0, r0
 8003ca6:	4b01      	ldr	r3, [pc, #4]	; (8003cac <HASH_ClearITPendingBit+0x8>)
 8003ca8:	6258      	str	r0, [r3, #36]	; 0x24
 8003caa:	4770      	bx	lr
 8003cac:	50060400 	.word	0x50060400

08003cb0 <HASH_MD5>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HASH_MD5(uint8_t *Input, uint32_t Ilen, uint8_t Output[16])
{
 8003cb0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003cb2:	b08f      	sub	sp, #60	; 0x3c
 8003cb4:	460f      	mov	r7, r1
 8003cb6:	4616      	mov	r6, r2
  HASH_InitTypeDef MD5_HASH_InitStructure;
  HASH_MsgDigest MD5_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 8003cb8:	2400      	movs	r4, #0
 8003cba:	f8ad 4006 	strh.w	r4, [sp, #6]
  uint32_t i = 0;
  __IO uint32_t counter = 0;
 8003cbe:	9400      	str	r4, [sp, #0]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t inputaddr  = (uint32_t)Input;
 8003cc0:	4605      	mov	r5, r0
  uint32_t outputaddr = (uint32_t)Output;


  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8003cc2:	f001 0303 	and.w	r3, r1, #3
 8003cc6:	00db      	lsls	r3, r3, #3
 8003cc8:	f8ad 3006 	strh.w	r3, [sp, #6]

  /* HASH peripheral initialization */
  HASH_DeInit();
 8003ccc:	f7ff fee4 	bl	8003a98 <HASH_DeInit>

  /* HASH Configuration */
  MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
 8003cd0:	2380      	movs	r3, #128	; 0x80
 8003cd2:	930a      	str	r3, [sp, #40]	; 0x28
  MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
 8003cd4:	940b      	str	r4, [sp, #44]	; 0x2c
  MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 8003cd6:	2320      	movs	r3, #32
 8003cd8:	930c      	str	r3, [sp, #48]	; 0x30
  HASH_Init(&MD5_HASH_InitStructure);
 8003cda:	a80a      	add	r0, sp, #40	; 0x28
 8003cdc:	f7ff fee6 	bl	8003aac <HASH_Init>

  /* Configure the number of valid bits in last word of the data */
  HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
 8003ce0:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8003ce4:	b280      	uxth	r0, r0
 8003ce6:	f7ff ff17 	bl	8003b18 <HASH_SetLastWordValidBitsNbr>

  /* Write the Input block in the IN FIFO */
  for(i=0; i<Ilen; i+=4)
 8003cea:	e004      	b.n	8003cf6 <HASH_MD5+0x46>
  {
    HASH_DataIn(*(uint32_t*)inputaddr);
 8003cec:	f855 0b04 	ldr.w	r0, [r5], #4
 8003cf0:	f7ff ff1e 	bl	8003b30 <HASH_DataIn>
  for(i=0; i<Ilen; i+=4)
 8003cf4:	3404      	adds	r4, #4
 8003cf6:	42bc      	cmp	r4, r7
 8003cf8:	d3f8      	bcc.n	8003cec <HASH_MD5+0x3c>
    inputaddr+=4;
  }

  /* Start the HASH processor */
  HASH_StartDigest();
 8003cfa:	f7ff ff3f 	bl	8003b7c <HASH_StartDigest>

  /* wait until the Busy flag is RESET */
  do
  {
    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8003cfe:	2008      	movs	r0, #8
 8003d00:	f7ff ffae 	bl	8003c60 <HASH_GetFlagStatus>
 8003d04:	4602      	mov	r2, r0
    counter++;
 8003d06:	9b00      	ldr	r3, [sp, #0]
 8003d08:	3301      	adds	r3, #1
 8003d0a:	9300      	str	r3, [sp, #0]
  }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
 8003d0c:	9b00      	ldr	r3, [sp, #0]
 8003d0e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003d12:	d001      	beq.n	8003d18 <HASH_MD5+0x68>
 8003d14:	2800      	cmp	r0, #0
 8003d16:	d1f2      	bne.n	8003cfe <HASH_MD5+0x4e>

  if (busystatus != RESET)
 8003d18:	b112      	cbz	r2, 8003d20 <HASH_MD5+0x70>
  {
     status = ERROR;
 8003d1a:	2000      	movs	r0, #0
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
  }
  return status; 
}
 8003d1c:	b00f      	add	sp, #60	; 0x3c
 8003d1e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    HASH_GetDigest(&MD5_MessageDigest);
 8003d20:	a802      	add	r0, sp, #8
 8003d22:	f7ff ff13 	bl	8003b4c <HASH_GetDigest>
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[0]);
 8003d26:	9b02      	ldr	r3, [sp, #8]
 8003d28:	ba1b      	rev	r3, r3
 8003d2a:	6033      	str	r3, [r6, #0]
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[1]);
 8003d2c:	9b03      	ldr	r3, [sp, #12]
 8003d2e:	ba1b      	rev	r3, r3
 8003d30:	6073      	str	r3, [r6, #4]
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
 8003d32:	9b04      	ldr	r3, [sp, #16]
 8003d34:	ba1b      	rev	r3, r3
 8003d36:	60b3      	str	r3, [r6, #8]
    *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
 8003d38:	9b05      	ldr	r3, [sp, #20]
 8003d3a:	ba1b      	rev	r3, r3
 8003d3c:	60f3      	str	r3, [r6, #12]
  ErrorStatus status = SUCCESS;
 8003d3e:	2001      	movs	r0, #1
 8003d40:	e7ec      	b.n	8003d1c <HASH_MD5+0x6c>

08003d42 <HMAC_MD5>:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HMAC_MD5(uint8_t *Key, uint32_t Keylen, uint8_t *Input, 
                     uint32_t Ilen, uint8_t Output[16])
{
 8003d42:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003d46:	b08f      	sub	sp, #60	; 0x3c
 8003d48:	4681      	mov	r9, r0
 8003d4a:	460d      	mov	r5, r1
 8003d4c:	461f      	mov	r7, r3
  HASH_InitTypeDef MD5_HASH_InitStructure;
  HASH_MsgDigest MD5_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 8003d4e:	2300      	movs	r3, #0
 8003d50:	f8ad 3006 	strh.w	r3, [sp, #6]
  __IO uint16_t nbvalidbitskey = 0;
 8003d54:	f8ad 3004 	strh.w	r3, [sp, #4]
  uint32_t i = 0;
  __IO uint32_t counter = 0;
 8003d58:	9300      	str	r3, [sp, #0]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
 8003d5a:	4680      	mov	r8, r0
  uint32_t inputaddr  = (uint32_t)Input;
 8003d5c:	4616      	mov	r6, r2
  uint32_t outputaddr = (uint32_t)Output;

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8003d5e:	f007 0303 	and.w	r3, r7, #3
 8003d62:	00db      	lsls	r3, r3, #3
 8003d64:	f8ad 3006 	strh.w	r3, [sp, #6]

  /* Number of valid bits in last word of the Key */
  nbvalidbitskey = 8 * (Keylen % 4);
 8003d68:	f001 0303 	and.w	r3, r1, #3
 8003d6c:	00db      	lsls	r3, r3, #3
 8003d6e:	f8ad 3004 	strh.w	r3, [sp, #4]
   
  /* HASH peripheral initialization */
  HASH_DeInit();
 8003d72:	f7ff fe91 	bl	8003a98 <HASH_DeInit>

  /* HASH Configuration */
  MD5_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_MD5;
 8003d76:	2380      	movs	r3, #128	; 0x80
 8003d78:	930a      	str	r3, [sp, #40]	; 0x28
  MD5_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
 8003d7a:	2340      	movs	r3, #64	; 0x40
 8003d7c:	930b      	str	r3, [sp, #44]	; 0x2c
  MD5_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 8003d7e:	2320      	movs	r3, #32
 8003d80:	930c      	str	r3, [sp, #48]	; 0x30
  if(Keylen > 64)
 8003d82:	2d40      	cmp	r5, #64	; 0x40
 8003d84:	d90c      	bls.n	8003da0 <HMAC_MD5+0x5e>
  {
    /* HMAC long Key */
    MD5_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
 8003d86:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8003d8a:	930d      	str	r3, [sp, #52]	; 0x34
  else
  {
    /* HMAC short Key */
    MD5_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
  }
  HASH_Init(&MD5_HASH_InitStructure);
 8003d8c:	a80a      	add	r0, sp, #40	; 0x28
 8003d8e:	f7ff fe8d 	bl	8003aac <HASH_Init>

  /* Configure the number of valid bits in last word of the Key */
  HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
 8003d92:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8003d96:	b280      	uxth	r0, r0
 8003d98:	f7ff febe 	bl	8003b18 <HASH_SetLastWordValidBitsNbr>

  /* Write the Key */
  for(i=0; i<Keylen; i+=4)
 8003d9c:	2400      	movs	r4, #0
 8003d9e:	e007      	b.n	8003db0 <HMAC_MD5+0x6e>
    MD5_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
 8003da0:	2300      	movs	r3, #0
 8003da2:	930d      	str	r3, [sp, #52]	; 0x34
 8003da4:	e7f2      	b.n	8003d8c <HMAC_MD5+0x4a>
  {
    HASH_DataIn(*(uint32_t*)keyaddr);
 8003da6:	f859 0b04 	ldr.w	r0, [r9], #4
 8003daa:	f7ff fec1 	bl	8003b30 <HASH_DataIn>
  for(i=0; i<Keylen; i+=4)
 8003dae:	3404      	adds	r4, #4
 8003db0:	42ac      	cmp	r4, r5
 8003db2:	d3f8      	bcc.n	8003da6 <HMAC_MD5+0x64>
    keyaddr+=4;
  }
  
  /* Start the HASH processor */
  HASH_StartDigest();
 8003db4:	f7ff fee2 	bl	8003b7c <HASH_StartDigest>

  /* wait until the Busy flag is RESET */
  do
  {
    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8003db8:	2008      	movs	r0, #8
 8003dba:	f7ff ff51 	bl	8003c60 <HASH_GetFlagStatus>
 8003dbe:	4604      	mov	r4, r0
    counter++;
 8003dc0:	9b00      	ldr	r3, [sp, #0]
 8003dc2:	3301      	adds	r3, #1
 8003dc4:	9300      	str	r3, [sp, #0]
  }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
 8003dc6:	9b00      	ldr	r3, [sp, #0]
 8003dc8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003dcc:	d001      	beq.n	8003dd2 <HMAC_MD5+0x90>
 8003dce:	2800      	cmp	r0, #0
 8003dd0:	d1f2      	bne.n	8003db8 <HMAC_MD5+0x76>

  if (busystatus != RESET)
 8003dd2:	b11c      	cbz	r4, 8003ddc <HMAC_MD5+0x9a>
  {
     status = ERROR;
 8003dd4:	2000      	movs	r0, #0
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
      }
    }
  }
  return status;  
}
 8003dd6:	b00f      	add	sp, #60	; 0x3c
 8003dd8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
 8003ddc:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8003de0:	b280      	uxth	r0, r0
 8003de2:	f7ff fe99 	bl	8003b18 <HASH_SetLastWordValidBitsNbr>
    for(i=0; i<Ilen; i+=4)
 8003de6:	e004      	b.n	8003df2 <HMAC_MD5+0xb0>
      HASH_DataIn(*(uint32_t*)inputaddr);
 8003de8:	f856 0b04 	ldr.w	r0, [r6], #4
 8003dec:	f7ff fea0 	bl	8003b30 <HASH_DataIn>
    for(i=0; i<Ilen; i+=4)
 8003df0:	3404      	adds	r4, #4
 8003df2:	42bc      	cmp	r4, r7
 8003df4:	d3f8      	bcc.n	8003de8 <HMAC_MD5+0xa6>
    HASH_StartDigest();
 8003df6:	f7ff fec1 	bl	8003b7c <HASH_StartDigest>
    counter =0;
 8003dfa:	2300      	movs	r3, #0
 8003dfc:	9300      	str	r3, [sp, #0]
       busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8003dfe:	2008      	movs	r0, #8
 8003e00:	f7ff ff2e 	bl	8003c60 <HASH_GetFlagStatus>
 8003e04:	4604      	mov	r4, r0
       counter++;
 8003e06:	9b00      	ldr	r3, [sp, #0]
 8003e08:	3301      	adds	r3, #1
 8003e0a:	9300      	str	r3, [sp, #0]
    }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
 8003e0c:	9b00      	ldr	r3, [sp, #0]
 8003e0e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003e12:	d001      	beq.n	8003e18 <HMAC_MD5+0xd6>
 8003e14:	2800      	cmp	r0, #0
 8003e16:	d1f2      	bne.n	8003dfe <HMAC_MD5+0xbc>
    if (busystatus != RESET)
 8003e18:	b10c      	cbz	r4, 8003e1e <HMAC_MD5+0xdc>
      status = ERROR;
 8003e1a:	2000      	movs	r0, #0
 8003e1c:	e7db      	b.n	8003dd6 <HMAC_MD5+0x94>
      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
 8003e1e:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8003e22:	b280      	uxth	r0, r0
 8003e24:	f7ff fe78 	bl	8003b18 <HASH_SetLastWordValidBitsNbr>
      for(i=0; i<Keylen; i+=4)
 8003e28:	e004      	b.n	8003e34 <HMAC_MD5+0xf2>
        HASH_DataIn(*(uint32_t*)keyaddr);
 8003e2a:	f858 0b04 	ldr.w	r0, [r8], #4
 8003e2e:	f7ff fe7f 	bl	8003b30 <HASH_DataIn>
      for(i=0; i<Keylen; i+=4)
 8003e32:	3404      	adds	r4, #4
 8003e34:	42ac      	cmp	r4, r5
 8003e36:	d3f8      	bcc.n	8003e2a <HMAC_MD5+0xe8>
       HASH_StartDigest();
 8003e38:	f7ff fea0 	bl	8003b7c <HASH_StartDigest>
       counter =0;
 8003e3c:	2300      	movs	r3, #0
 8003e3e:	9300      	str	r3, [sp, #0]
          busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8003e40:	2008      	movs	r0, #8
 8003e42:	f7ff ff0d 	bl	8003c60 <HASH_GetFlagStatus>
 8003e46:	4602      	mov	r2, r0
          counter++;
 8003e48:	9b00      	ldr	r3, [sp, #0]
 8003e4a:	3301      	adds	r3, #1
 8003e4c:	9300      	str	r3, [sp, #0]
      }while ((counter != MD5BUSY_TIMEOUT) && (busystatus != RESET));
 8003e4e:	9b00      	ldr	r3, [sp, #0]
 8003e50:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003e54:	d001      	beq.n	8003e5a <HMAC_MD5+0x118>
 8003e56:	2800      	cmp	r0, #0
 8003e58:	d1f2      	bne.n	8003e40 <HMAC_MD5+0xfe>
      if (busystatus != RESET)
 8003e5a:	b10a      	cbz	r2, 8003e60 <HMAC_MD5+0x11e>
         status = ERROR;
 8003e5c:	2000      	movs	r0, #0
 8003e5e:	e7ba      	b.n	8003dd6 <HMAC_MD5+0x94>
         HASH_GetDigest(&MD5_MessageDigest);
 8003e60:	a802      	add	r0, sp, #8
 8003e62:	f7ff fe73 	bl	8003b4c <HASH_GetDigest>
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[0]);
 8003e66:	9b02      	ldr	r3, [sp, #8]
 8003e68:	ba1b      	rev	r3, r3
 8003e6a:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8003e6c:	6013      	str	r3, [r2, #0]
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[1]);
 8003e6e:	9b03      	ldr	r3, [sp, #12]
 8003e70:	ba1b      	rev	r3, r3
 8003e72:	6053      	str	r3, [r2, #4]
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[2]);
 8003e74:	9b04      	ldr	r3, [sp, #16]
 8003e76:	ba1b      	rev	r3, r3
 8003e78:	6093      	str	r3, [r2, #8]
         *(uint32_t*)(outputaddr)  = __REV(MD5_MessageDigest.Data[3]);
 8003e7a:	9b05      	ldr	r3, [sp, #20]
 8003e7c:	ba1b      	rev	r3, r3
 8003e7e:	60d3      	str	r3, [r2, #12]
  ErrorStatus status = SUCCESS;
 8003e80:	2001      	movs	r0, #1
 8003e82:	e7a8      	b.n	8003dd6 <HMAC_MD5+0x94>

08003e84 <HASH_SHA1>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20])
{
 8003e84:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003e86:	b08f      	sub	sp, #60	; 0x3c
 8003e88:	460f      	mov	r7, r1
 8003e8a:	4616      	mov	r6, r2
  HASH_InitTypeDef SHA1_HASH_InitStructure;
  HASH_MsgDigest SHA1_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 8003e8c:	2400      	movs	r4, #0
 8003e8e:	f8ad 4006 	strh.w	r4, [sp, #6]
  uint32_t i = 0;
  __IO uint32_t counter = 0;
 8003e92:	9400      	str	r4, [sp, #0]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t inputaddr  = (uint32_t)Input;
 8003e94:	4605      	mov	r5, r0
  uint32_t outputaddr = (uint32_t)Output;

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8003e96:	f001 0303 	and.w	r3, r1, #3
 8003e9a:	00db      	lsls	r3, r3, #3
 8003e9c:	f8ad 3006 	strh.w	r3, [sp, #6]

  /* HASH peripheral initialization */
  HASH_DeInit();
 8003ea0:	f7ff fdfa 	bl	8003a98 <HASH_DeInit>

  /* HASH Configuration */
  SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
 8003ea4:	940a      	str	r4, [sp, #40]	; 0x28
  SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HASH;
 8003ea6:	940b      	str	r4, [sp, #44]	; 0x2c
  SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 8003ea8:	2320      	movs	r3, #32
 8003eaa:	930c      	str	r3, [sp, #48]	; 0x30
  HASH_Init(&SHA1_HASH_InitStructure);
 8003eac:	a80a      	add	r0, sp, #40	; 0x28
 8003eae:	f7ff fdfd 	bl	8003aac <HASH_Init>

  /* Configure the number of valid bits in last word of the data */
  HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
 8003eb2:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8003eb6:	b280      	uxth	r0, r0
 8003eb8:	f7ff fe2e 	bl	8003b18 <HASH_SetLastWordValidBitsNbr>

  /* Write the Input block in the IN FIFO */
  for(i=0; i<Ilen; i+=4)
 8003ebc:	e004      	b.n	8003ec8 <HASH_SHA1+0x44>
  {
    HASH_DataIn(*(uint32_t*)inputaddr);
 8003ebe:	f855 0b04 	ldr.w	r0, [r5], #4
 8003ec2:	f7ff fe35 	bl	8003b30 <HASH_DataIn>
  for(i=0; i<Ilen; i+=4)
 8003ec6:	3404      	adds	r4, #4
 8003ec8:	42bc      	cmp	r4, r7
 8003eca:	d3f8      	bcc.n	8003ebe <HASH_SHA1+0x3a>
    inputaddr+=4;
  }

  /* Start the HASH processor */
  HASH_StartDigest();
 8003ecc:	f7ff fe56 	bl	8003b7c <HASH_StartDigest>

  /* wait until the Busy flag is RESET */
  do
  {
    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8003ed0:	2008      	movs	r0, #8
 8003ed2:	f7ff fec5 	bl	8003c60 <HASH_GetFlagStatus>
 8003ed6:	4602      	mov	r2, r0
    counter++;
 8003ed8:	9b00      	ldr	r3, [sp, #0]
 8003eda:	3301      	adds	r3, #1
 8003edc:	9300      	str	r3, [sp, #0]
  }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
 8003ede:	9b00      	ldr	r3, [sp, #0]
 8003ee0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003ee4:	d001      	beq.n	8003eea <HASH_SHA1+0x66>
 8003ee6:	2800      	cmp	r0, #0
 8003ee8:	d1f2      	bne.n	8003ed0 <HASH_SHA1+0x4c>

  if (busystatus != RESET)
 8003eea:	b112      	cbz	r2, 8003ef2 <HASH_SHA1+0x6e>
  {
     status = ERROR;
 8003eec:	2000      	movs	r0, #0
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
    outputaddr+=4;
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
  }
  return status;
}
 8003eee:	b00f      	add	sp, #60	; 0x3c
 8003ef0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    HASH_GetDigest(&SHA1_MessageDigest);
 8003ef2:	a802      	add	r0, sp, #8
 8003ef4:	f7ff fe2a 	bl	8003b4c <HASH_GetDigest>
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
 8003ef8:	9b02      	ldr	r3, [sp, #8]
 8003efa:	ba1b      	rev	r3, r3
 8003efc:	6033      	str	r3, [r6, #0]
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
 8003efe:	9b03      	ldr	r3, [sp, #12]
 8003f00:	ba1b      	rev	r3, r3
 8003f02:	6073      	str	r3, [r6, #4]
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
 8003f04:	9b04      	ldr	r3, [sp, #16]
 8003f06:	ba1b      	rev	r3, r3
 8003f08:	60b3      	str	r3, [r6, #8]
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
 8003f0a:	9b05      	ldr	r3, [sp, #20]
 8003f0c:	ba1b      	rev	r3, r3
 8003f0e:	60f3      	str	r3, [r6, #12]
    *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
 8003f10:	9b06      	ldr	r3, [sp, #24]
 8003f12:	ba1b      	rev	r3, r3
 8003f14:	6133      	str	r3, [r6, #16]
  ErrorStatus status = SUCCESS;
 8003f16:	2001      	movs	r0, #1
 8003f18:	e7e9      	b.n	8003eee <HASH_SHA1+0x6a>

08003f1a <HMAC_SHA1>:
  *          - SUCCESS: digest computation done
  *          - ERROR: digest computation failed
  */
ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen, uint8_t *Input,
                      uint32_t Ilen, uint8_t Output[20])
{
 8003f1a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003f1e:	b08f      	sub	sp, #60	; 0x3c
 8003f20:	4681      	mov	r9, r0
 8003f22:	460d      	mov	r5, r1
 8003f24:	461f      	mov	r7, r3
  HASH_InitTypeDef SHA1_HASH_InitStructure;
  HASH_MsgDigest SHA1_MessageDigest;
  __IO uint16_t nbvalidbitsdata = 0;
 8003f26:	2400      	movs	r4, #0
 8003f28:	f8ad 4006 	strh.w	r4, [sp, #6]
  __IO uint16_t nbvalidbitskey = 0;
 8003f2c:	f8ad 4004 	strh.w	r4, [sp, #4]
  uint32_t i = 0;
  __IO uint32_t counter = 0;
 8003f30:	9400      	str	r4, [sp, #0]
  uint32_t busystatus = 0;
  ErrorStatus status = SUCCESS;
  uint32_t keyaddr    = (uint32_t)Key;
 8003f32:	4680      	mov	r8, r0
  uint32_t inputaddr  = (uint32_t)Input;
 8003f34:	4616      	mov	r6, r2
  uint32_t outputaddr = (uint32_t)Output;

  /* Number of valid bits in last word of the Input data */
  nbvalidbitsdata = 8 * (Ilen % 4);
 8003f36:	f003 0303 	and.w	r3, r3, #3
 8003f3a:	00db      	lsls	r3, r3, #3
 8003f3c:	f8ad 3006 	strh.w	r3, [sp, #6]

  /* Number of valid bits in last word of the Key */
  nbvalidbitskey = 8 * (Keylen % 4);
 8003f40:	f001 0303 	and.w	r3, r1, #3
 8003f44:	00db      	lsls	r3, r3, #3
 8003f46:	f8ad 3004 	strh.w	r3, [sp, #4]

  /* HASH peripheral initialization */
  HASH_DeInit();
 8003f4a:	f7ff fda5 	bl	8003a98 <HASH_DeInit>

  /* HASH Configuration */
  SHA1_HASH_InitStructure.HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
 8003f4e:	940a      	str	r4, [sp, #40]	; 0x28
  SHA1_HASH_InitStructure.HASH_AlgoMode = HASH_AlgoMode_HMAC;
 8003f50:	2340      	movs	r3, #64	; 0x40
 8003f52:	930b      	str	r3, [sp, #44]	; 0x2c
  SHA1_HASH_InitStructure.HASH_DataType = HASH_DataType_8b;
 8003f54:	2320      	movs	r3, #32
 8003f56:	930c      	str	r3, [sp, #48]	; 0x30
  if(Keylen > 64)
 8003f58:	2d40      	cmp	r5, #64	; 0x40
 8003f5a:	d90c      	bls.n	8003f76 <HMAC_SHA1+0x5c>
  {
    /* HMAC long Key */
    SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_LongKey;
 8003f5c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8003f60:	930d      	str	r3, [sp, #52]	; 0x34
  else
  {
    /* HMAC short Key */
    SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
  }
  HASH_Init(&SHA1_HASH_InitStructure);
 8003f62:	a80a      	add	r0, sp, #40	; 0x28
 8003f64:	f7ff fda2 	bl	8003aac <HASH_Init>

  /* Configure the number of valid bits in last word of the Key */
  HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
 8003f68:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8003f6c:	b280      	uxth	r0, r0
 8003f6e:	f7ff fdd3 	bl	8003b18 <HASH_SetLastWordValidBitsNbr>

  /* Write the Key */
  for(i=0; i<Keylen; i+=4)
 8003f72:	2400      	movs	r4, #0
 8003f74:	e007      	b.n	8003f86 <HMAC_SHA1+0x6c>
    SHA1_HASH_InitStructure.HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
 8003f76:	2300      	movs	r3, #0
 8003f78:	930d      	str	r3, [sp, #52]	; 0x34
 8003f7a:	e7f2      	b.n	8003f62 <HMAC_SHA1+0x48>
  {
    HASH_DataIn(*(uint32_t*)keyaddr);
 8003f7c:	f859 0b04 	ldr.w	r0, [r9], #4
 8003f80:	f7ff fdd6 	bl	8003b30 <HASH_DataIn>
  for(i=0; i<Keylen; i+=4)
 8003f84:	3404      	adds	r4, #4
 8003f86:	42ac      	cmp	r4, r5
 8003f88:	d3f8      	bcc.n	8003f7c <HMAC_SHA1+0x62>
    keyaddr+=4;
  }

  /* Start the HASH processor */
  HASH_StartDigest();
 8003f8a:	f7ff fdf7 	bl	8003b7c <HASH_StartDigest>

  /* wait until the Busy flag is RESET */
  do
  {
    busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8003f8e:	2008      	movs	r0, #8
 8003f90:	f7ff fe66 	bl	8003c60 <HASH_GetFlagStatus>
 8003f94:	4604      	mov	r4, r0
    counter++;
 8003f96:	9b00      	ldr	r3, [sp, #0]
 8003f98:	3301      	adds	r3, #1
 8003f9a:	9300      	str	r3, [sp, #0]
  }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
 8003f9c:	9b00      	ldr	r3, [sp, #0]
 8003f9e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003fa2:	d001      	beq.n	8003fa8 <HMAC_SHA1+0x8e>
 8003fa4:	2800      	cmp	r0, #0
 8003fa6:	d1f2      	bne.n	8003f8e <HMAC_SHA1+0x74>

  if (busystatus != RESET)
 8003fa8:	b11c      	cbz	r4, 8003fb2 <HMAC_SHA1+0x98>
  {
     status = ERROR;
 8003faa:	2000      	movs	r0, #0
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
      }
    }  
  }
  return status;  
}
 8003fac:	b00f      	add	sp, #60	; 0x3c
 8003fae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    HASH_SetLastWordValidBitsNbr(nbvalidbitsdata);
 8003fb2:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8003fb6:	b280      	uxth	r0, r0
 8003fb8:	f7ff fdae 	bl	8003b18 <HASH_SetLastWordValidBitsNbr>
    for(i=0; i<Ilen; i+=4)
 8003fbc:	e004      	b.n	8003fc8 <HMAC_SHA1+0xae>
      HASH_DataIn(*(uint32_t*)inputaddr);
 8003fbe:	f856 0b04 	ldr.w	r0, [r6], #4
 8003fc2:	f7ff fdb5 	bl	8003b30 <HASH_DataIn>
    for(i=0; i<Ilen; i+=4)
 8003fc6:	3404      	adds	r4, #4
 8003fc8:	42bc      	cmp	r4, r7
 8003fca:	d3f8      	bcc.n	8003fbe <HMAC_SHA1+0xa4>
    HASH_StartDigest();
 8003fcc:	f7ff fdd6 	bl	8003b7c <HASH_StartDigest>
    counter =0;
 8003fd0:	2300      	movs	r3, #0
 8003fd2:	9300      	str	r3, [sp, #0]
      busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8003fd4:	2008      	movs	r0, #8
 8003fd6:	f7ff fe43 	bl	8003c60 <HASH_GetFlagStatus>
 8003fda:	4604      	mov	r4, r0
      counter++;
 8003fdc:	9b00      	ldr	r3, [sp, #0]
 8003fde:	3301      	adds	r3, #1
 8003fe0:	9300      	str	r3, [sp, #0]
    }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
 8003fe2:	9b00      	ldr	r3, [sp, #0]
 8003fe4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003fe8:	d001      	beq.n	8003fee <HMAC_SHA1+0xd4>
 8003fea:	2800      	cmp	r0, #0
 8003fec:	d1f2      	bne.n	8003fd4 <HMAC_SHA1+0xba>
    if (busystatus != RESET)
 8003fee:	b10c      	cbz	r4, 8003ff4 <HMAC_SHA1+0xda>
      status = ERROR;
 8003ff0:	2000      	movs	r0, #0
 8003ff2:	e7db      	b.n	8003fac <HMAC_SHA1+0x92>
      HASH_SetLastWordValidBitsNbr(nbvalidbitskey);
 8003ff4:	f8bd 0004 	ldrh.w	r0, [sp, #4]
 8003ff8:	b280      	uxth	r0, r0
 8003ffa:	f7ff fd8d 	bl	8003b18 <HASH_SetLastWordValidBitsNbr>
      for(i=0; i<Keylen; i+=4)
 8003ffe:	e004      	b.n	800400a <HMAC_SHA1+0xf0>
        HASH_DataIn(*(uint32_t*)keyaddr);
 8004000:	f858 0b04 	ldr.w	r0, [r8], #4
 8004004:	f7ff fd94 	bl	8003b30 <HASH_DataIn>
      for(i=0; i<Keylen; i+=4)
 8004008:	3404      	adds	r4, #4
 800400a:	42ac      	cmp	r4, r5
 800400c:	d3f8      	bcc.n	8004000 <HMAC_SHA1+0xe6>
      HASH_StartDigest();
 800400e:	f7ff fdb5 	bl	8003b7c <HASH_StartDigest>
      counter =0;
 8004012:	2300      	movs	r3, #0
 8004014:	9300      	str	r3, [sp, #0]
        busystatus = HASH_GetFlagStatus(HASH_FLAG_BUSY);
 8004016:	2008      	movs	r0, #8
 8004018:	f7ff fe22 	bl	8003c60 <HASH_GetFlagStatus>
 800401c:	4602      	mov	r2, r0
        counter++;
 800401e:	9b00      	ldr	r3, [sp, #0]
 8004020:	3301      	adds	r3, #1
 8004022:	9300      	str	r3, [sp, #0]
      }while ((counter != SHA1BUSY_TIMEOUT) && (busystatus != RESET));
 8004024:	9b00      	ldr	r3, [sp, #0]
 8004026:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800402a:	d001      	beq.n	8004030 <HMAC_SHA1+0x116>
 800402c:	2800      	cmp	r0, #0
 800402e:	d1f2      	bne.n	8004016 <HMAC_SHA1+0xfc>
      if (busystatus != RESET)
 8004030:	b10a      	cbz	r2, 8004036 <HMAC_SHA1+0x11c>
        status = ERROR;
 8004032:	2000      	movs	r0, #0
 8004034:	e7ba      	b.n	8003fac <HMAC_SHA1+0x92>
        HASH_GetDigest(&SHA1_MessageDigest);
 8004036:	a802      	add	r0, sp, #8
 8004038:	f7ff fd88 	bl	8003b4c <HASH_GetDigest>
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[0]);
 800403c:	9b02      	ldr	r3, [sp, #8]
 800403e:	ba1b      	rev	r3, r3
 8004040:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8004042:	6013      	str	r3, [r2, #0]
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[1]);
 8004044:	9b03      	ldr	r3, [sp, #12]
 8004046:	ba1b      	rev	r3, r3
 8004048:	6053      	str	r3, [r2, #4]
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[2]);
 800404a:	9b04      	ldr	r3, [sp, #16]
 800404c:	ba1b      	rev	r3, r3
 800404e:	6093      	str	r3, [r2, #8]
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[3]);
 8004050:	9b05      	ldr	r3, [sp, #20]
 8004052:	ba1b      	rev	r3, r3
 8004054:	60d3      	str	r3, [r2, #12]
        *(uint32_t*)(outputaddr)  = __REV(SHA1_MessageDigest.Data[4]);
 8004056:	9b06      	ldr	r3, [sp, #24]
 8004058:	ba1b      	rev	r3, r3
 800405a:	6113      	str	r3, [r2, #16]
  ErrorStatus status = SUCCESS;
 800405c:	2001      	movs	r0, #1
 800405e:	e7a5      	b.n	8003fac <HMAC_SHA1+0x92>

08004060 <I2C_DeInit>:
  * @brief  Deinitialize the I2Cx peripheral registers to their default reset values.
  * @param  I2Cx: where x can be 1, 2 or 3 to select the I2C peripheral.
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
 8004060:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  if (I2Cx == I2C1)
 8004062:	4b15      	ldr	r3, [pc, #84]	; (80040b8 <I2C_DeInit+0x58>)
 8004064:	4298      	cmp	r0, r3
 8004066:	d006      	beq.n	8004076 <I2C_DeInit+0x16>
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
  }
  else if (I2Cx == I2C2)
 8004068:	4b14      	ldr	r3, [pc, #80]	; (80040bc <I2C_DeInit+0x5c>)
 800406a:	4298      	cmp	r0, r3
 800406c:	d00e      	beq.n	800408c <I2C_DeInit+0x2c>
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
  }
  else 
  {
    if (I2Cx == I2C3)
 800406e:	4b14      	ldr	r3, [pc, #80]	; (80040c0 <I2C_DeInit+0x60>)
 8004070:	4298      	cmp	r0, r3
 8004072:	d016      	beq.n	80040a2 <I2C_DeInit+0x42>
 8004074:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 8004076:	2101      	movs	r1, #1
 8004078:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800407c:	f000 fc94 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);    
 8004080:	2100      	movs	r1, #0
 8004082:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8004086:	f000 fc8f 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 800408a:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
 800408c:	2101      	movs	r1, #1
 800408e:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8004092:	f000 fc89 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);      
 8004096:	2100      	movs	r1, #0
 8004098:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800409c:	f000 fc84 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 80040a0:	bd08      	pop	{r3, pc}
    {
      /* Enable I2C3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, ENABLE);
 80040a2:	2101      	movs	r1, #1
 80040a4:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 80040a8:	f000 fc7e 	bl	80049a8 <RCC_APB1PeriphResetCmd>
      /* Release I2C3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C3, DISABLE);     
 80040ac:	2100      	movs	r1, #0
 80040ae:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 80040b2:	f000 fc79 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    }
  }
}
 80040b6:	e7dd      	b.n	8004074 <I2C_DeInit+0x14>
 80040b8:	40005400 	.word	0x40005400
 80040bc:	40005800 	.word	0x40005800
 80040c0:	40005c00 	.word	0x40005c00

080040c4 <I2C_Init>:
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that contains 
  *         the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 80040c4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80040c6:	b085      	sub	sp, #20
 80040c8:	4604      	mov	r4, r0
 80040ca:	460d      	mov	r5, r1
  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 80040cc:	8886      	ldrh	r6, [r0, #4]
 80040ce:	b2b6      	uxth	r6, r6
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= (uint16_t)~((uint16_t)I2C_CR2_FREQ);
 80040d0:	f026 063f 	bic.w	r6, r6, #63	; 0x3f
 80040d4:	b2b6      	uxth	r6, r6
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 80040d6:	4668      	mov	r0, sp
 80040d8:	f000 fb68 	bl	80047ac <RCC_GetClocksFreq>
  pclk1 = rcc_clocks.PCLK1_Frequency;
 80040dc:	9802      	ldr	r0, [sp, #8]
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 80040de:	4a2d      	ldr	r2, [pc, #180]	; (8004194 <I2C_Init+0xd0>)
 80040e0:	fba2 3200 	umull	r3, r2, r2, r0
 80040e4:	0c92      	lsrs	r2, r2, #18
 80040e6:	b297      	uxth	r7, r2
  tmpreg |= freqrange;
 80040e8:	433e      	orrs	r6, r7
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 80040ea:	80a6      	strh	r6, [r4, #4]

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 80040ec:	8821      	ldrh	r1, [r4, #0]
 80040ee:	b289      	uxth	r1, r1
 80040f0:	f021 0101 	bic.w	r1, r1, #1
 80040f4:	b289      	uxth	r1, r1
 80040f6:	8021      	strh	r1, [r4, #0]
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 80040f8:	682b      	ldr	r3, [r5, #0]
 80040fa:	4927      	ldr	r1, [pc, #156]	; (8004198 <I2C_Init+0xd4>)
 80040fc:	428b      	cmp	r3, r1
 80040fe:	d81f      	bhi.n	8004140 <I2C_Init+0x7c>
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 8004100:	005b      	lsls	r3, r3, #1
 8004102:	fbb0 f3f3 	udiv	r3, r0, r3
 8004106:	b29b      	uxth	r3, r3
    /* Test if CCR value is under 0x4*/
    if (result < 0x04)
 8004108:	2b03      	cmp	r3, #3
 800410a:	d800      	bhi.n	800410e <I2C_Init+0x4a>
    {
      /* Set minimum allowed value */
      result = 0x04;  
 800410c:	2304      	movs	r3, #4
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 800410e:	3701      	adds	r7, #1
 8004110:	8427      	strh	r7, [r4, #32]
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
 8004112:	83a3      	strh	r3, [r4, #28]
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8004114:	8823      	ldrh	r3, [r4, #0]
 8004116:	b29b      	uxth	r3, r3
 8004118:	f043 0301 	orr.w	r3, r3, #1
 800411c:	8023      	strh	r3, [r4, #0]

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 800411e:	8823      	ldrh	r3, [r4, #0]
 8004120:	b29b      	uxth	r3, r3
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_MASK;
 8004122:	f423 6381 	bic.w	r3, r3, #1032	; 0x408
 8004126:	f023 0302 	bic.w	r3, r3, #2
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 800412a:	88aa      	ldrh	r2, [r5, #4]
 800412c:	8969      	ldrh	r1, [r5, #10]
 800412e:	430a      	orrs	r2, r1
 8004130:	4313      	orrs	r3, r2
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 8004132:	8023      	strh	r3, [r4, #0]

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8004134:	89ab      	ldrh	r3, [r5, #12]
 8004136:	892a      	ldrh	r2, [r5, #8]
 8004138:	4313      	orrs	r3, r2
 800413a:	8123      	strh	r3, [r4, #8]
}
 800413c:	b005      	add	sp, #20
 800413e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
 8004140:	88ee      	ldrh	r6, [r5, #6]
 8004142:	f64b 71ff 	movw	r1, #49151	; 0xbfff
 8004146:	428e      	cmp	r6, r1
 8004148:	d01d      	beq.n	8004186 <I2C_Init+0xc2>
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
 800414a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800414e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8004152:	fbb0 f3f3 	udiv	r3, r0, r3
 8004156:	b29b      	uxth	r3, r3
      result |= I2C_DutyCycle_16_9;
 8004158:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    if ((result & I2C_CCR_CCR) == 0)
 800415c:	f3c3 010b 	ubfx	r1, r3, #0, #12
 8004160:	b909      	cbnz	r1, 8004166 <I2C_Init+0xa2>
      result |= (uint16_t)0x0001;  
 8004162:	f043 0301 	orr.w	r3, r3, #1
    tmpreg |= (uint16_t)(result | I2C_CCR_FS);
 8004166:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 800416a:	f44f 7196 	mov.w	r1, #300	; 0x12c
 800416e:	fb02 f201 	mul.w	r2, r2, r1
 8004172:	490a      	ldr	r1, [pc, #40]	; (800419c <I2C_Init+0xd8>)
 8004174:	fb81 0102 	smull	r0, r1, r1, r2
 8004178:	17d2      	asrs	r2, r2, #31
 800417a:	ebc2 12a1 	rsb	r2, r2, r1, asr #6
 800417e:	3201      	adds	r2, #1
 8004180:	b292      	uxth	r2, r2
 8004182:	8422      	strh	r2, [r4, #32]
 8004184:	e7c5      	b.n	8004112 <I2C_Init+0x4e>
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 8004186:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800418a:	fbb0 f3f3 	udiv	r3, r0, r3
 800418e:	b29b      	uxth	r3, r3
 8004190:	e7e4      	b.n	800415c <I2C_Init+0x98>
 8004192:	bf00      	nop
 8004194:	431bde83 	.word	0x431bde83
 8004198:	000186a0 	.word	0x000186a0
 800419c:	10624dd3 	.word	0x10624dd3

080041a0 <I2C_StructInit>:
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
/*---------------- Reset I2C init structure parameters values ----------------*/
  /* initialize the I2C_ClockSpeed member */
  I2C_InitStruct->I2C_ClockSpeed = 5000;
 80041a0:	f241 3388 	movw	r3, #5000	; 0x1388
 80041a4:	6003      	str	r3, [r0, #0]
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 80041a6:	2300      	movs	r3, #0
 80041a8:	8083      	strh	r3, [r0, #4]
  /* Initialize the I2C_DutyCycle member */
  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;
 80041aa:	f64b 72ff 	movw	r2, #49151	; 0xbfff
 80041ae:	80c2      	strh	r2, [r0, #6]
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
 80041b0:	8103      	strh	r3, [r0, #8]
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 80041b2:	8143      	strh	r3, [r0, #10]
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80041b4:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80041b8:	8183      	strh	r3, [r0, #12]
 80041ba:	4770      	bx	lr

080041bc <I2C_Cmd>:
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80041bc:	b931      	cbnz	r1, 80041cc <I2C_Cmd+0x10>
    I2Cx->CR1 |= I2C_CR1_PE;
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PE);
 80041be:	8803      	ldrh	r3, [r0, #0]
 80041c0:	b29b      	uxth	r3, r3
 80041c2:	f023 0301 	bic.w	r3, r3, #1
 80041c6:	b29b      	uxth	r3, r3
 80041c8:	8003      	strh	r3, [r0, #0]
 80041ca:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_PE;
 80041cc:	8803      	ldrh	r3, [r0, #0]
 80041ce:	b29b      	uxth	r3, r3
 80041d0:	f043 0301 	orr.w	r3, r3, #1
 80041d4:	8003      	strh	r3, [r0, #0]
 80041d6:	4770      	bx	lr

080041d8 <I2C_AnalogFilterCmd>:
void I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80041d8:	b929      	cbnz	r1, 80041e6 <I2C_AnalogFilterCmd+0xe>
    I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
  }
  else
  {
    /* Disable the analog filter */
    I2Cx->FLTR |= I2C_FLTR_ANOFF;
 80041da:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 80041dc:	b29b      	uxth	r3, r3
 80041de:	f043 0310 	orr.w	r3, r3, #16
 80041e2:	8483      	strh	r3, [r0, #36]	; 0x24
 80041e4:	4770      	bx	lr
    I2Cx->FLTR &= (uint16_t)~((uint16_t)I2C_FLTR_ANOFF);    
 80041e6:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 80041e8:	b29b      	uxth	r3, r3
 80041ea:	f023 0310 	bic.w	r3, r3, #16
 80041ee:	b29b      	uxth	r3, r3
 80041f0:	8483      	strh	r3, [r0, #36]	; 0x24
 80041f2:	4770      	bx	lr

080041f4 <I2C_DigitalFilterConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIGITAL_FILTER(I2C_DigitalFilter));
  
  /* Get the old register value */
  tmpreg = I2Cx->FLTR;
 80041f4:	8c83      	ldrh	r3, [r0, #36]	; 0x24
 80041f6:	b29b      	uxth	r3, r3
  
  /* Reset I2Cx DNF bit [3:0] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_FLTR_DNF);
 80041f8:	f023 030f 	bic.w	r3, r3, #15
  
  /* Set I2Cx DNF coefficient */
  tmpreg |= (uint16_t)((uint16_t)I2C_DigitalFilter & I2C_FLTR_DNF);
 80041fc:	f001 010f 	and.w	r1, r1, #15
 8004200:	430b      	orrs	r3, r1
  
  /* Store the new register value */
  I2Cx->FLTR = tmpreg;
 8004202:	8483      	strh	r3, [r0, #36]	; 0x24
 8004204:	4770      	bx	lr

08004206 <I2C_GenerateSTART>:
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004206:	b931      	cbnz	r1, 8004216 <I2C_GenerateSTART+0x10>
    I2Cx->CR1 |= I2C_CR1_START;
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_START);
 8004208:	8803      	ldrh	r3, [r0, #0]
 800420a:	b29b      	uxth	r3, r3
 800420c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004210:	b29b      	uxth	r3, r3
 8004212:	8003      	strh	r3, [r0, #0]
 8004214:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_START;
 8004216:	8803      	ldrh	r3, [r0, #0]
 8004218:	b29b      	uxth	r3, r3
 800421a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800421e:	8003      	strh	r3, [r0, #0]
 8004220:	4770      	bx	lr

08004222 <I2C_GenerateSTOP>:
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004222:	b931      	cbnz	r1, 8004232 <I2C_GenerateSTOP+0x10>
    I2Cx->CR1 |= I2C_CR1_STOP;
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_STOP);
 8004224:	8803      	ldrh	r3, [r0, #0]
 8004226:	b29b      	uxth	r3, r3
 8004228:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800422c:	b29b      	uxth	r3, r3
 800422e:	8003      	strh	r3, [r0, #0]
 8004230:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_STOP;
 8004232:	8803      	ldrh	r3, [r0, #0]
 8004234:	b29b      	uxth	r3, r3
 8004236:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800423a:	8003      	strh	r3, [r0, #0]
 800423c:	4770      	bx	lr

0800423e <I2C_Send7bitAddress>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 800423e:	b922      	cbnz	r2, 800424a <I2C_Send7bitAddress+0xc>
    Address |= I2C_OAR1_ADD0;
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= (uint8_t)~((uint8_t)I2C_OAR1_ADD0);
 8004240:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  }
  /* Send the address */
  I2Cx->DR = Address;
 8004244:	b289      	uxth	r1, r1
 8004246:	8201      	strh	r1, [r0, #16]
 8004248:	4770      	bx	lr
    Address |= I2C_OAR1_ADD0;
 800424a:	f041 0101 	orr.w	r1, r1, #1
 800424e:	e7f9      	b.n	8004244 <I2C_Send7bitAddress+0x6>

08004250 <I2C_AcknowledgeConfig>:
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004250:	b931      	cbnz	r1, 8004260 <I2C_AcknowledgeConfig+0x10>
    I2Cx->CR1 |= I2C_CR1_ACK;
  }
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ACK);
 8004252:	8803      	ldrh	r3, [r0, #0]
 8004254:	b29b      	uxth	r3, r3
 8004256:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800425a:	b29b      	uxth	r3, r3
 800425c:	8003      	strh	r3, [r0, #0]
 800425e:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_ACK;
 8004260:	8803      	ldrh	r3, [r0, #0]
 8004262:	b29b      	uxth	r3, r3
 8004264:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8004268:	8003      	strh	r3, [r0, #0]
 800426a:	4770      	bx	lr

0800426c <I2C_OwnAddress2Config>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Get the old register value */
  tmpreg = I2Cx->OAR2;
 800426c:	8983      	ldrh	r3, [r0, #12]
 800426e:	b29b      	uxth	r3, r3

  /* Reset I2Cx Own address2 bit [7:1] */
  tmpreg &= (uint16_t)~((uint16_t)I2C_OAR2_ADD2);
 8004270:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe

  /* Set I2Cx Own address2 */
  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);
 8004274:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
 8004278:	430b      	orrs	r3, r1

  /* Store the new register value */
  I2Cx->OAR2 = tmpreg;
 800427a:	8183      	strh	r3, [r0, #12]
 800427c:	4770      	bx	lr

0800427e <I2C_DualAddressCmd>:
void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800427e:	b931      	cbnz	r1, 800428e <I2C_DualAddressCmd+0x10>
    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
  }
  else
  {
    /* Disable dual addressing mode */
    I2Cx->OAR2 &= (uint16_t)~((uint16_t)I2C_OAR2_ENDUAL);
 8004280:	8983      	ldrh	r3, [r0, #12]
 8004282:	b29b      	uxth	r3, r3
 8004284:	f023 0301 	bic.w	r3, r3, #1
 8004288:	b29b      	uxth	r3, r3
 800428a:	8183      	strh	r3, [r0, #12]
 800428c:	4770      	bx	lr
    I2Cx->OAR2 |= I2C_OAR2_ENDUAL;
 800428e:	8983      	ldrh	r3, [r0, #12]
 8004290:	b29b      	uxth	r3, r3
 8004292:	f043 0301 	orr.w	r3, r3, #1
 8004296:	8183      	strh	r3, [r0, #12]
 8004298:	4770      	bx	lr

0800429a <I2C_GeneralCallCmd>:
void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800429a:	b931      	cbnz	r1, 80042aa <I2C_GeneralCallCmd+0x10>
    I2Cx->CR1 |= I2C_CR1_ENGC;
  }
  else
  {
    /* Disable generall call */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENGC);
 800429c:	8803      	ldrh	r3, [r0, #0]
 800429e:	b29b      	uxth	r3, r3
 80042a0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80042a4:	b29b      	uxth	r3, r3
 80042a6:	8003      	strh	r3, [r0, #0]
 80042a8:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_ENGC;
 80042aa:	8803      	ldrh	r3, [r0, #0]
 80042ac:	b29b      	uxth	r3, r3
 80042ae:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80042b2:	8003      	strh	r3, [r0, #0]
 80042b4:	4770      	bx	lr

080042b6 <I2C_SoftwareResetCmd>:
void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80042b6:	b921      	cbnz	r1, 80042c2 <I2C_SoftwareResetCmd+0xc>
    I2Cx->CR1 |= I2C_CR1_SWRST;
  }
  else
  {
    /* Peripheral not under reset */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_SWRST);
 80042b8:	8803      	ldrh	r3, [r0, #0]
 80042ba:	f3c3 030e 	ubfx	r3, r3, #0, #15
 80042be:	8003      	strh	r3, [r0, #0]
 80042c0:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_SWRST;
 80042c2:	8803      	ldrh	r3, [r0, #0]
 80042c4:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80042c8:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80042cc:	b29b      	uxth	r3, r3
 80042ce:	8003      	strh	r3, [r0, #0]
 80042d0:	4770      	bx	lr

080042d2 <I2C_StretchClockCmd>:
void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState == DISABLE)
 80042d2:	b131      	cbz	r1, 80042e2 <I2C_StretchClockCmd+0x10>
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
  }
  else
  {
    /* Disable the selected I2C Clock stretching */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_NOSTRETCH);
 80042d4:	8803      	ldrh	r3, [r0, #0]
 80042d6:	b29b      	uxth	r3, r3
 80042d8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80042dc:	b29b      	uxth	r3, r3
 80042de:	8003      	strh	r3, [r0, #0]
 80042e0:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 80042e2:	8803      	ldrh	r3, [r0, #0]
 80042e4:	b29b      	uxth	r3, r3
 80042e6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80042ea:	8003      	strh	r3, [r0, #0]
 80042ec:	4770      	bx	lr

080042ee <I2C_FastModeDutyCycleConfig>:
void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));
  if (I2C_DutyCycle != I2C_DutyCycle_16_9)
 80042ee:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 80042f2:	d006      	beq.n	8004302 <I2C_FastModeDutyCycleConfig+0x14>
  {
    /* I2C fast mode Tlow/Thigh=2 */
    I2Cx->CCR &= I2C_DutyCycle_2;
 80042f4:	8b83      	ldrh	r3, [r0, #28]
 80042f6:	b29b      	uxth	r3, r3
 80042f8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80042fc:	b29b      	uxth	r3, r3
 80042fe:	8383      	strh	r3, [r0, #28]
 8004300:	4770      	bx	lr
  }
  else
  {
    /* I2C fast mode Tlow/Thigh=16/9 */
    I2Cx->CCR |= I2C_DutyCycle_16_9;
 8004302:	8b83      	ldrh	r3, [r0, #28]
 8004304:	b29b      	uxth	r3, r3
 8004306:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800430a:	8383      	strh	r3, [r0, #28]
 800430c:	4770      	bx	lr

0800430e <I2C_NACKPositionConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));
  
  /* Check the input parameter */
  if (I2C_NACKPosition == I2C_NACKPosition_Next)
 800430e:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8004312:	d006      	beq.n	8004322 <I2C_NACKPositionConfig+0x14>
    I2Cx->CR1 |= I2C_NACKPosition_Next;
  }
  else
  {
    /* Current byte in shift register is the last received byte */
    I2Cx->CR1 &= I2C_NACKPosition_Current;
 8004314:	8803      	ldrh	r3, [r0, #0]
 8004316:	b29b      	uxth	r3, r3
 8004318:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800431c:	b29b      	uxth	r3, r3
 800431e:	8003      	strh	r3, [r0, #0]
 8004320:	4770      	bx	lr
    I2Cx->CR1 |= I2C_NACKPosition_Next;
 8004322:	8803      	ldrh	r3, [r0, #0]
 8004324:	b29b      	uxth	r3, r3
 8004326:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800432a:	8003      	strh	r3, [r0, #0]
 800432c:	4770      	bx	lr

0800432e <I2C_SMBusAlertConfig>:
void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));
  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)
 800432e:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 8004332:	d006      	beq.n	8004342 <I2C_SMBusAlertConfig+0x14>
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
  }
  else
  {
    /* Drive the SMBusAlert pin High  */
    I2Cx->CR1 &= I2C_SMBusAlert_High;
 8004334:	8803      	ldrh	r3, [r0, #0]
 8004336:	b29b      	uxth	r3, r3
 8004338:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800433c:	b29b      	uxth	r3, r3
 800433e:	8003      	strh	r3, [r0, #0]
 8004340:	4770      	bx	lr
    I2Cx->CR1 |= I2C_SMBusAlert_Low;
 8004342:	8803      	ldrh	r3, [r0, #0]
 8004344:	b29b      	uxth	r3, r3
 8004346:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800434a:	8003      	strh	r3, [r0, #0]
 800434c:	4770      	bx	lr

0800434e <I2C_ARPCmd>:
void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800434e:	b931      	cbnz	r1, 800435e <I2C_ARPCmd+0x10>
    I2Cx->CR1 |= I2C_CR1_ENARP;
  }
  else
  {
    /* Disable the selected I2C ARP */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENARP);
 8004350:	8803      	ldrh	r3, [r0, #0]
 8004352:	b29b      	uxth	r3, r3
 8004354:	f023 0310 	bic.w	r3, r3, #16
 8004358:	b29b      	uxth	r3, r3
 800435a:	8003      	strh	r3, [r0, #0]
 800435c:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_ENARP;
 800435e:	8803      	ldrh	r3, [r0, #0]
 8004360:	b29b      	uxth	r3, r3
 8004362:	f043 0310 	orr.w	r3, r3, #16
 8004366:	8003      	strh	r3, [r0, #0]
 8004368:	4770      	bx	lr

0800436a <I2C_SendData>:
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 800436a:	8201      	strh	r1, [r0, #16]
 800436c:	4770      	bx	lr

0800436e <I2C_ReceiveData>:
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 800436e:	8a00      	ldrh	r0, [r0, #16]
}
 8004370:	b2c0      	uxtb	r0, r0
 8004372:	4770      	bx	lr

08004374 <I2C_TransmitPEC>:
void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004374:	b931      	cbnz	r1, 8004384 <I2C_TransmitPEC+0x10>
    I2Cx->CR1 |= I2C_CR1_PEC;
  }
  else
  {
    /* Disable the selected I2C PEC transmission */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_PEC);
 8004376:	8803      	ldrh	r3, [r0, #0]
 8004378:	b29b      	uxth	r3, r3
 800437a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800437e:	b29b      	uxth	r3, r3
 8004380:	8003      	strh	r3, [r0, #0]
 8004382:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_PEC;
 8004384:	8803      	ldrh	r3, [r0, #0]
 8004386:	b29b      	uxth	r3, r3
 8004388:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800438c:	8003      	strh	r3, [r0, #0]
 800438e:	4770      	bx	lr

08004390 <I2C_PECPositionConfig>:
void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));
  if (I2C_PECPosition == I2C_PECPosition_Next)
 8004390:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
 8004394:	d006      	beq.n	80043a4 <I2C_PECPositionConfig+0x14>
    I2Cx->CR1 |= I2C_PECPosition_Next;
  }
  else
  {
    /* Current byte in shift register is PEC */
    I2Cx->CR1 &= I2C_PECPosition_Current;
 8004396:	8803      	ldrh	r3, [r0, #0]
 8004398:	b29b      	uxth	r3, r3
 800439a:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800439e:	b29b      	uxth	r3, r3
 80043a0:	8003      	strh	r3, [r0, #0]
 80043a2:	4770      	bx	lr
    I2Cx->CR1 |= I2C_PECPosition_Next;
 80043a4:	8803      	ldrh	r3, [r0, #0]
 80043a6:	b29b      	uxth	r3, r3
 80043a8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80043ac:	8003      	strh	r3, [r0, #0]
 80043ae:	4770      	bx	lr

080043b0 <I2C_CalculatePEC>:
void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80043b0:	b931      	cbnz	r1, 80043c0 <I2C_CalculatePEC+0x10>
    I2Cx->CR1 |= I2C_CR1_ENPEC;
  }
  else
  {
    /* Disable the selected I2C PEC calculation */
    I2Cx->CR1 &= (uint16_t)~((uint16_t)I2C_CR1_ENPEC);
 80043b2:	8803      	ldrh	r3, [r0, #0]
 80043b4:	b29b      	uxth	r3, r3
 80043b6:	f023 0320 	bic.w	r3, r3, #32
 80043ba:	b29b      	uxth	r3, r3
 80043bc:	8003      	strh	r3, [r0, #0]
 80043be:	4770      	bx	lr
    I2Cx->CR1 |= I2C_CR1_ENPEC;
 80043c0:	8803      	ldrh	r3, [r0, #0]
 80043c2:	b29b      	uxth	r3, r3
 80043c4:	f043 0320 	orr.w	r3, r3, #32
 80043c8:	8003      	strh	r3, [r0, #0]
 80043ca:	4770      	bx	lr

080043cc <I2C_GetPEC>:
uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the selected I2C PEC value */
  return ((I2Cx->SR2) >> 8);
 80043cc:	8b00      	ldrh	r0, [r0, #24]
}
 80043ce:	f3c0 2007 	ubfx	r0, r0, #8, #8
 80043d2:	4770      	bx	lr

080043d4 <I2C_DMACmd>:
void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80043d4:	b931      	cbnz	r1, 80043e4 <I2C_DMACmd+0x10>
    I2Cx->CR2 |= I2C_CR2_DMAEN;
  }
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_DMAEN);
 80043d6:	8883      	ldrh	r3, [r0, #4]
 80043d8:	b29b      	uxth	r3, r3
 80043da:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80043de:	b29b      	uxth	r3, r3
 80043e0:	8083      	strh	r3, [r0, #4]
 80043e2:	4770      	bx	lr
    I2Cx->CR2 |= I2C_CR2_DMAEN;
 80043e4:	8883      	ldrh	r3, [r0, #4]
 80043e6:	b29b      	uxth	r3, r3
 80043e8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80043ec:	8083      	strh	r3, [r0, #4]
 80043ee:	4770      	bx	lr

080043f0 <I2C_DMALastTransferCmd>:
void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80043f0:	b931      	cbnz	r1, 8004400 <I2C_DMALastTransferCmd+0x10>
    I2Cx->CR2 |= I2C_CR2_LAST;
  }
  else
  {
    /* Next DMA transfer is not the last transfer */
    I2Cx->CR2 &= (uint16_t)~((uint16_t)I2C_CR2_LAST);
 80043f2:	8883      	ldrh	r3, [r0, #4]
 80043f4:	b29b      	uxth	r3, r3
 80043f6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80043fa:	b29b      	uxth	r3, r3
 80043fc:	8083      	strh	r3, [r0, #4]
 80043fe:	4770      	bx	lr
    I2Cx->CR2 |= I2C_CR2_LAST;
 8004400:	8883      	ldrh	r3, [r0, #4]
 8004402:	b29b      	uxth	r3, r3
 8004404:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8004408:	8083      	strh	r3, [r0, #4]
 800440a:	4770      	bx	lr

0800440c <I2C_ReadRegister>:
  *            @arg I2C_Register_CCR:   CCR register.
  *            @arg I2C_Register_TRISE: TRISE register.
  * @retval The value of the read register.
  */
uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
{
 800440c:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 800440e:	2300      	movs	r3, #0
 8004410:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_REGISTER(I2C_Register));

  tmp = (uint32_t) I2Cx;
 8004412:	9001      	str	r0, [sp, #4]
  tmp += I2C_Register;
 8004414:	9b01      	ldr	r3, [sp, #4]
 8004416:	4419      	add	r1, r3
 8004418:	9101      	str	r1, [sp, #4]

  /* Return the selected register value */
  return (*(__IO uint16_t *) tmp);
 800441a:	9b01      	ldr	r3, [sp, #4]
 800441c:	8818      	ldrh	r0, [r3, #0]
}
 800441e:	b280      	uxth	r0, r0
 8004420:	b002      	add	sp, #8
 8004422:	4770      	bx	lr

08004424 <I2C_ITConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 8004424:	b92a      	cbnz	r2, 8004432 <I2C_ITConfig+0xe>
    I2Cx->CR2 |= I2C_IT;
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 8004426:	8883      	ldrh	r3, [r0, #4]
 8004428:	43c9      	mvns	r1, r1
 800442a:	b289      	uxth	r1, r1
 800442c:	4019      	ands	r1, r3
 800442e:	8081      	strh	r1, [r0, #4]
 8004430:	4770      	bx	lr
    I2Cx->CR2 |= I2C_IT;
 8004432:	8883      	ldrh	r3, [r0, #4]
 8004434:	b29b      	uxth	r3, r3
 8004436:	4319      	orrs	r1, r3
 8004438:	8081      	strh	r1, [r0, #4]
 800443a:	4770      	bx	lr

0800443c <I2C_CheckEvent>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 800443c:	8a83      	ldrh	r3, [r0, #20]
 800443e:	b29b      	uxth	r3, r3
  flag2 = I2Cx->SR2;
 8004440:	8b02      	ldrh	r2, [r0, #24]
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 8004442:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8004446:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000

  /* Check whether the last event contains the I2C_EVENT */
  if ((lastevent & I2C_EVENT) == I2C_EVENT)
 800444a:	ea31 0303 	bics.w	r3, r1, r3
 800444e:	d001      	beq.n	8004454 <I2C_CheckEvent+0x18>
    status = SUCCESS;
  }
  else
  {
    /* ERROR: last event is different from I2C_EVENT */
    status = ERROR;
 8004450:	2000      	movs	r0, #0
  }
  /* Return status */
  return status;
}
 8004452:	4770      	bx	lr
    status = SUCCESS;
 8004454:	2001      	movs	r0, #1
 8004456:	4770      	bx	lr

08004458 <I2C_GetLastEvent>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8004458:	8a83      	ldrh	r3, [r0, #20]
 800445a:	b29b      	uxth	r3, r3
  flag2 = I2Cx->SR2;
 800445c:	8b00      	ldrh	r0, [r0, #24]
  flag2 = flag2 << 16;

  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_MASK;
 800445e:	ea43 4000 	orr.w	r0, r3, r0, lsl #16

  /* Return status */
  return lastevent;
}
 8004462:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8004466:	4770      	bx	lr

08004468 <I2C_GetFlagStatus>:
  *                                Address matched flag (Slave mode)"ENDAD"
  *            @arg I2C_FLAG_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 8004468:	b082      	sub	sp, #8
  FlagStatus bitstatus = RESET;
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 800446a:	2300      	movs	r3, #0
 800446c:	9301      	str	r3, [sp, #4]
 800446e:	9300      	str	r3, [sp, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
 8004470:	9000      	str	r0, [sp, #0]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 8004472:	0f0b      	lsrs	r3, r1, #28
 8004474:	9301      	str	r3, [sp, #4]
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_MASK;
 8004476:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  
  if(i2creg != 0)
 800447a:	9b01      	ldr	r3, [sp, #4]
 800447c:	b14b      	cbz	r3, 8004492 <I2C_GetFlagStatus+0x2a>
  {
    /* Get the I2Cx SR1 register address */
    i2cxbase += 0x14;
 800447e:	9b00      	ldr	r3, [sp, #0]
 8004480:	3314      	adds	r3, #20
 8004482:	9300      	str	r3, [sp, #0]
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
  }
  
  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
 8004484:	9b00      	ldr	r3, [sp, #0]
 8004486:	681b      	ldr	r3, [r3, #0]
 8004488:	4219      	tst	r1, r3
 800448a:	d107      	bne.n	800449c <I2C_GetFlagStatus+0x34>
    bitstatus = SET;
  }
  else
  {
    /* I2C_FLAG is reset */
    bitstatus = RESET;
 800448c:	2000      	movs	r0, #0
  }
  
  /* Return the I2C_FLAG status */
  return  bitstatus;
}
 800448e:	b002      	add	sp, #8
 8004490:	4770      	bx	lr
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
 8004492:	0c09      	lsrs	r1, r1, #16
    i2cxbase += 0x18;
 8004494:	9b00      	ldr	r3, [sp, #0]
 8004496:	3318      	adds	r3, #24
 8004498:	9300      	str	r3, [sp, #0]
 800449a:	e7f3      	b.n	8004484 <I2C_GetFlagStatus+0x1c>
    bitstatus = SET;
 800449c:	2001      	movs	r0, #1
 800449e:	e7f6      	b.n	800448e <I2C_GetFlagStatus+0x26>

080044a0 <I2C_ClearFlag>:
  uint32_t flagpos = 0;
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
  /* Get the I2C flag position */
  flagpos = I2C_FLAG & FLAG_MASK;
 80044a0:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 80044a4:	43c9      	mvns	r1, r1
 80044a6:	b289      	uxth	r1, r1
 80044a8:	8281      	strh	r1, [r0, #20]
 80044aa:	4770      	bx	lr

080044ac <I2C_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  enablestatus = (uint32_t)(((I2C_IT & ITEN_MASK) >> 16) & (I2Cx->CR2)) ;
 80044ac:	8883      	ldrh	r3, [r0, #4]
 80044ae:	ea03 4311 	and.w	r3, r3, r1, lsr #16
 80044b2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  
  /* Get bit[23:0] of the flag */
  I2C_IT &= FLAG_MASK;

  /* Check the status of the specified I2C flag */
  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)
 80044b6:	8a82      	ldrh	r2, [r0, #20]
 80044b8:	b292      	uxth	r2, r2
 80044ba:	4211      	tst	r1, r2
 80044bc:	d002      	beq.n	80044c4 <I2C_GetITStatus+0x18>
 80044be:	b91b      	cbnz	r3, 80044c8 <I2C_GetITStatus+0x1c>
    bitstatus = SET;
  }
  else
  {
    /* I2C_IT is reset */
    bitstatus = RESET;
 80044c0:	2000      	movs	r0, #0
 80044c2:	4770      	bx	lr
 80044c4:	2000      	movs	r0, #0
 80044c6:	4770      	bx	lr
    bitstatus = SET;
 80044c8:	2001      	movs	r0, #1
  }
  /* Return the I2C_IT status */
  return  bitstatus;
}
 80044ca:	4770      	bx	lr

080044cc <I2C_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));

  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_MASK;
 80044cc:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000

  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 80044d0:	43c9      	mvns	r1, r1
 80044d2:	b289      	uxth	r1, r1
 80044d4:	8281      	strh	r1, [r0, #20]
 80044d6:	4770      	bx	lr

080044d8 <IWDG_WriteAccessCmd>:
  */
void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)
{
  /* Check the parameters */
  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
  IWDG->KR = IWDG_WriteAccess;
 80044d8:	4b01      	ldr	r3, [pc, #4]	; (80044e0 <IWDG_WriteAccessCmd+0x8>)
 80044da:	6018      	str	r0, [r3, #0]
 80044dc:	4770      	bx	lr
 80044de:	bf00      	nop
 80044e0:	40003000 	.word	0x40003000

080044e4 <IWDG_SetPrescaler>:
  */
void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)
{
  /* Check the parameters */
  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
  IWDG->PR = IWDG_Prescaler;
 80044e4:	4b01      	ldr	r3, [pc, #4]	; (80044ec <IWDG_SetPrescaler+0x8>)
 80044e6:	6058      	str	r0, [r3, #4]
 80044e8:	4770      	bx	lr
 80044ea:	bf00      	nop
 80044ec:	40003000 	.word	0x40003000

080044f0 <IWDG_SetReload>:
  */
void IWDG_SetReload(uint16_t Reload)
{
  /* Check the parameters */
  assert_param(IS_IWDG_RELOAD(Reload));
  IWDG->RLR = Reload;
 80044f0:	4b01      	ldr	r3, [pc, #4]	; (80044f8 <IWDG_SetReload+0x8>)
 80044f2:	6098      	str	r0, [r3, #8]
 80044f4:	4770      	bx	lr
 80044f6:	bf00      	nop
 80044f8:	40003000 	.word	0x40003000

080044fc <IWDG_ReloadCounter>:
  * @param  None
  * @retval None
  */
void IWDG_ReloadCounter(void)
{
  IWDG->KR = KR_KEY_RELOAD;
 80044fc:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8004500:	4b01      	ldr	r3, [pc, #4]	; (8004508 <IWDG_ReloadCounter+0xc>)
 8004502:	601a      	str	r2, [r3, #0]
 8004504:	4770      	bx	lr
 8004506:	bf00      	nop
 8004508:	40003000 	.word	0x40003000

0800450c <IWDG_Enable>:
  * @param  None
  * @retval None
  */
void IWDG_Enable(void)
{
  IWDG->KR = KR_KEY_ENABLE;
 800450c:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 8004510:	4b01      	ldr	r3, [pc, #4]	; (8004518 <IWDG_Enable+0xc>)
 8004512:	601a      	str	r2, [r3, #0]
 8004514:	4770      	bx	lr
 8004516:	bf00      	nop
 8004518:	40003000 	.word	0x40003000

0800451c <IWDG_GetFlagStatus>:
FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_IWDG_FLAG(IWDG_FLAG));
  if ((IWDG->SR & IWDG_FLAG) != (uint32_t)RESET)
 800451c:	4b03      	ldr	r3, [pc, #12]	; (800452c <IWDG_GetFlagStatus+0x10>)
 800451e:	68db      	ldr	r3, [r3, #12]
 8004520:	4218      	tst	r0, r3
 8004522:	d101      	bne.n	8004528 <IWDG_GetFlagStatus+0xc>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8004524:	2000      	movs	r0, #0
  }
  /* Return the flag status */
  return bitstatus;
}
 8004526:	4770      	bx	lr
    bitstatus = SET;
 8004528:	2001      	movs	r0, #1
 800452a:	4770      	bx	lr
 800452c:	40003000 	.word	0x40003000

08004530 <PWR_DeInit>:
  * @brief  Deinitializes the PWR peripheral registers to their default reset values.     
  * @param  None
  * @retval None
  */
void PWR_DeInit(void)
{
 8004530:	b508      	push	{r3, lr}
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
 8004532:	2101      	movs	r1, #1
 8004534:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8004538:	f000 fa36 	bl	80049a8 <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
 800453c:	2100      	movs	r1, #0
 800453e:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8004542:	f000 fa31 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8004546:	bd08      	pop	{r3, pc}

08004548 <PWR_BackupAccessCmd>:
void PWR_BackupAccessCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 8004548:	4b01      	ldr	r3, [pc, #4]	; (8004550 <PWR_BackupAccessCmd+0x8>)
 800454a:	6018      	str	r0, [r3, #0]
 800454c:	4770      	bx	lr
 800454e:	bf00      	nop
 8004550:	420e0020 	.word	0x420e0020

08004554 <PWR_PVDLevelConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
  
  tmpreg = PWR->CR;
 8004554:	4a03      	ldr	r2, [pc, #12]	; (8004564 <PWR_PVDLevelConfig+0x10>)
 8004556:	6813      	ldr	r3, [r2, #0]
  
  /* Clear PLS[7:5] bits */
  tmpreg &= CR_PLS_MASK;
 8004558:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
  
  /* Set PLS[7:5] bits according to PWR_PVDLevel value */
  tmpreg |= PWR_PVDLevel;
 800455c:	4318      	orrs	r0, r3
  
  /* Store the new value */
  PWR->CR = tmpreg;
 800455e:	6010      	str	r0, [r2, #0]
 8004560:	4770      	bx	lr
 8004562:	bf00      	nop
 8004564:	40007000 	.word	0x40007000

08004568 <PWR_PVDCmd>:
void PWR_PVDCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 8004568:	4b01      	ldr	r3, [pc, #4]	; (8004570 <PWR_PVDCmd+0x8>)
 800456a:	6018      	str	r0, [r3, #0]
 800456c:	4770      	bx	lr
 800456e:	bf00      	nop
 8004570:	420e0010 	.word	0x420e0010

08004574 <PWR_WakeUpPinCmd>:
void PWR_WakeUpPinCmd(FunctionalState NewState)
{
  /* Check the parameters */  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
 8004574:	4b01      	ldr	r3, [pc, #4]	; (800457c <PWR_WakeUpPinCmd+0x8>)
 8004576:	6018      	str	r0, [r3, #0]
 8004578:	4770      	bx	lr
 800457a:	bf00      	nop
 800457c:	420e00a0 	.word	0x420e00a0

08004580 <PWR_BackupRegulatorCmd>:
void PWR_BackupRegulatorCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
 8004580:	4b01      	ldr	r3, [pc, #4]	; (8004588 <PWR_BackupRegulatorCmd+0x8>)
 8004582:	6018      	str	r0, [r3, #0]
 8004584:	4770      	bx	lr
 8004586:	bf00      	nop
 8004588:	420e00a4 	.word	0x420e00a4

0800458c <PWR_MainRegulatorModeConfig>:
	uint32_t tmpreg = 0;
	
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));

  tmpreg = PWR->CR;
 800458c:	4a03      	ldr	r2, [pc, #12]	; (800459c <PWR_MainRegulatorModeConfig+0x10>)
 800458e:	6813      	ldr	r3, [r2, #0]
  
  /* Clear VOS[15:14] bits */
  tmpreg &= CR_VOS_MASK;
 8004590:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
  
  /* Set VOS[15:14] bits according to PWR_Regulator_Voltage value */
  tmpreg |= PWR_Regulator_Voltage;
 8004594:	4318      	orrs	r0, r3
  
  /* Store the new value */
  PWR->CR = tmpreg;
 8004596:	6010      	str	r0, [r2, #0]
 8004598:	4770      	bx	lr
 800459a:	bf00      	nop
 800459c:	40007000 	.word	0x40007000

080045a0 <PWR_FlashPowerDownCmd>:
void PWR_FlashPowerDownCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
 80045a0:	4b01      	ldr	r3, [pc, #4]	; (80045a8 <PWR_FlashPowerDownCmd+0x8>)
 80045a2:	6018      	str	r0, [r3, #0]
 80045a4:	4770      	bx	lr
 80045a6:	bf00      	nop
 80045a8:	420e0024 	.word	0x420e0024

080045ac <PWR_EnterSTOPMode>:
  /* Check the parameters */
  assert_param(IS_PWR_REGULATOR(PWR_Regulator));
  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
  
  /* Select the regulator state in STOP mode ---------------------------------*/
  tmpreg = PWR->CR;
 80045ac:	4a0a      	ldr	r2, [pc, #40]	; (80045d8 <PWR_EnterSTOPMode+0x2c>)
 80045ae:	6813      	ldr	r3, [r2, #0]
  /* Clear PDDS and LPDSR bits */
  tmpreg &= CR_DS_MASK;
 80045b0:	f023 0303 	bic.w	r3, r3, #3
  
  /* Set LPDSR bit according to PWR_Regulator value */
  tmpreg |= PWR_Regulator;
 80045b4:	4318      	orrs	r0, r3
  
  /* Store the new value */
  PWR->CR = tmpreg;
 80045b6:	6010      	str	r0, [r2, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 80045b8:	4a08      	ldr	r2, [pc, #32]	; (80045dc <PWR_EnterSTOPMode+0x30>)
 80045ba:	6913      	ldr	r3, [r2, #16]
 80045bc:	f043 0304 	orr.w	r3, r3, #4
 80045c0:	6113      	str	r3, [r2, #16]
  
  /* Select STOP mode entry --------------------------------------------------*/
  if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 80045c2:	2901      	cmp	r1, #1
 80045c4:	d006      	beq.n	80045d4 <PWR_EnterSTOPMode+0x28>
  __ASM volatile ("wfe");
 80045c6:	bf20      	wfe
  {
    /* Request Wait For Event */
    __WFE();
  }
  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 80045c8:	4a04      	ldr	r2, [pc, #16]	; (80045dc <PWR_EnterSTOPMode+0x30>)
 80045ca:	6913      	ldr	r3, [r2, #16]
 80045cc:	f023 0304 	bic.w	r3, r3, #4
 80045d0:	6113      	str	r3, [r2, #16]
 80045d2:	4770      	bx	lr
  __ASM volatile ("wfi");
 80045d4:	bf30      	wfi
 80045d6:	e7f7      	b.n	80045c8 <PWR_EnterSTOPMode+0x1c>
 80045d8:	40007000 	.word	0x40007000
 80045dc:	e000ed00 	.word	0xe000ed00

080045e0 <PWR_EnterSTANDBYMode>:
  * @retval None
  */
void PWR_EnterSTANDBYMode(void)
{
  /* Clear Wakeup flag */
  PWR->CR |= PWR_CR_CWUF;
 80045e0:	4b07      	ldr	r3, [pc, #28]	; (8004600 <PWR_EnterSTANDBYMode+0x20>)
 80045e2:	681a      	ldr	r2, [r3, #0]
 80045e4:	f042 0204 	orr.w	r2, r2, #4
 80045e8:	601a      	str	r2, [r3, #0]
  
  /* Select STANDBY mode */
  PWR->CR |= PWR_CR_PDDS;
 80045ea:	681a      	ldr	r2, [r3, #0]
 80045ec:	f042 0202 	orr.w	r2, r2, #2
 80045f0:	601a      	str	r2, [r3, #0]
  
  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 80045f2:	4a04      	ldr	r2, [pc, #16]	; (8004604 <PWR_EnterSTANDBYMode+0x24>)
 80045f4:	6913      	ldr	r3, [r2, #16]
 80045f6:	f043 0304 	orr.w	r3, r3, #4
 80045fa:	6113      	str	r3, [r2, #16]
 80045fc:	bf30      	wfi
 80045fe:	4770      	bx	lr
 8004600:	40007000 	.word	0x40007000
 8004604:	e000ed00 	.word	0xe000ed00

08004608 <PWR_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
  
  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 8004608:	4b03      	ldr	r3, [pc, #12]	; (8004618 <PWR_GetFlagStatus+0x10>)
 800460a:	685b      	ldr	r3, [r3, #4]
 800460c:	4203      	tst	r3, r0
 800460e:	d101      	bne.n	8004614 <PWR_GetFlagStatus+0xc>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8004610:	2000      	movs	r0, #0
  }
  /* Return the flag status */
  return bitstatus;
}
 8004612:	4770      	bx	lr
    bitstatus = SET;
 8004614:	2001      	movs	r0, #1
 8004616:	4770      	bx	lr
 8004618:	40007000 	.word	0x40007000

0800461c <PWR_ClearFlag>:
void PWR_ClearFlag(uint32_t PWR_FLAG)
{
  /* Check the parameters */
  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
         
  PWR->CR |=  PWR_FLAG << 2;
 800461c:	4a02      	ldr	r2, [pc, #8]	; (8004628 <PWR_ClearFlag+0xc>)
 800461e:	6813      	ldr	r3, [r2, #0]
 8004620:	ea43 0080 	orr.w	r0, r3, r0, lsl #2
 8004624:	6010      	str	r0, [r2, #0]
 8004626:	4770      	bx	lr
 8004628:	40007000 	.word	0x40007000

0800462c <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800462c:	4b0b      	ldr	r3, [pc, #44]	; (800465c <RCC_DeInit+0x30>)
 800462e:	681a      	ldr	r2, [r3, #0]
 8004630:	f042 0201 	orr.w	r2, r2, #1
 8004634:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8004636:	2100      	movs	r1, #0
 8004638:	6099      	str	r1, [r3, #8]

  /* Reset HSEON, CSSON, PLLON and PLLI2S bits */
  RCC->CR &= (uint32_t)0xFAF6FFFF;
 800463a:	681a      	ldr	r2, [r3, #0]
 800463c:	f022 62a1 	bic.w	r2, r2, #84410368	; 0x5080000
 8004640:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8004644:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8004646:	4a06      	ldr	r2, [pc, #24]	; (8004660 <RCC_DeInit+0x34>)
 8004648:	605a      	str	r2, [r3, #4]

  /* Reset PLLI2SCFGR register */
  RCC->PLLI2SCFGR = 0x20003000;
 800464a:	4a06      	ldr	r2, [pc, #24]	; (8004664 <RCC_DeInit+0x38>)
 800464c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8004650:	681a      	ldr	r2, [r3, #0]
 8004652:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8004656:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8004658:	60d9      	str	r1, [r3, #12]
 800465a:	4770      	bx	lr
 800465c:	40023800 	.word	0x40023800
 8004660:	24003010 	.word	0x24003010
 8004664:	20003000 	.word	0x20003000

08004668 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 8004668:	4b02      	ldr	r3, [pc, #8]	; (8004674 <RCC_HSEConfig+0xc>)
 800466a:	2200      	movs	r2, #0
 800466c:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 800466e:	7018      	strb	r0, [r3, #0]
 8004670:	4770      	bx	lr
 8004672:	bf00      	nop
 8004674:	40023802 	.word	0x40023802

08004678 <RCC_AdjustHSICalibrationValue>:
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 8004678:	4a03      	ldr	r2, [pc, #12]	; (8004688 <RCC_AdjustHSICalibrationValue+0x10>)
 800467a:	6813      	ldr	r3, [r2, #0]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 800467c:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8004680:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3

  /* Store the new value */
  RCC->CR = tmpreg;
 8004684:	6010      	str	r0, [r2, #0]
 8004686:	4770      	bx	lr
 8004688:	40023800 	.word	0x40023800

0800468c <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 800468c:	4b01      	ldr	r3, [pc, #4]	; (8004694 <RCC_HSICmd+0x8>)
 800468e:	6018      	str	r0, [r3, #0]
 8004690:	4770      	bx	lr
 8004692:	bf00      	nop
 8004694:	42470000 	.word	0x42470000

08004698 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8004698:	4b08      	ldr	r3, [pc, #32]	; (80046bc <RCC_LSEConfig+0x24>)
 800469a:	2200      	movs	r2, #0
 800469c:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 800469e:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 80046a0:	2801      	cmp	r0, #1
 80046a2:	d002      	beq.n	80046aa <RCC_LSEConfig+0x12>
 80046a4:	2804      	cmp	r0, #4
 80046a6:	d004      	beq.n	80046b2 <RCC_LSEConfig+0x1a>
 80046a8:	4770      	bx	lr
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 80046aa:	2201      	movs	r2, #1
 80046ac:	4b03      	ldr	r3, [pc, #12]	; (80046bc <RCC_LSEConfig+0x24>)
 80046ae:	701a      	strb	r2, [r3, #0]
      break;
 80046b0:	4770      	bx	lr
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 80046b2:	2205      	movs	r2, #5
 80046b4:	4b01      	ldr	r3, [pc, #4]	; (80046bc <RCC_LSEConfig+0x24>)
 80046b6:	701a      	strb	r2, [r3, #0]
 80046b8:	4770      	bx	lr
 80046ba:	bf00      	nop
 80046bc:	40023870 	.word	0x40023870

080046c0 <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 80046c0:	4b01      	ldr	r3, [pc, #4]	; (80046c8 <RCC_LSICmd+0x8>)
 80046c2:	6018      	str	r0, [r3, #0]
 80046c4:	4770      	bx	lr
 80046c6:	bf00      	nop
 80046c8:	42470e80 	.word	0x42470e80

080046cc <RCC_PLLConfig>:
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 80046cc:	ea41 1182 	orr.w	r1, r1, r2, lsl #6
 80046d0:	085b      	lsrs	r3, r3, #1
 80046d2:	3b01      	subs	r3, #1
 80046d4:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80046d8:	4301      	orrs	r1, r0
 80046da:	9800      	ldr	r0, [sp, #0]
 80046dc:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
 80046e0:	4b01      	ldr	r3, [pc, #4]	; (80046e8 <RCC_PLLConfig+0x1c>)
 80046e2:	6059      	str	r1, [r3, #4]
 80046e4:	4770      	bx	lr
 80046e6:	bf00      	nop
 80046e8:	40023800 	.word	0x40023800

080046ec <RCC_PLLCmd>:
  */
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 80046ec:	4b01      	ldr	r3, [pc, #4]	; (80046f4 <RCC_PLLCmd+0x8>)
 80046ee:	6018      	str	r0, [r3, #0]
 80046f0:	4770      	bx	lr
 80046f2:	bf00      	nop
 80046f4:	42470060 	.word	0x42470060

080046f8 <RCC_PLLI2SConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));

  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
 80046f8:	0709      	lsls	r1, r1, #28
 80046fa:	ea41 1180 	orr.w	r1, r1, r0, lsl #6
 80046fe:	4b02      	ldr	r3, [pc, #8]	; (8004708 <RCC_PLLI2SConfig+0x10>)
 8004700:	f8c3 1084 	str.w	r1, [r3, #132]	; 0x84
 8004704:	4770      	bx	lr
 8004706:	bf00      	nop
 8004708:	40023800 	.word	0x40023800

0800470c <RCC_PLLI2SCmd>:
  */
void RCC_PLLI2SCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
 800470c:	4b01      	ldr	r3, [pc, #4]	; (8004714 <RCC_PLLI2SCmd+0x8>)
 800470e:	6018      	str	r0, [r3, #0]
 8004710:	4770      	bx	lr
 8004712:	bf00      	nop
 8004714:	42470068 	.word	0x42470068

08004718 <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8004718:	4b01      	ldr	r3, [pc, #4]	; (8004720 <RCC_ClockSecuritySystemCmd+0x8>)
 800471a:	6018      	str	r0, [r3, #0]
 800471c:	4770      	bx	lr
 800471e:	bf00      	nop
 8004720:	4247004c 	.word	0x4247004c

08004724 <RCC_MCO1Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  

  tmpreg = RCC->CFGR;
 8004724:	4a03      	ldr	r2, [pc, #12]	; (8004734 <RCC_MCO1Config+0x10>)
 8004726:	6893      	ldr	r3, [r2, #8]

  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
  tmpreg &= CFGR_MCO1_RESET_MASK;
 8004728:	f023 63ec 	bic.w	r3, r3, #123731968	; 0x7600000

  /* Select MCO1 clock source and prescaler */
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
 800472c:	4301      	orrs	r1, r0
 800472e:	430b      	orrs	r3, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 8004730:	6093      	str	r3, [r2, #8]
 8004732:	4770      	bx	lr
 8004734:	40023800 	.word	0x40023800

08004738 <RCC_MCO2Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
  
  tmpreg = RCC->CFGR;
 8004738:	4a03      	ldr	r2, [pc, #12]	; (8004748 <RCC_MCO2Config+0x10>)
 800473a:	6893      	ldr	r3, [r2, #8]
  
  /* Clear MCO2 and MCO2PRE[2:0] bits */
  tmpreg &= CFGR_MCO2_RESET_MASK;
 800473c:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000

  /* Select MCO2 clock source and prescaler */
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
 8004740:	4301      	orrs	r1, r0
 8004742:	430b      	orrs	r3, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 8004744:	6093      	str	r3, [r2, #8]
 8004746:	4770      	bx	lr
 8004748:	40023800 	.word	0x40023800

0800474c <RCC_SYSCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 800474c:	4a03      	ldr	r2, [pc, #12]	; (800475c <RCC_SYSCLKConfig+0x10>)
 800474e:	6893      	ldr	r3, [r2, #8]

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 8004750:	f023 0303 	bic.w	r3, r3, #3

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8004754:	4318      	orrs	r0, r3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8004756:	6090      	str	r0, [r2, #8]
 8004758:	4770      	bx	lr
 800475a:	bf00      	nop
 800475c:	40023800 	.word	0x40023800

08004760 <RCC_GetSYSCLKSource>:
  *              - 0x04: HSE used as system clock
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 8004760:	4b02      	ldr	r3, [pc, #8]	; (800476c <RCC_GetSYSCLKSource+0xc>)
 8004762:	6898      	ldr	r0, [r3, #8]
}
 8004764:	f000 000c 	and.w	r0, r0, #12
 8004768:	4770      	bx	lr
 800476a:	bf00      	nop
 800476c:	40023800 	.word	0x40023800

08004770 <RCC_HCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 8004770:	4a03      	ldr	r2, [pc, #12]	; (8004780 <RCC_HCLKConfig+0x10>)
 8004772:	6893      	ldr	r3, [r2, #8]

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 8004774:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8004778:	4318      	orrs	r0, r3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800477a:	6090      	str	r0, [r2, #8]
 800477c:	4770      	bx	lr
 800477e:	bf00      	nop
 8004780:	40023800 	.word	0x40023800

08004784 <RCC_PCLK1Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 8004784:	4a03      	ldr	r2, [pc, #12]	; (8004794 <RCC_PCLK1Config+0x10>)
 8004786:	6893      	ldr	r3, [r2, #8]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 8004788:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 800478c:	4318      	orrs	r0, r3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 800478e:	6090      	str	r0, [r2, #8]
 8004790:	4770      	bx	lr
 8004792:	bf00      	nop
 8004794:	40023800 	.word	0x40023800

08004798 <RCC_PCLK2Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 8004798:	4a03      	ldr	r2, [pc, #12]	; (80047a8 <RCC_PCLK2Config+0x10>)
 800479a:	6893      	ldr	r3, [r2, #8]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 800479c:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 80047a0:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 80047a4:	6090      	str	r0, [r2, #8]
 80047a6:	4770      	bx	lr
 80047a8:	40023800 	.word	0x40023800

080047ac <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 80047ac:	b410      	push	{r4}
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80047ae:	4b29      	ldr	r3, [pc, #164]	; (8004854 <RCC_GetClocksFreq+0xa8>)
 80047b0:	689b      	ldr	r3, [r3, #8]
 80047b2:	f003 030c 	and.w	r3, r3, #12

  switch (tmp)
 80047b6:	2b04      	cmp	r3, #4
 80047b8:	d023      	beq.n	8004802 <RCC_GetClocksFreq+0x56>
 80047ba:	2b08      	cmp	r3, #8
 80047bc:	d024      	beq.n	8004808 <RCC_GetClocksFreq+0x5c>
 80047be:	b113      	cbz	r3, 80047c6 <RCC_GetClocksFreq+0x1a>

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
      break;
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80047c0:	4b25      	ldr	r3, [pc, #148]	; (8004858 <RCC_GetClocksFreq+0xac>)
 80047c2:	6003      	str	r3, [r0, #0]
      break;
 80047c4:	e001      	b.n	80047ca <RCC_GetClocksFreq+0x1e>
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80047c6:	4b24      	ldr	r3, [pc, #144]	; (8004858 <RCC_GetClocksFreq+0xac>)
 80047c8:	6003      	str	r3, [r0, #0]
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 80047ca:	4c22      	ldr	r4, [pc, #136]	; (8004854 <RCC_GetClocksFreq+0xa8>)
 80047cc:	68a3      	ldr	r3, [r4, #8]
  tmp = tmp >> 4;
 80047ce:	f3c3 1303 	ubfx	r3, r3, #4, #4
  presc = APBAHBPrescTable[tmp];
 80047d2:	4922      	ldr	r1, [pc, #136]	; (800485c <RCC_GetClocksFreq+0xb0>)
 80047d4:	5ccb      	ldrb	r3, [r1, r3]
 80047d6:	b2da      	uxtb	r2, r3
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 80047d8:	6803      	ldr	r3, [r0, #0]
 80047da:	40d3      	lsrs	r3, r2
 80047dc:	6043      	str	r3, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 80047de:	68a2      	ldr	r2, [r4, #8]
  tmp = tmp >> 10;
 80047e0:	f3c2 2282 	ubfx	r2, r2, #10, #3
  presc = APBAHBPrescTable[tmp];
 80047e4:	5c8a      	ldrb	r2, [r1, r2]
 80047e6:	b2d2      	uxtb	r2, r2
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80047e8:	fa23 f202 	lsr.w	r2, r3, r2
 80047ec:	6082      	str	r2, [r0, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 80047ee:	68a2      	ldr	r2, [r4, #8]
  tmp = tmp >> 13;
 80047f0:	f3c2 3242 	ubfx	r2, r2, #13, #3
  presc = APBAHBPrescTable[tmp];
 80047f4:	5c8a      	ldrb	r2, [r1, r2]
 80047f6:	b2d2      	uxtb	r2, r2
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80047f8:	40d3      	lsrs	r3, r2
 80047fa:	60c3      	str	r3, [r0, #12]
}
 80047fc:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004800:	4770      	bx	lr
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8004802:	4b17      	ldr	r3, [pc, #92]	; (8004860 <RCC_GetClocksFreq+0xb4>)
 8004804:	6003      	str	r3, [r0, #0]
      break;
 8004806:	e7e0      	b.n	80047ca <RCC_GetClocksFreq+0x1e>
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8004808:	4b12      	ldr	r3, [pc, #72]	; (8004854 <RCC_GetClocksFreq+0xa8>)
 800480a:	685a      	ldr	r2, [r3, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800480c:	685b      	ldr	r3, [r3, #4]
 800480e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
      if (pllsource != 0)
 8004812:	f412 0f80 	tst.w	r2, #4194304	; 0x400000
 8004816:	d012      	beq.n	800483e <RCC_GetClocksFreq+0x92>
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8004818:	4a11      	ldr	r2, [pc, #68]	; (8004860 <RCC_GetClocksFreq+0xb4>)
 800481a:	fbb2 f2f3 	udiv	r2, r2, r3
 800481e:	4b0d      	ldr	r3, [pc, #52]	; (8004854 <RCC_GetClocksFreq+0xa8>)
 8004820:	685b      	ldr	r3, [r3, #4]
 8004822:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8004826:	fb03 f302 	mul.w	r3, r3, r2
      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 800482a:	4a0a      	ldr	r2, [pc, #40]	; (8004854 <RCC_GetClocksFreq+0xa8>)
 800482c:	6852      	ldr	r2, [r2, #4]
 800482e:	f3c2 4201 	ubfx	r2, r2, #16, #2
 8004832:	3201      	adds	r2, #1
 8004834:	0052      	lsls	r2, r2, #1
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8004836:	fbb3 f3f2 	udiv	r3, r3, r2
 800483a:	6003      	str	r3, [r0, #0]
      break;
 800483c:	e7c5      	b.n	80047ca <RCC_GetClocksFreq+0x1e>
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 800483e:	4a06      	ldr	r2, [pc, #24]	; (8004858 <RCC_GetClocksFreq+0xac>)
 8004840:	fbb2 f2f3 	udiv	r2, r2, r3
 8004844:	4b03      	ldr	r3, [pc, #12]	; (8004854 <RCC_GetClocksFreq+0xa8>)
 8004846:	685b      	ldr	r3, [r3, #4]
 8004848:	f3c3 1388 	ubfx	r3, r3, #6, #9
 800484c:	fb03 f302 	mul.w	r3, r3, r2
 8004850:	e7eb      	b.n	800482a <RCC_GetClocksFreq+0x7e>
 8004852:	bf00      	nop
 8004854:	40023800 	.word	0x40023800
 8004858:	00f42400 	.word	0x00f42400
 800485c:	20000004 	.word	0x20000004
 8004860:	017d7840 	.word	0x017d7840

08004864 <RCC_RTCCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 8004864:	f400 7340 	and.w	r3, r0, #768	; 0x300
 8004868:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800486c:	d006      	beq.n	800487c <RCC_RTCCLKConfig+0x18>
    /* Store the new value */
    RCC->CFGR = tmpreg;
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 800486e:	4a09      	ldr	r2, [pc, #36]	; (8004894 <RCC_RTCCLKConfig+0x30>)
 8004870:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8004872:	f3c0 000b 	ubfx	r0, r0, #0, #12
 8004876:	4318      	orrs	r0, r3
 8004878:	6710      	str	r0, [r2, #112]	; 0x70
 800487a:	4770      	bx	lr
    tmpreg = RCC->CFGR;
 800487c:	4905      	ldr	r1, [pc, #20]	; (8004894 <RCC_RTCCLKConfig+0x30>)
 800487e:	688b      	ldr	r3, [r1, #8]
    tmpreg &= ~RCC_CFGR_RTCPRE;
 8004880:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 8004884:	f020 4270 	bic.w	r2, r0, #4026531840	; 0xf0000000
 8004888:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 800488c:	4313      	orrs	r3, r2
    RCC->CFGR = tmpreg;
 800488e:	608b      	str	r3, [r1, #8]
 8004890:	e7ed      	b.n	800486e <RCC_RTCCLKConfig+0xa>
 8004892:	bf00      	nop
 8004894:	40023800 	.word	0x40023800

08004898 <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8004898:	4b01      	ldr	r3, [pc, #4]	; (80048a0 <RCC_RTCCLKCmd+0x8>)
 800489a:	6018      	str	r0, [r3, #0]
 800489c:	4770      	bx	lr
 800489e:	bf00      	nop
 80048a0:	42470e3c 	.word	0x42470e3c

080048a4 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 80048a4:	4b01      	ldr	r3, [pc, #4]	; (80048ac <RCC_BackupResetCmd+0x8>)
 80048a6:	6018      	str	r0, [r3, #0]
 80048a8:	4770      	bx	lr
 80048aa:	bf00      	nop
 80048ac:	42470e40 	.word	0x42470e40

080048b0 <RCC_I2SCLKConfig>:
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 80048b0:	4b01      	ldr	r3, [pc, #4]	; (80048b8 <RCC_I2SCLKConfig+0x8>)
 80048b2:	6018      	str	r0, [r3, #0]
 80048b4:	4770      	bx	lr
 80048b6:	bf00      	nop
 80048b8:	4247015c 	.word	0x4247015c

080048bc <RCC_TIMCLKPresConfig>:
void RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler)
{
  /* Check the parameters */
  assert_param(IS_RCC_TIMCLK_PRESCALER(RCC_TIMCLKPrescaler));

  *(__IO uint32_t *) DCKCFGR_TIMPRE_BB = RCC_TIMCLKPrescaler;
 80048bc:	4b01      	ldr	r3, [pc, #4]	; (80048c4 <RCC_TIMCLKPresConfig+0x8>)
 80048be:	6018      	str	r0, [r3, #0]
 80048c0:	4770      	bx	lr
 80048c2:	bf00      	nop
 80048c4:	424711e0 	.word	0x424711e0

080048c8 <RCC_AHB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80048c8:	b929      	cbnz	r1, 80048d6 <RCC_AHB1PeriphClockCmd+0xe>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 80048ca:	4a05      	ldr	r2, [pc, #20]	; (80048e0 <RCC_AHB1PeriphClockCmd+0x18>)
 80048cc:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80048ce:	ea23 0000 	bic.w	r0, r3, r0
 80048d2:	6310      	str	r0, [r2, #48]	; 0x30
 80048d4:	4770      	bx	lr
    RCC->AHB1ENR |= RCC_AHB1Periph;
 80048d6:	4a02      	ldr	r2, [pc, #8]	; (80048e0 <RCC_AHB1PeriphClockCmd+0x18>)
 80048d8:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80048da:	4318      	orrs	r0, r3
 80048dc:	6310      	str	r0, [r2, #48]	; 0x30
 80048de:	4770      	bx	lr
 80048e0:	40023800 	.word	0x40023800

080048e4 <RCC_AHB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80048e4:	b929      	cbnz	r1, 80048f2 <RCC_AHB2PeriphClockCmd+0xe>
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 80048e6:	4a05      	ldr	r2, [pc, #20]	; (80048fc <RCC_AHB2PeriphClockCmd+0x18>)
 80048e8:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80048ea:	ea23 0000 	bic.w	r0, r3, r0
 80048ee:	6350      	str	r0, [r2, #52]	; 0x34
 80048f0:	4770      	bx	lr
    RCC->AHB2ENR |= RCC_AHB2Periph;
 80048f2:	4a02      	ldr	r2, [pc, #8]	; (80048fc <RCC_AHB2PeriphClockCmd+0x18>)
 80048f4:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80048f6:	4318      	orrs	r0, r3
 80048f8:	6350      	str	r0, [r2, #52]	; 0x34
 80048fa:	4770      	bx	lr
 80048fc:	40023800 	.word	0x40023800

08004900 <RCC_AHB3PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004900:	b929      	cbnz	r1, 800490e <RCC_AHB3PeriphClockCmd+0xe>
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 8004902:	4a05      	ldr	r2, [pc, #20]	; (8004918 <RCC_AHB3PeriphClockCmd+0x18>)
 8004904:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8004906:	ea23 0000 	bic.w	r0, r3, r0
 800490a:	6390      	str	r0, [r2, #56]	; 0x38
 800490c:	4770      	bx	lr
    RCC->AHB3ENR |= RCC_AHB3Periph;
 800490e:	4a02      	ldr	r2, [pc, #8]	; (8004918 <RCC_AHB3PeriphClockCmd+0x18>)
 8004910:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8004912:	4318      	orrs	r0, r3
 8004914:	6390      	str	r0, [r2, #56]	; 0x38
 8004916:	4770      	bx	lr
 8004918:	40023800 	.word	0x40023800

0800491c <RCC_APB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800491c:	b929      	cbnz	r1, 800492a <RCC_APB1PeriphClockCmd+0xe>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 800491e:	4a05      	ldr	r2, [pc, #20]	; (8004934 <RCC_APB1PeriphClockCmd+0x18>)
 8004920:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8004922:	ea23 0000 	bic.w	r0, r3, r0
 8004926:	6410      	str	r0, [r2, #64]	; 0x40
 8004928:	4770      	bx	lr
    RCC->APB1ENR |= RCC_APB1Periph;
 800492a:	4a02      	ldr	r2, [pc, #8]	; (8004934 <RCC_APB1PeriphClockCmd+0x18>)
 800492c:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800492e:	4318      	orrs	r0, r3
 8004930:	6410      	str	r0, [r2, #64]	; 0x40
 8004932:	4770      	bx	lr
 8004934:	40023800 	.word	0x40023800

08004938 <RCC_APB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004938:	b929      	cbnz	r1, 8004946 <RCC_APB2PeriphClockCmd+0xe>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 800493a:	4a05      	ldr	r2, [pc, #20]	; (8004950 <RCC_APB2PeriphClockCmd+0x18>)
 800493c:	6c53      	ldr	r3, [r2, #68]	; 0x44
 800493e:	ea23 0000 	bic.w	r0, r3, r0
 8004942:	6450      	str	r0, [r2, #68]	; 0x44
 8004944:	4770      	bx	lr
    RCC->APB2ENR |= RCC_APB2Periph;
 8004946:	4a02      	ldr	r2, [pc, #8]	; (8004950 <RCC_APB2PeriphClockCmd+0x18>)
 8004948:	6c53      	ldr	r3, [r2, #68]	; 0x44
 800494a:	4318      	orrs	r0, r3
 800494c:	6450      	str	r0, [r2, #68]	; 0x44
 800494e:	4770      	bx	lr
 8004950:	40023800 	.word	0x40023800

08004954 <RCC_AHB1PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004954:	b929      	cbnz	r1, 8004962 <RCC_AHB1PeriphResetCmd+0xe>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 8004956:	4a05      	ldr	r2, [pc, #20]	; (800496c <RCC_AHB1PeriphResetCmd+0x18>)
 8004958:	6913      	ldr	r3, [r2, #16]
 800495a:	ea23 0000 	bic.w	r0, r3, r0
 800495e:	6110      	str	r0, [r2, #16]
 8004960:	4770      	bx	lr
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 8004962:	4a02      	ldr	r2, [pc, #8]	; (800496c <RCC_AHB1PeriphResetCmd+0x18>)
 8004964:	6913      	ldr	r3, [r2, #16]
 8004966:	4318      	orrs	r0, r3
 8004968:	6110      	str	r0, [r2, #16]
 800496a:	4770      	bx	lr
 800496c:	40023800 	.word	0x40023800

08004970 <RCC_AHB2PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004970:	b929      	cbnz	r1, 800497e <RCC_AHB2PeriphResetCmd+0xe>
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 8004972:	4a05      	ldr	r2, [pc, #20]	; (8004988 <RCC_AHB2PeriphResetCmd+0x18>)
 8004974:	6953      	ldr	r3, [r2, #20]
 8004976:	ea23 0000 	bic.w	r0, r3, r0
 800497a:	6150      	str	r0, [r2, #20]
 800497c:	4770      	bx	lr
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 800497e:	4a02      	ldr	r2, [pc, #8]	; (8004988 <RCC_AHB2PeriphResetCmd+0x18>)
 8004980:	6953      	ldr	r3, [r2, #20]
 8004982:	4318      	orrs	r0, r3
 8004984:	6150      	str	r0, [r2, #20]
 8004986:	4770      	bx	lr
 8004988:	40023800 	.word	0x40023800

0800498c <RCC_AHB3PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800498c:	b929      	cbnz	r1, 800499a <RCC_AHB3PeriphResetCmd+0xe>
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
 800498e:	4a05      	ldr	r2, [pc, #20]	; (80049a4 <RCC_AHB3PeriphResetCmd+0x18>)
 8004990:	6993      	ldr	r3, [r2, #24]
 8004992:	ea23 0000 	bic.w	r0, r3, r0
 8004996:	6190      	str	r0, [r2, #24]
 8004998:	4770      	bx	lr
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 800499a:	4a02      	ldr	r2, [pc, #8]	; (80049a4 <RCC_AHB3PeriphResetCmd+0x18>)
 800499c:	6993      	ldr	r3, [r2, #24]
 800499e:	4318      	orrs	r0, r3
 80049a0:	6190      	str	r0, [r2, #24]
 80049a2:	4770      	bx	lr
 80049a4:	40023800 	.word	0x40023800

080049a8 <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80049a8:	b929      	cbnz	r1, 80049b6 <RCC_APB1PeriphResetCmd+0xe>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 80049aa:	4a05      	ldr	r2, [pc, #20]	; (80049c0 <RCC_APB1PeriphResetCmd+0x18>)
 80049ac:	6a13      	ldr	r3, [r2, #32]
 80049ae:	ea23 0000 	bic.w	r0, r3, r0
 80049b2:	6210      	str	r0, [r2, #32]
 80049b4:	4770      	bx	lr
    RCC->APB1RSTR |= RCC_APB1Periph;
 80049b6:	4a02      	ldr	r2, [pc, #8]	; (80049c0 <RCC_APB1PeriphResetCmd+0x18>)
 80049b8:	6a13      	ldr	r3, [r2, #32]
 80049ba:	4318      	orrs	r0, r3
 80049bc:	6210      	str	r0, [r2, #32]
 80049be:	4770      	bx	lr
 80049c0:	40023800 	.word	0x40023800

080049c4 <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80049c4:	b929      	cbnz	r1, 80049d2 <RCC_APB2PeriphResetCmd+0xe>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 80049c6:	4a05      	ldr	r2, [pc, #20]	; (80049dc <RCC_APB2PeriphResetCmd+0x18>)
 80049c8:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80049ca:	ea23 0000 	bic.w	r0, r3, r0
 80049ce:	6250      	str	r0, [r2, #36]	; 0x24
 80049d0:	4770      	bx	lr
    RCC->APB2RSTR |= RCC_APB2Periph;
 80049d2:	4a02      	ldr	r2, [pc, #8]	; (80049dc <RCC_APB2PeriphResetCmd+0x18>)
 80049d4:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80049d6:	4318      	orrs	r0, r3
 80049d8:	6250      	str	r0, [r2, #36]	; 0x24
 80049da:	4770      	bx	lr
 80049dc:	40023800 	.word	0x40023800

080049e0 <RCC_AHB1PeriphClockLPModeCmd>:
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80049e0:	b929      	cbnz	r1, 80049ee <RCC_AHB1PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
 80049e2:	4a05      	ldr	r2, [pc, #20]	; (80049f8 <RCC_AHB1PeriphClockLPModeCmd+0x18>)
 80049e4:	6d13      	ldr	r3, [r2, #80]	; 0x50
 80049e6:	ea23 0000 	bic.w	r0, r3, r0
 80049ea:	6510      	str	r0, [r2, #80]	; 0x50
 80049ec:	4770      	bx	lr
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 80049ee:	4a02      	ldr	r2, [pc, #8]	; (80049f8 <RCC_AHB1PeriphClockLPModeCmd+0x18>)
 80049f0:	6d13      	ldr	r3, [r2, #80]	; 0x50
 80049f2:	4318      	orrs	r0, r3
 80049f4:	6510      	str	r0, [r2, #80]	; 0x50
 80049f6:	4770      	bx	lr
 80049f8:	40023800 	.word	0x40023800

080049fc <RCC_AHB2PeriphClockLPModeCmd>:
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80049fc:	b929      	cbnz	r1, 8004a0a <RCC_AHB2PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
 80049fe:	4a05      	ldr	r2, [pc, #20]	; (8004a14 <RCC_AHB2PeriphClockLPModeCmd+0x18>)
 8004a00:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8004a02:	ea23 0000 	bic.w	r0, r3, r0
 8004a06:	6550      	str	r0, [r2, #84]	; 0x54
 8004a08:	4770      	bx	lr
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 8004a0a:	4a02      	ldr	r2, [pc, #8]	; (8004a14 <RCC_AHB2PeriphClockLPModeCmd+0x18>)
 8004a0c:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8004a0e:	4318      	orrs	r0, r3
 8004a10:	6550      	str	r0, [r2, #84]	; 0x54
 8004a12:	4770      	bx	lr
 8004a14:	40023800 	.word	0x40023800

08004a18 <RCC_AHB3PeriphClockLPModeCmd>:
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004a18:	b929      	cbnz	r1, 8004a26 <RCC_AHB3PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
 8004a1a:	4a05      	ldr	r2, [pc, #20]	; (8004a30 <RCC_AHB3PeriphClockLPModeCmd+0x18>)
 8004a1c:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8004a1e:	ea23 0000 	bic.w	r0, r3, r0
 8004a22:	6590      	str	r0, [r2, #88]	; 0x58
 8004a24:	4770      	bx	lr
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 8004a26:	4a02      	ldr	r2, [pc, #8]	; (8004a30 <RCC_AHB3PeriphClockLPModeCmd+0x18>)
 8004a28:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8004a2a:	4318      	orrs	r0, r3
 8004a2c:	6590      	str	r0, [r2, #88]	; 0x58
 8004a2e:	4770      	bx	lr
 8004a30:	40023800 	.word	0x40023800

08004a34 <RCC_APB1PeriphClockLPModeCmd>:
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004a34:	b929      	cbnz	r1, 8004a42 <RCC_APB1PeriphClockLPModeCmd+0xe>
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
 8004a36:	4a05      	ldr	r2, [pc, #20]	; (8004a4c <RCC_APB1PeriphClockLPModeCmd+0x18>)
 8004a38:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8004a3a:	ea23 0000 	bic.w	r0, r3, r0
 8004a3e:	6610      	str	r0, [r2, #96]	; 0x60
 8004a40:	4770      	bx	lr
    RCC->APB1LPENR |= RCC_APB1Periph;
 8004a42:	4a02      	ldr	r2, [pc, #8]	; (8004a4c <RCC_APB1PeriphClockLPModeCmd+0x18>)
 8004a44:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8004a46:	4318      	orrs	r0, r3
 8004a48:	6610      	str	r0, [r2, #96]	; 0x60
 8004a4a:	4770      	bx	lr
 8004a4c:	40023800 	.word	0x40023800

08004a50 <RCC_APB2PeriphClockLPModeCmd>:
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004a50:	b929      	cbnz	r1, 8004a5e <RCC_APB2PeriphClockLPModeCmd+0xe>
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
 8004a52:	4a05      	ldr	r2, [pc, #20]	; (8004a68 <RCC_APB2PeriphClockLPModeCmd+0x18>)
 8004a54:	6e53      	ldr	r3, [r2, #100]	; 0x64
 8004a56:	ea23 0000 	bic.w	r0, r3, r0
 8004a5a:	6650      	str	r0, [r2, #100]	; 0x64
 8004a5c:	4770      	bx	lr
    RCC->APB2LPENR |= RCC_APB2Periph;
 8004a5e:	4a02      	ldr	r2, [pc, #8]	; (8004a68 <RCC_APB2PeriphClockLPModeCmd+0x18>)
 8004a60:	6e53      	ldr	r3, [r2, #100]	; 0x64
 8004a62:	4318      	orrs	r0, r3
 8004a64:	6650      	str	r0, [r2, #100]	; 0x64
 8004a66:	4770      	bx	lr
 8004a68:	40023800 	.word	0x40023800

08004a6c <RCC_ITConfig>:
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004a6c:	b929      	cbnz	r1, 8004a7a <RCC_ITConfig+0xe>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 8004a6e:	4a05      	ldr	r2, [pc, #20]	; (8004a84 <RCC_ITConfig+0x18>)
 8004a70:	7813      	ldrb	r3, [r2, #0]
 8004a72:	ea23 0000 	bic.w	r0, r3, r0
 8004a76:	7010      	strb	r0, [r2, #0]
 8004a78:	4770      	bx	lr
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 8004a7a:	4a02      	ldr	r2, [pc, #8]	; (8004a84 <RCC_ITConfig+0x18>)
 8004a7c:	7813      	ldrb	r3, [r2, #0]
 8004a7e:	4318      	orrs	r0, r3
 8004a80:	7010      	strb	r0, [r2, #0]
 8004a82:	4770      	bx	lr
 8004a84:	4002380d 	.word	0x4002380d

08004a88 <RCC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8004a88:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 8004a8a:	2b01      	cmp	r3, #1
 8004a8c:	d00c      	beq.n	8004aa8 <RCC_GetFlagStatus+0x20>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8004a8e:	2b02      	cmp	r3, #2
 8004a90:	d00d      	beq.n	8004aae <RCC_GetFlagStatus+0x26>
  {
    statusreg = RCC->BDCR;
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8004a92:	4b09      	ldr	r3, [pc, #36]	; (8004ab8 <RCC_GetFlagStatus+0x30>)
 8004a94:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
 8004a96:	f000 001f 	and.w	r0, r0, #31
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8004a9a:	fa23 f000 	lsr.w	r0, r3, r0
 8004a9e:	f010 0f01 	tst.w	r0, #1
 8004aa2:	d107      	bne.n	8004ab4 <RCC_GetFlagStatus+0x2c>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8004aa4:	2000      	movs	r0, #0
  }
  /* Return the flag status */
  return bitstatus;
}
 8004aa6:	4770      	bx	lr
    statusreg = RCC->CR;
 8004aa8:	4b03      	ldr	r3, [pc, #12]	; (8004ab8 <RCC_GetFlagStatus+0x30>)
 8004aaa:	681b      	ldr	r3, [r3, #0]
 8004aac:	e7f3      	b.n	8004a96 <RCC_GetFlagStatus+0xe>
    statusreg = RCC->BDCR;
 8004aae:	4b02      	ldr	r3, [pc, #8]	; (8004ab8 <RCC_GetFlagStatus+0x30>)
 8004ab0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004ab2:	e7f0      	b.n	8004a96 <RCC_GetFlagStatus+0xe>
    bitstatus = SET;
 8004ab4:	2001      	movs	r0, #1
 8004ab6:	4770      	bx	lr
 8004ab8:	40023800 	.word	0x40023800

08004abc <RCC_WaitForHSEStartUp>:
{
 8004abc:	b500      	push	{lr}
 8004abe:	b083      	sub	sp, #12
  __IO uint32_t startupcounter = 0;
 8004ac0:	2300      	movs	r3, #0
 8004ac2:	9301      	str	r3, [sp, #4]
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 8004ac4:	2031      	movs	r0, #49	; 0x31
 8004ac6:	f7ff ffdf 	bl	8004a88 <RCC_GetFlagStatus>
    startupcounter++;
 8004aca:	9b01      	ldr	r3, [sp, #4]
 8004acc:	3301      	adds	r3, #1
 8004ace:	9301      	str	r3, [sp, #4]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8004ad0:	9b01      	ldr	r3, [sp, #4]
 8004ad2:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8004ad6:	d001      	beq.n	8004adc <RCC_WaitForHSEStartUp+0x20>
 8004ad8:	2800      	cmp	r0, #0
 8004ada:	d0f3      	beq.n	8004ac4 <RCC_WaitForHSEStartUp+0x8>
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8004adc:	2031      	movs	r0, #49	; 0x31
 8004ade:	f7ff ffd3 	bl	8004a88 <RCC_GetFlagStatus>
 8004ae2:	b918      	cbnz	r0, 8004aec <RCC_WaitForHSEStartUp+0x30>
    status = ERROR;
 8004ae4:	2000      	movs	r0, #0
}
 8004ae6:	b003      	add	sp, #12
 8004ae8:	f85d fb04 	ldr.w	pc, [sp], #4
    status = SUCCESS;
 8004aec:	2001      	movs	r0, #1
 8004aee:	e7fa      	b.n	8004ae6 <RCC_WaitForHSEStartUp+0x2a>

08004af0 <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 8004af0:	4a02      	ldr	r2, [pc, #8]	; (8004afc <RCC_ClearFlag+0xc>)
 8004af2:	6f53      	ldr	r3, [r2, #116]	; 0x74
 8004af4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8004af8:	6753      	str	r3, [r2, #116]	; 0x74
 8004afa:	4770      	bx	lr
 8004afc:	40023800 	.word	0x40023800

08004b00 <RCC_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 8004b00:	4b03      	ldr	r3, [pc, #12]	; (8004b10 <RCC_GetITStatus+0x10>)
 8004b02:	68db      	ldr	r3, [r3, #12]
 8004b04:	4218      	tst	r0, r3
 8004b06:	d101      	bne.n	8004b0c <RCC_GetITStatus+0xc>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8004b08:	2000      	movs	r0, #0
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}
 8004b0a:	4770      	bx	lr
    bitstatus = SET;
 8004b0c:	2001      	movs	r0, #1
 8004b0e:	4770      	bx	lr
 8004b10:	40023800 	.word	0x40023800

08004b14 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 8004b14:	4b01      	ldr	r3, [pc, #4]	; (8004b1c <RCC_ClearITPendingBit+0x8>)
 8004b16:	7018      	strb	r0, [r3, #0]
 8004b18:	4770      	bx	lr
 8004b1a:	bf00      	nop
 8004b1c:	4002380e 	.word	0x4002380e

08004b20 <RNG_DeInit>:
  * @brief  De-initializes the RNG peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void RNG_DeInit(void)
{
 8004b20:	b508      	push	{r3, lr}
  /* Enable RNG reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, ENABLE);
 8004b22:	2101      	movs	r1, #1
 8004b24:	2040      	movs	r0, #64	; 0x40
 8004b26:	f7ff ff23 	bl	8004970 <RCC_AHB2PeriphResetCmd>

  /* Release RNG from reset state */
  RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_RNG, DISABLE);
 8004b2a:	2100      	movs	r1, #0
 8004b2c:	2040      	movs	r0, #64	; 0x40
 8004b2e:	f7ff ff1f 	bl	8004970 <RCC_AHB2PeriphResetCmd>
 8004b32:	bd08      	pop	{r3, pc}

08004b34 <RNG_Cmd>:
void RNG_Cmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004b34:	b928      	cbnz	r0, 8004b42 <RNG_Cmd+0xe>
    RNG->CR |= RNG_CR_RNGEN;
  }
  else
  {
    /* Disable the RNG */
    RNG->CR &= ~RNG_CR_RNGEN;
 8004b36:	4a06      	ldr	r2, [pc, #24]	; (8004b50 <RNG_Cmd+0x1c>)
 8004b38:	6813      	ldr	r3, [r2, #0]
 8004b3a:	f023 0304 	bic.w	r3, r3, #4
 8004b3e:	6013      	str	r3, [r2, #0]
 8004b40:	4770      	bx	lr
    RNG->CR |= RNG_CR_RNGEN;
 8004b42:	4a03      	ldr	r2, [pc, #12]	; (8004b50 <RNG_Cmd+0x1c>)
 8004b44:	6813      	ldr	r3, [r2, #0]
 8004b46:	f043 0304 	orr.w	r3, r3, #4
 8004b4a:	6013      	str	r3, [r2, #0]
 8004b4c:	4770      	bx	lr
 8004b4e:	bf00      	nop
 8004b50:	50060800 	.word	0x50060800

08004b54 <RNG_GetRandomNumber>:
  * @retval 32-bit random number.
  */
uint32_t RNG_GetRandomNumber(void)
{
  /* Return the 32 bit random number from the DR register */
  return RNG->DR;
 8004b54:	4b01      	ldr	r3, [pc, #4]	; (8004b5c <RNG_GetRandomNumber+0x8>)
 8004b56:	6898      	ldr	r0, [r3, #8]
}
 8004b58:	4770      	bx	lr
 8004b5a:	bf00      	nop
 8004b5c:	50060800 	.word	0x50060800

08004b60 <RNG_ITConfig>:
void RNG_ITConfig(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004b60:	b928      	cbnz	r0, 8004b6e <RNG_ITConfig+0xe>
    RNG->CR |= RNG_CR_IE;
  }
  else
  {
    /* Disable the RNG interrupt */
    RNG->CR &= ~RNG_CR_IE;
 8004b62:	4a06      	ldr	r2, [pc, #24]	; (8004b7c <RNG_ITConfig+0x1c>)
 8004b64:	6813      	ldr	r3, [r2, #0]
 8004b66:	f023 0308 	bic.w	r3, r3, #8
 8004b6a:	6013      	str	r3, [r2, #0]
 8004b6c:	4770      	bx	lr
    RNG->CR |= RNG_CR_IE;
 8004b6e:	4a03      	ldr	r2, [pc, #12]	; (8004b7c <RNG_ITConfig+0x1c>)
 8004b70:	6813      	ldr	r3, [r2, #0]
 8004b72:	f043 0308 	orr.w	r3, r3, #8
 8004b76:	6013      	str	r3, [r2, #0]
 8004b78:	4770      	bx	lr
 8004b7a:	bf00      	nop
 8004b7c:	50060800 	.word	0x50060800

08004b80 <RNG_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RNG_GET_FLAG(RNG_FLAG));

  /* Check the status of the specified RNG flag */
  if ((RNG->SR & RNG_FLAG) != (uint8_t)RESET)
 8004b80:	4b03      	ldr	r3, [pc, #12]	; (8004b90 <RNG_GetFlagStatus+0x10>)
 8004b82:	685b      	ldr	r3, [r3, #4]
 8004b84:	4218      	tst	r0, r3
 8004b86:	d101      	bne.n	8004b8c <RNG_GetFlagStatus+0xc>
    bitstatus = SET;
  }
  else
  {
    /* RNG_FLAG is reset */
    bitstatus = RESET;
 8004b88:	2000      	movs	r0, #0
  }
  /* Return the RNG_FLAG status */
  return  bitstatus;
}
 8004b8a:	4770      	bx	lr
    bitstatus = SET;
 8004b8c:	2001      	movs	r0, #1
 8004b8e:	4770      	bx	lr
 8004b90:	50060800 	.word	0x50060800

08004b94 <RNG_ClearFlag>:
void RNG_ClearFlag(uint8_t RNG_FLAG)
{
  /* Check the parameters */
  assert_param(IS_RNG_CLEAR_FLAG(RNG_FLAG));
  /* Clear the selected RNG flags */
  RNG->SR = ~(uint32_t)(((uint32_t)RNG_FLAG) << 4);
 8004b94:	ea6f 1000 	mvn.w	r0, r0, lsl #4
 8004b98:	4b01      	ldr	r3, [pc, #4]	; (8004ba0 <RNG_ClearFlag+0xc>)
 8004b9a:	6058      	str	r0, [r3, #4]
 8004b9c:	4770      	bx	lr
 8004b9e:	bf00      	nop
 8004ba0:	50060800 	.word	0x50060800

08004ba4 <RNG_GetITStatus>:
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_RNG_GET_IT(RNG_IT));

  /* Check the status of the specified RNG interrupt */
  if ((RNG->SR & RNG_IT) != (uint8_t)RESET)
 8004ba4:	4b03      	ldr	r3, [pc, #12]	; (8004bb4 <RNG_GetITStatus+0x10>)
 8004ba6:	685b      	ldr	r3, [r3, #4]
 8004ba8:	4218      	tst	r0, r3
 8004baa:	d101      	bne.n	8004bb0 <RNG_GetITStatus+0xc>
    bitstatus = SET;
  }
  else
  {
    /* RNG_IT is reset */
    bitstatus = RESET;
 8004bac:	2000      	movs	r0, #0
  }
  /* Return the RNG_IT status */
  return bitstatus;
}
 8004bae:	4770      	bx	lr
    bitstatus = SET;
 8004bb0:	2001      	movs	r0, #1
 8004bb2:	4770      	bx	lr
 8004bb4:	50060800 	.word	0x50060800

08004bb8 <RNG_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_RNG_IT(RNG_IT));

  /* Clear the selected RNG interrupt pending bit */
  RNG->SR = (uint8_t)~RNG_IT;
 8004bb8:	43c0      	mvns	r0, r0
 8004bba:	b2c0      	uxtb	r0, r0
 8004bbc:	4b01      	ldr	r3, [pc, #4]	; (8004bc4 <RNG_ClearITPendingBit+0xc>)
 8004bbe:	6058      	str	r0, [r3, #4]
 8004bc0:	4770      	bx	lr
 8004bc2:	bf00      	nop
 8004bc4:	50060800 	.word	0x50060800

08004bc8 <RTC_ByteToBcd2>:
  * @param  Value: Byte to be converted.
  * @retval Converted byte
  */
static uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint8_t bcdhigh = 0;
 8004bc8:	2300      	movs	r3, #0
  
  while (Value >= 10)
 8004bca:	e003      	b.n	8004bd4 <RTC_ByteToBcd2+0xc>
  {
    bcdhigh++;
 8004bcc:	3301      	adds	r3, #1
 8004bce:	b2db      	uxtb	r3, r3
    Value -= 10;
 8004bd0:	380a      	subs	r0, #10
 8004bd2:	b2c0      	uxtb	r0, r0
  while (Value >= 10)
 8004bd4:	2809      	cmp	r0, #9
 8004bd6:	d8f9      	bhi.n	8004bcc <RTC_ByteToBcd2+0x4>
  }
  
  return  ((uint8_t)(bcdhigh << 4) | Value);
 8004bd8:	011b      	lsls	r3, r3, #4
 8004bda:	b2db      	uxtb	r3, r3
}
 8004bdc:	4318      	orrs	r0, r3
 8004bde:	4770      	bx	lr

08004be0 <RTC_Bcd2ToByte>:
  * @retval Converted word
  */
static uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint8_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8004be0:	0902      	lsrs	r2, r0, #4
 8004be2:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8004be6:	0053      	lsls	r3, r2, #1
 8004be8:	b2db      	uxtb	r3, r3
  return (tmp + (Value & (uint8_t)0x0F));
 8004bea:	f000 000f 	and.w	r0, r0, #15
 8004bee:	4418      	add	r0, r3
}
 8004bf0:	b2c0      	uxtb	r0, r0
 8004bf2:	4770      	bx	lr

08004bf4 <RTC_StructInit>:
  RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
 8004bf4:	2300      	movs	r3, #0
 8004bf6:	6003      	str	r3, [r0, #0]
  RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
 8004bf8:	237f      	movs	r3, #127	; 0x7f
 8004bfa:	6043      	str	r3, [r0, #4]
  RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
 8004bfc:	23ff      	movs	r3, #255	; 0xff
 8004bfe:	6083      	str	r3, [r0, #8]
 8004c00:	4770      	bx	lr

08004c02 <RTC_WriteProtectionCmd>:
  if (NewState != DISABLE)
 8004c02:	b928      	cbnz	r0, 8004c10 <RTC_WriteProtectionCmd+0xe>
    RTC->WPR = 0xCA;
 8004c04:	4b04      	ldr	r3, [pc, #16]	; (8004c18 <RTC_WriteProtectionCmd+0x16>)
 8004c06:	22ca      	movs	r2, #202	; 0xca
 8004c08:	625a      	str	r2, [r3, #36]	; 0x24
    RTC->WPR = 0x53;    
 8004c0a:	2253      	movs	r2, #83	; 0x53
 8004c0c:	625a      	str	r2, [r3, #36]	; 0x24
 8004c0e:	4770      	bx	lr
    RTC->WPR = 0xFF;   
 8004c10:	22ff      	movs	r2, #255	; 0xff
 8004c12:	4b01      	ldr	r3, [pc, #4]	; (8004c18 <RTC_WriteProtectionCmd+0x16>)
 8004c14:	625a      	str	r2, [r3, #36]	; 0x24
 8004c16:	4770      	bx	lr
 8004c18:	40002800 	.word	0x40002800

08004c1c <RTC_EnterInitMode>:
{
 8004c1c:	b082      	sub	sp, #8
  __IO uint32_t initcounter = 0x00;
 8004c1e:	2300      	movs	r3, #0
 8004c20:	9301      	str	r3, [sp, #4]
  if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8004c22:	4b11      	ldr	r3, [pc, #68]	; (8004c68 <RTC_EnterInitMode+0x4c>)
 8004c24:	68db      	ldr	r3, [r3, #12]
 8004c26:	f013 0f40 	tst.w	r3, #64	; 0x40
 8004c2a:	d119      	bne.n	8004c60 <RTC_EnterInitMode+0x44>
    RTC->ISR = (uint32_t)RTC_INIT_MASK;
 8004c2c:	f04f 32ff 	mov.w	r2, #4294967295
 8004c30:	4b0d      	ldr	r3, [pc, #52]	; (8004c68 <RTC_EnterInitMode+0x4c>)
 8004c32:	60da      	str	r2, [r3, #12]
      initstatus = RTC->ISR & RTC_ISR_INITF;
 8004c34:	4b0c      	ldr	r3, [pc, #48]	; (8004c68 <RTC_EnterInitMode+0x4c>)
 8004c36:	68da      	ldr	r2, [r3, #12]
 8004c38:	f002 0240 	and.w	r2, r2, #64	; 0x40
      initcounter++;  
 8004c3c:	9b01      	ldr	r3, [sp, #4]
 8004c3e:	3301      	adds	r3, #1
 8004c40:	9301      	str	r3, [sp, #4]
    } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
 8004c42:	9b01      	ldr	r3, [sp, #4]
 8004c44:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8004c48:	d001      	beq.n	8004c4e <RTC_EnterInitMode+0x32>
 8004c4a:	2a00      	cmp	r2, #0
 8004c4c:	d0f2      	beq.n	8004c34 <RTC_EnterInitMode+0x18>
    if ((RTC->ISR & RTC_ISR_INITF) != RESET)
 8004c4e:	4b06      	ldr	r3, [pc, #24]	; (8004c68 <RTC_EnterInitMode+0x4c>)
 8004c50:	68db      	ldr	r3, [r3, #12]
 8004c52:	f013 0f40 	tst.w	r3, #64	; 0x40
 8004c56:	d101      	bne.n	8004c5c <RTC_EnterInitMode+0x40>
      status = ERROR;
 8004c58:	2000      	movs	r0, #0
 8004c5a:	e002      	b.n	8004c62 <RTC_EnterInitMode+0x46>
      status = SUCCESS;
 8004c5c:	2001      	movs	r0, #1
 8004c5e:	e000      	b.n	8004c62 <RTC_EnterInitMode+0x46>
    status = SUCCESS;  
 8004c60:	2001      	movs	r0, #1
}
 8004c62:	b002      	add	sp, #8
 8004c64:	4770      	bx	lr
 8004c66:	bf00      	nop
 8004c68:	40002800 	.word	0x40002800

08004c6c <RTC_ExitInitMode>:
  RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
 8004c6c:	4a02      	ldr	r2, [pc, #8]	; (8004c78 <RTC_ExitInitMode+0xc>)
 8004c6e:	68d3      	ldr	r3, [r2, #12]
 8004c70:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004c74:	60d3      	str	r3, [r2, #12]
 8004c76:	4770      	bx	lr
 8004c78:	40002800 	.word	0x40002800

08004c7c <RTC_Init>:
{
 8004c7c:	b510      	push	{r4, lr}
 8004c7e:	4604      	mov	r4, r0
  RTC->WPR = 0xCA;
 8004c80:	4b10      	ldr	r3, [pc, #64]	; (8004cc4 <RTC_Init+0x48>)
 8004c82:	22ca      	movs	r2, #202	; 0xca
 8004c84:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8004c86:	2253      	movs	r2, #83	; 0x53
 8004c88:	625a      	str	r2, [r3, #36]	; 0x24
  if (RTC_EnterInitMode() == ERROR)
 8004c8a:	f7ff ffc7 	bl	8004c1c <RTC_EnterInitMode>
 8004c8e:	4603      	mov	r3, r0
 8004c90:	b920      	cbnz	r0, 8004c9c <RTC_Init+0x20>
  RTC->WPR = 0xFF; 
 8004c92:	21ff      	movs	r1, #255	; 0xff
 8004c94:	4a0b      	ldr	r2, [pc, #44]	; (8004cc4 <RTC_Init+0x48>)
 8004c96:	6251      	str	r1, [r2, #36]	; 0x24
}
 8004c98:	4618      	mov	r0, r3
 8004c9a:	bd10      	pop	{r4, pc}
    RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
 8004c9c:	4b09      	ldr	r3, [pc, #36]	; (8004cc4 <RTC_Init+0x48>)
 8004c9e:	689a      	ldr	r2, [r3, #8]
 8004ca0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8004ca4:	609a      	str	r2, [r3, #8]
    RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
 8004ca6:	689a      	ldr	r2, [r3, #8]
 8004ca8:	6821      	ldr	r1, [r4, #0]
 8004caa:	430a      	orrs	r2, r1
 8004cac:	609a      	str	r2, [r3, #8]
    RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
 8004cae:	68a2      	ldr	r2, [r4, #8]
 8004cb0:	611a      	str	r2, [r3, #16]
    RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
 8004cb2:	691a      	ldr	r2, [r3, #16]
 8004cb4:	6861      	ldr	r1, [r4, #4]
 8004cb6:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8004cba:	611a      	str	r2, [r3, #16]
    RTC_ExitInitMode();
 8004cbc:	f7ff ffd6 	bl	8004c6c <RTC_ExitInitMode>
    status = SUCCESS;    
 8004cc0:	2301      	movs	r3, #1
 8004cc2:	e7e6      	b.n	8004c92 <RTC_Init+0x16>
 8004cc4:	40002800 	.word	0x40002800

08004cc8 <RTC_WaitForSynchro>:
{
 8004cc8:	b082      	sub	sp, #8
  __IO uint32_t synchrocounter = 0;
 8004cca:	2300      	movs	r3, #0
 8004ccc:	9301      	str	r3, [sp, #4]
  RTC->WPR = 0xCA;
 8004cce:	4b11      	ldr	r3, [pc, #68]	; (8004d14 <RTC_WaitForSynchro+0x4c>)
 8004cd0:	22ca      	movs	r2, #202	; 0xca
 8004cd2:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8004cd4:	2253      	movs	r2, #83	; 0x53
 8004cd6:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->ISR &= (uint32_t)RTC_RSF_MASK;
 8004cd8:	68da      	ldr	r2, [r3, #12]
 8004cda:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 8004cde:	60da      	str	r2, [r3, #12]
    synchrostatus = RTC->ISR & RTC_ISR_RSF;
 8004ce0:	4b0c      	ldr	r3, [pc, #48]	; (8004d14 <RTC_WaitForSynchro+0x4c>)
 8004ce2:	68da      	ldr	r2, [r3, #12]
 8004ce4:	f002 0220 	and.w	r2, r2, #32
    synchrocounter++;  
 8004ce8:	9b01      	ldr	r3, [sp, #4]
 8004cea:	3301      	adds	r3, #1
 8004cec:	9301      	str	r3, [sp, #4]
  } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
 8004cee:	9b01      	ldr	r3, [sp, #4]
 8004cf0:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8004cf4:	d001      	beq.n	8004cfa <RTC_WaitForSynchro+0x32>
 8004cf6:	2a00      	cmp	r2, #0
 8004cf8:	d0f2      	beq.n	8004ce0 <RTC_WaitForSynchro+0x18>
  if ((RTC->ISR & RTC_ISR_RSF) != RESET)
 8004cfa:	4b06      	ldr	r3, [pc, #24]	; (8004d14 <RTC_WaitForSynchro+0x4c>)
 8004cfc:	68db      	ldr	r3, [r3, #12]
 8004cfe:	f013 0f20 	tst.w	r3, #32
 8004d02:	d105      	bne.n	8004d10 <RTC_WaitForSynchro+0x48>
    status = ERROR;
 8004d04:	2000      	movs	r0, #0
  RTC->WPR = 0xFF; 
 8004d06:	22ff      	movs	r2, #255	; 0xff
 8004d08:	4b02      	ldr	r3, [pc, #8]	; (8004d14 <RTC_WaitForSynchro+0x4c>)
 8004d0a:	625a      	str	r2, [r3, #36]	; 0x24
}
 8004d0c:	b002      	add	sp, #8
 8004d0e:	4770      	bx	lr
    status = SUCCESS;
 8004d10:	2001      	movs	r0, #1
 8004d12:	e7f8      	b.n	8004d06 <RTC_WaitForSynchro+0x3e>
 8004d14:	40002800 	.word	0x40002800

08004d18 <RTC_DeInit>:
{
 8004d18:	b500      	push	{lr}
 8004d1a:	b083      	sub	sp, #12
  __IO uint32_t wutcounter = 0x00;
 8004d1c:	2300      	movs	r3, #0
 8004d1e:	9301      	str	r3, [sp, #4]
  RTC->WPR = 0xCA;
 8004d20:	4b22      	ldr	r3, [pc, #136]	; (8004dac <RTC_DeInit+0x94>)
 8004d22:	22ca      	movs	r2, #202	; 0xca
 8004d24:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8004d26:	2253      	movs	r2, #83	; 0x53
 8004d28:	625a      	str	r2, [r3, #36]	; 0x24
  if (RTC_EnterInitMode() == ERROR)
 8004d2a:	f7ff ff77 	bl	8004c1c <RTC_EnterInitMode>
 8004d2e:	4603      	mov	r3, r0
 8004d30:	b1e0      	cbz	r0, 8004d6c <RTC_DeInit+0x54>
    RTC->TR = (uint32_t)0x00000000;
 8004d32:	4b1e      	ldr	r3, [pc, #120]	; (8004dac <RTC_DeInit+0x94>)
 8004d34:	2200      	movs	r2, #0
 8004d36:	601a      	str	r2, [r3, #0]
    RTC->DR = (uint32_t)0x00002101;
 8004d38:	f242 1201 	movw	r2, #8449	; 0x2101
 8004d3c:	605a      	str	r2, [r3, #4]
    RTC->CR &= (uint32_t)0x00000007;
 8004d3e:	689a      	ldr	r2, [r3, #8]
 8004d40:	f002 0207 	and.w	r2, r2, #7
 8004d44:	609a      	str	r2, [r3, #8]
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 8004d46:	4b19      	ldr	r3, [pc, #100]	; (8004dac <RTC_DeInit+0x94>)
 8004d48:	68da      	ldr	r2, [r3, #12]
 8004d4a:	f002 0204 	and.w	r2, r2, #4
      wutcounter++;  
 8004d4e:	9b01      	ldr	r3, [sp, #4]
 8004d50:	3301      	adds	r3, #1
 8004d52:	9301      	str	r3, [sp, #4]
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 8004d54:	9b01      	ldr	r3, [sp, #4]
 8004d56:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8004d5a:	d001      	beq.n	8004d60 <RTC_DeInit+0x48>
 8004d5c:	2a00      	cmp	r2, #0
 8004d5e:	d0f2      	beq.n	8004d46 <RTC_DeInit+0x2e>
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 8004d60:	4b12      	ldr	r3, [pc, #72]	; (8004dac <RTC_DeInit+0x94>)
 8004d62:	68db      	ldr	r3, [r3, #12]
 8004d64:	f013 0f04 	tst.w	r3, #4
 8004d68:	d107      	bne.n	8004d7a <RTC_DeInit+0x62>
      status = ERROR;
 8004d6a:	2300      	movs	r3, #0
  RTC->WPR = 0xFF;  
 8004d6c:	21ff      	movs	r1, #255	; 0xff
 8004d6e:	4a0f      	ldr	r2, [pc, #60]	; (8004dac <RTC_DeInit+0x94>)
 8004d70:	6251      	str	r1, [r2, #36]	; 0x24
}
 8004d72:	4618      	mov	r0, r3
 8004d74:	b003      	add	sp, #12
 8004d76:	f85d fb04 	ldr.w	pc, [sp], #4
      RTC->CR &= (uint32_t)0x00000000;
 8004d7a:	4b0c      	ldr	r3, [pc, #48]	; (8004dac <RTC_DeInit+0x94>)
 8004d7c:	689a      	ldr	r2, [r3, #8]
 8004d7e:	2200      	movs	r2, #0
 8004d80:	609a      	str	r2, [r3, #8]
      RTC->WUTR = (uint32_t)0x0000FFFF;
 8004d82:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8004d86:	6159      	str	r1, [r3, #20]
      RTC->PRER = (uint32_t)0x007F00FF;
 8004d88:	4909      	ldr	r1, [pc, #36]	; (8004db0 <RTC_DeInit+0x98>)
 8004d8a:	6119      	str	r1, [r3, #16]
      RTC->CALIBR = (uint32_t)0x00000000;
 8004d8c:	619a      	str	r2, [r3, #24]
      RTC->ALRMAR = (uint32_t)0x00000000;        
 8004d8e:	61da      	str	r2, [r3, #28]
      RTC->ALRMBR = (uint32_t)0x00000000;
 8004d90:	621a      	str	r2, [r3, #32]
      RTC->SHIFTR = (uint32_t)0x00000000;
 8004d92:	62da      	str	r2, [r3, #44]	; 0x2c
      RTC->CALR = (uint32_t)0x00000000;
 8004d94:	63da      	str	r2, [r3, #60]	; 0x3c
      RTC->ALRMASSR = (uint32_t)0x00000000;
 8004d96:	645a      	str	r2, [r3, #68]	; 0x44
      RTC->ALRMBSSR = (uint32_t)0x00000000;
 8004d98:	649a      	str	r2, [r3, #72]	; 0x48
      RTC->ISR = (uint32_t)0x00000000;
 8004d9a:	60da      	str	r2, [r3, #12]
      RTC->TAFCR = 0x00000000;
 8004d9c:	641a      	str	r2, [r3, #64]	; 0x40
      if(RTC_WaitForSynchro() == ERROR)
 8004d9e:	f7ff ff93 	bl	8004cc8 <RTC_WaitForSynchro>
 8004da2:	4603      	mov	r3, r0
 8004da4:	2800      	cmp	r0, #0
 8004da6:	d0e1      	beq.n	8004d6c <RTC_DeInit+0x54>
        status = SUCCESS;      
 8004da8:	2301      	movs	r3, #1
 8004daa:	e7df      	b.n	8004d6c <RTC_DeInit+0x54>
 8004dac:	40002800 	.word	0x40002800
 8004db0:	007f00ff 	.word	0x007f00ff

08004db4 <RTC_RefClockCmd>:
{ 
 8004db4:	b510      	push	{r4, lr}
 8004db6:	4604      	mov	r4, r0
  RTC->WPR = 0xCA;
 8004db8:	4b0e      	ldr	r3, [pc, #56]	; (8004df4 <RTC_RefClockCmd+0x40>)
 8004dba:	22ca      	movs	r2, #202	; 0xca
 8004dbc:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8004dbe:	2253      	movs	r2, #83	; 0x53
 8004dc0:	625a      	str	r2, [r3, #36]	; 0x24
  if (RTC_EnterInitMode() == ERROR)
 8004dc2:	f7ff ff2b 	bl	8004c1c <RTC_EnterInitMode>
 8004dc6:	4603      	mov	r3, r0
 8004dc8:	b140      	cbz	r0, 8004ddc <RTC_RefClockCmd+0x28>
    if (NewState != DISABLE)
 8004dca:	b164      	cbz	r4, 8004de6 <RTC_RefClockCmd+0x32>
      RTC->CR |= RTC_CR_REFCKON;   
 8004dcc:	4a09      	ldr	r2, [pc, #36]	; (8004df4 <RTC_RefClockCmd+0x40>)
 8004dce:	6893      	ldr	r3, [r2, #8]
 8004dd0:	f043 0310 	orr.w	r3, r3, #16
 8004dd4:	6093      	str	r3, [r2, #8]
    RTC_ExitInitMode();
 8004dd6:	f7ff ff49 	bl	8004c6c <RTC_ExitInitMode>
    status = SUCCESS;
 8004dda:	2301      	movs	r3, #1
  RTC->WPR = 0xFF;  
 8004ddc:	21ff      	movs	r1, #255	; 0xff
 8004dde:	4a05      	ldr	r2, [pc, #20]	; (8004df4 <RTC_RefClockCmd+0x40>)
 8004de0:	6251      	str	r1, [r2, #36]	; 0x24
}
 8004de2:	4618      	mov	r0, r3
 8004de4:	bd10      	pop	{r4, pc}
      RTC->CR &= ~RTC_CR_REFCKON;    
 8004de6:	4a03      	ldr	r2, [pc, #12]	; (8004df4 <RTC_RefClockCmd+0x40>)
 8004de8:	6893      	ldr	r3, [r2, #8]
 8004dea:	f023 0310 	bic.w	r3, r3, #16
 8004dee:	6093      	str	r3, [r2, #8]
 8004df0:	e7f1      	b.n	8004dd6 <RTC_RefClockCmd+0x22>
 8004df2:	bf00      	nop
 8004df4:	40002800 	.word	0x40002800

08004df8 <RTC_BypassShadowCmd>:
  RTC->WPR = 0xCA;
 8004df8:	4b0a      	ldr	r3, [pc, #40]	; (8004e24 <RTC_BypassShadowCmd+0x2c>)
 8004dfa:	22ca      	movs	r2, #202	; 0xca
 8004dfc:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8004dfe:	2253      	movs	r2, #83	; 0x53
 8004e00:	625a      	str	r2, [r3, #36]	; 0x24
  if (NewState != DISABLE)
 8004e02:	b940      	cbnz	r0, 8004e16 <RTC_BypassShadowCmd+0x1e>
    RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
 8004e04:	4a07      	ldr	r2, [pc, #28]	; (8004e24 <RTC_BypassShadowCmd+0x2c>)
 8004e06:	6893      	ldr	r3, [r2, #8]
 8004e08:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8004e0c:	6093      	str	r3, [r2, #8]
  RTC->WPR = 0xFF;
 8004e0e:	22ff      	movs	r2, #255	; 0xff
 8004e10:	4b04      	ldr	r3, [pc, #16]	; (8004e24 <RTC_BypassShadowCmd+0x2c>)
 8004e12:	625a      	str	r2, [r3, #36]	; 0x24
 8004e14:	4770      	bx	lr
    RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
 8004e16:	461a      	mov	r2, r3
 8004e18:	689b      	ldr	r3, [r3, #8]
 8004e1a:	f043 0320 	orr.w	r3, r3, #32
 8004e1e:	6093      	str	r3, [r2, #8]
 8004e20:	e7f5      	b.n	8004e0e <RTC_BypassShadowCmd+0x16>
 8004e22:	bf00      	nop
 8004e24:	40002800 	.word	0x40002800

08004e28 <RTC_SetTime>:
{
 8004e28:	b538      	push	{r3, r4, r5, lr}
 8004e2a:	460d      	mov	r5, r1
  if (RTC_Format == RTC_Format_BIN)
 8004e2c:	4603      	mov	r3, r0
 8004e2e:	b9f8      	cbnz	r0, 8004e70 <RTC_SetTime+0x48>
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8004e30:	4a26      	ldr	r2, [pc, #152]	; (8004ecc <RTC_SetTime+0xa4>)
 8004e32:	6892      	ldr	r2, [r2, #8]
 8004e34:	f012 0f40 	tst.w	r2, #64	; 0x40
 8004e38:	d101      	bne.n	8004e3e <RTC_SetTime+0x16>
      RTC_TimeStruct->RTC_H12 = 0x00;
 8004e3a:	2200      	movs	r2, #0
 8004e3c:	70ca      	strb	r2, [r1, #3]
  if (RTC_Format != RTC_Format_BIN)
 8004e3e:	b1fb      	cbz	r3, 8004e80 <RTC_SetTime+0x58>
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8004e40:	782c      	ldrb	r4, [r5, #0]
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8004e42:	7868      	ldrb	r0, [r5, #1]
 8004e44:	0200      	lsls	r0, r0, #8
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8004e46:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
             ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
 8004e4a:	78ac      	ldrb	r4, [r5, #2]
             ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8004e4c:	4320      	orrs	r0, r4
             ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
 8004e4e:	78ec      	ldrb	r4, [r5, #3]
    tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
 8004e50:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
  RTC->WPR = 0xCA;
 8004e54:	4b1d      	ldr	r3, [pc, #116]	; (8004ecc <RTC_SetTime+0xa4>)
 8004e56:	22ca      	movs	r2, #202	; 0xca
 8004e58:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8004e5a:	2253      	movs	r2, #83	; 0x53
 8004e5c:	625a      	str	r2, [r3, #36]	; 0x24
  if (RTC_EnterInitMode() == ERROR)
 8004e5e:	f7ff fedd 	bl	8004c1c <RTC_EnterInitMode>
 8004e62:	4603      	mov	r3, r0
 8004e64:	b9e8      	cbnz	r0, 8004ea2 <RTC_SetTime+0x7a>
  RTC->WPR = 0xFF; 
 8004e66:	21ff      	movs	r1, #255	; 0xff
 8004e68:	4a18      	ldr	r2, [pc, #96]	; (8004ecc <RTC_SetTime+0xa4>)
 8004e6a:	6251      	str	r1, [r2, #36]	; 0x24
}
 8004e6c:	4618      	mov	r0, r3
 8004e6e:	bd38      	pop	{r3, r4, r5, pc}
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8004e70:	4a16      	ldr	r2, [pc, #88]	; (8004ecc <RTC_SetTime+0xa4>)
 8004e72:	6892      	ldr	r2, [r2, #8]
 8004e74:	f012 0f40 	tst.w	r2, #64	; 0x40
 8004e78:	d1e1      	bne.n	8004e3e <RTC_SetTime+0x16>
      RTC_TimeStruct->RTC_H12 = 0x00;
 8004e7a:	2200      	movs	r2, #0
 8004e7c:	70ca      	strb	r2, [r1, #3]
 8004e7e:	e7de      	b.n	8004e3e <RTC_SetTime+0x16>
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8004e80:	7828      	ldrb	r0, [r5, #0]
 8004e82:	f7ff fea1 	bl	8004bc8 <RTC_ByteToBcd2>
 8004e86:	0404      	lsls	r4, r0, #16
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8004e88:	7868      	ldrb	r0, [r5, #1]
 8004e8a:	f7ff fe9d 	bl	8004bc8 <RTC_ByteToBcd2>
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8004e8e:	ea44 2400 	orr.w	r4, r4, r0, lsl #8
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
 8004e92:	78a8      	ldrb	r0, [r5, #2]
 8004e94:	f7ff fe98 	bl	8004bc8 <RTC_ByteToBcd2>
                   ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
 8004e98:	4320      	orrs	r0, r4
                   (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
 8004e9a:	78ec      	ldrb	r4, [r5, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
 8004e9c:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
 8004ea0:	e7d8      	b.n	8004e54 <RTC_SetTime+0x2c>
    RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8004ea2:	f004 307f 	and.w	r0, r4, #2139062143	; 0x7f7f7f7f
 8004ea6:	f020 40fe 	bic.w	r0, r0, #2130706432	; 0x7f000000
 8004eaa:	4c08      	ldr	r4, [pc, #32]	; (8004ecc <RTC_SetTime+0xa4>)
 8004eac:	6020      	str	r0, [r4, #0]
    RTC_ExitInitMode(); 
 8004eae:	f7ff fedd 	bl	8004c6c <RTC_ExitInitMode>
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 8004eb2:	68a3      	ldr	r3, [r4, #8]
 8004eb4:	f013 0f20 	tst.w	r3, #32
 8004eb8:	d001      	beq.n	8004ebe <RTC_SetTime+0x96>
      status = SUCCESS;
 8004eba:	2301      	movs	r3, #1
 8004ebc:	e7d3      	b.n	8004e66 <RTC_SetTime+0x3e>
    if(RTC_WaitForSynchro() == ERROR)
 8004ebe:	f7ff ff03 	bl	8004cc8 <RTC_WaitForSynchro>
 8004ec2:	4603      	mov	r3, r0
 8004ec4:	2800      	cmp	r0, #0
 8004ec6:	d0ce      	beq.n	8004e66 <RTC_SetTime+0x3e>
      status = SUCCESS;
 8004ec8:	2301      	movs	r3, #1
 8004eca:	e7cc      	b.n	8004e66 <RTC_SetTime+0x3e>
 8004ecc:	40002800 	.word	0x40002800

08004ed0 <RTC_TimeStructInit>:
  RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
 8004ed0:	2300      	movs	r3, #0
 8004ed2:	70c3      	strb	r3, [r0, #3]
  RTC_TimeStruct->RTC_Hours = 0;
 8004ed4:	7003      	strb	r3, [r0, #0]
  RTC_TimeStruct->RTC_Minutes = 0;
 8004ed6:	7043      	strb	r3, [r0, #1]
  RTC_TimeStruct->RTC_Seconds = 0; 
 8004ed8:	7083      	strb	r3, [r0, #2]
 8004eda:	4770      	bx	lr

08004edc <RTC_GetTime>:
{
 8004edc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
 8004ede:	4b11      	ldr	r3, [pc, #68]	; (8004f24 <RTC_GetTime+0x48>)
 8004ee0:	681b      	ldr	r3, [r3, #0]
 8004ee2:	f003 337f 	and.w	r3, r3, #2139062143	; 0x7f7f7f7f
 8004ee6:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
  RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8004eea:	0c1a      	lsrs	r2, r3, #16
 8004eec:	f002 073f 	and.w	r7, r2, #63	; 0x3f
 8004ef0:	700f      	strb	r7, [r1, #0]
  RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8004ef2:	f3c3 2606 	ubfx	r6, r3, #8, #7
 8004ef6:	704e      	strb	r6, [r1, #1]
  RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8004ef8:	f003 047f 	and.w	r4, r3, #127	; 0x7f
 8004efc:	708c      	strb	r4, [r1, #2]
  RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
 8004efe:	f002 0240 	and.w	r2, r2, #64	; 0x40
 8004f02:	70ca      	strb	r2, [r1, #3]
  if (RTC_Format == RTC_Format_BIN)
 8004f04:	b960      	cbnz	r0, 8004f20 <RTC_GetTime+0x44>
 8004f06:	460d      	mov	r5, r1
    RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
 8004f08:	4638      	mov	r0, r7
 8004f0a:	f7ff fe69 	bl	8004be0 <RTC_Bcd2ToByte>
 8004f0e:	7028      	strb	r0, [r5, #0]
    RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
 8004f10:	4630      	mov	r0, r6
 8004f12:	f7ff fe65 	bl	8004be0 <RTC_Bcd2ToByte>
 8004f16:	7068      	strb	r0, [r5, #1]
    RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
 8004f18:	4620      	mov	r0, r4
 8004f1a:	f7ff fe61 	bl	8004be0 <RTC_Bcd2ToByte>
 8004f1e:	70a8      	strb	r0, [r5, #2]
 8004f20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004f22:	bf00      	nop
 8004f24:	40002800 	.word	0x40002800

08004f28 <RTC_GetSubSecond>:
  tmpreg = (uint32_t)(RTC->SSR);
 8004f28:	4b01      	ldr	r3, [pc, #4]	; (8004f30 <RTC_GetSubSecond+0x8>)
 8004f2a:	6a98      	ldr	r0, [r3, #40]	; 0x28
  (void) (RTC->DR);
 8004f2c:	685b      	ldr	r3, [r3, #4]
}
 8004f2e:	4770      	bx	lr
 8004f30:	40002800 	.word	0x40002800

08004f34 <RTC_SetDate>:
{
 8004f34:	b538      	push	{r3, r4, r5, lr}
 8004f36:	460d      	mov	r5, r1
  if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
 8004f38:	4602      	mov	r2, r0
 8004f3a:	b938      	cbnz	r0, 8004f4c <RTC_SetDate+0x18>
 8004f3c:	784b      	ldrb	r3, [r1, #1]
 8004f3e:	f013 0f10 	tst.w	r3, #16
 8004f42:	d003      	beq.n	8004f4c <RTC_SetDate+0x18>
    RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
 8004f44:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 8004f48:	330a      	adds	r3, #10
 8004f4a:	704b      	strb	r3, [r1, #1]
  if (RTC_Format != RTC_Format_BIN)
 8004f4c:	b1ba      	cbz	r2, 8004f7e <RTC_SetDate+0x4a>
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8004f4e:	78ec      	ldrb	r4, [r5, #3]
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8004f50:	7868      	ldrb	r0, [r5, #1]
 8004f52:	0200      	lsls	r0, r0, #8
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8004f54:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
              ((uint32_t)RTC_DateStruct->RTC_Date) | \
 8004f58:	78ac      	ldrb	r4, [r5, #2]
              (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
 8004f5a:	4320      	orrs	r0, r4
              (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
 8004f5c:	782c      	ldrb	r4, [r5, #0]
    tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
 8004f5e:	ea40 3444 	orr.w	r4, r0, r4, lsl #13
  RTC->WPR = 0xCA;
 8004f62:	4b1a      	ldr	r3, [pc, #104]	; (8004fcc <RTC_SetDate+0x98>)
 8004f64:	22ca      	movs	r2, #202	; 0xca
 8004f66:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8004f68:	2253      	movs	r2, #83	; 0x53
 8004f6a:	625a      	str	r2, [r3, #36]	; 0x24
  if (RTC_EnterInitMode() == ERROR)
 8004f6c:	f7ff fe56 	bl	8004c1c <RTC_EnterInitMode>
 8004f70:	4603      	mov	r3, r0
 8004f72:	b9a8      	cbnz	r0, 8004fa0 <RTC_SetDate+0x6c>
  RTC->WPR = 0xFF;   
 8004f74:	21ff      	movs	r1, #255	; 0xff
 8004f76:	4a15      	ldr	r2, [pc, #84]	; (8004fcc <RTC_SetDate+0x98>)
 8004f78:	6251      	str	r1, [r2, #36]	; 0x24
}
 8004f7a:	4618      	mov	r0, r3
 8004f7c:	bd38      	pop	{r3, r4, r5, pc}
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8004f7e:	78e8      	ldrb	r0, [r5, #3]
 8004f80:	f7ff fe22 	bl	8004bc8 <RTC_ByteToBcd2>
 8004f84:	0404      	lsls	r4, r0, #16
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 8004f86:	7868      	ldrb	r0, [r5, #1]
 8004f88:	f7ff fe1e 	bl	8004bc8 <RTC_ByteToBcd2>
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8004f8c:	ea44 2400 	orr.w	r4, r4, r0, lsl #8
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
 8004f90:	78a8      	ldrb	r0, [r5, #2]
 8004f92:	f7ff fe19 	bl	8004bc8 <RTC_ByteToBcd2>
              ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
 8004f96:	4320      	orrs	r0, r4
              ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
 8004f98:	782c      	ldrb	r4, [r5, #0]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
 8004f9a:	ea40 3444 	orr.w	r4, r0, r4, lsl #13
 8004f9e:	e7e0      	b.n	8004f62 <RTC_SetDate+0x2e>
    RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
 8004fa0:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
 8004fa4:	f020 00c0 	bic.w	r0, r0, #192	; 0xc0
 8004fa8:	4c08      	ldr	r4, [pc, #32]	; (8004fcc <RTC_SetDate+0x98>)
 8004faa:	6060      	str	r0, [r4, #4]
    RTC_ExitInitMode(); 
 8004fac:	f7ff fe5e 	bl	8004c6c <RTC_ExitInitMode>
    if ((RTC->CR & RTC_CR_BYPSHAD) == RESET)
 8004fb0:	68a3      	ldr	r3, [r4, #8]
 8004fb2:	f013 0f20 	tst.w	r3, #32
 8004fb6:	d001      	beq.n	8004fbc <RTC_SetDate+0x88>
      status = SUCCESS;
 8004fb8:	2301      	movs	r3, #1
 8004fba:	e7db      	b.n	8004f74 <RTC_SetDate+0x40>
    if(RTC_WaitForSynchro() == ERROR)
 8004fbc:	f7ff fe84 	bl	8004cc8 <RTC_WaitForSynchro>
 8004fc0:	4603      	mov	r3, r0
 8004fc2:	2800      	cmp	r0, #0
 8004fc4:	d0d6      	beq.n	8004f74 <RTC_SetDate+0x40>
      status = SUCCESS;
 8004fc6:	2301      	movs	r3, #1
 8004fc8:	e7d4      	b.n	8004f74 <RTC_SetDate+0x40>
 8004fca:	bf00      	nop
 8004fcc:	40002800 	.word	0x40002800

08004fd0 <RTC_DateStructInit>:
  RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
 8004fd0:	2301      	movs	r3, #1
 8004fd2:	7003      	strb	r3, [r0, #0]
  RTC_DateStruct->RTC_Date = 1;
 8004fd4:	7083      	strb	r3, [r0, #2]
  RTC_DateStruct->RTC_Month = RTC_Month_January;
 8004fd6:	7043      	strb	r3, [r0, #1]
  RTC_DateStruct->RTC_Year = 0;
 8004fd8:	2300      	movs	r3, #0
 8004fda:	70c3      	strb	r3, [r0, #3]
 8004fdc:	4770      	bx	lr

08004fde <RTC_GetDate>:
{
 8004fde:	b570      	push	{r4, r5, r6, lr}
  tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
 8004fe0:	4b0f      	ldr	r3, [pc, #60]	; (8005020 <RTC_GetDate+0x42>)
 8004fe2:	685b      	ldr	r3, [r3, #4]
 8004fe4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8004fe8:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
  RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8004fec:	0c1a      	lsrs	r2, r3, #16
 8004fee:	70ca      	strb	r2, [r1, #3]
  RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8004ff0:	f3c3 2604 	ubfx	r6, r3, #8, #5
 8004ff4:	704e      	strb	r6, [r1, #1]
  RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
 8004ff6:	f003 053f 	and.w	r5, r3, #63	; 0x3f
 8004ffa:	708d      	strb	r5, [r1, #2]
  RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
 8004ffc:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8005000:	700b      	strb	r3, [r1, #0]
  if (RTC_Format == RTC_Format_BIN)
 8005002:	b960      	cbnz	r0, 800501e <RTC_GetDate+0x40>
 8005004:	460c      	mov	r4, r1
    RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
 8005006:	4610      	mov	r0, r2
 8005008:	f7ff fdea 	bl	8004be0 <RTC_Bcd2ToByte>
 800500c:	70e0      	strb	r0, [r4, #3]
    RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
 800500e:	4630      	mov	r0, r6
 8005010:	f7ff fde6 	bl	8004be0 <RTC_Bcd2ToByte>
 8005014:	7060      	strb	r0, [r4, #1]
    RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
 8005016:	4628      	mov	r0, r5
 8005018:	f7ff fde2 	bl	8004be0 <RTC_Bcd2ToByte>
 800501c:	70a0      	strb	r0, [r4, #2]
 800501e:	bd70      	pop	{r4, r5, r6, pc}
 8005020:	40002800 	.word	0x40002800

08005024 <RTC_SetAlarm>:
{
 8005024:	b570      	push	{r4, r5, r6, lr}
 8005026:	460d      	mov	r5, r1
 8005028:	4616      	mov	r6, r2
  if (RTC_Format == RTC_Format_BIN)
 800502a:	4603      	mov	r3, r0
 800502c:	bb30      	cbnz	r0, 800507c <RTC_SetAlarm+0x58>
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 800502e:	4a25      	ldr	r2, [pc, #148]	; (80050c4 <RTC_SetAlarm+0xa0>)
 8005030:	6892      	ldr	r2, [r2, #8]
 8005032:	f012 0f40 	tst.w	r2, #64	; 0x40
 8005036:	d101      	bne.n	800503c <RTC_SetAlarm+0x18>
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 8005038:	2200      	movs	r2, #0
 800503a:	70f2      	strb	r2, [r6, #3]
  if (RTC_Format != RTC_Format_BIN)
 800503c:	b333      	cbz	r3, 800508c <RTC_SetAlarm+0x68>
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 800503e:	7833      	ldrb	r3, [r6, #0]
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8005040:	7870      	ldrb	r0, [r6, #1]
 8005042:	0200      	lsls	r0, r0, #8
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 8005044:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 8005048:	78b3      	ldrb	r3, [r6, #2]
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 800504a:	4318      	orrs	r0, r3
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 800504c:	78f3      	ldrb	r3, [r6, #3]
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
 800504e:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 8005052:	7b33      	ldrb	r3, [r6, #12]
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 8005054:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 8005058:	68b3      	ldr	r3, [r6, #8]
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 800505a:	4318      	orrs	r0, r3
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 800505c:	6873      	ldr	r3, [r6, #4]
    tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 800505e:	4318      	orrs	r0, r3
  RTC->WPR = 0xCA;
 8005060:	4b18      	ldr	r3, [pc, #96]	; (80050c4 <RTC_SetAlarm+0xa0>)
 8005062:	22ca      	movs	r2, #202	; 0xca
 8005064:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8005066:	2253      	movs	r2, #83	; 0x53
 8005068:	625a      	str	r2, [r3, #36]	; 0x24
  if (RTC_Alarm == RTC_Alarm_A)
 800506a:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 800506e:	d027      	beq.n	80050c0 <RTC_SetAlarm+0x9c>
    RTC->ALRMBR = (uint32_t)tmpreg;
 8005070:	4b14      	ldr	r3, [pc, #80]	; (80050c4 <RTC_SetAlarm+0xa0>)
 8005072:	6218      	str	r0, [r3, #32]
  RTC->WPR = 0xFF;   
 8005074:	22ff      	movs	r2, #255	; 0xff
 8005076:	4b13      	ldr	r3, [pc, #76]	; (80050c4 <RTC_SetAlarm+0xa0>)
 8005078:	625a      	str	r2, [r3, #36]	; 0x24
 800507a:	bd70      	pop	{r4, r5, r6, pc}
    if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
 800507c:	4a11      	ldr	r2, [pc, #68]	; (80050c4 <RTC_SetAlarm+0xa0>)
 800507e:	6892      	ldr	r2, [r2, #8]
 8005080:	f012 0f40 	tst.w	r2, #64	; 0x40
 8005084:	d1da      	bne.n	800503c <RTC_SetAlarm+0x18>
      RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
 8005086:	2200      	movs	r2, #0
 8005088:	70f2      	strb	r2, [r6, #3]
 800508a:	e7d7      	b.n	800503c <RTC_SetAlarm+0x18>
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 800508c:	7830      	ldrb	r0, [r6, #0]
 800508e:	f7ff fd9b 	bl	8004bc8 <RTC_ByteToBcd2>
 8005092:	0404      	lsls	r4, r0, #16
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 8005094:	7870      	ldrb	r0, [r6, #1]
 8005096:	f7ff fd97 	bl	8004bc8 <RTC_ByteToBcd2>
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 800509a:	ea44 2400 	orr.w	r4, r4, r0, lsl #8
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 800509e:	78b0      	ldrb	r0, [r6, #2]
 80050a0:	f7ff fd92 	bl	8004bc8 <RTC_ByteToBcd2>
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
 80050a4:	4304      	orrs	r4, r0
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 80050a6:	78f0      	ldrb	r0, [r6, #3]
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
 80050a8:	ea44 4400 	orr.w	r4, r4, r0, lsl #16
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 80050ac:	7b30      	ldrb	r0, [r6, #12]
 80050ae:	f7ff fd8b 	bl	8004bc8 <RTC_ByteToBcd2>
              ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
 80050b2:	ea44 6000 	orr.w	r0, r4, r0, lsl #24
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
 80050b6:	68b4      	ldr	r4, [r6, #8]
              ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
 80050b8:	4320      	orrs	r0, r4
              ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
 80050ba:	6873      	ldr	r3, [r6, #4]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
 80050bc:	4318      	orrs	r0, r3
 80050be:	e7cf      	b.n	8005060 <RTC_SetAlarm+0x3c>
    RTC->ALRMAR = (uint32_t)tmpreg;
 80050c0:	61d8      	str	r0, [r3, #28]
 80050c2:	e7d7      	b.n	8005074 <RTC_SetAlarm+0x50>
 80050c4:	40002800 	.word	0x40002800

080050c8 <RTC_AlarmStructInit>:
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
 80050c8:	2300      	movs	r3, #0
 80050ca:	70c3      	strb	r3, [r0, #3]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
 80050cc:	7003      	strb	r3, [r0, #0]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
 80050ce:	7043      	strb	r3, [r0, #1]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
 80050d0:	7083      	strb	r3, [r0, #2]
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
 80050d2:	6083      	str	r3, [r0, #8]
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
 80050d4:	2201      	movs	r2, #1
 80050d6:	7302      	strb	r2, [r0, #12]
  RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
 80050d8:	6043      	str	r3, [r0, #4]
 80050da:	4770      	bx	lr

080050dc <RTC_GetAlarm>:
{
 80050dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (RTC_Alarm == RTC_Alarm_A)
 80050de:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 80050e2:	d02c      	beq.n	800513e <RTC_GetAlarm+0x62>
    tmpreg = (uint32_t)(RTC->ALRMBR);
 80050e4:	4b17      	ldr	r3, [pc, #92]	; (8005144 <RTC_GetAlarm+0x68>)
 80050e6:	6a1b      	ldr	r3, [r3, #32]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
 80050e8:	f3c3 4107 	ubfx	r1, r3, #16, #8
 80050ec:	f001 0e3f 	and.w	lr, r1, #63	; 0x3f
 80050f0:	f882 e000 	strb.w	lr, [r2]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
 80050f4:	f3c3 2606 	ubfx	r6, r3, #8, #7
 80050f8:	7056      	strb	r6, [r2, #1]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
 80050fa:	f003 057f 	and.w	r5, r3, #127	; 0x7f
 80050fe:	7095      	strb	r5, [r2, #2]
  RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
 8005100:	f001 0140 	and.w	r1, r1, #64	; 0x40
 8005104:	70d1      	strb	r1, [r2, #3]
  RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
 8005106:	f3c3 6705 	ubfx	r7, r3, #24, #6
 800510a:	7317      	strb	r7, [r2, #12]
  RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
 800510c:	f003 4180 	and.w	r1, r3, #1073741824	; 0x40000000
 8005110:	6091      	str	r1, [r2, #8]
  RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
 8005112:	f003 3380 	and.w	r3, r3, #2155905152	; 0x80808080
 8005116:	6053      	str	r3, [r2, #4]
  if (RTC_Format == RTC_Format_BIN)
 8005118:	b980      	cbnz	r0, 800513c <RTC_GetAlarm+0x60>
 800511a:	4614      	mov	r4, r2
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 800511c:	4670      	mov	r0, lr
 800511e:	f7ff fd5f 	bl	8004be0 <RTC_Bcd2ToByte>
 8005122:	7020      	strb	r0, [r4, #0]
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 8005124:	4630      	mov	r0, r6
 8005126:	f7ff fd5b 	bl	8004be0 <RTC_Bcd2ToByte>
 800512a:	7060      	strb	r0, [r4, #1]
    RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
 800512c:	4628      	mov	r0, r5
 800512e:	f7ff fd57 	bl	8004be0 <RTC_Bcd2ToByte>
 8005132:	70a0      	strb	r0, [r4, #2]
    RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
 8005134:	4638      	mov	r0, r7
 8005136:	f7ff fd53 	bl	8004be0 <RTC_Bcd2ToByte>
 800513a:	7320      	strb	r0, [r4, #12]
 800513c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmpreg = (uint32_t)(RTC->ALRMAR);
 800513e:	4b01      	ldr	r3, [pc, #4]	; (8005144 <RTC_GetAlarm+0x68>)
 8005140:	69db      	ldr	r3, [r3, #28]
 8005142:	e7d1      	b.n	80050e8 <RTC_GetAlarm+0xc>
 8005144:	40002800 	.word	0x40002800

08005148 <RTC_AlarmCmd>:
{
 8005148:	b082      	sub	sp, #8
  __IO uint32_t alarmcounter = 0x00;
 800514a:	2300      	movs	r3, #0
 800514c:	9301      	str	r3, [sp, #4]
  RTC->WPR = 0xCA;
 800514e:	4b15      	ldr	r3, [pc, #84]	; (80051a4 <RTC_AlarmCmd+0x5c>)
 8005150:	22ca      	movs	r2, #202	; 0xca
 8005152:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8005154:	2253      	movs	r2, #83	; 0x53
 8005156:	625a      	str	r2, [r3, #36]	; 0x24
  if (NewState != DISABLE)
 8005158:	b9b9      	cbnz	r1, 800518a <RTC_AlarmCmd+0x42>
    RTC->CR &= (uint32_t)~RTC_Alarm;
 800515a:	4a12      	ldr	r2, [pc, #72]	; (80051a4 <RTC_AlarmCmd+0x5c>)
 800515c:	6893      	ldr	r3, [r2, #8]
 800515e:	ea23 0300 	bic.w	r3, r3, r0
 8005162:	6093      	str	r3, [r2, #8]
      alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
 8005164:	4b0f      	ldr	r3, [pc, #60]	; (80051a4 <RTC_AlarmCmd+0x5c>)
 8005166:	68da      	ldr	r2, [r3, #12]
 8005168:	0a01      	lsrs	r1, r0, #8
 800516a:	400a      	ands	r2, r1
      alarmcounter++;  
 800516c:	9b01      	ldr	r3, [sp, #4]
 800516e:	3301      	adds	r3, #1
 8005170:	9301      	str	r3, [sp, #4]
    } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
 8005172:	9b01      	ldr	r3, [sp, #4]
 8005174:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8005178:	d001      	beq.n	800517e <RTC_AlarmCmd+0x36>
 800517a:	2a00      	cmp	r2, #0
 800517c:	d0f2      	beq.n	8005164 <RTC_AlarmCmd+0x1c>
    if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
 800517e:	4b09      	ldr	r3, [pc, #36]	; (80051a4 <RTC_AlarmCmd+0x5c>)
 8005180:	68db      	ldr	r3, [r3, #12]
 8005182:	4219      	tst	r1, r3
 8005184:	d00b      	beq.n	800519e <RTC_AlarmCmd+0x56>
      status = SUCCESS;
 8005186:	2001      	movs	r0, #1
 8005188:	e004      	b.n	8005194 <RTC_AlarmCmd+0x4c>
    RTC->CR |= (uint32_t)RTC_Alarm;
 800518a:	461a      	mov	r2, r3
 800518c:	689b      	ldr	r3, [r3, #8]
 800518e:	4318      	orrs	r0, r3
 8005190:	6090      	str	r0, [r2, #8]
    status = SUCCESS;    
 8005192:	2001      	movs	r0, #1
  RTC->WPR = 0xFF; 
 8005194:	22ff      	movs	r2, #255	; 0xff
 8005196:	4b03      	ldr	r3, [pc, #12]	; (80051a4 <RTC_AlarmCmd+0x5c>)
 8005198:	625a      	str	r2, [r3, #36]	; 0x24
}
 800519a:	b002      	add	sp, #8
 800519c:	4770      	bx	lr
      status = ERROR;
 800519e:	2000      	movs	r0, #0
 80051a0:	e7f8      	b.n	8005194 <RTC_AlarmCmd+0x4c>
 80051a2:	bf00      	nop
 80051a4:	40002800 	.word	0x40002800

080051a8 <RTC_AlarmSubSecondConfig>:
{
 80051a8:	b410      	push	{r4}
  RTC->WPR = 0xCA;
 80051aa:	4b09      	ldr	r3, [pc, #36]	; (80051d0 <RTC_AlarmSubSecondConfig+0x28>)
 80051ac:	24ca      	movs	r4, #202	; 0xca
 80051ae:	625c      	str	r4, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80051b0:	2453      	movs	r4, #83	; 0x53
 80051b2:	625c      	str	r4, [r3, #36]	; 0x24
  tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
 80051b4:	430a      	orrs	r2, r1
  if (RTC_Alarm == RTC_Alarm_A)
 80051b6:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 80051ba:	d007      	beq.n	80051cc <RTC_AlarmSubSecondConfig+0x24>
    RTC->ALRMBSSR = tmpreg;
 80051bc:	4b04      	ldr	r3, [pc, #16]	; (80051d0 <RTC_AlarmSubSecondConfig+0x28>)
 80051be:	649a      	str	r2, [r3, #72]	; 0x48
  RTC->WPR = 0xFF;
 80051c0:	22ff      	movs	r2, #255	; 0xff
 80051c2:	4b03      	ldr	r3, [pc, #12]	; (80051d0 <RTC_AlarmSubSecondConfig+0x28>)
 80051c4:	625a      	str	r2, [r3, #36]	; 0x24
}
 80051c6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80051ca:	4770      	bx	lr
    RTC->ALRMASSR = tmpreg;
 80051cc:	645a      	str	r2, [r3, #68]	; 0x44
 80051ce:	e7f7      	b.n	80051c0 <RTC_AlarmSubSecondConfig+0x18>
 80051d0:	40002800 	.word	0x40002800

080051d4 <RTC_GetAlarmSubSecond>:
  if (RTC_Alarm == RTC_Alarm_A)
 80051d4:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 80051d8:	d004      	beq.n	80051e4 <RTC_GetAlarmSubSecond+0x10>
    tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
 80051da:	4b05      	ldr	r3, [pc, #20]	; (80051f0 <RTC_GetAlarmSubSecond+0x1c>)
 80051dc:	6c98      	ldr	r0, [r3, #72]	; 0x48
 80051de:	f3c0 000e 	ubfx	r0, r0, #0, #15
}
 80051e2:	4770      	bx	lr
    tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
 80051e4:	4b02      	ldr	r3, [pc, #8]	; (80051f0 <RTC_GetAlarmSubSecond+0x1c>)
 80051e6:	6c58      	ldr	r0, [r3, #68]	; 0x44
 80051e8:	f3c0 000e 	ubfx	r0, r0, #0, #15
 80051ec:	4770      	bx	lr
 80051ee:	bf00      	nop
 80051f0:	40002800 	.word	0x40002800

080051f4 <RTC_WakeUpClockConfig>:
  RTC->WPR = 0xCA;
 80051f4:	4b07      	ldr	r3, [pc, #28]	; (8005214 <RTC_WakeUpClockConfig+0x20>)
 80051f6:	22ca      	movs	r2, #202	; 0xca
 80051f8:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80051fa:	2253      	movs	r2, #83	; 0x53
 80051fc:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
 80051fe:	689a      	ldr	r2, [r3, #8]
 8005200:	f022 0207 	bic.w	r2, r2, #7
 8005204:	609a      	str	r2, [r3, #8]
  RTC->CR |= (uint32_t)RTC_WakeUpClock;
 8005206:	689a      	ldr	r2, [r3, #8]
 8005208:	4310      	orrs	r0, r2
 800520a:	6098      	str	r0, [r3, #8]
  RTC->WPR = 0xFF; 
 800520c:	22ff      	movs	r2, #255	; 0xff
 800520e:	625a      	str	r2, [r3, #36]	; 0x24
 8005210:	4770      	bx	lr
 8005212:	bf00      	nop
 8005214:	40002800 	.word	0x40002800

08005218 <RTC_SetWakeUpCounter>:
  RTC->WPR = 0xCA;
 8005218:	4b04      	ldr	r3, [pc, #16]	; (800522c <RTC_SetWakeUpCounter+0x14>)
 800521a:	22ca      	movs	r2, #202	; 0xca
 800521c:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800521e:	2253      	movs	r2, #83	; 0x53
 8005220:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
 8005222:	6158      	str	r0, [r3, #20]
  RTC->WPR = 0xFF; 
 8005224:	22ff      	movs	r2, #255	; 0xff
 8005226:	625a      	str	r2, [r3, #36]	; 0x24
 8005228:	4770      	bx	lr
 800522a:	bf00      	nop
 800522c:	40002800 	.word	0x40002800

08005230 <RTC_GetWakeUpCounter>:
  return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
 8005230:	4b01      	ldr	r3, [pc, #4]	; (8005238 <RTC_GetWakeUpCounter+0x8>)
 8005232:	6958      	ldr	r0, [r3, #20]
}
 8005234:	b280      	uxth	r0, r0
 8005236:	4770      	bx	lr
 8005238:	40002800 	.word	0x40002800

0800523c <RTC_WakeUpCmd>:
{
 800523c:	b082      	sub	sp, #8
  __IO uint32_t wutcounter = 0x00;
 800523e:	2300      	movs	r3, #0
 8005240:	9301      	str	r3, [sp, #4]
  RTC->WPR = 0xCA;
 8005242:	4b16      	ldr	r3, [pc, #88]	; (800529c <RTC_WakeUpCmd+0x60>)
 8005244:	22ca      	movs	r2, #202	; 0xca
 8005246:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8005248:	2253      	movs	r2, #83	; 0x53
 800524a:	625a      	str	r2, [r3, #36]	; 0x24
  if (NewState != DISABLE)
 800524c:	b9c0      	cbnz	r0, 8005280 <RTC_WakeUpCmd+0x44>
    RTC->CR &= (uint32_t)~RTC_CR_WUTE;
 800524e:	4a13      	ldr	r2, [pc, #76]	; (800529c <RTC_WakeUpCmd+0x60>)
 8005250:	6893      	ldr	r3, [r2, #8]
 8005252:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8005256:	6093      	str	r3, [r2, #8]
      wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
 8005258:	4b10      	ldr	r3, [pc, #64]	; (800529c <RTC_WakeUpCmd+0x60>)
 800525a:	68da      	ldr	r2, [r3, #12]
 800525c:	f002 0204 	and.w	r2, r2, #4
      wutcounter++;  
 8005260:	9b01      	ldr	r3, [sp, #4]
 8005262:	3301      	adds	r3, #1
 8005264:	9301      	str	r3, [sp, #4]
    } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
 8005266:	9b01      	ldr	r3, [sp, #4]
 8005268:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800526c:	d001      	beq.n	8005272 <RTC_WakeUpCmd+0x36>
 800526e:	2a00      	cmp	r2, #0
 8005270:	d0f2      	beq.n	8005258 <RTC_WakeUpCmd+0x1c>
    if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
 8005272:	4b0a      	ldr	r3, [pc, #40]	; (800529c <RTC_WakeUpCmd+0x60>)
 8005274:	68db      	ldr	r3, [r3, #12]
 8005276:	f013 0f04 	tst.w	r3, #4
 800527a:	d00c      	beq.n	8005296 <RTC_WakeUpCmd+0x5a>
      status = SUCCESS;
 800527c:	2001      	movs	r0, #1
 800527e:	e005      	b.n	800528c <RTC_WakeUpCmd+0x50>
    RTC->CR |= (uint32_t)RTC_CR_WUTE;
 8005280:	461a      	mov	r2, r3
 8005282:	689b      	ldr	r3, [r3, #8]
 8005284:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8005288:	6093      	str	r3, [r2, #8]
    status = SUCCESS;    
 800528a:	2001      	movs	r0, #1
  RTC->WPR = 0xFF; 
 800528c:	22ff      	movs	r2, #255	; 0xff
 800528e:	4b03      	ldr	r3, [pc, #12]	; (800529c <RTC_WakeUpCmd+0x60>)
 8005290:	625a      	str	r2, [r3, #36]	; 0x24
}
 8005292:	b002      	add	sp, #8
 8005294:	4770      	bx	lr
      status = ERROR;
 8005296:	2000      	movs	r0, #0
 8005298:	e7f8      	b.n	800528c <RTC_WakeUpCmd+0x50>
 800529a:	bf00      	nop
 800529c:	40002800 	.word	0x40002800

080052a0 <RTC_DayLightSavingConfig>:
  RTC->WPR = 0xCA;
 80052a0:	4b07      	ldr	r3, [pc, #28]	; (80052c0 <RTC_DayLightSavingConfig+0x20>)
 80052a2:	22ca      	movs	r2, #202	; 0xca
 80052a4:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80052a6:	2253      	movs	r2, #83	; 0x53
 80052a8:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->CR &= (uint32_t)~(RTC_CR_BCK);
 80052aa:	689a      	ldr	r2, [r3, #8]
 80052ac:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80052b0:	609a      	str	r2, [r3, #8]
  RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
 80052b2:	689a      	ldr	r2, [r3, #8]
 80052b4:	4301      	orrs	r1, r0
 80052b6:	430a      	orrs	r2, r1
 80052b8:	609a      	str	r2, [r3, #8]
  RTC->WPR = 0xFF; 
 80052ba:	22ff      	movs	r2, #255	; 0xff
 80052bc:	625a      	str	r2, [r3, #36]	; 0x24
 80052be:	4770      	bx	lr
 80052c0:	40002800 	.word	0x40002800

080052c4 <RTC_GetStoreOperation>:
  return (RTC->CR & RTC_CR_BCK);
 80052c4:	4b02      	ldr	r3, [pc, #8]	; (80052d0 <RTC_GetStoreOperation+0xc>)
 80052c6:	6898      	ldr	r0, [r3, #8]
}
 80052c8:	f400 2080 	and.w	r0, r0, #262144	; 0x40000
 80052cc:	4770      	bx	lr
 80052ce:	bf00      	nop
 80052d0:	40002800 	.word	0x40002800

080052d4 <RTC_OutputConfig>:
  RTC->WPR = 0xCA;
 80052d4:	4b07      	ldr	r3, [pc, #28]	; (80052f4 <RTC_OutputConfig+0x20>)
 80052d6:	22ca      	movs	r2, #202	; 0xca
 80052d8:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80052da:	2253      	movs	r2, #83	; 0x53
 80052dc:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
 80052de:	689a      	ldr	r2, [r3, #8]
 80052e0:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
 80052e4:	609a      	str	r2, [r3, #8]
  RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
 80052e6:	689a      	ldr	r2, [r3, #8]
 80052e8:	4301      	orrs	r1, r0
 80052ea:	430a      	orrs	r2, r1
 80052ec:	609a      	str	r2, [r3, #8]
  RTC->WPR = 0xFF; 
 80052ee:	22ff      	movs	r2, #255	; 0xff
 80052f0:	625a      	str	r2, [r3, #36]	; 0x24
 80052f2:	4770      	bx	lr
 80052f4:	40002800 	.word	0x40002800

080052f8 <RTC_CoarseCalibConfig>:
{
 80052f8:	b538      	push	{r3, r4, r5, lr}
 80052fa:	4604      	mov	r4, r0
 80052fc:	460d      	mov	r5, r1
  RTC->WPR = 0xCA;
 80052fe:	4b0a      	ldr	r3, [pc, #40]	; (8005328 <RTC_CoarseCalibConfig+0x30>)
 8005300:	22ca      	movs	r2, #202	; 0xca
 8005302:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8005304:	2253      	movs	r2, #83	; 0x53
 8005306:	625a      	str	r2, [r3, #36]	; 0x24
  if (RTC_EnterInitMode() == ERROR)
 8005308:	f7ff fc88 	bl	8004c1c <RTC_EnterInitMode>
 800530c:	4603      	mov	r3, r0
 800530e:	b920      	cbnz	r0, 800531a <RTC_CoarseCalibConfig+0x22>
  RTC->WPR = 0xFF; 
 8005310:	21ff      	movs	r1, #255	; 0xff
 8005312:	4a05      	ldr	r2, [pc, #20]	; (8005328 <RTC_CoarseCalibConfig+0x30>)
 8005314:	6251      	str	r1, [r2, #36]	; 0x24
}
 8005316:	4618      	mov	r0, r3
 8005318:	bd38      	pop	{r3, r4, r5, pc}
    RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
 800531a:	432c      	orrs	r4, r5
 800531c:	4b02      	ldr	r3, [pc, #8]	; (8005328 <RTC_CoarseCalibConfig+0x30>)
 800531e:	619c      	str	r4, [r3, #24]
    RTC_ExitInitMode();
 8005320:	f7ff fca4 	bl	8004c6c <RTC_ExitInitMode>
    status = SUCCESS;
 8005324:	2301      	movs	r3, #1
 8005326:	e7f3      	b.n	8005310 <RTC_CoarseCalibConfig+0x18>
 8005328:	40002800 	.word	0x40002800

0800532c <RTC_CoarseCalibCmd>:
{
 800532c:	b510      	push	{r4, lr}
 800532e:	4604      	mov	r4, r0
  RTC->WPR = 0xCA;
 8005330:	4b0e      	ldr	r3, [pc, #56]	; (800536c <RTC_CoarseCalibCmd+0x40>)
 8005332:	22ca      	movs	r2, #202	; 0xca
 8005334:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8005336:	2253      	movs	r2, #83	; 0x53
 8005338:	625a      	str	r2, [r3, #36]	; 0x24
  if (RTC_EnterInitMode() == ERROR)
 800533a:	f7ff fc6f 	bl	8004c1c <RTC_EnterInitMode>
 800533e:	4603      	mov	r3, r0
 8005340:	b140      	cbz	r0, 8005354 <RTC_CoarseCalibCmd+0x28>
    if (NewState != DISABLE)
 8005342:	b164      	cbz	r4, 800535e <RTC_CoarseCalibCmd+0x32>
      RTC->CR |= (uint32_t)RTC_CR_DCE;
 8005344:	4a09      	ldr	r2, [pc, #36]	; (800536c <RTC_CoarseCalibCmd+0x40>)
 8005346:	6893      	ldr	r3, [r2, #8]
 8005348:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800534c:	6093      	str	r3, [r2, #8]
    RTC_ExitInitMode();
 800534e:	f7ff fc8d 	bl	8004c6c <RTC_ExitInitMode>
    status = SUCCESS;
 8005352:	2301      	movs	r3, #1
  RTC->WPR = 0xFF; 
 8005354:	21ff      	movs	r1, #255	; 0xff
 8005356:	4a05      	ldr	r2, [pc, #20]	; (800536c <RTC_CoarseCalibCmd+0x40>)
 8005358:	6251      	str	r1, [r2, #36]	; 0x24
}
 800535a:	4618      	mov	r0, r3
 800535c:	bd10      	pop	{r4, pc}
      RTC->CR &= (uint32_t)~RTC_CR_DCE;
 800535e:	4a03      	ldr	r2, [pc, #12]	; (800536c <RTC_CoarseCalibCmd+0x40>)
 8005360:	6893      	ldr	r3, [r2, #8]
 8005362:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005366:	6093      	str	r3, [r2, #8]
 8005368:	e7f1      	b.n	800534e <RTC_CoarseCalibCmd+0x22>
 800536a:	bf00      	nop
 800536c:	40002800 	.word	0x40002800

08005370 <RTC_CalibOutputCmd>:
  RTC->WPR = 0xCA;
 8005370:	4b0a      	ldr	r3, [pc, #40]	; (800539c <RTC_CalibOutputCmd+0x2c>)
 8005372:	22ca      	movs	r2, #202	; 0xca
 8005374:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8005376:	2253      	movs	r2, #83	; 0x53
 8005378:	625a      	str	r2, [r3, #36]	; 0x24
  if (NewState != DISABLE)
 800537a:	b940      	cbnz	r0, 800538e <RTC_CalibOutputCmd+0x1e>
    RTC->CR &= (uint32_t)~RTC_CR_COE;
 800537c:	4a07      	ldr	r2, [pc, #28]	; (800539c <RTC_CalibOutputCmd+0x2c>)
 800537e:	6893      	ldr	r3, [r2, #8]
 8005380:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8005384:	6093      	str	r3, [r2, #8]
  RTC->WPR = 0xFF; 
 8005386:	22ff      	movs	r2, #255	; 0xff
 8005388:	4b04      	ldr	r3, [pc, #16]	; (800539c <RTC_CalibOutputCmd+0x2c>)
 800538a:	625a      	str	r2, [r3, #36]	; 0x24
 800538c:	4770      	bx	lr
    RTC->CR |= (uint32_t)RTC_CR_COE;
 800538e:	461a      	mov	r2, r3
 8005390:	689b      	ldr	r3, [r3, #8]
 8005392:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8005396:	6093      	str	r3, [r2, #8]
 8005398:	e7f5      	b.n	8005386 <RTC_CalibOutputCmd+0x16>
 800539a:	bf00      	nop
 800539c:	40002800 	.word	0x40002800

080053a0 <RTC_CalibOutputConfig>:
  RTC->WPR = 0xCA;
 80053a0:	4b07      	ldr	r3, [pc, #28]	; (80053c0 <RTC_CalibOutputConfig+0x20>)
 80053a2:	22ca      	movs	r2, #202	; 0xca
 80053a4:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80053a6:	2253      	movs	r2, #83	; 0x53
 80053a8:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
 80053aa:	689a      	ldr	r2, [r3, #8]
 80053ac:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 80053b0:	609a      	str	r2, [r3, #8]
  RTC->CR |= (uint32_t)RTC_CalibOutput;
 80053b2:	689a      	ldr	r2, [r3, #8]
 80053b4:	4310      	orrs	r0, r2
 80053b6:	6098      	str	r0, [r3, #8]
  RTC->WPR = 0xFF;
 80053b8:	22ff      	movs	r2, #255	; 0xff
 80053ba:	625a      	str	r2, [r3, #36]	; 0x24
 80053bc:	4770      	bx	lr
 80053be:	bf00      	nop
 80053c0:	40002800 	.word	0x40002800

080053c4 <RTC_SmoothCalibConfig>:
{
 80053c4:	b410      	push	{r4}
  RTC->WPR = 0xCA;
 80053c6:	4b13      	ldr	r3, [pc, #76]	; (8005414 <RTC_SmoothCalibConfig+0x50>)
 80053c8:	24ca      	movs	r4, #202	; 0xca
 80053ca:	625c      	str	r4, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 80053cc:	2453      	movs	r4, #83	; 0x53
 80053ce:	625c      	str	r4, [r3, #36]	; 0x24
  if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
 80053d0:	68db      	ldr	r3, [r3, #12]
 80053d2:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80053d6:	d119      	bne.n	800540c <RTC_SmoothCalibConfig+0x48>
  if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
 80053d8:	4b0e      	ldr	r3, [pc, #56]	; (8005414 <RTC_SmoothCalibConfig+0x50>)
 80053da:	68db      	ldr	r3, [r3, #12]
 80053dc:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 80053e0:	d116      	bne.n	8005410 <RTC_SmoothCalibConfig+0x4c>
    RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
 80053e2:	4308      	orrs	r0, r1
 80053e4:	4302      	orrs	r2, r0
 80053e6:	4b0b      	ldr	r3, [pc, #44]	; (8005414 <RTC_SmoothCalibConfig+0x50>)
 80053e8:	63da      	str	r2, [r3, #60]	; 0x3c
    status = SUCCESS;
 80053ea:	2001      	movs	r0, #1
  RTC->WPR = 0xFF;
 80053ec:	22ff      	movs	r2, #255	; 0xff
 80053ee:	4b09      	ldr	r3, [pc, #36]	; (8005414 <RTC_SmoothCalibConfig+0x50>)
 80053f0:	625a      	str	r2, [r3, #36]	; 0x24
}
 80053f2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80053f6:	4770      	bx	lr
      recalpfcount++;
 80053f8:	3301      	adds	r3, #1
    while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
 80053fa:	4c06      	ldr	r4, [pc, #24]	; (8005414 <RTC_SmoothCalibConfig+0x50>)
 80053fc:	68e4      	ldr	r4, [r4, #12]
 80053fe:	f414 3f80 	tst.w	r4, #65536	; 0x10000
 8005402:	d0e9      	beq.n	80053d8 <RTC_SmoothCalibConfig+0x14>
 8005404:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8005408:	d1f6      	bne.n	80053f8 <RTC_SmoothCalibConfig+0x34>
 800540a:	e7e5      	b.n	80053d8 <RTC_SmoothCalibConfig+0x14>
 800540c:	2300      	movs	r3, #0
 800540e:	e7f4      	b.n	80053fa <RTC_SmoothCalibConfig+0x36>
    status = ERROR;
 8005410:	2000      	movs	r0, #0
 8005412:	e7eb      	b.n	80053ec <RTC_SmoothCalibConfig+0x28>
 8005414:	40002800 	.word	0x40002800

08005418 <RTC_TimeStampCmd>:
  tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 8005418:	4b0a      	ldr	r3, [pc, #40]	; (8005444 <RTC_TimeStampCmd+0x2c>)
 800541a:	689b      	ldr	r3, [r3, #8]
 800541c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8005420:	f023 0308 	bic.w	r3, r3, #8
  if (NewState != DISABLE)
 8005424:	b949      	cbnz	r1, 800543a <RTC_TimeStampCmd+0x22>
    tmpreg |= (uint32_t)(RTC_TimeStampEdge);
 8005426:	4303      	orrs	r3, r0
  RTC->WPR = 0xCA;
 8005428:	4a06      	ldr	r2, [pc, #24]	; (8005444 <RTC_TimeStampCmd+0x2c>)
 800542a:	21ca      	movs	r1, #202	; 0xca
 800542c:	6251      	str	r1, [r2, #36]	; 0x24
  RTC->WPR = 0x53;
 800542e:	2153      	movs	r1, #83	; 0x53
 8005430:	6251      	str	r1, [r2, #36]	; 0x24
  RTC->CR = (uint32_t)tmpreg;
 8005432:	6093      	str	r3, [r2, #8]
  RTC->WPR = 0xFF; 
 8005434:	23ff      	movs	r3, #255	; 0xff
 8005436:	6253      	str	r3, [r2, #36]	; 0x24
 8005438:	4770      	bx	lr
    tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
 800543a:	4303      	orrs	r3, r0
 800543c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8005440:	e7f2      	b.n	8005428 <RTC_TimeStampCmd+0x10>
 8005442:	bf00      	nop
 8005444:	40002800 	.word	0x40002800

08005448 <RTC_GetTimeStamp>:
{
 8005448:	b570      	push	{r4, r5, r6, lr}
  tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
 800544a:	4b1d      	ldr	r3, [pc, #116]	; (80054c0 <RTC_GetTimeStamp+0x78>)
 800544c:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 800544e:	f004 347f 	and.w	r4, r4, #2139062143	; 0x7f7f7f7f
 8005452:	f024 44fe 	bic.w	r4, r4, #2130706432	; 0x7f000000
  tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
 8005456:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005458:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 800545c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
  RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8005460:	0c25      	lsrs	r5, r4, #16
 8005462:	f005 063f 	and.w	r6, r5, #63	; 0x3f
 8005466:	700e      	strb	r6, [r1, #0]
  RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
 8005468:	f3c4 2606 	ubfx	r6, r4, #8, #7
 800546c:	704e      	strb	r6, [r1, #1]
  RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
 800546e:	708c      	strb	r4, [r1, #2]
  RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
 8005470:	f005 0540 	and.w	r5, r5, #64	; 0x40
 8005474:	70cd      	strb	r5, [r1, #3]
  RTC_StampDateStruct->RTC_Year = 0;
 8005476:	2400      	movs	r4, #0
 8005478:	70d4      	strb	r4, [r2, #3]
  RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 800547a:	f3c3 2404 	ubfx	r4, r3, #8, #5
 800547e:	7054      	strb	r4, [r2, #1]
  RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
 8005480:	7093      	strb	r3, [r2, #2]
  RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
 8005482:	f3c3 3342 	ubfx	r3, r3, #13, #3
 8005486:	7013      	strb	r3, [r2, #0]
  if (RTC_Format == RTC_Format_BIN)
 8005488:	b9c8      	cbnz	r0, 80054be <RTC_GetTimeStamp+0x76>
 800548a:	4614      	mov	r4, r2
 800548c:	460d      	mov	r5, r1
    RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
 800548e:	7808      	ldrb	r0, [r1, #0]
 8005490:	f7ff fba6 	bl	8004be0 <RTC_Bcd2ToByte>
 8005494:	7028      	strb	r0, [r5, #0]
    RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
 8005496:	7868      	ldrb	r0, [r5, #1]
 8005498:	f7ff fba2 	bl	8004be0 <RTC_Bcd2ToByte>
 800549c:	7068      	strb	r0, [r5, #1]
    RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
 800549e:	78a8      	ldrb	r0, [r5, #2]
 80054a0:	f7ff fb9e 	bl	8004be0 <RTC_Bcd2ToByte>
 80054a4:	70a8      	strb	r0, [r5, #2]
    RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
 80054a6:	7860      	ldrb	r0, [r4, #1]
 80054a8:	f7ff fb9a 	bl	8004be0 <RTC_Bcd2ToByte>
 80054ac:	7060      	strb	r0, [r4, #1]
    RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
 80054ae:	78a0      	ldrb	r0, [r4, #2]
 80054b0:	f7ff fb96 	bl	8004be0 <RTC_Bcd2ToByte>
 80054b4:	70a0      	strb	r0, [r4, #2]
    RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
 80054b6:	7820      	ldrb	r0, [r4, #0]
 80054b8:	f7ff fb92 	bl	8004be0 <RTC_Bcd2ToByte>
 80054bc:	7020      	strb	r0, [r4, #0]
 80054be:	bd70      	pop	{r4, r5, r6, pc}
 80054c0:	40002800 	.word	0x40002800

080054c4 <RTC_GetTimeStampSubSecond>:
  return (uint32_t)(RTC->TSSSR);
 80054c4:	4b01      	ldr	r3, [pc, #4]	; (80054cc <RTC_GetTimeStampSubSecond+0x8>)
 80054c6:	6b98      	ldr	r0, [r3, #56]	; 0x38
}
 80054c8:	4770      	bx	lr
 80054ca:	bf00      	nop
 80054cc:	40002800 	.word	0x40002800

080054d0 <RTC_TamperTriggerConfig>:
  if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
 80054d0:	b129      	cbz	r1, 80054de <RTC_TamperTriggerConfig+0xe>
    RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
 80054d2:	4a06      	ldr	r2, [pc, #24]	; (80054ec <RTC_TamperTriggerConfig+0x1c>)
 80054d4:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80054d6:	ea43 0040 	orr.w	r0, r3, r0, lsl #1
 80054da:	6410      	str	r0, [r2, #64]	; 0x40
 80054dc:	4770      	bx	lr
    RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
 80054de:	4a03      	ldr	r2, [pc, #12]	; (80054ec <RTC_TamperTriggerConfig+0x1c>)
 80054e0:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80054e2:	ea23 0040 	bic.w	r0, r3, r0, lsl #1
 80054e6:	6410      	str	r0, [r2, #64]	; 0x40
 80054e8:	4770      	bx	lr
 80054ea:	bf00      	nop
 80054ec:	40002800 	.word	0x40002800

080054f0 <RTC_TamperCmd>:
  if (NewState != DISABLE)
 80054f0:	b929      	cbnz	r1, 80054fe <RTC_TamperCmd+0xe>
    RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
 80054f2:	4a05      	ldr	r2, [pc, #20]	; (8005508 <RTC_TamperCmd+0x18>)
 80054f4:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80054f6:	ea23 0000 	bic.w	r0, r3, r0
 80054fa:	6410      	str	r0, [r2, #64]	; 0x40
 80054fc:	4770      	bx	lr
    RTC->TAFCR |= (uint32_t)RTC_Tamper;
 80054fe:	4a02      	ldr	r2, [pc, #8]	; (8005508 <RTC_TamperCmd+0x18>)
 8005500:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8005502:	4318      	orrs	r0, r3
 8005504:	6410      	str	r0, [r2, #64]	; 0x40
 8005506:	4770      	bx	lr
 8005508:	40002800 	.word	0x40002800

0800550c <RTC_TamperFilterConfig>:
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
 800550c:	4b04      	ldr	r3, [pc, #16]	; (8005520 <RTC_TamperFilterConfig+0x14>)
 800550e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005510:	f422 52c0 	bic.w	r2, r2, #6144	; 0x1800
 8005514:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
 8005516:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005518:	4310      	orrs	r0, r2
 800551a:	6418      	str	r0, [r3, #64]	; 0x40
 800551c:	4770      	bx	lr
 800551e:	bf00      	nop
 8005520:	40002800 	.word	0x40002800

08005524 <RTC_TamperSamplingFreqConfig>:
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
 8005524:	4b04      	ldr	r3, [pc, #16]	; (8005538 <RTC_TamperSamplingFreqConfig+0x14>)
 8005526:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005528:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 800552c:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
 800552e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005530:	4310      	orrs	r0, r2
 8005532:	6418      	str	r0, [r3, #64]	; 0x40
 8005534:	4770      	bx	lr
 8005536:	bf00      	nop
 8005538:	40002800 	.word	0x40002800

0800553c <RTC_TamperPinsPrechargeDuration>:
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
 800553c:	4b04      	ldr	r3, [pc, #16]	; (8005550 <RTC_TamperPinsPrechargeDuration+0x14>)
 800553e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005540:	f422 42c0 	bic.w	r2, r2, #24576	; 0x6000
 8005544:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
 8005546:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005548:	4310      	orrs	r0, r2
 800554a:	6418      	str	r0, [r3, #64]	; 0x40
 800554c:	4770      	bx	lr
 800554e:	bf00      	nop
 8005550:	40002800 	.word	0x40002800

08005554 <RTC_TimeStampOnTamperDetectionCmd>:
  if (NewState != DISABLE)
 8005554:	b928      	cbnz	r0, 8005562 <RTC_TimeStampOnTamperDetectionCmd+0xe>
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
 8005556:	4a06      	ldr	r2, [pc, #24]	; (8005570 <RTC_TimeStampOnTamperDetectionCmd+0x1c>)
 8005558:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800555a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800555e:	6413      	str	r3, [r2, #64]	; 0x40
 8005560:	4770      	bx	lr
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
 8005562:	4a03      	ldr	r2, [pc, #12]	; (8005570 <RTC_TimeStampOnTamperDetectionCmd+0x1c>)
 8005564:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8005566:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800556a:	6413      	str	r3, [r2, #64]	; 0x40
 800556c:	4770      	bx	lr
 800556e:	bf00      	nop
 8005570:	40002800 	.word	0x40002800

08005574 <RTC_TamperPullUpCmd>:
 if (NewState != DISABLE)
 8005574:	b928      	cbnz	r0, 8005582 <RTC_TamperPullUpCmd+0xe>
    RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
 8005576:	4a06      	ldr	r2, [pc, #24]	; (8005590 <RTC_TamperPullUpCmd+0x1c>)
 8005578:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800557a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800557e:	6413      	str	r3, [r2, #64]	; 0x40
 8005580:	4770      	bx	lr
    RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
 8005582:	4a03      	ldr	r2, [pc, #12]	; (8005590 <RTC_TamperPullUpCmd+0x1c>)
 8005584:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8005586:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800558a:	6413      	str	r3, [r2, #64]	; 0x40
 800558c:	4770      	bx	lr
 800558e:	bf00      	nop
 8005590:	40002800 	.word	0x40002800

08005594 <RTC_WriteBackupRegister>:
{
 8005594:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8005596:	2300      	movs	r3, #0
 8005598:	9301      	str	r3, [sp, #4]
  tmp = RTC_BASE + 0x50;
 800559a:	4b05      	ldr	r3, [pc, #20]	; (80055b0 <RTC_WriteBackupRegister+0x1c>)
 800559c:	9301      	str	r3, [sp, #4]
  tmp += (RTC_BKP_DR * 4);
 800559e:	9b01      	ldr	r3, [sp, #4]
 80055a0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80055a4:	9001      	str	r0, [sp, #4]
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 80055a6:	9b01      	ldr	r3, [sp, #4]
 80055a8:	6019      	str	r1, [r3, #0]
}
 80055aa:	b002      	add	sp, #8
 80055ac:	4770      	bx	lr
 80055ae:	bf00      	nop
 80055b0:	40002850 	.word	0x40002850

080055b4 <RTC_ReadBackupRegister>:
{
 80055b4:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 80055b6:	2300      	movs	r3, #0
 80055b8:	9301      	str	r3, [sp, #4]
  tmp = RTC_BASE + 0x50;
 80055ba:	4b05      	ldr	r3, [pc, #20]	; (80055d0 <RTC_ReadBackupRegister+0x1c>)
 80055bc:	9301      	str	r3, [sp, #4]
  tmp += (RTC_BKP_DR * 4);
 80055be:	9b01      	ldr	r3, [sp, #4]
 80055c0:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80055c4:	9001      	str	r0, [sp, #4]
  return (*(__IO uint32_t *)tmp);
 80055c6:	9b01      	ldr	r3, [sp, #4]
 80055c8:	6818      	ldr	r0, [r3, #0]
}
 80055ca:	b002      	add	sp, #8
 80055cc:	4770      	bx	lr
 80055ce:	bf00      	nop
 80055d0:	40002850 	.word	0x40002850

080055d4 <RTC_TamperPinSelection>:
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
 80055d4:	4b04      	ldr	r3, [pc, #16]	; (80055e8 <RTC_TamperPinSelection+0x14>)
 80055d6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80055d8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80055dc:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
 80055de:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80055e0:	4310      	orrs	r0, r2
 80055e2:	6418      	str	r0, [r3, #64]	; 0x40
 80055e4:	4770      	bx	lr
 80055e6:	bf00      	nop
 80055e8:	40002800 	.word	0x40002800

080055ec <RTC_TimeStampPinSelection>:
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
 80055ec:	4b04      	ldr	r3, [pc, #16]	; (8005600 <RTC_TimeStampPinSelection+0x14>)
 80055ee:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80055f0:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 80055f4:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
 80055f6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80055f8:	4310      	orrs	r0, r2
 80055fa:	6418      	str	r0, [r3, #64]	; 0x40
 80055fc:	4770      	bx	lr
 80055fe:	bf00      	nop
 8005600:	40002800 	.word	0x40002800

08005604 <RTC_OutputTypeConfig>:
  RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
 8005604:	4b04      	ldr	r3, [pc, #16]	; (8005618 <RTC_OutputTypeConfig+0x14>)
 8005606:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005608:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800560c:	641a      	str	r2, [r3, #64]	; 0x40
  RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
 800560e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8005610:	4310      	orrs	r0, r2
 8005612:	6418      	str	r0, [r3, #64]	; 0x40
 8005614:	4770      	bx	lr
 8005616:	bf00      	nop
 8005618:	40002800 	.word	0x40002800

0800561c <RTC_SynchroShiftConfig>:
{
 800561c:	b508      	push	{r3, lr}
  RTC->WPR = 0xCA;
 800561e:	4b18      	ldr	r3, [pc, #96]	; (8005680 <RTC_SynchroShiftConfig+0x64>)
 8005620:	22ca      	movs	r2, #202	; 0xca
 8005622:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 8005624:	2253      	movs	r2, #83	; 0x53
 8005626:	625a      	str	r2, [r3, #36]	; 0x24
  if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
 8005628:	68db      	ldr	r3, [r3, #12]
 800562a:	f013 0f08 	tst.w	r3, #8
 800562e:	d115      	bne.n	800565c <RTC_SynchroShiftConfig+0x40>
  if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
 8005630:	4b13      	ldr	r3, [pc, #76]	; (8005680 <RTC_SynchroShiftConfig+0x64>)
 8005632:	68db      	ldr	r3, [r3, #12]
 8005634:	f013 0f08 	tst.w	r3, #8
 8005638:	d11b      	bne.n	8005672 <RTC_SynchroShiftConfig+0x56>
    if((RTC->CR & RTC_CR_REFCKON) == RESET)
 800563a:	4b11      	ldr	r3, [pc, #68]	; (8005680 <RTC_SynchroShiftConfig+0x64>)
 800563c:	689b      	ldr	r3, [r3, #8]
 800563e:	f013 0f10 	tst.w	r3, #16
 8005642:	d00d      	beq.n	8005660 <RTC_SynchroShiftConfig+0x44>
      status = ERROR;
 8005644:	2300      	movs	r3, #0
 8005646:	e015      	b.n	8005674 <RTC_SynchroShiftConfig+0x58>
      shpfcount++;
 8005648:	3301      	adds	r3, #1
    while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
 800564a:	4a0d      	ldr	r2, [pc, #52]	; (8005680 <RTC_SynchroShiftConfig+0x64>)
 800564c:	68d2      	ldr	r2, [r2, #12]
 800564e:	f012 0f08 	tst.w	r2, #8
 8005652:	d0ed      	beq.n	8005630 <RTC_SynchroShiftConfig+0x14>
 8005654:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005658:	d1f6      	bne.n	8005648 <RTC_SynchroShiftConfig+0x2c>
 800565a:	e7e9      	b.n	8005630 <RTC_SynchroShiftConfig+0x14>
 800565c:	2300      	movs	r3, #0
 800565e:	e7f4      	b.n	800564a <RTC_SynchroShiftConfig+0x2e>
      RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
 8005660:	4301      	orrs	r1, r0
 8005662:	4b07      	ldr	r3, [pc, #28]	; (8005680 <RTC_SynchroShiftConfig+0x64>)
 8005664:	62d9      	str	r1, [r3, #44]	; 0x2c
      if(RTC_WaitForSynchro() == ERROR)
 8005666:	f7ff fb2f 	bl	8004cc8 <RTC_WaitForSynchro>
 800566a:	4603      	mov	r3, r0
 800566c:	b110      	cbz	r0, 8005674 <RTC_SynchroShiftConfig+0x58>
        status = SUCCESS;
 800566e:	2301      	movs	r3, #1
 8005670:	e000      	b.n	8005674 <RTC_SynchroShiftConfig+0x58>
    status = ERROR;
 8005672:	2300      	movs	r3, #0
  RTC->WPR = 0xFF;
 8005674:	21ff      	movs	r1, #255	; 0xff
 8005676:	4a02      	ldr	r2, [pc, #8]	; (8005680 <RTC_SynchroShiftConfig+0x64>)
 8005678:	6251      	str	r1, [r2, #36]	; 0x24
}
 800567a:	4618      	mov	r0, r3
 800567c:	bd08      	pop	{r3, pc}
 800567e:	bf00      	nop
 8005680:	40002800 	.word	0x40002800

08005684 <RTC_ITConfig>:
  RTC->WPR = 0xCA;
 8005684:	4b10      	ldr	r3, [pc, #64]	; (80056c8 <RTC_ITConfig+0x44>)
 8005686:	22ca      	movs	r2, #202	; 0xca
 8005688:	625a      	str	r2, [r3, #36]	; 0x24
  RTC->WPR = 0x53;
 800568a:	2253      	movs	r2, #83	; 0x53
 800568c:	625a      	str	r2, [r3, #36]	; 0x24
  if (NewState != DISABLE)
 800568e:	b981      	cbnz	r1, 80056b2 <RTC_ITConfig+0x2e>
    RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
 8005690:	4b0d      	ldr	r3, [pc, #52]	; (80056c8 <RTC_ITConfig+0x44>)
 8005692:	689a      	ldr	r2, [r3, #8]
 8005694:	f020 0104 	bic.w	r1, r0, #4
 8005698:	ea22 0201 	bic.w	r2, r2, r1
 800569c:	609a      	str	r2, [r3, #8]
    RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
 800569e:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80056a0:	f000 0004 	and.w	r0, r0, #4
 80056a4:	ea22 0000 	bic.w	r0, r2, r0
 80056a8:	6418      	str	r0, [r3, #64]	; 0x40
  RTC->WPR = 0xFF; 
 80056aa:	22ff      	movs	r2, #255	; 0xff
 80056ac:	4b06      	ldr	r3, [pc, #24]	; (80056c8 <RTC_ITConfig+0x44>)
 80056ae:	625a      	str	r2, [r3, #36]	; 0x24
 80056b0:	4770      	bx	lr
    RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
 80056b2:	689a      	ldr	r2, [r3, #8]
 80056b4:	f020 0104 	bic.w	r1, r0, #4
 80056b8:	430a      	orrs	r2, r1
 80056ba:	609a      	str	r2, [r3, #8]
    RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
 80056bc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80056be:	f000 0004 	and.w	r0, r0, #4
 80056c2:	4310      	orrs	r0, r2
 80056c4:	6418      	str	r0, [r3, #64]	; 0x40
 80056c6:	e7f0      	b.n	80056aa <RTC_ITConfig+0x26>
 80056c8:	40002800 	.word	0x40002800

080056cc <RTC_GetFlagStatus>:
  tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
 80056cc:	4b07      	ldr	r3, [pc, #28]	; (80056ec <RTC_GetFlagStatus+0x20>)
 80056ce:	68db      	ldr	r3, [r3, #12]
 80056d0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80056d4:	f423 037e 	bic.w	r3, r3, #16646144	; 0xfe0000
 80056d8:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 80056dc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
 80056e0:	4203      	tst	r3, r0
 80056e2:	d101      	bne.n	80056e8 <RTC_GetFlagStatus+0x1c>
    bitstatus = RESET;
 80056e4:	2000      	movs	r0, #0
}
 80056e6:	4770      	bx	lr
    bitstatus = SET;
 80056e8:	2001      	movs	r0, #1
 80056ea:	4770      	bx	lr
 80056ec:	40002800 	.word	0x40002800

080056f0 <RTC_ClearFlag>:
  RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
 80056f0:	b280      	uxth	r0, r0
 80056f2:	f040 0380 	orr.w	r3, r0, #128	; 0x80
 80056f6:	4a04      	ldr	r2, [pc, #16]	; (8005708 <RTC_ClearFlag+0x18>)
 80056f8:	68d0      	ldr	r0, [r2, #12]
 80056fa:	f000 0080 	and.w	r0, r0, #128	; 0x80
 80056fe:	ea60 0003 	orn	r0, r0, r3
 8005702:	60d0      	str	r0, [r2, #12]
 8005704:	4770      	bx	lr
 8005706:	bf00      	nop
 8005708:	40002800 	.word	0x40002800

0800570c <RTC_GetITStatus>:
  tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
 800570c:	4a0a      	ldr	r2, [pc, #40]	; (8005738 <RTC_GetITStatus+0x2c>)
 800570e:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8005710:	f003 0304 	and.w	r3, r3, #4
  enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
 8005714:	6891      	ldr	r1, [r2, #8]
 8005716:	4001      	ands	r1, r0
 8005718:	ea03 33d0 	and.w	r3, r3, r0, lsr #15
  tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
 800571c:	68d2      	ldr	r2, [r2, #12]
 800571e:	ea02 1210 	and.w	r2, r2, r0, lsr #4
  if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
 8005722:	430b      	orrs	r3, r1
 8005724:	d003      	beq.n	800572e <RTC_GetITStatus+0x22>
 8005726:	b292      	uxth	r2, r2
 8005728:	b91a      	cbnz	r2, 8005732 <RTC_GetITStatus+0x26>
    bitstatus = RESET;
 800572a:	2000      	movs	r0, #0
 800572c:	4770      	bx	lr
 800572e:	2000      	movs	r0, #0
 8005730:	4770      	bx	lr
    bitstatus = SET;
 8005732:	2001      	movs	r0, #1
}
 8005734:	4770      	bx	lr
 8005736:	bf00      	nop
 8005738:	40002800 	.word	0x40002800

0800573c <RTC_ClearITPendingBit>:
  RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
 800573c:	f3c0 100f 	ubfx	r0, r0, #4, #16
 8005740:	f040 0380 	orr.w	r3, r0, #128	; 0x80
 8005744:	4a03      	ldr	r2, [pc, #12]	; (8005754 <RTC_ClearITPendingBit+0x18>)
 8005746:	68d0      	ldr	r0, [r2, #12]
 8005748:	f000 0080 	and.w	r0, r0, #128	; 0x80
 800574c:	ea60 0003 	orn	r0, r0, r3
 8005750:	60d0      	str	r0, [r2, #12]
 8005752:	4770      	bx	lr
 8005754:	40002800 	.word	0x40002800

08005758 <SDIO_DeInit>:
  * @brief  Deinitializes the SDIO peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void SDIO_DeInit(void)
{
 8005758:	b508      	push	{r3, lr}
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, ENABLE);
 800575a:	2101      	movs	r1, #1
 800575c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8005760:	f7ff f930 	bl	80049c4 <RCC_APB2PeriphResetCmd>
  RCC_APB2PeriphResetCmd(RCC_APB2Periph_SDIO, DISABLE);
 8005764:	2100      	movs	r1, #0
 8005766:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800576a:	f7ff f92b 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 800576e:	bd08      	pop	{r3, pc}

08005770 <SDIO_Init>:
  * @param  SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure 
  *         that contains the configuration information for the SDIO peripheral.
  * @retval None
  */
void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)
{
 8005770:	b410      	push	{r4}
  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));
  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl)); 
   
/*---------------------------- SDIO CLKCR Configuration ------------------------*/  
  /* Get the SDIO CLKCR value */
  tmpreg = SDIO->CLKCR;
 8005772:	490b      	ldr	r1, [pc, #44]	; (80057a0 <SDIO_Init+0x30>)
 8005774:	684a      	ldr	r2, [r1, #4]
  
  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */
  tmpreg &= CLKCR_CLEAR_MASK;
 8005776:	f422 42fd 	bic.w	r2, r2, #32384	; 0x7e80
 800577a:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */
  /* Set BYPASS bit according to SDIO_ClockBypass value */
  /* Set WIDBUS bits according to SDIO_BusWide value */
  /* Set NEGEDGE bits according to SDIO_ClockEdge value */
  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
 800577e:	7d03      	ldrb	r3, [r0, #20]
 8005780:	6884      	ldr	r4, [r0, #8]
 8005782:	4323      	orrs	r3, r4
             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
 8005784:	6844      	ldr	r4, [r0, #4]
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
 8005786:	4323      	orrs	r3, r4
             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
 8005788:	68c4      	ldr	r4, [r0, #12]
 800578a:	4323      	orrs	r3, r4
             SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
 800578c:	6804      	ldr	r4, [r0, #0]
             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |
 800578e:	4323      	orrs	r3, r4
             SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl); 
 8005790:	6900      	ldr	r0, [r0, #16]
 8005792:	4303      	orrs	r3, r0
  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |
 8005794:	4313      	orrs	r3, r2
  
  /* Write to SDIO CLKCR */
  SDIO->CLKCR = tmpreg;
 8005796:	604b      	str	r3, [r1, #4]
}
 8005798:	f85d 4b04 	ldr.w	r4, [sp], #4
 800579c:	4770      	bx	lr
 800579e:	bf00      	nop
 80057a0:	40012c00 	.word	0x40012c00

080057a4 <SDIO_StructInit>:
  * @retval None
  */
void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)
{
  /* SDIO_InitStruct members default value */
  SDIO_InitStruct->SDIO_ClockDiv = 0x00;
 80057a4:	2300      	movs	r3, #0
 80057a6:	7503      	strb	r3, [r0, #20]
  SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;
 80057a8:	6003      	str	r3, [r0, #0]
  SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;
 80057aa:	6043      	str	r3, [r0, #4]
  SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;
 80057ac:	6083      	str	r3, [r0, #8]
  SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;
 80057ae:	60c3      	str	r3, [r0, #12]
  SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;
 80057b0:	6103      	str	r3, [r0, #16]
 80057b2:	4770      	bx	lr

080057b4 <SDIO_ClockCmd>:
void SDIO_ClockCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;
 80057b4:	4b01      	ldr	r3, [pc, #4]	; (80057bc <SDIO_ClockCmd+0x8>)
 80057b6:	6018      	str	r0, [r3, #0]
 80057b8:	4770      	bx	lr
 80057ba:	bf00      	nop
 80057bc:	422580a0 	.word	0x422580a0

080057c0 <SDIO_SetPowerState>:
void SDIO_SetPowerState(uint32_t SDIO_PowerState)
{
  /* Check the parameters */
  assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));
  
  SDIO->POWER = SDIO_PowerState;
 80057c0:	4b01      	ldr	r3, [pc, #4]	; (80057c8 <SDIO_SetPowerState+0x8>)
 80057c2:	6018      	str	r0, [r3, #0]
 80057c4:	4770      	bx	lr
 80057c6:	bf00      	nop
 80057c8:	40012c00 	.word	0x40012c00

080057cc <SDIO_GetPowerState>:
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDIO_GetPowerState(void)
{
  return (SDIO->POWER & (~PWR_PWRCTRL_MASK));
 80057cc:	4b02      	ldr	r3, [pc, #8]	; (80057d8 <SDIO_GetPowerState+0xc>)
 80057ce:	6818      	ldr	r0, [r3, #0]
}
 80057d0:	f000 0003 	and.w	r0, r0, #3
 80057d4:	4770      	bx	lr
 80057d6:	bf00      	nop
 80057d8:	40012c00 	.word	0x40012c00

080057dc <SDIO_SendCommand>:
  *         structure that contains the configuration information for the SDIO 
  *         command.
  * @retval None
  */
void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)
{
 80057dc:	b410      	push	{r4}
  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));
  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));
  
/*---------------------------- SDIO ARG Configuration ------------------------*/
  /* Set the SDIO Argument value */
  SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;
 80057de:	6803      	ldr	r3, [r0, #0]
 80057e0:	4909      	ldr	r1, [pc, #36]	; (8005808 <SDIO_SendCommand+0x2c>)
 80057e2:	608b      	str	r3, [r1, #8]
  
/*---------------------------- SDIO CMD Configuration ------------------------*/  
  /* Get the SDIO CMD value */
  tmpreg = SDIO->CMD;
 80057e4:	68cb      	ldr	r3, [r1, #12]
  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */
  tmpreg &= CMD_CLEAR_MASK;
 80057e6:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 80057ea:	f023 0307 	bic.w	r3, r3, #7
  /* Set CMDINDEX bits according to SDIO_CmdIndex value */
  /* Set WAITRESP bits according to SDIO_Response value */
  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */
  /* Set CPSMEN bits according to SDIO_CPSM value */
  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
 80057ee:	6842      	ldr	r2, [r0, #4]
 80057f0:	6884      	ldr	r4, [r0, #8]
 80057f2:	4322      	orrs	r2, r4
           | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;
 80057f4:	68c4      	ldr	r4, [r0, #12]
 80057f6:	4322      	orrs	r2, r4
 80057f8:	6900      	ldr	r0, [r0, #16]
 80057fa:	4302      	orrs	r2, r0
  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response
 80057fc:	4313      	orrs	r3, r2
  
  /* Write to SDIO CMD */
  SDIO->CMD = tmpreg;
 80057fe:	60cb      	str	r3, [r1, #12]
}
 8005800:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005804:	4770      	bx	lr
 8005806:	bf00      	nop
 8005808:	40012c00 	.word	0x40012c00

0800580c <SDIO_CmdStructInit>:
  * @retval None
  */
void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)
{
  /* SDIO_CmdInitStruct members default value */
  SDIO_CmdInitStruct->SDIO_Argument = 0x00;
 800580c:	2300      	movs	r3, #0
 800580e:	6003      	str	r3, [r0, #0]
  SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;
 8005810:	6043      	str	r3, [r0, #4]
  SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;
 8005812:	6083      	str	r3, [r0, #8]
  SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;
 8005814:	60c3      	str	r3, [r0, #12]
  SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;
 8005816:	6103      	str	r3, [r0, #16]
 8005818:	4770      	bx	lr

0800581a <SDIO_GetCommandResponse>:
  * @param  None
  * @retval Returns the command index of the last command response received.
  */
uint8_t SDIO_GetCommandResponse(void)
{
  return (uint8_t)(SDIO->RESPCMD);
 800581a:	4b02      	ldr	r3, [pc, #8]	; (8005824 <SDIO_GetCommandResponse+0xa>)
 800581c:	6918      	ldr	r0, [r3, #16]
}
 800581e:	b2c0      	uxtb	r0, r0
 8005820:	4770      	bx	lr
 8005822:	bf00      	nop
 8005824:	40012c00 	.word	0x40012c00

08005828 <SDIO_GetResponse>:
  *            @arg SDIO_RESP3: Response Register 3
  *            @arg SDIO_RESP4: Response Register 4
  * @retval The Corresponding response register value.
  */
uint32_t SDIO_GetResponse(uint32_t SDIO_RESP)
{
 8005828:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 800582a:	2300      	movs	r3, #0
 800582c:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_SDIO_RESP(SDIO_RESP));

  tmp = SDIO_RESP_ADDR + SDIO_RESP;
 800582e:	4b03      	ldr	r3, [pc, #12]	; (800583c <SDIO_GetResponse+0x14>)
 8005830:	4403      	add	r3, r0
 8005832:	9301      	str	r3, [sp, #4]
  
  return (*(__IO uint32_t *) tmp); 
 8005834:	9b01      	ldr	r3, [sp, #4]
 8005836:	6818      	ldr	r0, [r3, #0]
}
 8005838:	b002      	add	sp, #8
 800583a:	4770      	bx	lr
 800583c:	40012c14 	.word	0x40012c14

08005840 <SDIO_DataConfig>:
  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure 
  *         that contains the configuration information for the SDIO command.
  * @retval None
  */
void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
 8005840:	b410      	push	{r4}
  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));
  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));

/*---------------------------- SDIO DTIMER Configuration ---------------------*/
  /* Set the SDIO Data TimeOut value */
  SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;
 8005842:	6803      	ldr	r3, [r0, #0]
 8005844:	4909      	ldr	r1, [pc, #36]	; (800586c <SDIO_DataConfig+0x2c>)
 8005846:	624b      	str	r3, [r1, #36]	; 0x24

/*---------------------------- SDIO DLEN Configuration -----------------------*/
  /* Set the SDIO DataLength value */
  SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;
 8005848:	6843      	ldr	r3, [r0, #4]
 800584a:	628b      	str	r3, [r1, #40]	; 0x28

/*---------------------------- SDIO DCTRL Configuration ----------------------*/  
  /* Get the SDIO DCTRL value */
  tmpreg = SDIO->DCTRL;
 800584c:	6aca      	ldr	r2, [r1, #44]	; 0x2c
  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */
  tmpreg &= DCTRL_CLEAR_MASK;
 800584e:	f022 02f7 	bic.w	r2, r2, #247	; 0xf7
  /* Set DEN bit according to SDIO_DPSM value */
  /* Set DTMODE bit according to SDIO_TransferMode value */
  /* Set DTDIR bit according to SDIO_TransferDir value */
  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */
  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
 8005852:	6883      	ldr	r3, [r0, #8]
 8005854:	68c4      	ldr	r4, [r0, #12]
 8005856:	4323      	orrs	r3, r4
           | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;
 8005858:	6904      	ldr	r4, [r0, #16]
 800585a:	4323      	orrs	r3, r4
 800585c:	6940      	ldr	r0, [r0, #20]
 800585e:	4303      	orrs	r3, r0
  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir
 8005860:	4313      	orrs	r3, r2

  /* Write to SDIO DCTRL */
  SDIO->DCTRL = tmpreg;
 8005862:	62cb      	str	r3, [r1, #44]	; 0x2c
}
 8005864:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005868:	4770      	bx	lr
 800586a:	bf00      	nop
 800586c:	40012c00 	.word	0x40012c00

08005870 <SDIO_DataStructInit>:
  * @retval None
  */
void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)
{
  /* SDIO_DataInitStruct members default value */
  SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;
 8005870:	f04f 33ff 	mov.w	r3, #4294967295
 8005874:	6003      	str	r3, [r0, #0]
  SDIO_DataInitStruct->SDIO_DataLength = 0x00;
 8005876:	2300      	movs	r3, #0
 8005878:	6043      	str	r3, [r0, #4]
  SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;
 800587a:	6083      	str	r3, [r0, #8]
  SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;
 800587c:	60c3      	str	r3, [r0, #12]
  SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;  
 800587e:	6103      	str	r3, [r0, #16]
  SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;
 8005880:	6143      	str	r3, [r0, #20]
 8005882:	4770      	bx	lr

08005884 <SDIO_GetDataCounter>:
  * @param  None
  * @retval Number of remaining data bytes to be transferred
  */
uint32_t SDIO_GetDataCounter(void)
{ 
  return SDIO->DCOUNT;
 8005884:	4b01      	ldr	r3, [pc, #4]	; (800588c <SDIO_GetDataCounter+0x8>)
 8005886:	6b18      	ldr	r0, [r3, #48]	; 0x30
}
 8005888:	4770      	bx	lr
 800588a:	bf00      	nop
 800588c:	40012c00 	.word	0x40012c00

08005890 <SDIO_ReadData>:
  * @param  None
  * @retval Data received
  */
uint32_t SDIO_ReadData(void)
{ 
  return SDIO->FIFO;
 8005890:	4b01      	ldr	r3, [pc, #4]	; (8005898 <SDIO_ReadData+0x8>)
 8005892:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
}
 8005896:	4770      	bx	lr
 8005898:	40012c00 	.word	0x40012c00

0800589c <SDIO_WriteData>:
  * @param  Data: 32-bit data word to write.
  * @retval None
  */
void SDIO_WriteData(uint32_t Data)
{ 
  SDIO->FIFO = Data;
 800589c:	4b01      	ldr	r3, [pc, #4]	; (80058a4 <SDIO_WriteData+0x8>)
 800589e:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
 80058a2:	4770      	bx	lr
 80058a4:	40012c00 	.word	0x40012c00

080058a8 <SDIO_GetFIFOCount>:
  * @param  None
  * @retval Remaining number of words.
  */
uint32_t SDIO_GetFIFOCount(void)
{ 
  return SDIO->FIFOCNT;
 80058a8:	4b01      	ldr	r3, [pc, #4]	; (80058b0 <SDIO_GetFIFOCount+0x8>)
 80058aa:	6c98      	ldr	r0, [r3, #72]	; 0x48
}
 80058ac:	4770      	bx	lr
 80058ae:	bf00      	nop
 80058b0:	40012c00 	.word	0x40012c00

080058b4 <SDIO_StartSDIOReadWait>:
void SDIO_StartSDIOReadWait(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;
 80058b4:	4b01      	ldr	r3, [pc, #4]	; (80058bc <SDIO_StartSDIOReadWait+0x8>)
 80058b6:	6018      	str	r0, [r3, #0]
 80058b8:	4770      	bx	lr
 80058ba:	bf00      	nop
 80058bc:	422585a0 	.word	0x422585a0

080058c0 <SDIO_StopSDIOReadWait>:
void SDIO_StopSDIOReadWait(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;
 80058c0:	4b01      	ldr	r3, [pc, #4]	; (80058c8 <SDIO_StopSDIOReadWait+0x8>)
 80058c2:	6018      	str	r0, [r3, #0]
 80058c4:	4770      	bx	lr
 80058c6:	bf00      	nop
 80058c8:	422585a4 	.word	0x422585a4

080058cc <SDIO_SetSDIOReadWaitMode>:
void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)
{
  /* Check the parameters */
  assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
  
  *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;
 80058cc:	4b01      	ldr	r3, [pc, #4]	; (80058d4 <SDIO_SetSDIOReadWaitMode+0x8>)
 80058ce:	6018      	str	r0, [r3, #0]
 80058d0:	4770      	bx	lr
 80058d2:	bf00      	nop
 80058d4:	422585a8 	.word	0x422585a8

080058d8 <SDIO_SetSDIOOperation>:
void SDIO_SetSDIOOperation(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;
 80058d8:	4b01      	ldr	r3, [pc, #4]	; (80058e0 <SDIO_SetSDIOOperation+0x8>)
 80058da:	6018      	str	r0, [r3, #0]
 80058dc:	4770      	bx	lr
 80058de:	bf00      	nop
 80058e0:	422585ac 	.word	0x422585ac

080058e4 <SDIO_SendSDIOSuspendCmd>:
void SDIO_SendSDIOSuspendCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;
 80058e4:	4b01      	ldr	r3, [pc, #4]	; (80058ec <SDIO_SendSDIOSuspendCmd+0x8>)
 80058e6:	6018      	str	r0, [r3, #0]
 80058e8:	4770      	bx	lr
 80058ea:	bf00      	nop
 80058ec:	422581ac 	.word	0x422581ac

080058f0 <SDIO_CommandCompletionCmd>:
void SDIO_CommandCompletionCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;
 80058f0:	4b01      	ldr	r3, [pc, #4]	; (80058f8 <SDIO_CommandCompletionCmd+0x8>)
 80058f2:	6018      	str	r0, [r3, #0]
 80058f4:	4770      	bx	lr
 80058f6:	bf00      	nop
 80058f8:	422581b0 	.word	0x422581b0

080058fc <SDIO_CEATAITCmd>:
void SDIO_CEATAITCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));
 80058fc:	f080 0001 	eor.w	r0, r0, #1
 8005900:	f000 0001 	and.w	r0, r0, #1
 8005904:	4b01      	ldr	r3, [pc, #4]	; (800590c <SDIO_CEATAITCmd+0x10>)
 8005906:	6018      	str	r0, [r3, #0]
 8005908:	4770      	bx	lr
 800590a:	bf00      	nop
 800590c:	422581b4 	.word	0x422581b4

08005910 <SDIO_SendCEATACmd>:
void SDIO_SendCEATACmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;
 8005910:	4b01      	ldr	r3, [pc, #4]	; (8005918 <SDIO_SendCEATACmd+0x8>)
 8005912:	6018      	str	r0, [r3, #0]
 8005914:	4770      	bx	lr
 8005916:	bf00      	nop
 8005918:	422581b8 	.word	0x422581b8

0800591c <SDIO_DMACmd>:
void SDIO_DMACmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;
 800591c:	4b01      	ldr	r3, [pc, #4]	; (8005924 <SDIO_DMACmd+0x8>)
 800591e:	6018      	str	r0, [r3, #0]
 8005920:	4770      	bx	lr
 8005922:	bf00      	nop
 8005924:	4225858c 	.word	0x4225858c

08005928 <SDIO_ITConfig>:
{
  /* Check the parameters */
  assert_param(IS_SDIO_IT(SDIO_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005928:	b929      	cbnz	r1, 8005936 <SDIO_ITConfig+0xe>
    SDIO->MASK |= SDIO_IT;
  }
  else
  {
    /* Disable the SDIO interrupts */
    SDIO->MASK &= ~SDIO_IT;
 800592a:	4a05      	ldr	r2, [pc, #20]	; (8005940 <SDIO_ITConfig+0x18>)
 800592c:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 800592e:	ea23 0000 	bic.w	r0, r3, r0
 8005932:	63d0      	str	r0, [r2, #60]	; 0x3c
 8005934:	4770      	bx	lr
    SDIO->MASK |= SDIO_IT;
 8005936:	4a02      	ldr	r2, [pc, #8]	; (8005940 <SDIO_ITConfig+0x18>)
 8005938:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 800593a:	4318      	orrs	r0, r3
 800593c:	63d0      	str	r0, [r2, #60]	; 0x3c
 800593e:	4770      	bx	lr
 8005940:	40012c00 	.word	0x40012c00

08005944 <SDIO_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_SDIO_FLAG(SDIO_FLAG));
  
  if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)
 8005944:	4b03      	ldr	r3, [pc, #12]	; (8005954 <SDIO_GetFlagStatus+0x10>)
 8005946:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005948:	4203      	tst	r3, r0
 800594a:	d101      	bne.n	8005950 <SDIO_GetFlagStatus+0xc>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 800594c:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 800594e:	4770      	bx	lr
    bitstatus = SET;
 8005950:	2001      	movs	r0, #1
 8005952:	4770      	bx	lr
 8005954:	40012c00 	.word	0x40012c00

08005958 <SDIO_ClearFlag>:
void SDIO_ClearFlag(uint32_t SDIO_FLAG)
{ 
  /* Check the parameters */
  assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));
   
  SDIO->ICR = SDIO_FLAG;
 8005958:	4b01      	ldr	r3, [pc, #4]	; (8005960 <SDIO_ClearFlag+0x8>)
 800595a:	6398      	str	r0, [r3, #56]	; 0x38
 800595c:	4770      	bx	lr
 800595e:	bf00      	nop
 8005960:	40012c00 	.word	0x40012c00

08005964 <SDIO_GetITStatus>:
{ 
  ITStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_SDIO_GET_IT(SDIO_IT));
  if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)  
 8005964:	4b03      	ldr	r3, [pc, #12]	; (8005974 <SDIO_GetITStatus+0x10>)
 8005966:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005968:	4203      	tst	r3, r0
 800596a:	d101      	bne.n	8005970 <SDIO_GetITStatus+0xc>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 800596c:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 800596e:	4770      	bx	lr
    bitstatus = SET;
 8005970:	2001      	movs	r0, #1
 8005972:	4770      	bx	lr
 8005974:	40012c00 	.word	0x40012c00

08005978 <SDIO_ClearITPendingBit>:
void SDIO_ClearITPendingBit(uint32_t SDIO_IT)
{ 
  /* Check the parameters */
  assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));
   
  SDIO->ICR = SDIO_IT;
 8005978:	4b01      	ldr	r3, [pc, #4]	; (8005980 <SDIO_ClearITPendingBit+0x8>)
 800597a:	6398      	str	r0, [r3, #56]	; 0x38
 800597c:	4770      	bx	lr
 800597e:	bf00      	nop
 8005980:	40012c00 	.word	0x40012c00

08005984 <SPI_I2S_DeInit>:
  *         is managed by the I2S peripheral clock).
  *             
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
 8005984:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  if (SPIx == SPI1)
 8005986:	4b2a      	ldr	r3, [pc, #168]	; (8005a30 <SPI_I2S_DeInit+0xac>)
 8005988:	4298      	cmp	r0, r3
 800598a:	d00f      	beq.n	80059ac <SPI_I2S_DeInit+0x28>
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
  }
  else if (SPIx == SPI2)
 800598c:	4b29      	ldr	r3, [pc, #164]	; (8005a34 <SPI_I2S_DeInit+0xb0>)
 800598e:	4298      	cmp	r0, r3
 8005990:	d017      	beq.n	80059c2 <SPI_I2S_DeInit+0x3e>
    /* Enable SPI2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
  }
  else if (SPIx == SPI3)
 8005992:	4b29      	ldr	r3, [pc, #164]	; (8005a38 <SPI_I2S_DeInit+0xb4>)
 8005994:	4298      	cmp	r0, r3
 8005996:	d01f      	beq.n	80059d8 <SPI_I2S_DeInit+0x54>
    /* Enable SPI3 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
    /* Release SPI3 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
  }
  else if (SPIx == SPI4)
 8005998:	4b28      	ldr	r3, [pc, #160]	; (8005a3c <SPI_I2S_DeInit+0xb8>)
 800599a:	4298      	cmp	r0, r3
 800599c:	d027      	beq.n	80059ee <SPI_I2S_DeInit+0x6a>
    /* Enable SPI4 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, ENABLE);
    /* Release SPI4 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, DISABLE);
  }
  else if (SPIx == SPI5)
 800599e:	4b28      	ldr	r3, [pc, #160]	; (8005a40 <SPI_I2S_DeInit+0xbc>)
 80059a0:	4298      	cmp	r0, r3
 80059a2:	d02f      	beq.n	8005a04 <SPI_I2S_DeInit+0x80>
    /* Release SPI5 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, DISABLE);
  }
  else 
  {
    if (SPIx == SPI6)
 80059a4:	4b27      	ldr	r3, [pc, #156]	; (8005a44 <SPI_I2S_DeInit+0xc0>)
 80059a6:	4298      	cmp	r0, r3
 80059a8:	d037      	beq.n	8005a1a <SPI_I2S_DeInit+0x96>
 80059aa:	bd08      	pop	{r3, pc}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
 80059ac:	2101      	movs	r1, #1
 80059ae:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80059b2:	f7ff f807 	bl	80049c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 80059b6:	2100      	movs	r1, #0
 80059b8:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80059bc:	f7ff f802 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 80059c0:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
 80059c2:	2101      	movs	r1, #1
 80059c4:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80059c8:	f7fe ffee 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 80059cc:	2100      	movs	r1, #0
 80059ce:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80059d2:	f7fe ffe9 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 80059d6:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
 80059d8:	2101      	movs	r1, #1
 80059da:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80059de:	f7fe ffe3 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 80059e2:	2100      	movs	r1, #0
 80059e4:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80059e8:	f7fe ffde 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 80059ec:	bd08      	pop	{r3, pc}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, ENABLE);
 80059ee:	2101      	movs	r1, #1
 80059f0:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80059f4:	f7fe ffe6 	bl	80049c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI4, DISABLE);
 80059f8:	2100      	movs	r1, #0
 80059fa:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80059fe:	f7fe ffe1 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 8005a02:	bd08      	pop	{r3, pc}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, ENABLE);
 8005a04:	2101      	movs	r1, #1
 8005a06:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8005a0a:	f7fe ffdb 	bl	80049c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI5, DISABLE);
 8005a0e:	2100      	movs	r1, #0
 8005a10:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8005a14:	f7fe ffd6 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 8005a18:	bd08      	pop	{r3, pc}
    {
      /* Enable SPI6 reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, ENABLE);
 8005a1a:	2101      	movs	r1, #1
 8005a1c:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8005a20:	f7fe ffd0 	bl	80049c4 <RCC_APB2PeriphResetCmd>
      /* Release SPI6 from reset state */
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI6, DISABLE);
 8005a24:	2100      	movs	r1, #0
 8005a26:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8005a2a:	f7fe ffcb 	bl	80049c4 <RCC_APB2PeriphResetCmd>
    }
  }
}
 8005a2e:	e7bc      	b.n	80059aa <SPI_I2S_DeInit+0x26>
 8005a30:	40013000 	.word	0x40013000
 8005a34:	40003800 	.word	0x40003800
 8005a38:	40003c00 	.word	0x40003c00
 8005a3c:	40013400 	.word	0x40013400
 8005a40:	40015000 	.word	0x40015000
 8005a44:	40015400 	.word	0x40015400

08005a48 <SPI_Init>:
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 8005a48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

/*---------------------------- SPIx CR1 Configuration ------------------------*/
  /* Get the SPIx CR1 value */
  tmpreg = SPIx->CR1;
 8005a4c:	8803      	ldrh	r3, [r0, #0]
  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
  tmpreg &= CR1_CLEAR_MASK;
 8005a4e:	f403 5341 	and.w	r3, r3, #12352	; 0x3040
  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
  /* Set LSBFirst bit according to SPI_FirstBit value */
  /* Set BR bits according to SPI_BaudRatePrescaler value */
  /* Set CPOL bit according to SPI_CPOL value */
  /* Set CPHA bit according to SPI_CPHA value */
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8005a52:	f8b1 c000 	ldrh.w	ip, [r1]
 8005a56:	f8b1 8002 	ldrh.w	r8, [r1, #2]
                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
 8005a5a:	f8b1 e004 	ldrh.w	lr, [r1, #4]
 8005a5e:	88cf      	ldrh	r7, [r1, #6]
                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
 8005a60:	890e      	ldrh	r6, [r1, #8]
 8005a62:	894d      	ldrh	r5, [r1, #10]
                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
 8005a64:	898c      	ldrh	r4, [r1, #12]
 8005a66:	89ca      	ldrh	r2, [r1, #14]
  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
 8005a68:	ea4c 0c08 	orr.w	ip, ip, r8
 8005a6c:	ea4e 0e0c 	orr.w	lr, lr, ip
 8005a70:	ea47 070e 	orr.w	r7, r7, lr
 8005a74:	433e      	orrs	r6, r7
 8005a76:	4335      	orrs	r5, r6
 8005a78:	432c      	orrs	r4, r5
 8005a7a:	4322      	orrs	r2, r4
 8005a7c:	4313      	orrs	r3, r2
  /* Write to SPIx CR1 */
  SPIx->CR1 = tmpreg;
 8005a7e:	8003      	strh	r3, [r0, #0]

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 8005a80:	8b83      	ldrh	r3, [r0, #28]
 8005a82:	b29b      	uxth	r3, r3
 8005a84:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8005a88:	b29b      	uxth	r3, r3
 8005a8a:	8383      	strh	r3, [r0, #28]
/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8005a8c:	8a0b      	ldrh	r3, [r1, #16]
 8005a8e:	8203      	strh	r3, [r0, #16]
 8005a90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005a94 <I2S_Init>:
  *         to the value of the the source clock frequency (in Hz).
  *  
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 8005a94:	b4f0      	push	{r4, r5, r6, r7}
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8005a96:	8b83      	ldrh	r3, [r0, #28]
 8005a98:	b29b      	uxth	r3, r3
 8005a9a:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 8005a9e:	f023 030f 	bic.w	r3, r3, #15
 8005aa2:	b29b      	uxth	r3, r3
 8005aa4:	8383      	strh	r3, [r0, #28]
  SPIx->I2SPR = 0x0002;
 8005aa6:	2302      	movs	r3, #2
 8005aa8:	8403      	strh	r3, [r0, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
 8005aaa:	8b82      	ldrh	r2, [r0, #28]
 8005aac:	b292      	uxth	r2, r2
  
  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 8005aae:	688b      	ldr	r3, [r1, #8]
 8005ab0:	2b02      	cmp	r3, #2
 8005ab2:	d05c      	beq.n	8005b6e <I2S_Init+0xda>
  }
  /* If the requested audio frequency is not the default, compute the prescaler */
  else
  {
    /* Check the frame length (For the Prescaler computing) *******************/
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 8005ab4:	888b      	ldrh	r3, [r1, #4]
 8005ab6:	2b00      	cmp	r3, #0
 8005ab8:	d14d      	bne.n	8005b56 <I2S_Init+0xc2>
    {
      /* Packet length is 16 bits */
      packetlength = 1;
 8005aba:	2701      	movs	r7, #1
    /* Set the I2S clock to the external clock  value */
    i2sclk = I2S_EXTERNAL_CLOCK_VAL;

  #else /* There is no define for External I2S clock source */
    /* Set PLLI2S as I2S clock source */
    if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
 8005abc:	4b2d      	ldr	r3, [pc, #180]	; (8005b74 <I2S_Init+0xe0>)
 8005abe:	689b      	ldr	r3, [r3, #8]
 8005ac0:	f413 0f00 	tst.w	r3, #8388608	; 0x800000
 8005ac4:	d004      	beq.n	8005ad0 <I2S_Init+0x3c>
    {
      RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
 8005ac6:	4c2b      	ldr	r4, [pc, #172]	; (8005b74 <I2S_Init+0xe0>)
 8005ac8:	68a3      	ldr	r3, [r4, #8]
 8005aca:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8005ace:	60a3      	str	r3, [r4, #8]
    }    
    
    /* Get the PLLI2SN value */
    plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
 8005ad0:	4e28      	ldr	r6, [pc, #160]	; (8005b74 <I2S_Init+0xe0>)
 8005ad2:	f8d6 5084 	ldr.w	r5, [r6, #132]	; 0x84
 8005ad6:	f3c5 1588 	ubfx	r5, r5, #6, #9
                      (RCC_PLLI2SCFGR_PLLI2SN >> 6));
    
    /* Get the PLLI2SR value */
    pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
 8005ada:	f8d6 3084 	ldr.w	r3, [r6, #132]	; 0x84
 8005ade:	f3c3 7302 	ubfx	r3, r3, #28, #3
                      (RCC_PLLI2SCFGR_PLLI2SR >> 28));
    
    /* Get the PLLM value */
    pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
 8005ae2:	6876      	ldr	r6, [r6, #4]
 8005ae4:	f006 063f 	and.w	r6, r6, #63	; 0x3f

    /* Get the I2S source clock value */
    i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
 8005ae8:	4c23      	ldr	r4, [pc, #140]	; (8005b78 <I2S_Init+0xe4>)
 8005aea:	fbb4 f4f6 	udiv	r4, r4, r6
 8005aee:	fb04 f405 	mul.w	r4, r4, r5
 8005af2:	fbb4 f4f3 	udiv	r4, r4, r3
  #endif /* I2S_EXTERNAL_CLOCK_VAL */
    
    /* Compute the Real divider depending on the MCLK output state, with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 8005af6:	88cb      	ldrh	r3, [r1, #6]
 8005af8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005afc:	d02d      	beq.n	8005b5a <I2S_Init+0xc6>
      tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8005afe:	017f      	lsls	r7, r7, #5
 8005b00:	fbb4 f4f7 	udiv	r4, r4, r7
 8005b04:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8005b08:	0063      	lsls	r3, r4, #1
 8005b0a:	688c      	ldr	r4, [r1, #8]
 8005b0c:	fbb3 f3f4 	udiv	r3, r3, r4
 8005b10:	3305      	adds	r3, #5
 8005b12:	b29b      	uxth	r3, r3
    }
    
    /* Remove the flatting point */
    tmp = tmp / 10;  
 8005b14:	4c19      	ldr	r4, [pc, #100]	; (8005b7c <I2S_Init+0xe8>)
 8005b16:	fba4 4303 	umull	r4, r3, r4, r3
 8005b1a:	08db      	lsrs	r3, r3, #3
      
    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
 8005b1c:	f003 0401 	and.w	r4, r3, #1
   
    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 8005b20:	1b1b      	subs	r3, r3, r4
 8005b22:	f3c3 034f 	ubfx	r3, r3, #1, #16
   
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 8005b26:	0224      	lsls	r4, r4, #8
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 8005b28:	1e9d      	subs	r5, r3, #2
 8005b2a:	b2ad      	uxth	r5, r5
 8005b2c:	2dfd      	cmp	r5, #253	; 0xfd
 8005b2e:	d901      	bls.n	8005b34 <I2S_Init+0xa0>
  {
    /* Set the default values */
    i2sdiv = 2;
    i2sodd = 0;
 8005b30:	2400      	movs	r4, #0
    i2sdiv = 2;
 8005b32:	2302      	movs	r3, #2
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 8005b34:	88cd      	ldrh	r5, [r1, #6]
 8005b36:	432c      	orrs	r4, r5
 8005b38:	4323      	orrs	r3, r4
 8005b3a:	8403      	strh	r3, [r0, #32]
 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 8005b3c:	880b      	ldrh	r3, [r1, #0]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8005b3e:	884c      	ldrh	r4, [r1, #2]
 8005b40:	888d      	ldrh	r5, [r1, #4]
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 8005b42:	8989      	ldrh	r1, [r1, #12]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8005b44:	4329      	orrs	r1, r5
 8005b46:	4321      	orrs	r1, r4
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
 8005b48:	430b      	orrs	r3, r1
 8005b4a:	431a      	orrs	r2, r3
 8005b4c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 
  /* Write to SPIx I2SCFGR */  
  SPIx->I2SCFGR = tmpreg;
 8005b50:	8382      	strh	r2, [r0, #28]
}
 8005b52:	bcf0      	pop	{r4, r5, r6, r7}
 8005b54:	4770      	bx	lr
      packetlength = 2;
 8005b56:	2702      	movs	r7, #2
 8005b58:	e7b0      	b.n	8005abc <I2S_Init+0x28>
      tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8005b5a:	0a24      	lsrs	r4, r4, #8
 8005b5c:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8005b60:	0063      	lsls	r3, r4, #1
 8005b62:	688c      	ldr	r4, [r1, #8]
 8005b64:	fbb3 f3f4 	udiv	r3, r3, r4
 8005b68:	3305      	adds	r3, #5
 8005b6a:	b29b      	uxth	r3, r3
 8005b6c:	e7d2      	b.n	8005b14 <I2S_Init+0x80>
    i2sodd = (uint16_t)0;
 8005b6e:	2400      	movs	r4, #0
    i2sdiv = (uint16_t)2;   
 8005b70:	2302      	movs	r3, #2
 8005b72:	e7d9      	b.n	8005b28 <I2S_Init+0x94>
 8005b74:	40023800 	.word	0x40023800
 8005b78:	017d7840 	.word	0x017d7840
 8005b7c:	cccccccd 	.word	0xcccccccd

08005b80 <SPI_StructInit>:
  */
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
{
/*--------------- Reset SPI init structure parameters values -----------------*/
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8005b80:	2300      	movs	r3, #0
 8005b82:	8003      	strh	r3, [r0, #0]
  /* initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
 8005b84:	8043      	strh	r3, [r0, #2]
  /* initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 8005b86:	8083      	strh	r3, [r0, #4]
  /* Initialize the SPI_CPOL member */
  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
 8005b88:	80c3      	strh	r3, [r0, #6]
  /* Initialize the SPI_CPHA member */
  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
 8005b8a:	8103      	strh	r3, [r0, #8]
  /* Initialize the SPI_NSS member */
  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
 8005b8c:	8143      	strh	r3, [r0, #10]
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 8005b8e:	8183      	strh	r3, [r0, #12]
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
 8005b90:	81c3      	strh	r3, [r0, #14]
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 8005b92:	2307      	movs	r3, #7
 8005b94:	8203      	strh	r3, [r0, #16]
 8005b96:	4770      	bx	lr

08005b98 <I2S_StructInit>:
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 8005b98:	2300      	movs	r3, #0
 8005b9a:	8003      	strh	r3, [r0, #0]
  
  /* Initialize the I2S_Standard member */
  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
 8005b9c:	8043      	strh	r3, [r0, #2]
  
  /* Initialize the I2S_DataFormat member */
  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
 8005b9e:	8083      	strh	r3, [r0, #4]
  
  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
 8005ba0:	80c3      	strh	r3, [r0, #6]
  
  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 8005ba2:	2202      	movs	r2, #2
 8005ba4:	6082      	str	r2, [r0, #8]
  
  /* Initialize the I2S_CPOL member */
  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
 8005ba6:	8183      	strh	r3, [r0, #12]
 8005ba8:	4770      	bx	lr

08005baa <SPI_Cmd>:
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005baa:	b931      	cbnz	r1, 8005bba <SPI_Cmd+0x10>
    SPIx->CR1 |= SPI_CR1_SPE;
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 8005bac:	8803      	ldrh	r3, [r0, #0]
 8005bae:	b29b      	uxth	r3, r3
 8005bb0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8005bb4:	b29b      	uxth	r3, r3
 8005bb6:	8003      	strh	r3, [r0, #0]
 8005bb8:	4770      	bx	lr
    SPIx->CR1 |= SPI_CR1_SPE;
 8005bba:	8803      	ldrh	r3, [r0, #0]
 8005bbc:	b29b      	uxth	r3, r3
 8005bbe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005bc2:	8003      	strh	r3, [r0, #0]
 8005bc4:	4770      	bx	lr

08005bc6 <I2S_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005bc6:	b931      	cbnz	r1, 8005bd6 <I2S_Cmd+0x10>
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
  }
  else
  {
    /* Disable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
 8005bc8:	8b83      	ldrh	r3, [r0, #28]
 8005bca:	b29b      	uxth	r3, r3
 8005bcc:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8005bd0:	b29b      	uxth	r3, r3
 8005bd2:	8383      	strh	r3, [r0, #28]
 8005bd4:	4770      	bx	lr
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8005bd6:	8b83      	ldrh	r3, [r0, #28]
 8005bd8:	b29b      	uxth	r3, r3
 8005bda:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8005bde:	8383      	strh	r3, [r0, #28]
 8005be0:	4770      	bx	lr

08005be2 <SPI_DataSizeConfig>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DATASIZE(SPI_DataSize));
  /* Clear DFF bit */
  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
 8005be2:	8803      	ldrh	r3, [r0, #0]
 8005be4:	b29b      	uxth	r3, r3
 8005be6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8005bea:	b29b      	uxth	r3, r3
 8005bec:	8003      	strh	r3, [r0, #0]
  /* Set new DFF bit value */
  SPIx->CR1 |= SPI_DataSize;
 8005bee:	8803      	ldrh	r3, [r0, #0]
 8005bf0:	b29b      	uxth	r3, r3
 8005bf2:	4319      	orrs	r1, r3
 8005bf4:	8001      	strh	r1, [r0, #0]
 8005bf6:	4770      	bx	lr

08005bf8 <SPI_BiDirectionalLineConfig>:
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 8005bf8:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 8005bfc:	d006      	beq.n	8005c0c <SPI_BiDirectionalLineConfig+0x14>
    SPIx->CR1 |= SPI_Direction_Tx;
  }
  else
  {
    /* Set the Rx only mode */
    SPIx->CR1 &= SPI_Direction_Rx;
 8005bfe:	8803      	ldrh	r3, [r0, #0]
 8005c00:	b29b      	uxth	r3, r3
 8005c02:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8005c06:	b29b      	uxth	r3, r3
 8005c08:	8003      	strh	r3, [r0, #0]
 8005c0a:	4770      	bx	lr
    SPIx->CR1 |= SPI_Direction_Tx;
 8005c0c:	8803      	ldrh	r3, [r0, #0]
 8005c0e:	b29b      	uxth	r3, r3
 8005c10:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005c14:	8003      	strh	r3, [r0, #0]
 8005c16:	4770      	bx	lr

08005c18 <SPI_NSSInternalSoftwareConfig>:
void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 8005c18:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 8005c1c:	4299      	cmp	r1, r3
 8005c1e:	d005      	beq.n	8005c2c <SPI_NSSInternalSoftwareConfig+0x14>
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 8005c20:	8803      	ldrh	r3, [r0, #0]
 8005c22:	b29b      	uxth	r3, r3
 8005c24:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005c28:	8003      	strh	r3, [r0, #0]
 8005c2a:	4770      	bx	lr
  }
  else
  {
    /* Reset NSS pin internally by software */
    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
 8005c2c:	8803      	ldrh	r3, [r0, #0]
 8005c2e:	b29b      	uxth	r3, r3
 8005c30:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8005c34:	b29b      	uxth	r3, r3
 8005c36:	8003      	strh	r3, [r0, #0]
 8005c38:	4770      	bx	lr

08005c3a <SPI_SSOutputCmd>:
void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005c3a:	b931      	cbnz	r1, 8005c4a <SPI_SSOutputCmd+0x10>
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
  }
  else
  {
    /* Disable the selected SPI SS output */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
 8005c3c:	8883      	ldrh	r3, [r0, #4]
 8005c3e:	b29b      	uxth	r3, r3
 8005c40:	f023 0304 	bic.w	r3, r3, #4
 8005c44:	b29b      	uxth	r3, r3
 8005c46:	8083      	strh	r3, [r0, #4]
 8005c48:	4770      	bx	lr
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 8005c4a:	8883      	ldrh	r3, [r0, #4]
 8005c4c:	b29b      	uxth	r3, r3
 8005c4e:	f043 0304 	orr.w	r3, r3, #4
 8005c52:	8083      	strh	r3, [r0, #4]
 8005c54:	4770      	bx	lr

08005c56 <SPI_TIModeCmd>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005c56:	b931      	cbnz	r1, 8005c66 <SPI_TIModeCmd+0x10>
    SPIx->CR2 |= SPI_CR2_FRF;
  }
  else
  {
    /* Disable the TI mode for the selected SPI peripheral */
    SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
 8005c58:	8883      	ldrh	r3, [r0, #4]
 8005c5a:	b29b      	uxth	r3, r3
 8005c5c:	f023 0310 	bic.w	r3, r3, #16
 8005c60:	b29b      	uxth	r3, r3
 8005c62:	8083      	strh	r3, [r0, #4]
 8005c64:	4770      	bx	lr
    SPIx->CR2 |= SPI_CR2_FRF;
 8005c66:	8883      	ldrh	r3, [r0, #4]
 8005c68:	b29b      	uxth	r3, r3
 8005c6a:	f043 0310 	orr.w	r3, r3, #16
 8005c6e:	8083      	strh	r3, [r0, #4]
 8005c70:	4770      	bx	lr

08005c72 <I2S_FullDuplexConfig>:
  * @note   The I2S full duplex extension can be configured in slave mode only.    
  *  
  * @retval None
  */
void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
{
 8005c72:	b430      	push	{r4, r5}
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8005c74:	8b83      	ldrh	r3, [r0, #28]
 8005c76:	b29b      	uxth	r3, r3
 8005c78:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 8005c7c:	f023 030f 	bic.w	r3, r3, #15
 8005c80:	b29b      	uxth	r3, r3
 8005c82:	8383      	strh	r3, [r0, #28]
  I2Sxext->I2SPR = 0x0002;
 8005c84:	2302      	movs	r3, #2
 8005c86:	8403      	strh	r3, [r0, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
 8005c88:	8b83      	ldrh	r3, [r0, #28]
 8005c8a:	b29b      	uxth	r3, r3
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8005c8c:	880a      	ldrh	r2, [r1, #0]
 8005c8e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8005c92:	d010      	beq.n	8005cb6 <I2S_FullDuplexConfig+0x44>
 8005c94:	b162      	cbz	r2, 8005cb0 <I2S_FullDuplexConfig+0x3e>
  }
  else
  {
    if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
    {
      tmp = I2S_Mode_SlaveTx;
 8005c96:	2500      	movs	r5, #0
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8005c98:	884a      	ldrh	r2, [r1, #2]
 8005c9a:	888c      	ldrh	r4, [r1, #4]
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 8005c9c:	8989      	ldrh	r1, [r1, #12]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8005c9e:	4321      	orrs	r1, r4
 8005ca0:	430a      	orrs	r2, r1
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8005ca2:	432a      	orrs	r2, r5
 8005ca4:	4313      	orrs	r3, r2
 8005ca6:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 
  /* Write to SPIx I2SCFGR */  
  I2Sxext->I2SCFGR = tmpreg;
 8005caa:	8383      	strh	r3, [r0, #28]
}
 8005cac:	bc30      	pop	{r4, r5}
 8005cae:	4770      	bx	lr
    tmp = I2S_Mode_SlaveRx;
 8005cb0:	f44f 7580 	mov.w	r5, #256	; 0x100
 8005cb4:	e7f0      	b.n	8005c98 <I2S_FullDuplexConfig+0x26>
 8005cb6:	f44f 7580 	mov.w	r5, #256	; 0x100
 8005cba:	e7ed      	b.n	8005c98 <I2S_FullDuplexConfig+0x26>

08005cbc <SPI_I2S_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Return the data in the DR register */
  return SPIx->DR;
 8005cbc:	8980      	ldrh	r0, [r0, #12]
}
 8005cbe:	b280      	uxth	r0, r0
 8005cc0:	4770      	bx	lr

08005cc2 <SPI_I2S_SendData>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  /* Write in the DR register the data to be sent */
  SPIx->DR = Data;
 8005cc2:	8181      	strh	r1, [r0, #12]
 8005cc4:	4770      	bx	lr

08005cc6 <SPI_CalculateCRC>:
void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005cc6:	b931      	cbnz	r1, 8005cd6 <SPI_CalculateCRC+0x10>
    SPIx->CR1 |= SPI_CR1_CRCEN;
  }
  else
  {
    /* Disable the selected SPI CRC calculation */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
 8005cc8:	8803      	ldrh	r3, [r0, #0]
 8005cca:	b29b      	uxth	r3, r3
 8005ccc:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8005cd0:	b29b      	uxth	r3, r3
 8005cd2:	8003      	strh	r3, [r0, #0]
 8005cd4:	4770      	bx	lr
    SPIx->CR1 |= SPI_CR1_CRCEN;
 8005cd6:	8803      	ldrh	r3, [r0, #0]
 8005cd8:	b29b      	uxth	r3, r3
 8005cda:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8005cde:	8003      	strh	r3, [r0, #0]
 8005ce0:	4770      	bx	lr

08005ce2 <SPI_TransmitCRC>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Enable the selected SPI CRC transmission */
  SPIx->CR1 |= SPI_CR1_CRCNEXT;
 8005ce2:	8803      	ldrh	r3, [r0, #0]
 8005ce4:	b29b      	uxth	r3, r3
 8005ce6:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8005cea:	8003      	strh	r3, [r0, #0]
 8005cec:	4770      	bx	lr

08005cee <SPI_GetCRC>:
{
  uint16_t crcreg = 0;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC(SPI_CRC));
  if (SPI_CRC != SPI_CRC_Rx)
 8005cee:	2901      	cmp	r1, #1
 8005cf0:	d002      	beq.n	8005cf8 <SPI_GetCRC+0xa>
  {
    /* Get the Tx CRC register */
    crcreg = SPIx->TXCRCR;
 8005cf2:	8b00      	ldrh	r0, [r0, #24]
 8005cf4:	b280      	uxth	r0, r0
 8005cf6:	4770      	bx	lr
  }
  else
  {
    /* Get the Rx CRC register */
    crcreg = SPIx->RXCRCR;
 8005cf8:	8a80      	ldrh	r0, [r0, #20]
 8005cfa:	b280      	uxth	r0, r0
  }
  /* Return the selected CRC register */
  return crcreg;
}
 8005cfc:	4770      	bx	lr

08005cfe <SPI_GetCRCPolynomial>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  
  /* Return the CRC polynomial register */
  return SPIx->CRCPR;
 8005cfe:	8a00      	ldrh	r0, [r0, #16]
}
 8005d00:	b280      	uxth	r0, r0
 8005d02:	4770      	bx	lr

08005d04 <SPI_I2S_DMACmd>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
 8005d04:	b92a      	cbnz	r2, 8005d12 <SPI_I2S_DMACmd+0xe>
    SPIx->CR2 |= SPI_I2S_DMAReq;
  }
  else
  {
    /* Disable the selected SPI DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 8005d06:	8883      	ldrh	r3, [r0, #4]
 8005d08:	43c9      	mvns	r1, r1
 8005d0a:	b289      	uxth	r1, r1
 8005d0c:	4019      	ands	r1, r3
 8005d0e:	8081      	strh	r1, [r0, #4]
 8005d10:	4770      	bx	lr
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8005d12:	8883      	ldrh	r3, [r0, #4]
 8005d14:	b29b      	uxth	r3, r3
 8005d16:	4319      	orrs	r1, r3
 8005d18:	8081      	strh	r1, [r0, #4]
 8005d1a:	4770      	bx	lr

08005d1c <SPI_I2S_ITConfig>:
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));

  /* Get the SPI IT index */
  itpos = SPI_I2S_IT >> 4;
 8005d1c:	090b      	lsrs	r3, r1, #4

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;
 8005d1e:	2101      	movs	r1, #1
 8005d20:	4099      	lsls	r1, r3
 8005d22:	b289      	uxth	r1, r1

  if (NewState != DISABLE)
 8005d24:	b92a      	cbnz	r2, 8005d32 <SPI_I2S_ITConfig+0x16>
    SPIx->CR2 |= itmask;
  }
  else
  {
    /* Disable the selected SPI interrupt */
    SPIx->CR2 &= (uint16_t)~itmask;
 8005d26:	8883      	ldrh	r3, [r0, #4]
 8005d28:	43c9      	mvns	r1, r1
 8005d2a:	b289      	uxth	r1, r1
 8005d2c:	4019      	ands	r1, r3
 8005d2e:	8081      	strh	r1, [r0, #4]
 8005d30:	4770      	bx	lr
    SPIx->CR2 |= itmask;
 8005d32:	8883      	ldrh	r3, [r0, #4]
 8005d34:	b29b      	uxth	r3, r3
 8005d36:	4319      	orrs	r1, r3
 8005d38:	8081      	strh	r1, [r0, #4]
 8005d3a:	4770      	bx	lr

08005d3c <SPI_I2S_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
  
  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 8005d3c:	8903      	ldrh	r3, [r0, #8]
 8005d3e:	4219      	tst	r1, r3
 8005d40:	d101      	bne.n	8005d46 <SPI_I2S_GetFlagStatus+0xa>
    bitstatus = SET;
  }
  else
  {
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
 8005d42:	2000      	movs	r0, #0
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
}
 8005d44:	4770      	bx	lr
    bitstatus = SET;
 8005d46:	2001      	movs	r0, #1
 8005d48:	4770      	bx	lr

08005d4a <SPI_I2S_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    
  /* Clear the selected SPI CRC Error (CRCERR) flag */
  SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
 8005d4a:	43c9      	mvns	r1, r1
 8005d4c:	b289      	uxth	r1, r1
 8005d4e:	8101      	strh	r1, [r0, #8]
 8005d50:	4770      	bx	lr

08005d52 <SPI_I2S_GetITStatus>:
  *            @arg I2S_IT_UDR: Underrun interrupt.  
  *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
  * @retval The new state of SPI_I2S_IT (SET or RESET).
  */
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 8005d52:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI_I2S_IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 8005d54:	f001 040f 	and.w	r4, r1, #15
 8005d58:	2301      	movs	r3, #1
 8005d5a:	fa03 f404 	lsl.w	r4, r3, r4

  /* Get the SPI_I2S_IT IT mask */
  itmask = SPI_I2S_IT >> 4;
 8005d5e:	0909      	lsrs	r1, r1, #4

  /* Set the IT mask */
  itmask = 0x01 << itmask;
 8005d60:	408b      	lsls	r3, r1

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 8005d62:	8881      	ldrh	r1, [r0, #4]
 8005d64:	b289      	uxth	r1, r1
 8005d66:	400b      	ands	r3, r1

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 8005d68:	8902      	ldrh	r2, [r0, #8]
 8005d6a:	b292      	uxth	r2, r2
 8005d6c:	4214      	tst	r4, r2
 8005d6e:	d002      	beq.n	8005d76 <SPI_I2S_GetITStatus+0x24>
 8005d70:	b92b      	cbnz	r3, 8005d7e <SPI_I2S_GetITStatus+0x2c>
    bitstatus = SET;
  }
  else
  {
    /* SPI_I2S_IT is reset */
    bitstatus = RESET;
 8005d72:	2000      	movs	r0, #0
 8005d74:	e000      	b.n	8005d78 <SPI_I2S_GetITStatus+0x26>
 8005d76:	2000      	movs	r0, #0
  }
  /* Return the SPI_I2S_IT status */
  return bitstatus;
}
 8005d78:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005d7c:	4770      	bx	lr
    bitstatus = SET;
 8005d7e:	2001      	movs	r0, #1
 8005d80:	e7fa      	b.n	8005d78 <SPI_I2S_GetITStatus+0x26>

08005d82 <SPI_I2S_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));

  /* Get the SPI_I2S IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 8005d82:	f001 010f 	and.w	r1, r1, #15
 8005d86:	2301      	movs	r3, #1
 8005d88:	408b      	lsls	r3, r1
 8005d8a:	b29b      	uxth	r3, r3

  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
  SPIx->SR = (uint16_t)~itpos;
 8005d8c:	43db      	mvns	r3, r3
 8005d8e:	b29b      	uxth	r3, r3
 8005d90:	8103      	strh	r3, [r0, #8]
 8005d92:	4770      	bx	lr

08005d94 <SYSCFG_DeInit>:
  *   registers to their default reset values.
  * @param  None
  * @retval None
  */
void SYSCFG_DeInit(void)
{
 8005d94:	b508      	push	{r3, lr}
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 8005d96:	2101      	movs	r1, #1
 8005d98:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8005d9c:	f7fe fe12 	bl	80049c4 <RCC_APB2PeriphResetCmd>
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
 8005da0:	2100      	movs	r1, #0
 8005da2:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8005da6:	f7fe fe0d 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 8005daa:	bd08      	pop	{r3, pc}

08005dac <SYSCFG_MemoryRemapConfig>:
void SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_MEMORY_REMAP_CONFING(SYSCFG_MemoryRemap));

  SYSCFG->MEMRMP = SYSCFG_MemoryRemap;
 8005dac:	4b01      	ldr	r3, [pc, #4]	; (8005db4 <SYSCFG_MemoryRemapConfig+0x8>)
 8005dae:	6018      	str	r0, [r3, #0]
 8005db0:	4770      	bx	lr
 8005db2:	bf00      	nop
 8005db4:	40013800 	.word	0x40013800

08005db8 <SYSCFG_EXTILineConfig>:
  *           and STM32F427x/STM32F437x devices. 
  *             
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 8005db8:	b430      	push	{r4, r5}

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 8005dba:	f001 0303 	and.w	r3, r1, #3
 8005dbe:	009b      	lsls	r3, r3, #2
 8005dc0:	240f      	movs	r4, #15
 8005dc2:	fa04 f503 	lsl.w	r5, r4, r3
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 8005dc6:	0889      	lsrs	r1, r1, #2
 8005dc8:	4a07      	ldr	r2, [pc, #28]	; (8005de8 <SYSCFG_EXTILineConfig+0x30>)
 8005dca:	3102      	adds	r1, #2
 8005dcc:	f852 4021 	ldr.w	r4, [r2, r1, lsl #2]
 8005dd0:	ea24 0405 	bic.w	r4, r4, r5
 8005dd4:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 8005dd8:	f852 4021 	ldr.w	r4, [r2, r1, lsl #2]
 8005ddc:	4098      	lsls	r0, r3
 8005dde:	4320      	orrs	r0, r4
 8005de0:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
}
 8005de4:	bc30      	pop	{r4, r5}
 8005de6:	4770      	bx	lr
 8005de8:	40013800 	.word	0x40013800

08005dec <SYSCFG_ETH_MediaInterfaceConfig>:
  */
void SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface) 
{ 
  assert_param(IS_SYSCFG_ETH_MEDIA_INTERFACE(SYSCFG_ETH_MediaInterface)); 
  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) PMC_MII_RMII_SEL_BB = SYSCFG_ETH_MediaInterface; 
 8005dec:	4b01      	ldr	r3, [pc, #4]	; (8005df4 <SYSCFG_ETH_MediaInterfaceConfig+0x8>)
 8005dee:	6018      	str	r0, [r3, #0]
 8005df0:	4770      	bx	lr
 8005df2:	bf00      	nop
 8005df4:	422700dc 	.word	0x422700dc

08005df8 <SYSCFG_CompensationCellCmd>:
void SYSCFG_CompensationCellCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CMPCR_CMP_PD_BB = (uint32_t)NewState;
 8005df8:	4b01      	ldr	r3, [pc, #4]	; (8005e00 <SYSCFG_CompensationCellCmd+0x8>)
 8005dfa:	6018      	str	r0, [r3, #0]
 8005dfc:	4770      	bx	lr
 8005dfe:	bf00      	nop
 8005e00:	42270400 	.word	0x42270400

08005e04 <SYSCFG_GetCompensationCellStatus>:
  */
FlagStatus SYSCFG_GetCompensationCellStatus(void)
{
  FlagStatus bitstatus = RESET;
    
  if ((SYSCFG->CMPCR & SYSCFG_CMPCR_READY ) != (uint32_t)RESET)
 8005e04:	4b04      	ldr	r3, [pc, #16]	; (8005e18 <SYSCFG_GetCompensationCellStatus+0x14>)
 8005e06:	6a1b      	ldr	r3, [r3, #32]
 8005e08:	f413 7f80 	tst.w	r3, #256	; 0x100
 8005e0c:	d101      	bne.n	8005e12 <SYSCFG_GetCompensationCellStatus+0xe>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8005e0e:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 8005e10:	4770      	bx	lr
    bitstatus = SET;
 8005e12:	2001      	movs	r0, #1
 8005e14:	4770      	bx	lr
 8005e16:	bf00      	nop
 8005e18:	40013800 	.word	0x40013800

08005e1c <TI1_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8005e1c:	b430      	push	{r4, r5}
  uint16_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 8005e1e:	8c04      	ldrh	r4, [r0, #32]
 8005e20:	b2a4      	uxth	r4, r4
 8005e22:	f024 0401 	bic.w	r4, r4, #1
 8005e26:	b2a4      	uxth	r4, r4
 8005e28:	8404      	strh	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8005e2a:	8b05      	ldrh	r5, [r0, #24]
 8005e2c:	b2ad      	uxth	r5, r5
  tmpccer = TIMx->CCER;
 8005e2e:	8c04      	ldrh	r4, [r0, #32]
 8005e30:	b2a4      	uxth	r4, r4

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
 8005e32:	f025 05f3 	bic.w	r5, r5, #243	; 0xf3
  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8005e36:	011b      	lsls	r3, r3, #4
 8005e38:	b29b      	uxth	r3, r3
 8005e3a:	431a      	orrs	r2, r3
 8005e3c:	4315      	orrs	r5, r2

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8005e3e:	f024 040a 	bic.w	r4, r4, #10
  tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
 8005e42:	430c      	orrs	r4, r1
 8005e44:	f044 0401 	orr.w	r4, r4, #1

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8005e48:	8305      	strh	r5, [r0, #24]
  TIMx->CCER = tmpccer;
 8005e4a:	8404      	strh	r4, [r0, #32]
}
 8005e4c:	bc30      	pop	{r4, r5}
 8005e4e:	4770      	bx	lr

08005e50 <TI2_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8005e50:	b430      	push	{r4, r5}
  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 8005e52:	8c04      	ldrh	r4, [r0, #32]
 8005e54:	b2a4      	uxth	r4, r4
 8005e56:	f024 0410 	bic.w	r4, r4, #16
 8005e5a:	b2a4      	uxth	r4, r4
 8005e5c:	8404      	strh	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8005e5e:	8b05      	ldrh	r5, [r0, #24]
  tmpccer = TIMx->CCER;
 8005e60:	8c04      	ldrh	r4, [r0, #32]
 8005e62:	b2a4      	uxth	r4, r4
  tmp = (uint16_t)(TIM_ICPolarity << 4);
 8005e64:	0109      	lsls	r1, r1, #4
 8005e66:	b289      	uxth	r1, r1

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 8005e68:	f425 7540 	bic.w	r5, r5, #768	; 0x300
 8005e6c:	052d      	lsls	r5, r5, #20
 8005e6e:	0d2d      	lsrs	r5, r5, #20
  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
 8005e70:	031b      	lsls	r3, r3, #12
 8005e72:	b29b      	uxth	r3, r3
 8005e74:	431d      	orrs	r5, r3
  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
 8005e76:	0212      	lsls	r2, r2, #8
 8005e78:	b292      	uxth	r2, r2
 8005e7a:	4315      	orrs	r5, r2

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8005e7c:	f024 04a0 	bic.w	r4, r4, #160	; 0xa0
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8005e80:	430c      	orrs	r4, r1
 8005e82:	f044 0410 	orr.w	r4, r4, #16

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8005e86:	8305      	strh	r5, [r0, #24]
  TIMx->CCER = tmpccer;
 8005e88:	8404      	strh	r4, [r0, #32]
}
 8005e8a:	bc30      	pop	{r4, r5}
 8005e8c:	4770      	bx	lr

08005e8e <TI3_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8005e8e:	b430      	push	{r4, r5}
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 8005e90:	8c04      	ldrh	r4, [r0, #32]
 8005e92:	b2a4      	uxth	r4, r4
 8005e94:	f424 7480 	bic.w	r4, r4, #256	; 0x100
 8005e98:	b2a4      	uxth	r4, r4
 8005e9a:	8404      	strh	r4, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 8005e9c:	8b85      	ldrh	r5, [r0, #28]
 8005e9e:	b2ad      	uxth	r5, r5
  tmpccer = TIMx->CCER;
 8005ea0:	8c04      	ldrh	r4, [r0, #32]
 8005ea2:	b2a4      	uxth	r4, r4
  tmp = (uint16_t)(TIM_ICPolarity << 8);
 8005ea4:	0209      	lsls	r1, r1, #8
 8005ea6:	b289      	uxth	r1, r1

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
 8005ea8:	f025 05f3 	bic.w	r5, r5, #243	; 0xf3
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8005eac:	011b      	lsls	r3, r3, #4
 8005eae:	b29b      	uxth	r3, r3
 8005eb0:	431a      	orrs	r2, r3
 8005eb2:	4315      	orrs	r5, r2

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 8005eb4:	f424 6420 	bic.w	r4, r4, #2560	; 0xa00
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 8005eb8:	430c      	orrs	r4, r1
 8005eba:	f444 7480 	orr.w	r4, r4, #256	; 0x100

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8005ebe:	8385      	strh	r5, [r0, #28]
  TIMx->CCER = tmpccer;
 8005ec0:	8404      	strh	r4, [r0, #32]
}
 8005ec2:	bc30      	pop	{r4, r5}
 8005ec4:	4770      	bx	lr

08005ec6 <TI4_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8005ec6:	b430      	push	{r4, r5}
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 8005ec8:	8c04      	ldrh	r4, [r0, #32]
 8005eca:	b2a4      	uxth	r4, r4
 8005ecc:	f424 5480 	bic.w	r4, r4, #4096	; 0x1000
 8005ed0:	b2a4      	uxth	r4, r4
 8005ed2:	8404      	strh	r4, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 8005ed4:	8b84      	ldrh	r4, [r0, #28]
  tmpccer = TIMx->CCER;
 8005ed6:	8c05      	ldrh	r5, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 12);
 8005ed8:	0309      	lsls	r1, r1, #12
 8005eda:	b289      	uxth	r1, r1

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 8005edc:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 8005ee0:	0524      	lsls	r4, r4, #20
 8005ee2:	0d24      	lsrs	r4, r4, #20
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 8005ee4:	0212      	lsls	r2, r2, #8
 8005ee6:	b292      	uxth	r2, r2
 8005ee8:	4314      	orrs	r4, r2
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);
 8005eea:	031b      	lsls	r3, r3, #12
 8005eec:	b29b      	uxth	r3, r3
 8005eee:	431c      	orrs	r4, r3

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 8005ef0:	f425 5500 	bic.w	r5, r5, #8192	; 0x2000
 8005ef4:	046d      	lsls	r5, r5, #17
 8005ef6:	0c6d      	lsrs	r5, r5, #17
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 8005ef8:	4329      	orrs	r1, r5
 8005efa:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8005efe:	8384      	strh	r4, [r0, #28]
  TIMx->CCER = tmpccer ;
 8005f00:	8401      	strh	r1, [r0, #32]
}
 8005f02:	bc30      	pop	{r4, r5}
 8005f04:	4770      	bx	lr

08005f06 <TIM_DeInit>:
{
 8005f06:	b508      	push	{r3, lr}
  if (TIMx == TIM1)
 8005f08:	4b58      	ldr	r3, [pc, #352]	; (800606c <TIM_DeInit+0x166>)
 8005f0a:	4298      	cmp	r0, r3
 8005f0c:	d027      	beq.n	8005f5e <TIM_DeInit+0x58>
  else if (TIMx == TIM2) 
 8005f0e:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8005f12:	d02d      	beq.n	8005f70 <TIM_DeInit+0x6a>
  else if (TIMx == TIM3)
 8005f14:	4b56      	ldr	r3, [pc, #344]	; (8006070 <TIM_DeInit+0x16a>)
 8005f16:	4298      	cmp	r0, r3
 8005f18:	d033      	beq.n	8005f82 <TIM_DeInit+0x7c>
  else if (TIMx == TIM4)
 8005f1a:	4b56      	ldr	r3, [pc, #344]	; (8006074 <TIM_DeInit+0x16e>)
 8005f1c:	4298      	cmp	r0, r3
 8005f1e:	d039      	beq.n	8005f94 <TIM_DeInit+0x8e>
  else if (TIMx == TIM5)
 8005f20:	4b55      	ldr	r3, [pc, #340]	; (8006078 <TIM_DeInit+0x172>)
 8005f22:	4298      	cmp	r0, r3
 8005f24:	d03f      	beq.n	8005fa6 <TIM_DeInit+0xa0>
  else if (TIMx == TIM6)  
 8005f26:	4b55      	ldr	r3, [pc, #340]	; (800607c <TIM_DeInit+0x176>)
 8005f28:	4298      	cmp	r0, r3
 8005f2a:	d045      	beq.n	8005fb8 <TIM_DeInit+0xb2>
  else if (TIMx == TIM7)
 8005f2c:	4b54      	ldr	r3, [pc, #336]	; (8006080 <TIM_DeInit+0x17a>)
 8005f2e:	4298      	cmp	r0, r3
 8005f30:	d04b      	beq.n	8005fca <TIM_DeInit+0xc4>
  else if (TIMx == TIM8)
 8005f32:	4b54      	ldr	r3, [pc, #336]	; (8006084 <TIM_DeInit+0x17e>)
 8005f34:	4298      	cmp	r0, r3
 8005f36:	d051      	beq.n	8005fdc <TIM_DeInit+0xd6>
  else if (TIMx == TIM9)
 8005f38:	4b53      	ldr	r3, [pc, #332]	; (8006088 <TIM_DeInit+0x182>)
 8005f3a:	4298      	cmp	r0, r3
 8005f3c:	d057      	beq.n	8005fee <TIM_DeInit+0xe8>
  else if (TIMx == TIM10)
 8005f3e:	4b53      	ldr	r3, [pc, #332]	; (800608c <TIM_DeInit+0x186>)
 8005f40:	4298      	cmp	r0, r3
 8005f42:	d05f      	beq.n	8006004 <TIM_DeInit+0xfe>
  else if (TIMx == TIM11) 
 8005f44:	4b52      	ldr	r3, [pc, #328]	; (8006090 <TIM_DeInit+0x18a>)
 8005f46:	4298      	cmp	r0, r3
 8005f48:	d067      	beq.n	800601a <TIM_DeInit+0x114>
  else if (TIMx == TIM12)
 8005f4a:	4b52      	ldr	r3, [pc, #328]	; (8006094 <TIM_DeInit+0x18e>)
 8005f4c:	4298      	cmp	r0, r3
 8005f4e:	d06f      	beq.n	8006030 <TIM_DeInit+0x12a>
  else if (TIMx == TIM13) 
 8005f50:	4b51      	ldr	r3, [pc, #324]	; (8006098 <TIM_DeInit+0x192>)
 8005f52:	4298      	cmp	r0, r3
 8005f54:	d075      	beq.n	8006042 <TIM_DeInit+0x13c>
    if (TIMx == TIM14) 
 8005f56:	4b51      	ldr	r3, [pc, #324]	; (800609c <TIM_DeInit+0x196>)
 8005f58:	4298      	cmp	r0, r3
 8005f5a:	d07b      	beq.n	8006054 <TIM_DeInit+0x14e>
 8005f5c:	bd08      	pop	{r3, pc}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
 8005f5e:	2101      	movs	r1, #1
 8005f60:	4608      	mov	r0, r1
 8005f62:	f7fe fd2f 	bl	80049c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
 8005f66:	2100      	movs	r1, #0
 8005f68:	2001      	movs	r0, #1
 8005f6a:	f7fe fd2b 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 8005f6e:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
 8005f70:	2101      	movs	r1, #1
 8005f72:	4608      	mov	r0, r1
 8005f74:	f7fe fd18 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
 8005f78:	2100      	movs	r1, #0
 8005f7a:	2001      	movs	r0, #1
 8005f7c:	f7fe fd14 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8005f80:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
 8005f82:	2101      	movs	r1, #1
 8005f84:	2002      	movs	r0, #2
 8005f86:	f7fe fd0f 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 8005f8a:	2100      	movs	r1, #0
 8005f8c:	2002      	movs	r0, #2
 8005f8e:	f7fe fd0b 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8005f92:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
 8005f94:	2101      	movs	r1, #1
 8005f96:	2004      	movs	r0, #4
 8005f98:	f7fe fd06 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
 8005f9c:	2100      	movs	r1, #0
 8005f9e:	2004      	movs	r0, #4
 8005fa0:	f7fe fd02 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8005fa4:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
 8005fa6:	2101      	movs	r1, #1
 8005fa8:	2008      	movs	r0, #8
 8005faa:	f7fe fcfd 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
 8005fae:	2100      	movs	r1, #0
 8005fb0:	2008      	movs	r0, #8
 8005fb2:	f7fe fcf9 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8005fb6:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
 8005fb8:	2101      	movs	r1, #1
 8005fba:	2010      	movs	r0, #16
 8005fbc:	f7fe fcf4 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
 8005fc0:	2100      	movs	r1, #0
 8005fc2:	2010      	movs	r0, #16
 8005fc4:	f7fe fcf0 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8005fc8:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
 8005fca:	2101      	movs	r1, #1
 8005fcc:	2020      	movs	r0, #32
 8005fce:	f7fe fceb 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
 8005fd2:	2100      	movs	r1, #0
 8005fd4:	2020      	movs	r0, #32
 8005fd6:	f7fe fce7 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8005fda:	bd08      	pop	{r3, pc}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
 8005fdc:	2101      	movs	r1, #1
 8005fde:	2002      	movs	r0, #2
 8005fe0:	f7fe fcf0 	bl	80049c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
 8005fe4:	2100      	movs	r1, #0
 8005fe6:	2002      	movs	r0, #2
 8005fe8:	f7fe fcec 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 8005fec:	bd08      	pop	{r3, pc}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
 8005fee:	2101      	movs	r1, #1
 8005ff0:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8005ff4:	f7fe fce6 	bl	80049c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
 8005ff8:	2100      	movs	r1, #0
 8005ffa:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8005ffe:	f7fe fce1 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 8006002:	bd08      	pop	{r3, pc}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
 8006004:	2101      	movs	r1, #1
 8006006:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800600a:	f7fe fcdb 	bl	80049c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
 800600e:	2100      	movs	r1, #0
 8006010:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8006014:	f7fe fcd6 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 8006018:	bd08      	pop	{r3, pc}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
 800601a:	2101      	movs	r1, #1
 800601c:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8006020:	f7fe fcd0 	bl	80049c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
 8006024:	2100      	movs	r1, #0
 8006026:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800602a:	f7fe fccb 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 800602e:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
 8006030:	2101      	movs	r1, #1
 8006032:	2040      	movs	r0, #64	; 0x40
 8006034:	f7fe fcb8 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
 8006038:	2100      	movs	r1, #0
 800603a:	2040      	movs	r0, #64	; 0x40
 800603c:	f7fe fcb4 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8006040:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
 8006042:	2101      	movs	r1, #1
 8006044:	2080      	movs	r0, #128	; 0x80
 8006046:	f7fe fcaf 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
 800604a:	2100      	movs	r1, #0
 800604c:	2080      	movs	r0, #128	; 0x80
 800604e:	f7fe fcab 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8006052:	bd08      	pop	{r3, pc}
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
 8006054:	2101      	movs	r1, #1
 8006056:	f44f 7080 	mov.w	r0, #256	; 0x100
 800605a:	f7fe fca5 	bl	80049a8 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
 800605e:	2100      	movs	r1, #0
 8006060:	f44f 7080 	mov.w	r0, #256	; 0x100
 8006064:	f7fe fca0 	bl	80049a8 <RCC_APB1PeriphResetCmd>
}
 8006068:	e778      	b.n	8005f5c <TIM_DeInit+0x56>
 800606a:	bf00      	nop
 800606c:	40010000 	.word	0x40010000
 8006070:	40000400 	.word	0x40000400
 8006074:	40000800 	.word	0x40000800
 8006078:	40000c00 	.word	0x40000c00
 800607c:	40001000 	.word	0x40001000
 8006080:	40001400 	.word	0x40001400
 8006084:	40010400 	.word	0x40010400
 8006088:	40014000 	.word	0x40014000
 800608c:	40014400 	.word	0x40014400
 8006090:	40014800 	.word	0x40014800
 8006094:	40001800 	.word	0x40001800
 8006098:	40001c00 	.word	0x40001c00
 800609c:	40002000 	.word	0x40002000

080060a0 <TIM_TimeBaseInit>:
  tmpcr1 = TIMx->CR1;  
 80060a0:	8803      	ldrh	r3, [r0, #0]
 80060a2:	b29b      	uxth	r3, r3
  if((TIMx == TIM1) || (TIMx == TIM8)||
 80060a4:	4a1b      	ldr	r2, [pc, #108]	; (8006114 <TIM_TimeBaseInit+0x74>)
 80060a6:	4290      	cmp	r0, r2
 80060a8:	d012      	beq.n	80060d0 <TIM_TimeBaseInit+0x30>
 80060aa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80060ae:	4290      	cmp	r0, r2
 80060b0:	d00e      	beq.n	80060d0 <TIM_TimeBaseInit+0x30>
 80060b2:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80060b6:	d00b      	beq.n	80060d0 <TIM_TimeBaseInit+0x30>
     (TIMx == TIM2) || (TIMx == TIM3)||
 80060b8:	f5a2 3280 	sub.w	r2, r2, #65536	; 0x10000
 80060bc:	4290      	cmp	r0, r2
 80060be:	d007      	beq.n	80060d0 <TIM_TimeBaseInit+0x30>
 80060c0:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80060c4:	4290      	cmp	r0, r2
 80060c6:	d003      	beq.n	80060d0 <TIM_TimeBaseInit+0x30>
     (TIMx == TIM4) || (TIMx == TIM5)) 
 80060c8:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80060cc:	4290      	cmp	r0, r2
 80060ce:	d103      	bne.n	80060d8 <TIM_TimeBaseInit+0x38>
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 80060d0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 80060d4:	884a      	ldrh	r2, [r1, #2]
 80060d6:	4313      	orrs	r3, r2
  if((TIMx != TIM6) && (TIMx != TIM7))
 80060d8:	4a0f      	ldr	r2, [pc, #60]	; (8006118 <TIM_TimeBaseInit+0x78>)
 80060da:	4290      	cmp	r0, r2
 80060dc:	d008      	beq.n	80060f0 <TIM_TimeBaseInit+0x50>
 80060de:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80060e2:	4290      	cmp	r0, r2
 80060e4:	d004      	beq.n	80060f0 <TIM_TimeBaseInit+0x50>
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 80060e6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80060ea:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 80060ec:	890a      	ldrh	r2, [r1, #8]
 80060ee:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
 80060f0:	8003      	strh	r3, [r0, #0]
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 80060f2:	684b      	ldr	r3, [r1, #4]
 80060f4:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 80060f6:	880b      	ldrh	r3, [r1, #0]
 80060f8:	8503      	strh	r3, [r0, #40]	; 0x28
  if ((TIMx == TIM1) || (TIMx == TIM8))  
 80060fa:	4b06      	ldr	r3, [pc, #24]	; (8006114 <TIM_TimeBaseInit+0x74>)
 80060fc:	4298      	cmp	r0, r3
 80060fe:	d006      	beq.n	800610e <TIM_TimeBaseInit+0x6e>
 8006100:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8006104:	4298      	cmp	r0, r3
 8006106:	d002      	beq.n	800610e <TIM_TimeBaseInit+0x6e>
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 8006108:	2301      	movs	r3, #1
 800610a:	8283      	strh	r3, [r0, #20]
 800610c:	4770      	bx	lr
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 800610e:	7a8b      	ldrb	r3, [r1, #10]
 8006110:	8603      	strh	r3, [r0, #48]	; 0x30
 8006112:	e7f9      	b.n	8006108 <TIM_TimeBaseInit+0x68>
 8006114:	40010000 	.word	0x40010000
 8006118:	40001000 	.word	0x40001000

0800611c <TIM_TimeBaseStructInit>:
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
 800611c:	f04f 33ff 	mov.w	r3, #4294967295
 8006120:	6043      	str	r3, [r0, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 8006122:	2300      	movs	r3, #0
 8006124:	8003      	strh	r3, [r0, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 8006126:	8103      	strh	r3, [r0, #8]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 8006128:	8043      	strh	r3, [r0, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 800612a:	7283      	strb	r3, [r0, #10]
 800612c:	4770      	bx	lr

0800612e <TIM_PrescalerConfig>:
  TIMx->PSC = Prescaler;
 800612e:	8501      	strh	r1, [r0, #40]	; 0x28
  TIMx->EGR = TIM_PSCReloadMode;
 8006130:	8282      	strh	r2, [r0, #20]
 8006132:	4770      	bx	lr

08006134 <TIM_CounterModeConfig>:
  tmpcr1 = TIMx->CR1;
 8006134:	8803      	ldrh	r3, [r0, #0]
 8006136:	b29b      	uxth	r3, r3
  tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
 8006138:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpcr1 |= TIM_CounterMode;
 800613c:	4319      	orrs	r1, r3
  TIMx->CR1 = tmpcr1;
 800613e:	8001      	strh	r1, [r0, #0]
 8006140:	4770      	bx	lr

08006142 <TIM_SetCounter>:
  TIMx->CNT = Counter;
 8006142:	6241      	str	r1, [r0, #36]	; 0x24
 8006144:	4770      	bx	lr

08006146 <TIM_SetAutoreload>:
  TIMx->ARR = Autoreload;
 8006146:	62c1      	str	r1, [r0, #44]	; 0x2c
 8006148:	4770      	bx	lr

0800614a <TIM_GetCounter>:
  return TIMx->CNT;
 800614a:	6a40      	ldr	r0, [r0, #36]	; 0x24
}
 800614c:	4770      	bx	lr

0800614e <TIM_GetPrescaler>:
  return TIMx->PSC;
 800614e:	8d00      	ldrh	r0, [r0, #40]	; 0x28
}
 8006150:	b280      	uxth	r0, r0
 8006152:	4770      	bx	lr

08006154 <TIM_UpdateDisableConfig>:
  if (NewState != DISABLE)
 8006154:	b931      	cbnz	r1, 8006164 <TIM_UpdateDisableConfig+0x10>
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
 8006156:	8803      	ldrh	r3, [r0, #0]
 8006158:	b29b      	uxth	r3, r3
 800615a:	f023 0302 	bic.w	r3, r3, #2
 800615e:	b29b      	uxth	r3, r3
 8006160:	8003      	strh	r3, [r0, #0]
 8006162:	4770      	bx	lr
    TIMx->CR1 |= TIM_CR1_UDIS;
 8006164:	8803      	ldrh	r3, [r0, #0]
 8006166:	b29b      	uxth	r3, r3
 8006168:	f043 0302 	orr.w	r3, r3, #2
 800616c:	8003      	strh	r3, [r0, #0]
 800616e:	4770      	bx	lr

08006170 <TIM_UpdateRequestConfig>:
  if (TIM_UpdateSource != TIM_UpdateSource_Global)
 8006170:	b931      	cbnz	r1, 8006180 <TIM_UpdateRequestConfig+0x10>
    TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
 8006172:	8803      	ldrh	r3, [r0, #0]
 8006174:	b29b      	uxth	r3, r3
 8006176:	f023 0304 	bic.w	r3, r3, #4
 800617a:	b29b      	uxth	r3, r3
 800617c:	8003      	strh	r3, [r0, #0]
 800617e:	4770      	bx	lr
    TIMx->CR1 |= TIM_CR1_URS;
 8006180:	8803      	ldrh	r3, [r0, #0]
 8006182:	b29b      	uxth	r3, r3
 8006184:	f043 0304 	orr.w	r3, r3, #4
 8006188:	8003      	strh	r3, [r0, #0]
 800618a:	4770      	bx	lr

0800618c <TIM_ARRPreloadConfig>:
  if (NewState != DISABLE)
 800618c:	b931      	cbnz	r1, 800619c <TIM_ARRPreloadConfig+0x10>
    TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
 800618e:	8803      	ldrh	r3, [r0, #0]
 8006190:	b29b      	uxth	r3, r3
 8006192:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8006196:	b29b      	uxth	r3, r3
 8006198:	8003      	strh	r3, [r0, #0]
 800619a:	4770      	bx	lr
    TIMx->CR1 |= TIM_CR1_ARPE;
 800619c:	8803      	ldrh	r3, [r0, #0]
 800619e:	b29b      	uxth	r3, r3
 80061a0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80061a4:	8003      	strh	r3, [r0, #0]
 80061a6:	4770      	bx	lr

080061a8 <TIM_SelectOnePulseMode>:
  TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
 80061a8:	8803      	ldrh	r3, [r0, #0]
 80061aa:	b29b      	uxth	r3, r3
 80061ac:	f023 0308 	bic.w	r3, r3, #8
 80061b0:	b29b      	uxth	r3, r3
 80061b2:	8003      	strh	r3, [r0, #0]
  TIMx->CR1 |= TIM_OPMode;
 80061b4:	8803      	ldrh	r3, [r0, #0]
 80061b6:	b29b      	uxth	r3, r3
 80061b8:	4319      	orrs	r1, r3
 80061ba:	8001      	strh	r1, [r0, #0]
 80061bc:	4770      	bx	lr

080061be <TIM_SetClockDivision>:
  TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
 80061be:	8803      	ldrh	r3, [r0, #0]
 80061c0:	b29b      	uxth	r3, r3
 80061c2:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80061c6:	b29b      	uxth	r3, r3
 80061c8:	8003      	strh	r3, [r0, #0]
  TIMx->CR1 |= TIM_CKD;
 80061ca:	8803      	ldrh	r3, [r0, #0]
 80061cc:	b29b      	uxth	r3, r3
 80061ce:	4319      	orrs	r1, r3
 80061d0:	8001      	strh	r1, [r0, #0]
 80061d2:	4770      	bx	lr

080061d4 <TIM_Cmd>:
  if (NewState != DISABLE)
 80061d4:	b931      	cbnz	r1, 80061e4 <TIM_Cmd+0x10>
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 80061d6:	8803      	ldrh	r3, [r0, #0]
 80061d8:	b29b      	uxth	r3, r3
 80061da:	f023 0301 	bic.w	r3, r3, #1
 80061de:	b29b      	uxth	r3, r3
 80061e0:	8003      	strh	r3, [r0, #0]
 80061e2:	4770      	bx	lr
    TIMx->CR1 |= TIM_CR1_CEN;
 80061e4:	8803      	ldrh	r3, [r0, #0]
 80061e6:	b29b      	uxth	r3, r3
 80061e8:	f043 0301 	orr.w	r3, r3, #1
 80061ec:	8003      	strh	r3, [r0, #0]
 80061ee:	4770      	bx	lr

080061f0 <TIM_OC1Init>:
{
 80061f0:	b430      	push	{r4, r5}
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 80061f2:	8c03      	ldrh	r3, [r0, #32]
 80061f4:	b29b      	uxth	r3, r3
 80061f6:	f023 0301 	bic.w	r3, r3, #1
 80061fa:	b29b      	uxth	r3, r3
 80061fc:	8403      	strh	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 80061fe:	8c03      	ldrh	r3, [r0, #32]
 8006200:	b29b      	uxth	r3, r3
  tmpcr2 =  TIMx->CR2;
 8006202:	8884      	ldrh	r4, [r0, #4]
 8006204:	b2a4      	uxth	r4, r4
  tmpccmrx = TIMx->CCMR1;
 8006206:	8b02      	ldrh	r2, [r0, #24]
 8006208:	b292      	uxth	r2, r2
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
 800620a:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 800620e:	880d      	ldrh	r5, [r1, #0]
 8006210:	432a      	orrs	r2, r5
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
 8006212:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8006216:	898d      	ldrh	r5, [r1, #12]
 8006218:	432b      	orrs	r3, r5
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 800621a:	884d      	ldrh	r5, [r1, #2]
 800621c:	432b      	orrs	r3, r5
  if((TIMx == TIM1) || (TIMx == TIM8))
 800621e:	4d0e      	ldr	r5, [pc, #56]	; (8006258 <TIM_OC1Init+0x68>)
 8006220:	42a8      	cmp	r0, r5
 8006222:	d00a      	beq.n	800623a <TIM_OC1Init+0x4a>
 8006224:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8006228:	42a8      	cmp	r0, r5
 800622a:	d006      	beq.n	800623a <TIM_OC1Init+0x4a>
  TIMx->CR2 = tmpcr2;
 800622c:	8084      	strh	r4, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 800622e:	8302      	strh	r2, [r0, #24]
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 8006230:	688a      	ldr	r2, [r1, #8]
 8006232:	6342      	str	r2, [r0, #52]	; 0x34
  TIMx->CCER = tmpccer;
 8006234:	8403      	strh	r3, [r0, #32]
}
 8006236:	bc30      	pop	{r4, r5}
 8006238:	4770      	bx	lr
    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 800623a:	f023 0308 	bic.w	r3, r3, #8
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 800623e:	89cd      	ldrh	r5, [r1, #14]
 8006240:	432b      	orrs	r3, r5
    tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
 8006242:	f023 0304 	bic.w	r3, r3, #4
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8006246:	888d      	ldrh	r5, [r1, #4]
 8006248:	432b      	orrs	r3, r5
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
 800624a:	f424 7440 	bic.w	r4, r4, #768	; 0x300
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 800624e:	8a0d      	ldrh	r5, [r1, #16]
 8006250:	432c      	orrs	r4, r5
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 8006252:	8a4d      	ldrh	r5, [r1, #18]
 8006254:	432c      	orrs	r4, r5
 8006256:	e7e9      	b.n	800622c <TIM_OC1Init+0x3c>
 8006258:	40010000 	.word	0x40010000

0800625c <TIM_OC2Init>:
{
 800625c:	b430      	push	{r4, r5}
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 800625e:	8c03      	ldrh	r3, [r0, #32]
 8006260:	b29b      	uxth	r3, r3
 8006262:	f023 0310 	bic.w	r3, r3, #16
 8006266:	b29b      	uxth	r3, r3
 8006268:	8403      	strh	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 800626a:	8c03      	ldrh	r3, [r0, #32]
 800626c:	b29b      	uxth	r3, r3
  tmpcr2 =  TIMx->CR2;
 800626e:	8885      	ldrh	r5, [r0, #4]
 8006270:	b2ad      	uxth	r5, r5
  tmpccmrx = TIMx->CCMR1;
 8006272:	8b02      	ldrh	r2, [r0, #24]
 8006274:	b292      	uxth	r2, r2
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
 8006276:	f422 44e6 	bic.w	r4, r2, #29440	; 0x7300
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 800627a:	880a      	ldrh	r2, [r1, #0]
 800627c:	0212      	lsls	r2, r2, #8
 800627e:	b292      	uxth	r2, r2
 8006280:	4322      	orrs	r2, r4
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
 8006282:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 8006286:	898c      	ldrh	r4, [r1, #12]
 8006288:	0124      	lsls	r4, r4, #4
 800628a:	b2a4      	uxth	r4, r4
 800628c:	4323      	orrs	r3, r4
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 800628e:	884c      	ldrh	r4, [r1, #2]
 8006290:	0124      	lsls	r4, r4, #4
 8006292:	b2a4      	uxth	r4, r4
 8006294:	4323      	orrs	r3, r4
  if((TIMx == TIM1) || (TIMx == TIM8))
 8006296:	4c12      	ldr	r4, [pc, #72]	; (80062e0 <TIM_OC2Init+0x84>)
 8006298:	42a0      	cmp	r0, r4
 800629a:	d00a      	beq.n	80062b2 <TIM_OC2Init+0x56>
 800629c:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 80062a0:	42a0      	cmp	r0, r4
 80062a2:	d006      	beq.n	80062b2 <TIM_OC2Init+0x56>
  TIMx->CR2 = tmpcr2;
 80062a4:	8085      	strh	r5, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 80062a6:	8302      	strh	r2, [r0, #24]
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 80062a8:	688a      	ldr	r2, [r1, #8]
 80062aa:	6382      	str	r2, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 80062ac:	8403      	strh	r3, [r0, #32]
}
 80062ae:	bc30      	pop	{r4, r5}
 80062b0:	4770      	bx	lr
    tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 80062b2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 80062b6:	89cc      	ldrh	r4, [r1, #14]
 80062b8:	0124      	lsls	r4, r4, #4
 80062ba:	b2a4      	uxth	r4, r4
 80062bc:	4323      	orrs	r3, r4
    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
 80062be:	f023 0440 	bic.w	r4, r3, #64	; 0x40
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 80062c2:	888b      	ldrh	r3, [r1, #4]
 80062c4:	011b      	lsls	r3, r3, #4
 80062c6:	b29b      	uxth	r3, r3
 80062c8:	4323      	orrs	r3, r4
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
 80062ca:	f425 6540 	bic.w	r5, r5, #3072	; 0xc00
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 80062ce:	8a0c      	ldrh	r4, [r1, #16]
 80062d0:	00a4      	lsls	r4, r4, #2
 80062d2:	b2a4      	uxth	r4, r4
 80062d4:	4325      	orrs	r5, r4
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 80062d6:	8a4c      	ldrh	r4, [r1, #18]
 80062d8:	00a4      	lsls	r4, r4, #2
 80062da:	b2a4      	uxth	r4, r4
 80062dc:	4325      	orrs	r5, r4
 80062de:	e7e1      	b.n	80062a4 <TIM_OC2Init+0x48>
 80062e0:	40010000 	.word	0x40010000

080062e4 <TIM_OC3Init>:
{
 80062e4:	b430      	push	{r4, r5}
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 80062e6:	8c03      	ldrh	r3, [r0, #32]
 80062e8:	b29b      	uxth	r3, r3
 80062ea:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80062ee:	b29b      	uxth	r3, r3
 80062f0:	8403      	strh	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 80062f2:	8c03      	ldrh	r3, [r0, #32]
 80062f4:	b29b      	uxth	r3, r3
  tmpcr2 =  TIMx->CR2;
 80062f6:	8885      	ldrh	r5, [r0, #4]
 80062f8:	b2ad      	uxth	r5, r5
  tmpccmrx = TIMx->CCMR2;
 80062fa:	8b82      	ldrh	r2, [r0, #28]
 80062fc:	b292      	uxth	r2, r2
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
 80062fe:	f022 0273 	bic.w	r2, r2, #115	; 0x73
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8006302:	880c      	ldrh	r4, [r1, #0]
 8006304:	4322      	orrs	r2, r4
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 8006306:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 800630a:	898c      	ldrh	r4, [r1, #12]
 800630c:	0224      	lsls	r4, r4, #8
 800630e:	b2a4      	uxth	r4, r4
 8006310:	4323      	orrs	r3, r4
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 8006312:	884c      	ldrh	r4, [r1, #2]
 8006314:	0224      	lsls	r4, r4, #8
 8006316:	b2a4      	uxth	r4, r4
 8006318:	4323      	orrs	r3, r4
  if((TIMx == TIM1) || (TIMx == TIM8))
 800631a:	4c12      	ldr	r4, [pc, #72]	; (8006364 <TIM_OC3Init+0x80>)
 800631c:	42a0      	cmp	r0, r4
 800631e:	d00a      	beq.n	8006336 <TIM_OC3Init+0x52>
 8006320:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8006324:	42a0      	cmp	r0, r4
 8006326:	d006      	beq.n	8006336 <TIM_OC3Init+0x52>
  TIMx->CR2 = tmpcr2;
 8006328:	8085      	strh	r5, [r0, #4]
  TIMx->CCMR2 = tmpccmrx;
 800632a:	8382      	strh	r2, [r0, #28]
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 800632c:	688a      	ldr	r2, [r1, #8]
 800632e:	63c2      	str	r2, [r0, #60]	; 0x3c
  TIMx->CCER = tmpccer;
 8006330:	8403      	strh	r3, [r0, #32]
}
 8006332:	bc30      	pop	{r4, r5}
 8006334:	4770      	bx	lr
    tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 8006336:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
 800633a:	89cc      	ldrh	r4, [r1, #14]
 800633c:	0224      	lsls	r4, r4, #8
 800633e:	b2a4      	uxth	r4, r4
 8006340:	4323      	orrs	r3, r4
    tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
 8006342:	f423 6480 	bic.w	r4, r3, #1024	; 0x400
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 8006346:	888b      	ldrh	r3, [r1, #4]
 8006348:	021b      	lsls	r3, r3, #8
 800634a:	b29b      	uxth	r3, r3
 800634c:	4323      	orrs	r3, r4
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
 800634e:	f425 5540 	bic.w	r5, r5, #12288	; 0x3000
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
 8006352:	8a0c      	ldrh	r4, [r1, #16]
 8006354:	0124      	lsls	r4, r4, #4
 8006356:	b2a4      	uxth	r4, r4
 8006358:	4325      	orrs	r5, r4
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
 800635a:	8a4c      	ldrh	r4, [r1, #18]
 800635c:	0124      	lsls	r4, r4, #4
 800635e:	b2a4      	uxth	r4, r4
 8006360:	4325      	orrs	r5, r4
 8006362:	e7e1      	b.n	8006328 <TIM_OC3Init+0x44>
 8006364:	40010000 	.word	0x40010000

08006368 <TIM_OC4Init>:
{
 8006368:	b430      	push	{r4, r5}
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 800636a:	8c03      	ldrh	r3, [r0, #32]
 800636c:	b29b      	uxth	r3, r3
 800636e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8006372:	b29b      	uxth	r3, r3
 8006374:	8403      	strh	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8006376:	8c03      	ldrh	r3, [r0, #32]
 8006378:	b29b      	uxth	r3, r3
  tmpcr2 =  TIMx->CR2;
 800637a:	8885      	ldrh	r5, [r0, #4]
 800637c:	b2ad      	uxth	r5, r5
  tmpccmrx = TIMx->CCMR2;
 800637e:	8b82      	ldrh	r2, [r0, #28]
 8006380:	b292      	uxth	r2, r2
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
 8006382:	f422 44e6 	bic.w	r4, r2, #29440	; 0x7300
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8006386:	880a      	ldrh	r2, [r1, #0]
 8006388:	0212      	lsls	r2, r2, #8
 800638a:	b292      	uxth	r2, r2
 800638c:	4322      	orrs	r2, r4
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 800638e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 8006392:	898c      	ldrh	r4, [r1, #12]
 8006394:	0324      	lsls	r4, r4, #12
 8006396:	b2a4      	uxth	r4, r4
 8006398:	4323      	orrs	r3, r4
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 800639a:	884c      	ldrh	r4, [r1, #2]
 800639c:	0324      	lsls	r4, r4, #12
 800639e:	b2a4      	uxth	r4, r4
 80063a0:	4323      	orrs	r3, r4
  if((TIMx == TIM1) || (TIMx == TIM8))
 80063a2:	4c0a      	ldr	r4, [pc, #40]	; (80063cc <TIM_OC4Init+0x64>)
 80063a4:	42a0      	cmp	r0, r4
 80063a6:	d00a      	beq.n	80063be <TIM_OC4Init+0x56>
 80063a8:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 80063ac:	42a0      	cmp	r0, r4
 80063ae:	d006      	beq.n	80063be <TIM_OC4Init+0x56>
  TIMx->CR2 = tmpcr2;
 80063b0:	8085      	strh	r5, [r0, #4]
  TIMx->CCMR2 = tmpccmrx;
 80063b2:	8382      	strh	r2, [r0, #28]
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 80063b4:	688a      	ldr	r2, [r1, #8]
 80063b6:	6402      	str	r2, [r0, #64]	; 0x40
  TIMx->CCER = tmpccer;
 80063b8:	8403      	strh	r3, [r0, #32]
}
 80063ba:	bc30      	pop	{r4, r5}
 80063bc:	4770      	bx	lr
    tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
 80063be:	f425 4580 	bic.w	r5, r5, #16384	; 0x4000
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
 80063c2:	8a0c      	ldrh	r4, [r1, #16]
 80063c4:	01a4      	lsls	r4, r4, #6
 80063c6:	b2a4      	uxth	r4, r4
 80063c8:	4325      	orrs	r5, r4
 80063ca:	e7f1      	b.n	80063b0 <TIM_OC4Init+0x48>
 80063cc:	40010000 	.word	0x40010000

080063d0 <TIM_OCStructInit>:
  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
 80063d0:	2300      	movs	r3, #0
 80063d2:	8003      	strh	r3, [r0, #0]
  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
 80063d4:	8043      	strh	r3, [r0, #2]
  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
 80063d6:	8083      	strh	r3, [r0, #4]
  TIM_OCInitStruct->TIM_Pulse = 0x00000000;
 80063d8:	6083      	str	r3, [r0, #8]
  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
 80063da:	8183      	strh	r3, [r0, #12]
  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
 80063dc:	81c3      	strh	r3, [r0, #14]
  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
 80063de:	8203      	strh	r3, [r0, #16]
  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
 80063e0:	8243      	strh	r3, [r0, #18]
 80063e2:	4770      	bx	lr

080063e4 <TIM_SelectOCxM>:
{
 80063e4:	b430      	push	{r4, r5}
  tmp += CCMR_OFFSET;
 80063e6:	f100 0418 	add.w	r4, r0, #24
  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
 80063ea:	2301      	movs	r3, #1
 80063ec:	408b      	lsls	r3, r1
 80063ee:	b29b      	uxth	r3, r3
  TIMx->CCER &= (uint16_t) ~tmp1;
 80063f0:	8c05      	ldrh	r5, [r0, #32]
 80063f2:	43db      	mvns	r3, r3
 80063f4:	b29b      	uxth	r3, r3
 80063f6:	402b      	ands	r3, r5
 80063f8:	8403      	strh	r3, [r0, #32]
  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 80063fa:	b181      	cbz	r1, 800641e <TIM_SelectOCxM+0x3a>
 80063fc:	2908      	cmp	r1, #8
 80063fe:	d00e      	beq.n	800641e <TIM_SelectOCxM+0x3a>
    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
 8006400:	3904      	subs	r1, #4
 8006402:	f3c1 014e 	ubfx	r1, r1, #1, #15
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
 8006406:	5863      	ldr	r3, [r4, r1]
 8006408:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800640c:	041b      	lsls	r3, r3, #16
 800640e:	0c1b      	lsrs	r3, r3, #16
 8006410:	5063      	str	r3, [r4, r1]
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8006412:	5863      	ldr	r3, [r4, r1]
 8006414:	0212      	lsls	r2, r2, #8
 8006416:	b292      	uxth	r2, r2
 8006418:	431a      	orrs	r2, r3
 800641a:	5062      	str	r2, [r4, r1]
}
 800641c:	e009      	b.n	8006432 <TIM_SelectOCxM+0x4e>
    tmp += (TIM_Channel>>1);
 800641e:	0849      	lsrs	r1, r1, #1
    *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
 8006420:	5863      	ldr	r3, [r4, r1]
 8006422:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8006426:	041b      	lsls	r3, r3, #16
 8006428:	0c1b      	lsrs	r3, r3, #16
 800642a:	5063      	str	r3, [r4, r1]
    *(__IO uint32_t *) tmp |= TIM_OCMode;
 800642c:	5863      	ldr	r3, [r4, r1]
 800642e:	431a      	orrs	r2, r3
 8006430:	5062      	str	r2, [r4, r1]
}
 8006432:	bc30      	pop	{r4, r5}
 8006434:	4770      	bx	lr

08006436 <TIM_SetCompare1>:
  TIMx->CCR1 = Compare1;
 8006436:	6341      	str	r1, [r0, #52]	; 0x34
 8006438:	4770      	bx	lr

0800643a <TIM_SetCompare2>:
  TIMx->CCR2 = Compare2;
 800643a:	6381      	str	r1, [r0, #56]	; 0x38
 800643c:	4770      	bx	lr

0800643e <TIM_SetCompare3>:
  TIMx->CCR3 = Compare3;
 800643e:	63c1      	str	r1, [r0, #60]	; 0x3c
 8006440:	4770      	bx	lr

08006442 <TIM_SetCompare4>:
  TIMx->CCR4 = Compare4;
 8006442:	6401      	str	r1, [r0, #64]	; 0x40
 8006444:	4770      	bx	lr

08006446 <TIM_ForcedOC1Config>:
  tmpccmr1 = TIMx->CCMR1;
 8006446:	8b03      	ldrh	r3, [r0, #24]
 8006448:	b29b      	uxth	r3, r3
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
 800644a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpccmr1 |= TIM_ForcedAction;
 800644e:	4319      	orrs	r1, r3
  TIMx->CCMR1 = tmpccmr1;
 8006450:	8301      	strh	r1, [r0, #24]
 8006452:	4770      	bx	lr

08006454 <TIM_ForcedOC2Config>:
  tmpccmr1 = TIMx->CCMR1;
 8006454:	8b03      	ldrh	r3, [r0, #24]
 8006456:	b29b      	uxth	r3, r3
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
 8006458:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
 800645c:	0209      	lsls	r1, r1, #8
 800645e:	b289      	uxth	r1, r1
 8006460:	430b      	orrs	r3, r1
  TIMx->CCMR1 = tmpccmr1;
 8006462:	8303      	strh	r3, [r0, #24]
 8006464:	4770      	bx	lr

08006466 <TIM_ForcedOC3Config>:
  tmpccmr2 = TIMx->CCMR2;
 8006466:	8b83      	ldrh	r3, [r0, #28]
 8006468:	b29b      	uxth	r3, r3
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
 800646a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpccmr2 |= TIM_ForcedAction;
 800646e:	4319      	orrs	r1, r3
  TIMx->CCMR2 = tmpccmr2;
 8006470:	8381      	strh	r1, [r0, #28]
 8006472:	4770      	bx	lr

08006474 <TIM_ForcedOC4Config>:
  tmpccmr2 = TIMx->CCMR2;
 8006474:	8b83      	ldrh	r3, [r0, #28]
 8006476:	b29b      	uxth	r3, r3
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
 8006478:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
 800647c:	0209      	lsls	r1, r1, #8
 800647e:	b289      	uxth	r1, r1
 8006480:	430b      	orrs	r3, r1
  TIMx->CCMR2 = tmpccmr2;
 8006482:	8383      	strh	r3, [r0, #28]
 8006484:	4770      	bx	lr

08006486 <TIM_OC1PreloadConfig>:
  tmpccmr1 = TIMx->CCMR1;
 8006486:	8b03      	ldrh	r3, [r0, #24]
 8006488:	b29b      	uxth	r3, r3
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
 800648a:	f023 0308 	bic.w	r3, r3, #8
  tmpccmr1 |= TIM_OCPreload;
 800648e:	4319      	orrs	r1, r3
  TIMx->CCMR1 = tmpccmr1;
 8006490:	8301      	strh	r1, [r0, #24]
 8006492:	4770      	bx	lr

08006494 <TIM_OC2PreloadConfig>:
  tmpccmr1 = TIMx->CCMR1;
 8006494:	8b03      	ldrh	r3, [r0, #24]
 8006496:	b29b      	uxth	r3, r3
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
 8006498:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
 800649c:	0209      	lsls	r1, r1, #8
 800649e:	b289      	uxth	r1, r1
 80064a0:	430b      	orrs	r3, r1
  TIMx->CCMR1 = tmpccmr1;
 80064a2:	8303      	strh	r3, [r0, #24]
 80064a4:	4770      	bx	lr

080064a6 <TIM_OC3PreloadConfig>:
  tmpccmr2 = TIMx->CCMR2;
 80064a6:	8b83      	ldrh	r3, [r0, #28]
 80064a8:	b29b      	uxth	r3, r3
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
 80064aa:	f023 0308 	bic.w	r3, r3, #8
  tmpccmr2 |= TIM_OCPreload;
 80064ae:	4319      	orrs	r1, r3
  TIMx->CCMR2 = tmpccmr2;
 80064b0:	8381      	strh	r1, [r0, #28]
 80064b2:	4770      	bx	lr

080064b4 <TIM_OC4PreloadConfig>:
  tmpccmr2 = TIMx->CCMR2;
 80064b4:	8b83      	ldrh	r3, [r0, #28]
 80064b6:	b29b      	uxth	r3, r3
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
 80064b8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
 80064bc:	0209      	lsls	r1, r1, #8
 80064be:	b289      	uxth	r1, r1
 80064c0:	430b      	orrs	r3, r1
  TIMx->CCMR2 = tmpccmr2;
 80064c2:	8383      	strh	r3, [r0, #28]
 80064c4:	4770      	bx	lr

080064c6 <TIM_OC1FastConfig>:
  tmpccmr1 = TIMx->CCMR1;
 80064c6:	8b03      	ldrh	r3, [r0, #24]
 80064c8:	b29b      	uxth	r3, r3
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
 80064ca:	f023 0304 	bic.w	r3, r3, #4
  tmpccmr1 |= TIM_OCFast;
 80064ce:	4319      	orrs	r1, r3
  TIMx->CCMR1 = tmpccmr1;
 80064d0:	8301      	strh	r1, [r0, #24]
 80064d2:	4770      	bx	lr

080064d4 <TIM_OC2FastConfig>:
  tmpccmr1 = TIMx->CCMR1;
 80064d4:	8b03      	ldrh	r3, [r0, #24]
 80064d6:	b29b      	uxth	r3, r3
  tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
 80064d8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
 80064dc:	0209      	lsls	r1, r1, #8
 80064de:	b289      	uxth	r1, r1
 80064e0:	430b      	orrs	r3, r1
  TIMx->CCMR1 = tmpccmr1;
 80064e2:	8303      	strh	r3, [r0, #24]
 80064e4:	4770      	bx	lr

080064e6 <TIM_OC3FastConfig>:
  tmpccmr2 = TIMx->CCMR2;
 80064e6:	8b83      	ldrh	r3, [r0, #28]
 80064e8:	b29b      	uxth	r3, r3
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
 80064ea:	f023 0304 	bic.w	r3, r3, #4
  tmpccmr2 |= TIM_OCFast;
 80064ee:	4319      	orrs	r1, r3
  TIMx->CCMR2 = tmpccmr2;
 80064f0:	8381      	strh	r1, [r0, #28]
 80064f2:	4770      	bx	lr

080064f4 <TIM_OC4FastConfig>:
  tmpccmr2 = TIMx->CCMR2;
 80064f4:	8b83      	ldrh	r3, [r0, #28]
 80064f6:	b29b      	uxth	r3, r3
  tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
 80064f8:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
 80064fc:	0209      	lsls	r1, r1, #8
 80064fe:	b289      	uxth	r1, r1
 8006500:	430b      	orrs	r3, r1
  TIMx->CCMR2 = tmpccmr2;
 8006502:	8383      	strh	r3, [r0, #28]
 8006504:	4770      	bx	lr

08006506 <TIM_ClearOC1Ref>:
  tmpccmr1 = TIMx->CCMR1;
 8006506:	8b03      	ldrh	r3, [r0, #24]
 8006508:	b29b      	uxth	r3, r3
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
 800650a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tmpccmr1 |= TIM_OCClear;
 800650e:	4319      	orrs	r1, r3
  TIMx->CCMR1 = tmpccmr1;
 8006510:	8301      	strh	r1, [r0, #24]
 8006512:	4770      	bx	lr

08006514 <TIM_ClearOC2Ref>:
  tmpccmr1 = TIMx->CCMR1;
 8006514:	8b03      	ldrh	r3, [r0, #24]
  tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
 8006516:	f3c3 030e 	ubfx	r3, r3, #0, #15
  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
 800651a:	0209      	lsls	r1, r1, #8
 800651c:	b289      	uxth	r1, r1
 800651e:	430b      	orrs	r3, r1
  TIMx->CCMR1 = tmpccmr1;
 8006520:	8303      	strh	r3, [r0, #24]
 8006522:	4770      	bx	lr

08006524 <TIM_ClearOC3Ref>:
  tmpccmr2 = TIMx->CCMR2;
 8006524:	8b83      	ldrh	r3, [r0, #28]
 8006526:	b29b      	uxth	r3, r3
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
 8006528:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tmpccmr2 |= TIM_OCClear;
 800652c:	4319      	orrs	r1, r3
  TIMx->CCMR2 = tmpccmr2;
 800652e:	8381      	strh	r1, [r0, #28]
 8006530:	4770      	bx	lr

08006532 <TIM_ClearOC4Ref>:
  tmpccmr2 = TIMx->CCMR2;
 8006532:	8b83      	ldrh	r3, [r0, #28]
  tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
 8006534:	f3c3 030e 	ubfx	r3, r3, #0, #15
  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
 8006538:	0209      	lsls	r1, r1, #8
 800653a:	b289      	uxth	r1, r1
 800653c:	430b      	orrs	r3, r1
  TIMx->CCMR2 = tmpccmr2;
 800653e:	8383      	strh	r3, [r0, #28]
 8006540:	4770      	bx	lr

08006542 <TIM_OC1PolarityConfig>:
  tmpccer = TIMx->CCER;
 8006542:	8c03      	ldrh	r3, [r0, #32]
 8006544:	b29b      	uxth	r3, r3
  tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
 8006546:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= TIM_OCPolarity;
 800654a:	4319      	orrs	r1, r3
  TIMx->CCER = tmpccer;
 800654c:	8401      	strh	r1, [r0, #32]
 800654e:	4770      	bx	lr

08006550 <TIM_OC1NPolarityConfig>:
  tmpccer = TIMx->CCER;
 8006550:	8c03      	ldrh	r3, [r0, #32]
 8006552:	b29b      	uxth	r3, r3
  tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 8006554:	f023 0308 	bic.w	r3, r3, #8
  tmpccer |= TIM_OCNPolarity;
 8006558:	4319      	orrs	r1, r3
  TIMx->CCER = tmpccer;
 800655a:	8401      	strh	r1, [r0, #32]
 800655c:	4770      	bx	lr

0800655e <TIM_OC2PolarityConfig>:
  tmpccer = TIMx->CCER;
 800655e:	8c03      	ldrh	r3, [r0, #32]
 8006560:	b29b      	uxth	r3, r3
  tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
 8006562:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
 8006566:	0109      	lsls	r1, r1, #4
 8006568:	b289      	uxth	r1, r1
 800656a:	430b      	orrs	r3, r1
  TIMx->CCER = tmpccer;
 800656c:	8403      	strh	r3, [r0, #32]
 800656e:	4770      	bx	lr

08006570 <TIM_OC2NPolarityConfig>:
  tmpccer = TIMx->CCER;
 8006570:	8c03      	ldrh	r3, [r0, #32]
 8006572:	b29b      	uxth	r3, r3
  tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 8006574:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
 8006578:	0109      	lsls	r1, r1, #4
 800657a:	b289      	uxth	r1, r1
 800657c:	430b      	orrs	r3, r1
  TIMx->CCER = tmpccer;
 800657e:	8403      	strh	r3, [r0, #32]
 8006580:	4770      	bx	lr

08006582 <TIM_OC3PolarityConfig>:
  tmpccer = TIMx->CCER;
 8006582:	8c03      	ldrh	r3, [r0, #32]
 8006584:	b29b      	uxth	r3, r3
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 8006586:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
 800658a:	0209      	lsls	r1, r1, #8
 800658c:	b289      	uxth	r1, r1
 800658e:	430b      	orrs	r3, r1
  TIMx->CCER = tmpccer;
 8006590:	8403      	strh	r3, [r0, #32]
 8006592:	4770      	bx	lr

08006594 <TIM_OC3NPolarityConfig>:
  tmpccer = TIMx->CCER;
 8006594:	8c03      	ldrh	r3, [r0, #32]
 8006596:	b29b      	uxth	r3, r3
  tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 8006598:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
 800659c:	0209      	lsls	r1, r1, #8
 800659e:	b289      	uxth	r1, r1
 80065a0:	430b      	orrs	r3, r1
  TIMx->CCER = tmpccer;
 80065a2:	8403      	strh	r3, [r0, #32]
 80065a4:	4770      	bx	lr

080065a6 <TIM_OC4PolarityConfig>:
  tmpccer = TIMx->CCER;
 80065a6:	8c03      	ldrh	r3, [r0, #32]
 80065a8:	b29b      	uxth	r3, r3
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 80065aa:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
 80065ae:	0309      	lsls	r1, r1, #12
 80065b0:	b289      	uxth	r1, r1
 80065b2:	430b      	orrs	r3, r1
  TIMx->CCER = tmpccer;
 80065b4:	8403      	strh	r3, [r0, #32]
 80065b6:	4770      	bx	lr

080065b8 <TIM_CCxCmd>:
{
 80065b8:	b410      	push	{r4}
  tmp = CCER_CCE_SET << TIM_Channel;
 80065ba:	2301      	movs	r3, #1
 80065bc:	408b      	lsls	r3, r1
 80065be:	b29b      	uxth	r3, r3
  TIMx->CCER &= (uint16_t)~ tmp;
 80065c0:	8c04      	ldrh	r4, [r0, #32]
 80065c2:	43db      	mvns	r3, r3
 80065c4:	b29b      	uxth	r3, r3
 80065c6:	4023      	ands	r3, r4
 80065c8:	8403      	strh	r3, [r0, #32]
  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
 80065ca:	8c03      	ldrh	r3, [r0, #32]
 80065cc:	b29b      	uxth	r3, r3
 80065ce:	408a      	lsls	r2, r1
 80065d0:	b292      	uxth	r2, r2
 80065d2:	431a      	orrs	r2, r3
 80065d4:	8402      	strh	r2, [r0, #32]
}
 80065d6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80065da:	4770      	bx	lr

080065dc <TIM_CCxNCmd>:
{
 80065dc:	b410      	push	{r4}
  tmp = CCER_CCNE_SET << TIM_Channel;
 80065de:	2304      	movs	r3, #4
 80065e0:	408b      	lsls	r3, r1
 80065e2:	b29b      	uxth	r3, r3
  TIMx->CCER &= (uint16_t) ~tmp;
 80065e4:	8c04      	ldrh	r4, [r0, #32]
 80065e6:	43db      	mvns	r3, r3
 80065e8:	b29b      	uxth	r3, r3
 80065ea:	4023      	ands	r3, r4
 80065ec:	8403      	strh	r3, [r0, #32]
  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
 80065ee:	8c03      	ldrh	r3, [r0, #32]
 80065f0:	b29b      	uxth	r3, r3
 80065f2:	408a      	lsls	r2, r1
 80065f4:	b292      	uxth	r2, r2
 80065f6:	431a      	orrs	r2, r3
 80065f8:	8402      	strh	r2, [r0, #32]
}
 80065fa:	f85d 4b04 	ldr.w	r4, [sp], #4
 80065fe:	4770      	bx	lr

08006600 <TIM_ICStructInit>:
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 8006600:	2300      	movs	r3, #0
 8006602:	8003      	strh	r3, [r0, #0]
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
 8006604:	8043      	strh	r3, [r0, #2]
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 8006606:	2201      	movs	r2, #1
 8006608:	8082      	strh	r2, [r0, #4]
  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
 800660a:	80c3      	strh	r3, [r0, #6]
  TIM_ICInitStruct->TIM_ICFilter = 0x00;
 800660c:	8103      	strh	r3, [r0, #8]
 800660e:	4770      	bx	lr

08006610 <TIM_GetCapture1>:
  return TIMx->CCR1;
 8006610:	6b40      	ldr	r0, [r0, #52]	; 0x34
}
 8006612:	4770      	bx	lr

08006614 <TIM_GetCapture2>:
  return TIMx->CCR2;
 8006614:	6b80      	ldr	r0, [r0, #56]	; 0x38
}
 8006616:	4770      	bx	lr

08006618 <TIM_GetCapture3>:
  return TIMx->CCR3;
 8006618:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
}
 800661a:	4770      	bx	lr

0800661c <TIM_GetCapture4>:
  return TIMx->CCR4;
 800661c:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
 800661e:	4770      	bx	lr

08006620 <TIM_SetIC1Prescaler>:
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
 8006620:	8b03      	ldrh	r3, [r0, #24]
 8006622:	b29b      	uxth	r3, r3
 8006624:	f023 030c 	bic.w	r3, r3, #12
 8006628:	b29b      	uxth	r3, r3
 800662a:	8303      	strh	r3, [r0, #24]
  TIMx->CCMR1 |= TIM_ICPSC;
 800662c:	8b03      	ldrh	r3, [r0, #24]
 800662e:	b29b      	uxth	r3, r3
 8006630:	4319      	orrs	r1, r3
 8006632:	8301      	strh	r1, [r0, #24]
 8006634:	4770      	bx	lr

08006636 <TIM_SetIC2Prescaler>:
  TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
 8006636:	8b03      	ldrh	r3, [r0, #24]
 8006638:	b29b      	uxth	r3, r3
 800663a:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 800663e:	b29b      	uxth	r3, r3
 8006640:	8303      	strh	r3, [r0, #24]
  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
 8006642:	8b03      	ldrh	r3, [r0, #24]
 8006644:	b29b      	uxth	r3, r3
 8006646:	0209      	lsls	r1, r1, #8
 8006648:	b289      	uxth	r1, r1
 800664a:	430b      	orrs	r3, r1
 800664c:	8303      	strh	r3, [r0, #24]
 800664e:	4770      	bx	lr

08006650 <TIM_PWMIConfig>:
{
 8006650:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006652:	4605      	mov	r5, r0
 8006654:	460c      	mov	r4, r1
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 8006656:	8849      	ldrh	r1, [r1, #2]
 8006658:	b9c9      	cbnz	r1, 800668e <TIM_PWMIConfig+0x3e>
    icoppositepolarity = TIM_ICPolarity_Falling;
 800665a:	2602      	movs	r6, #2
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 800665c:	88a2      	ldrh	r2, [r4, #4]
 800665e:	2a01      	cmp	r2, #1
 8006660:	d017      	beq.n	8006692 <TIM_PWMIConfig+0x42>
    icoppositeselection = TIM_ICSelection_DirectTI;
 8006662:	2701      	movs	r7, #1
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8006664:	8823      	ldrh	r3, [r4, #0]
 8006666:	b1b3      	cbz	r3, 8006696 <TIM_PWMIConfig+0x46>
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 8006668:	8923      	ldrh	r3, [r4, #8]
 800666a:	4628      	mov	r0, r5
 800666c:	f7ff fbf0 	bl	8005e50 <TI2_Config>
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8006670:	88e1      	ldrh	r1, [r4, #6]
 8006672:	4628      	mov	r0, r5
 8006674:	f7ff ffdf 	bl	8006636 <TIM_SetIC2Prescaler>
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 8006678:	8923      	ldrh	r3, [r4, #8]
 800667a:	463a      	mov	r2, r7
 800667c:	4631      	mov	r1, r6
 800667e:	4628      	mov	r0, r5
 8006680:	f7ff fbcc 	bl	8005e1c <TI1_Config>
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8006684:	88e1      	ldrh	r1, [r4, #6]
 8006686:	4628      	mov	r0, r5
 8006688:	f7ff ffca 	bl	8006620 <TIM_SetIC1Prescaler>
 800668c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    icoppositepolarity = TIM_ICPolarity_Rising;
 800668e:	2600      	movs	r6, #0
 8006690:	e7e4      	b.n	800665c <TIM_PWMIConfig+0xc>
    icoppositeselection = TIM_ICSelection_IndirectTI;
 8006692:	2702      	movs	r7, #2
 8006694:	e7e6      	b.n	8006664 <TIM_PWMIConfig+0x14>
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 8006696:	8923      	ldrh	r3, [r4, #8]
 8006698:	4628      	mov	r0, r5
 800669a:	f7ff fbbf 	bl	8005e1c <TI1_Config>
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800669e:	88e1      	ldrh	r1, [r4, #6]
 80066a0:	4628      	mov	r0, r5
 80066a2:	f7ff ffbd 	bl	8006620 <TIM_SetIC1Prescaler>
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 80066a6:	8923      	ldrh	r3, [r4, #8]
 80066a8:	463a      	mov	r2, r7
 80066aa:	4631      	mov	r1, r6
 80066ac:	4628      	mov	r0, r5
 80066ae:	f7ff fbcf 	bl	8005e50 <TI2_Config>
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80066b2:	88e1      	ldrh	r1, [r4, #6]
 80066b4:	4628      	mov	r0, r5
 80066b6:	f7ff ffbe 	bl	8006636 <TIM_SetIC2Prescaler>
 80066ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080066bc <TIM_SetIC3Prescaler>:
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
 80066bc:	8b83      	ldrh	r3, [r0, #28]
 80066be:	b29b      	uxth	r3, r3
 80066c0:	f023 030c 	bic.w	r3, r3, #12
 80066c4:	b29b      	uxth	r3, r3
 80066c6:	8383      	strh	r3, [r0, #28]
  TIMx->CCMR2 |= TIM_ICPSC;
 80066c8:	8b83      	ldrh	r3, [r0, #28]
 80066ca:	b29b      	uxth	r3, r3
 80066cc:	4319      	orrs	r1, r3
 80066ce:	8381      	strh	r1, [r0, #28]
 80066d0:	4770      	bx	lr

080066d2 <TIM_SetIC4Prescaler>:
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
 80066d2:	8b83      	ldrh	r3, [r0, #28]
 80066d4:	b29b      	uxth	r3, r3
 80066d6:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 80066da:	b29b      	uxth	r3, r3
 80066dc:	8383      	strh	r3, [r0, #28]
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 80066de:	8b83      	ldrh	r3, [r0, #28]
 80066e0:	b29b      	uxth	r3, r3
 80066e2:	0209      	lsls	r1, r1, #8
 80066e4:	b289      	uxth	r1, r1
 80066e6:	430b      	orrs	r3, r1
 80066e8:	8383      	strh	r3, [r0, #28]
 80066ea:	4770      	bx	lr

080066ec <TIM_ICInit>:
{
 80066ec:	b538      	push	{r3, r4, r5, lr}
 80066ee:	4605      	mov	r5, r0
 80066f0:	460c      	mov	r4, r1
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 80066f2:	880b      	ldrh	r3, [r1, #0]
 80066f4:	b16b      	cbz	r3, 8006712 <TIM_ICInit+0x26>
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
 80066f6:	2b04      	cmp	r3, #4
 80066f8:	d015      	beq.n	8006726 <TIM_ICInit+0x3a>
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 80066fa:	2b08      	cmp	r3, #8
 80066fc:	d01d      	beq.n	800673a <TIM_ICInit+0x4e>
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 80066fe:	890b      	ldrh	r3, [r1, #8]
 8006700:	888a      	ldrh	r2, [r1, #4]
 8006702:	8849      	ldrh	r1, [r1, #2]
 8006704:	f7ff fbdf 	bl	8005ec6 <TI4_Config>
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8006708:	88e1      	ldrh	r1, [r4, #6]
 800670a:	4628      	mov	r0, r5
 800670c:	f7ff ffe1 	bl	80066d2 <TIM_SetIC4Prescaler>
 8006710:	bd38      	pop	{r3, r4, r5, pc}
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8006712:	890b      	ldrh	r3, [r1, #8]
 8006714:	888a      	ldrh	r2, [r1, #4]
 8006716:	8849      	ldrh	r1, [r1, #2]
 8006718:	f7ff fb80 	bl	8005e1c <TI1_Config>
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800671c:	88e1      	ldrh	r1, [r4, #6]
 800671e:	4628      	mov	r0, r5
 8006720:	f7ff ff7e 	bl	8006620 <TIM_SetIC1Prescaler>
 8006724:	bd38      	pop	{r3, r4, r5, pc}
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8006726:	890b      	ldrh	r3, [r1, #8]
 8006728:	888a      	ldrh	r2, [r1, #4]
 800672a:	8849      	ldrh	r1, [r1, #2]
 800672c:	f7ff fb90 	bl	8005e50 <TI2_Config>
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8006730:	88e1      	ldrh	r1, [r4, #6]
 8006732:	4628      	mov	r0, r5
 8006734:	f7ff ff7f 	bl	8006636 <TIM_SetIC2Prescaler>
 8006738:	bd38      	pop	{r3, r4, r5, pc}
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
 800673a:	890b      	ldrh	r3, [r1, #8]
 800673c:	888a      	ldrh	r2, [r1, #4]
 800673e:	8849      	ldrh	r1, [r1, #2]
 8006740:	f7ff fba5 	bl	8005e8e <TI3_Config>
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8006744:	88e1      	ldrh	r1, [r4, #6]
 8006746:	4628      	mov	r0, r5
 8006748:	f7ff ffb8 	bl	80066bc <TIM_SetIC3Prescaler>
 800674c:	bd38      	pop	{r3, r4, r5, pc}

0800674e <TIM_BDTRConfig>:
{
 800674e:	b5f0      	push	{r4, r5, r6, r7, lr}
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 8006750:	880f      	ldrh	r7, [r1, #0]
 8006752:	f8b1 e002 	ldrh.w	lr, [r1, #2]
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
 8006756:	888e      	ldrh	r6, [r1, #4]
 8006758:	88cd      	ldrh	r5, [r1, #6]
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
 800675a:	890c      	ldrh	r4, [r1, #8]
 800675c:	894a      	ldrh	r2, [r1, #10]
             TIM_BDTRInitStruct->TIM_AutomaticOutput;
 800675e:	898b      	ldrh	r3, [r1, #12]
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 8006760:	ea47 010e 	orr.w	r1, r7, lr
 8006764:	4331      	orrs	r1, r6
 8006766:	4329      	orrs	r1, r5
 8006768:	4321      	orrs	r1, r4
 800676a:	430a      	orrs	r2, r1
 800676c:	4313      	orrs	r3, r2
 800676e:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
 8006772:	bdf0      	pop	{r4, r5, r6, r7, pc}

08006774 <TIM_BDTRStructInit>:
  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
 8006774:	2300      	movs	r3, #0
 8006776:	8003      	strh	r3, [r0, #0]
  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
 8006778:	8043      	strh	r3, [r0, #2]
  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
 800677a:	8083      	strh	r3, [r0, #4]
  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
 800677c:	80c3      	strh	r3, [r0, #6]
  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
 800677e:	8103      	strh	r3, [r0, #8]
  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
 8006780:	8143      	strh	r3, [r0, #10]
  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
 8006782:	8183      	strh	r3, [r0, #12]
 8006784:	4770      	bx	lr

08006786 <TIM_CtrlPWMOutputs>:
  if (NewState != DISABLE)
 8006786:	b931      	cbnz	r1, 8006796 <TIM_CtrlPWMOutputs+0x10>
    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
 8006788:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 800678c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8006790:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
 8006794:	4770      	bx	lr
    TIMx->BDTR |= TIM_BDTR_MOE;
 8006796:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 800679a:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 800679e:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 80067a2:	b29b      	uxth	r3, r3
 80067a4:	f8a0 3044 	strh.w	r3, [r0, #68]	; 0x44
 80067a8:	4770      	bx	lr

080067aa <TIM_SelectCOM>:
  if (NewState != DISABLE)
 80067aa:	b931      	cbnz	r1, 80067ba <TIM_SelectCOM+0x10>
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
 80067ac:	8883      	ldrh	r3, [r0, #4]
 80067ae:	b29b      	uxth	r3, r3
 80067b0:	f023 0304 	bic.w	r3, r3, #4
 80067b4:	b29b      	uxth	r3, r3
 80067b6:	8083      	strh	r3, [r0, #4]
 80067b8:	4770      	bx	lr
    TIMx->CR2 |= TIM_CR2_CCUS;
 80067ba:	8883      	ldrh	r3, [r0, #4]
 80067bc:	b29b      	uxth	r3, r3
 80067be:	f043 0304 	orr.w	r3, r3, #4
 80067c2:	8083      	strh	r3, [r0, #4]
 80067c4:	4770      	bx	lr

080067c6 <TIM_CCPreloadControl>:
  if (NewState != DISABLE)
 80067c6:	b931      	cbnz	r1, 80067d6 <TIM_CCPreloadControl+0x10>
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
 80067c8:	8883      	ldrh	r3, [r0, #4]
 80067ca:	b29b      	uxth	r3, r3
 80067cc:	f023 0301 	bic.w	r3, r3, #1
 80067d0:	b29b      	uxth	r3, r3
 80067d2:	8083      	strh	r3, [r0, #4]
 80067d4:	4770      	bx	lr
    TIMx->CR2 |= TIM_CR2_CCPC;
 80067d6:	8883      	ldrh	r3, [r0, #4]
 80067d8:	b29b      	uxth	r3, r3
 80067da:	f043 0301 	orr.w	r3, r3, #1
 80067de:	8083      	strh	r3, [r0, #4]
 80067e0:	4770      	bx	lr

080067e2 <TIM_ITConfig>:
  if (NewState != DISABLE)
 80067e2:	b92a      	cbnz	r2, 80067f0 <TIM_ITConfig+0xe>
    TIMx->DIER &= (uint16_t)~TIM_IT;
 80067e4:	8983      	ldrh	r3, [r0, #12]
 80067e6:	43c9      	mvns	r1, r1
 80067e8:	b289      	uxth	r1, r1
 80067ea:	4019      	ands	r1, r3
 80067ec:	8181      	strh	r1, [r0, #12]
 80067ee:	4770      	bx	lr
    TIMx->DIER |= TIM_IT;
 80067f0:	8983      	ldrh	r3, [r0, #12]
 80067f2:	b29b      	uxth	r3, r3
 80067f4:	4319      	orrs	r1, r3
 80067f6:	8181      	strh	r1, [r0, #12]
 80067f8:	4770      	bx	lr

080067fa <TIM_GenerateEvent>:
  TIMx->EGR = TIM_EventSource;
 80067fa:	8281      	strh	r1, [r0, #20]
 80067fc:	4770      	bx	lr

080067fe <TIM_GetFlagStatus>:
  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
 80067fe:	8a03      	ldrh	r3, [r0, #16]
 8006800:	4219      	tst	r1, r3
 8006802:	d101      	bne.n	8006808 <TIM_GetFlagStatus+0xa>
    bitstatus = RESET;
 8006804:	2000      	movs	r0, #0
}
 8006806:	4770      	bx	lr
    bitstatus = SET;
 8006808:	2001      	movs	r0, #1
 800680a:	4770      	bx	lr

0800680c <TIM_ClearFlag>:
  TIMx->SR = (uint16_t)~TIM_FLAG;
 800680c:	43c9      	mvns	r1, r1
 800680e:	b289      	uxth	r1, r1
 8006810:	8201      	strh	r1, [r0, #16]
 8006812:	4770      	bx	lr

08006814 <TIM_GetITStatus>:
  itstatus = TIMx->SR & TIM_IT;
 8006814:	8a02      	ldrh	r2, [r0, #16]
  itenable = TIMx->DIER & TIM_IT;
 8006816:	8983      	ldrh	r3, [r0, #12]
 8006818:	400b      	ands	r3, r1
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 800681a:	4211      	tst	r1, r2
 800681c:	d002      	beq.n	8006824 <TIM_GetITStatus+0x10>
 800681e:	b91b      	cbnz	r3, 8006828 <TIM_GetITStatus+0x14>
    bitstatus = RESET;
 8006820:	2000      	movs	r0, #0
 8006822:	4770      	bx	lr
 8006824:	2000      	movs	r0, #0
 8006826:	4770      	bx	lr
    bitstatus = SET;
 8006828:	2001      	movs	r0, #1
}
 800682a:	4770      	bx	lr

0800682c <TIM_ClearITPendingBit>:
  TIMx->SR = (uint16_t)~TIM_IT;
 800682c:	43c9      	mvns	r1, r1
 800682e:	b289      	uxth	r1, r1
 8006830:	8201      	strh	r1, [r0, #16]
 8006832:	4770      	bx	lr

08006834 <TIM_DMAConfig>:
  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
 8006834:	430a      	orrs	r2, r1
 8006836:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
 800683a:	4770      	bx	lr

0800683c <TIM_DMACmd>:
  if (NewState != DISABLE)
 800683c:	b92a      	cbnz	r2, 800684a <TIM_DMACmd+0xe>
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
 800683e:	8983      	ldrh	r3, [r0, #12]
 8006840:	43c9      	mvns	r1, r1
 8006842:	b289      	uxth	r1, r1
 8006844:	4019      	ands	r1, r3
 8006846:	8181      	strh	r1, [r0, #12]
 8006848:	4770      	bx	lr
    TIMx->DIER |= TIM_DMASource; 
 800684a:	8983      	ldrh	r3, [r0, #12]
 800684c:	b29b      	uxth	r3, r3
 800684e:	4319      	orrs	r1, r3
 8006850:	8181      	strh	r1, [r0, #12]
 8006852:	4770      	bx	lr

08006854 <TIM_SelectCCDMA>:
  if (NewState != DISABLE)
 8006854:	b931      	cbnz	r1, 8006864 <TIM_SelectCCDMA+0x10>
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
 8006856:	8883      	ldrh	r3, [r0, #4]
 8006858:	b29b      	uxth	r3, r3
 800685a:	f023 0308 	bic.w	r3, r3, #8
 800685e:	b29b      	uxth	r3, r3
 8006860:	8083      	strh	r3, [r0, #4]
 8006862:	4770      	bx	lr
    TIMx->CR2 |= TIM_CR2_CCDS;
 8006864:	8883      	ldrh	r3, [r0, #4]
 8006866:	b29b      	uxth	r3, r3
 8006868:	f043 0308 	orr.w	r3, r3, #8
 800686c:	8083      	strh	r3, [r0, #4]
 800686e:	4770      	bx	lr

08006870 <TIM_InternalClockConfig>:
  TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
 8006870:	8903      	ldrh	r3, [r0, #8]
 8006872:	b29b      	uxth	r3, r3
 8006874:	f023 0307 	bic.w	r3, r3, #7
 8006878:	b29b      	uxth	r3, r3
 800687a:	8103      	strh	r3, [r0, #8]
 800687c:	4770      	bx	lr

0800687e <TIM_SelectInputTrigger>:
  tmpsmcr = TIMx->SMCR;
 800687e:	8903      	ldrh	r3, [r0, #8]
 8006880:	b29b      	uxth	r3, r3
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 8006882:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  tmpsmcr |= TIM_InputTriggerSource;
 8006886:	4319      	orrs	r1, r3
  TIMx->SMCR = tmpsmcr;
 8006888:	8101      	strh	r1, [r0, #8]
 800688a:	4770      	bx	lr

0800688c <TIM_ITRxExternalClockConfig>:
{
 800688c:	b510      	push	{r4, lr}
 800688e:	4604      	mov	r4, r0
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
 8006890:	f7ff fff5 	bl	800687e <TIM_SelectInputTrigger>
  TIMx->SMCR |= TIM_SlaveMode_External1;
 8006894:	8923      	ldrh	r3, [r4, #8]
 8006896:	b29b      	uxth	r3, r3
 8006898:	f043 0307 	orr.w	r3, r3, #7
 800689c:	8123      	strh	r3, [r4, #8]
 800689e:	bd10      	pop	{r4, pc}

080068a0 <TIM_TIxExternalClockConfig>:
{
 80068a0:	b538      	push	{r3, r4, r5, lr}
 80068a2:	4604      	mov	r4, r0
 80068a4:	460d      	mov	r5, r1
 80068a6:	4611      	mov	r1, r2
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 80068a8:	2d60      	cmp	r5, #96	; 0x60
 80068aa:	d00c      	beq.n	80068c6 <TIM_TIxExternalClockConfig+0x26>
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 80068ac:	2201      	movs	r2, #1
 80068ae:	f7ff fab5 	bl	8005e1c <TI1_Config>
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
 80068b2:	4629      	mov	r1, r5
 80068b4:	4620      	mov	r0, r4
 80068b6:	f7ff ffe2 	bl	800687e <TIM_SelectInputTrigger>
  TIMx->SMCR |= TIM_SlaveMode_External1;
 80068ba:	8923      	ldrh	r3, [r4, #8]
 80068bc:	b29b      	uxth	r3, r3
 80068be:	f043 0307 	orr.w	r3, r3, #7
 80068c2:	8123      	strh	r3, [r4, #8]
 80068c4:	bd38      	pop	{r3, r4, r5, pc}
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 80068c6:	2201      	movs	r2, #1
 80068c8:	f7ff fac2 	bl	8005e50 <TI2_Config>
 80068cc:	e7f1      	b.n	80068b2 <TIM_TIxExternalClockConfig+0x12>

080068ce <TIM_SelectOutputTrigger>:
  TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
 80068ce:	8883      	ldrh	r3, [r0, #4]
 80068d0:	b29b      	uxth	r3, r3
 80068d2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80068d6:	b29b      	uxth	r3, r3
 80068d8:	8083      	strh	r3, [r0, #4]
  TIMx->CR2 |=  TIM_TRGOSource;
 80068da:	8883      	ldrh	r3, [r0, #4]
 80068dc:	b29b      	uxth	r3, r3
 80068de:	4319      	orrs	r1, r3
 80068e0:	8081      	strh	r1, [r0, #4]
 80068e2:	4770      	bx	lr

080068e4 <TIM_SelectSlaveMode>:
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
 80068e4:	8903      	ldrh	r3, [r0, #8]
 80068e6:	b29b      	uxth	r3, r3
 80068e8:	f023 0307 	bic.w	r3, r3, #7
 80068ec:	b29b      	uxth	r3, r3
 80068ee:	8103      	strh	r3, [r0, #8]
  TIMx->SMCR |= TIM_SlaveMode;
 80068f0:	8903      	ldrh	r3, [r0, #8]
 80068f2:	b29b      	uxth	r3, r3
 80068f4:	4319      	orrs	r1, r3
 80068f6:	8101      	strh	r1, [r0, #8]
 80068f8:	4770      	bx	lr

080068fa <TIM_SelectMasterSlaveMode>:
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
 80068fa:	8903      	ldrh	r3, [r0, #8]
 80068fc:	b29b      	uxth	r3, r3
 80068fe:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8006902:	b29b      	uxth	r3, r3
 8006904:	8103      	strh	r3, [r0, #8]
  TIMx->SMCR |= TIM_MasterSlaveMode;
 8006906:	8903      	ldrh	r3, [r0, #8]
 8006908:	b29b      	uxth	r3, r3
 800690a:	4319      	orrs	r1, r3
 800690c:	8101      	strh	r1, [r0, #8]
 800690e:	4770      	bx	lr

08006910 <TIM_ETRConfig>:
{
 8006910:	b410      	push	{r4}
  tmpsmcr = TIMx->SMCR;
 8006912:	8904      	ldrh	r4, [r0, #8]
  tmpsmcr &= SMCR_ETR_MASK;
 8006914:	b2e4      	uxtb	r4, r4
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8006916:	021b      	lsls	r3, r3, #8
 8006918:	b29b      	uxth	r3, r3
 800691a:	4313      	orrs	r3, r2
 800691c:	430b      	orrs	r3, r1
 800691e:	4323      	orrs	r3, r4
  TIMx->SMCR = tmpsmcr;
 8006920:	8103      	strh	r3, [r0, #8]
}
 8006922:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006926:	4770      	bx	lr

08006928 <TIM_ETRClockMode1Config>:
{
 8006928:	b510      	push	{r4, lr}
 800692a:	4604      	mov	r4, r0
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 800692c:	f7ff fff0 	bl	8006910 <TIM_ETRConfig>
  tmpsmcr = TIMx->SMCR;
 8006930:	8923      	ldrh	r3, [r4, #8]
 8006932:	b29b      	uxth	r3, r3
  tmpsmcr |= TIM_TS_ETRF;
 8006934:	f043 0377 	orr.w	r3, r3, #119	; 0x77
  TIMx->SMCR = tmpsmcr;
 8006938:	8123      	strh	r3, [r4, #8]
 800693a:	bd10      	pop	{r4, pc}

0800693c <TIM_ETRClockMode2Config>:
{
 800693c:	b510      	push	{r4, lr}
 800693e:	4604      	mov	r4, r0
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 8006940:	f7ff ffe6 	bl	8006910 <TIM_ETRConfig>
  TIMx->SMCR |= TIM_SMCR_ECE;
 8006944:	8923      	ldrh	r3, [r4, #8]
 8006946:	b29b      	uxth	r3, r3
 8006948:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800694c:	8123      	strh	r3, [r4, #8]
 800694e:	bd10      	pop	{r4, pc}

08006950 <TIM_EncoderInterfaceConfig>:
{
 8006950:	b470      	push	{r4, r5, r6}
  tmpsmcr = TIMx->SMCR;
 8006952:	8906      	ldrh	r6, [r0, #8]
 8006954:	b2b6      	uxth	r6, r6
  tmpccmr1 = TIMx->CCMR1;
 8006956:	8b04      	ldrh	r4, [r0, #24]
 8006958:	b2a4      	uxth	r4, r4
  tmpccer = TIMx->CCER;
 800695a:	8c05      	ldrh	r5, [r0, #32]
 800695c:	b2ad      	uxth	r5, r5
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 800695e:	f026 0607 	bic.w	r6, r6, #7
  tmpsmcr |= TIM_EncoderMode;
 8006962:	4331      	orrs	r1, r6
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 8006964:	f424 7440 	bic.w	r4, r4, #768	; 0x300
 8006968:	f024 0403 	bic.w	r4, r4, #3
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 800696c:	f444 7480 	orr.w	r4, r4, #256	; 0x100
 8006970:	f044 0401 	orr.w	r4, r4, #1
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
 8006974:	f025 0522 	bic.w	r5, r5, #34	; 0x22
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 8006978:	011b      	lsls	r3, r3, #4
 800697a:	b29b      	uxth	r3, r3
 800697c:	431a      	orrs	r2, r3
 800697e:	4315      	orrs	r5, r2
  TIMx->SMCR = tmpsmcr;
 8006980:	8101      	strh	r1, [r0, #8]
  TIMx->CCMR1 = tmpccmr1;
 8006982:	8304      	strh	r4, [r0, #24]
  TIMx->CCER = tmpccer;
 8006984:	8405      	strh	r5, [r0, #32]
}
 8006986:	bc70      	pop	{r4, r5, r6}
 8006988:	4770      	bx	lr

0800698a <TIM_SelectHallSensor>:
  if (NewState != DISABLE)
 800698a:	b931      	cbnz	r1, 800699a <TIM_SelectHallSensor+0x10>
    TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
 800698c:	8883      	ldrh	r3, [r0, #4]
 800698e:	b29b      	uxth	r3, r3
 8006990:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8006994:	b29b      	uxth	r3, r3
 8006996:	8083      	strh	r3, [r0, #4]
 8006998:	4770      	bx	lr
    TIMx->CR2 |= TIM_CR2_TI1S;
 800699a:	8883      	ldrh	r3, [r0, #4]
 800699c:	b29b      	uxth	r3, r3
 800699e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80069a2:	8083      	strh	r3, [r0, #4]
 80069a4:	4770      	bx	lr

080069a6 <TIM_RemapConfig>:
  TIMx->OR =  TIM_Remap;
 80069a6:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
 80069aa:	4770      	bx	lr

080069ac <USART_DeInit>:
  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
  *         UART peripheral.
  * @retval None
  */
void USART_DeInit(USART_TypeDef* USARTx)
{
 80069ac:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
 80069ae:	4b36      	ldr	r3, [pc, #216]	; (8006a88 <USART_DeInit+0xdc>)
 80069b0:	4298      	cmp	r0, r3
 80069b2:	d015      	beq.n	80069e0 <USART_DeInit+0x34>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  }
  else if (USARTx == USART2)
 80069b4:	4b35      	ldr	r3, [pc, #212]	; (8006a8c <USART_DeInit+0xe0>)
 80069b6:	4298      	cmp	r0, r3
 80069b8:	d01b      	beq.n	80069f2 <USART_DeInit+0x46>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  }
  else if (USARTx == USART3)
 80069ba:	4b35      	ldr	r3, [pc, #212]	; (8006a90 <USART_DeInit+0xe4>)
 80069bc:	4298      	cmp	r0, r3
 80069be:	d023      	beq.n	8006a08 <USART_DeInit+0x5c>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  }    
  else if (USARTx == UART4)
 80069c0:	4b34      	ldr	r3, [pc, #208]	; (8006a94 <USART_DeInit+0xe8>)
 80069c2:	4298      	cmp	r0, r3
 80069c4:	d02b      	beq.n	8006a1e <USART_DeInit+0x72>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
  }
  else if (USARTx == UART5)
 80069c6:	4b34      	ldr	r3, [pc, #208]	; (8006a98 <USART_DeInit+0xec>)
 80069c8:	4298      	cmp	r0, r3
 80069ca:	d033      	beq.n	8006a34 <USART_DeInit+0x88>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
  }  
  else if (USARTx == USART6)
 80069cc:	4b33      	ldr	r3, [pc, #204]	; (8006a9c <USART_DeInit+0xf0>)
 80069ce:	4298      	cmp	r0, r3
 80069d0:	d03b      	beq.n	8006a4a <USART_DeInit+0x9e>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
  }
  else if (USARTx == UART7)
 80069d2:	4b33      	ldr	r3, [pc, #204]	; (8006aa0 <USART_DeInit+0xf4>)
 80069d4:	4298      	cmp	r0, r3
 80069d6:	d041      	beq.n	8006a5c <USART_DeInit+0xb0>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, DISABLE);
  }     
  else
  {
    if (USARTx == UART8)
 80069d8:	4b32      	ldr	r3, [pc, #200]	; (8006aa4 <USART_DeInit+0xf8>)
 80069da:	4298      	cmp	r0, r3
 80069dc:	d049      	beq.n	8006a72 <USART_DeInit+0xc6>
 80069de:	bd08      	pop	{r3, pc}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 80069e0:	2101      	movs	r1, #1
 80069e2:	2010      	movs	r0, #16
 80069e4:	f7fd ffee 	bl	80049c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 80069e8:	2100      	movs	r1, #0
 80069ea:	2010      	movs	r0, #16
 80069ec:	f7fd ffea 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 80069f0:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 80069f2:	2101      	movs	r1, #1
 80069f4:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80069f8:	f7fd ffd6 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 80069fc:	2100      	movs	r1, #0
 80069fe:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8006a02:	f7fd ffd1 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8006a06:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 8006a08:	2101      	movs	r1, #1
 8006a0a:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8006a0e:	f7fd ffcb 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 8006a12:	2100      	movs	r1, #0
 8006a14:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8006a18:	f7fd ffc6 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8006a1c:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 8006a1e:	2101      	movs	r1, #1
 8006a20:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8006a24:	f7fd ffc0 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 8006a28:	2100      	movs	r1, #0
 8006a2a:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8006a2e:	f7fd ffbb 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8006a32:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 8006a34:	2101      	movs	r1, #1
 8006a36:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8006a3a:	f7fd ffb5 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 8006a3e:	2100      	movs	r1, #0
 8006a40:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8006a44:	f7fd ffb0 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8006a48:	bd08      	pop	{r3, pc}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
 8006a4a:	2101      	movs	r1, #1
 8006a4c:	2020      	movs	r0, #32
 8006a4e:	f7fd ffb9 	bl	80049c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 8006a52:	2100      	movs	r1, #0
 8006a54:	2020      	movs	r0, #32
 8006a56:	f7fd ffb5 	bl	80049c4 <RCC_APB2PeriphResetCmd>
 8006a5a:	bd08      	pop	{r3, pc}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, ENABLE);
 8006a5c:	2101      	movs	r1, #1
 8006a5e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8006a62:	f7fd ffa1 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART7, DISABLE);
 8006a66:	2100      	movs	r1, #0
 8006a68:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8006a6c:	f7fd ff9c 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8006a70:	bd08      	pop	{r3, pc}
    { 
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, ENABLE);
 8006a72:	2101      	movs	r1, #1
 8006a74:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 8006a78:	f7fd ff96 	bl	80049a8 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART8, DISABLE);
 8006a7c:	2100      	movs	r1, #0
 8006a7e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 8006a82:	f7fd ff91 	bl	80049a8 <RCC_APB1PeriphResetCmd>
    }
  }
}
 8006a86:	e7aa      	b.n	80069de <USART_DeInit+0x32>
 8006a88:	40011000 	.word	0x40011000
 8006a8c:	40004400 	.word	0x40004400
 8006a90:	40004800 	.word	0x40004800
 8006a94:	40004c00 	.word	0x40004c00
 8006a98:	40005000 	.word	0x40005000
 8006a9c:	40011400 	.word	0x40011400
 8006aa0:	40007800 	.word	0x40007800
 8006aa4:	40007c00 	.word	0x40007c00

08006aa8 <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8006aa8:	b530      	push	{r4, r5, lr}
 8006aaa:	b085      	sub	sp, #20
 8006aac:	4604      	mov	r4, r0
 8006aae:	460d      	mov	r5, r1
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8006ab0:	8a03      	ldrh	r3, [r0, #16]
 8006ab2:	b29b      	uxth	r3, r3

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8006ab4:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000

  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8006ab8:	88ca      	ldrh	r2, [r1, #6]
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8006aba:	4313      	orrs	r3, r2
 8006abc:	8203      	strh	r3, [r0, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8006abe:	8983      	ldrh	r3, [r0, #12]
 8006ac0:	b29b      	uxth	r3, r3

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 8006ac2:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
 8006ac6:	f023 030c 	bic.w	r3, r3, #12

  /* Configure the USART Word Length, Parity and mode: 
     Set the M bits according to USART_WordLength value 
     Set PCE and PS bits according to USART_Parity value
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8006aca:	8889      	ldrh	r1, [r1, #4]
 8006acc:	8928      	ldrh	r0, [r5, #8]
            USART_InitStruct->USART_Mode;
 8006ace:	896a      	ldrh	r2, [r5, #10]
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8006ad0:	4301      	orrs	r1, r0
 8006ad2:	430a      	orrs	r2, r1

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8006ad4:	4313      	orrs	r3, r2
 8006ad6:	81a3      	strh	r3, [r4, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8006ad8:	8aa3      	ldrh	r3, [r4, #20]
 8006ada:	b29b      	uxth	r3, r3

  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 8006adc:	f423 7340 	bic.w	r3, r3, #768	; 0x300

  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8006ae0:	89aa      	ldrh	r2, [r5, #12]

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8006ae2:	4313      	orrs	r3, r2
 8006ae4:	82a3      	strh	r3, [r4, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8006ae6:	4668      	mov	r0, sp
 8006ae8:	f7fd fe60 	bl	80047ac <RCC_GetClocksFreq>

  if ((USARTx == USART1) || (USARTx == USART6))
 8006aec:	4b20      	ldr	r3, [pc, #128]	; (8006b70 <USART_Init+0xc8>)
 8006aee:	429c      	cmp	r4, r3
 8006af0:	d028      	beq.n	8006b44 <USART_Init+0x9c>
 8006af2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8006af6:	429c      	cmp	r4, r3
 8006af8:	d024      	beq.n	8006b44 <USART_Init+0x9c>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8006afa:	9b02      	ldr	r3, [sp, #8]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8006afc:	89a2      	ldrh	r2, [r4, #12]
 8006afe:	f412 4f00 	tst.w	r2, #32768	; 0x8000
 8006b02:	d121      	bne.n	8006b48 <USART_Init+0xa0>
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8006b04:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8006b08:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8006b0c:	6829      	ldr	r1, [r5, #0]
 8006b0e:	0089      	lsls	r1, r1, #2
 8006b10:	fbb3 f1f1 	udiv	r1, r3, r1
  }
  tmpreg = (integerdivider / 100) << 4;
 8006b14:	4b17      	ldr	r3, [pc, #92]	; (8006b74 <USART_Init+0xcc>)
 8006b16:	fba3 2301 	umull	r2, r3, r3, r1
 8006b1a:	0958      	lsrs	r0, r3, #5
 8006b1c:	0105      	lsls	r5, r0, #4

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8006b1e:	2364      	movs	r3, #100	; 0x64
 8006b20:	fb00 1313 	mls	r3, r0, r3, r1

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8006b24:	89a2      	ldrh	r2, [r4, #12]
 8006b26:	f412 4f00 	tst.w	r2, #32768	; 0x8000
 8006b2a:	d116      	bne.n	8006b5a <USART_Init+0xb2>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8006b2c:	011b      	lsls	r3, r3, #4
 8006b2e:	3332      	adds	r3, #50	; 0x32
 8006b30:	4a10      	ldr	r2, [pc, #64]	; (8006b74 <USART_Init+0xcc>)
 8006b32:	fba2 2303 	umull	r2, r3, r2, r3
 8006b36:	f3c3 1343 	ubfx	r3, r3, #5, #4
 8006b3a:	432b      	orrs	r3, r5
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 8006b3c:	b29b      	uxth	r3, r3
 8006b3e:	8123      	strh	r3, [r4, #8]
}
 8006b40:	b005      	add	sp, #20
 8006b42:	bd30      	pop	{r4, r5, pc}
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8006b44:	9b03      	ldr	r3, [sp, #12]
 8006b46:	e7d9      	b.n	8006afc <USART_Init+0x54>
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8006b48:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8006b4c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8006b50:	6829      	ldr	r1, [r5, #0]
 8006b52:	0049      	lsls	r1, r1, #1
 8006b54:	fbb3 f1f1 	udiv	r1, r3, r1
 8006b58:	e7dc      	b.n	8006b14 <USART_Init+0x6c>
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 8006b5a:	00d9      	lsls	r1, r3, #3
 8006b5c:	3132      	adds	r1, #50	; 0x32
 8006b5e:	4a05      	ldr	r2, [pc, #20]	; (8006b74 <USART_Init+0xcc>)
 8006b60:	fba2 3101 	umull	r3, r1, r2, r1
 8006b64:	f3c1 1242 	ubfx	r2, r1, #5, #3
 8006b68:	ea45 0302 	orr.w	r3, r5, r2
 8006b6c:	e7e6      	b.n	8006b3c <USART_Init+0x94>
 8006b6e:	bf00      	nop
 8006b70:	40011000 	.word	0x40011000
 8006b74:	51eb851f 	.word	0x51eb851f

08006b78 <USART_StructInit>:
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 8006b78:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 8006b7c:	6003      	str	r3, [r0, #0]
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 8006b7e:	2300      	movs	r3, #0
 8006b80:	8083      	strh	r3, [r0, #4]
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
 8006b82:	80c3      	strh	r3, [r0, #6]
  USART_InitStruct->USART_Parity = USART_Parity_No ;
 8006b84:	8103      	strh	r3, [r0, #8]
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8006b86:	220c      	movs	r2, #12
 8006b88:	8142      	strh	r2, [r0, #10]
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 8006b8a:	8183      	strh	r3, [r0, #12]
 8006b8c:	4770      	bx	lr

08006b8e <USART_ClockInit>:
  *         contains the configuration information for the specified  USART peripheral.
  * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
  * @retval None
  */
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
{
 8006b8e:	b470      	push	{r4, r5, r6}
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8006b90:	8a03      	ldrh	r3, [r0, #16]
 8006b92:	b29b      	uxth	r3, r3
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 8006b94:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 8006b98:	880d      	ldrh	r5, [r1, #0]
 8006b9a:	884e      	ldrh	r6, [r1, #2]
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 8006b9c:	888c      	ldrh	r4, [r1, #4]
 8006b9e:	88ca      	ldrh	r2, [r1, #6]
 8006ba0:	ea45 0106 	orr.w	r1, r5, r6
 8006ba4:	4321      	orrs	r1, r4
 8006ba6:	430a      	orrs	r2, r1
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8006ba8:	4313      	orrs	r3, r2
 8006baa:	8203      	strh	r3, [r0, #16]
}
 8006bac:	bc70      	pop	{r4, r5, r6}
 8006bae:	4770      	bx	lr

08006bb0 <USART_ClockStructInit>:
  * @retval None
  */
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 8006bb0:	2300      	movs	r3, #0
 8006bb2:	8003      	strh	r3, [r0, #0]
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 8006bb4:	8043      	strh	r3, [r0, #2]
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 8006bb6:	8083      	strh	r3, [r0, #4]
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 8006bb8:	80c3      	strh	r3, [r0, #6]
 8006bba:	4770      	bx	lr

08006bbc <USART_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8006bbc:	b931      	cbnz	r1, 8006bcc <USART_Cmd+0x10>
    USARTx->CR1 |= USART_CR1_UE;
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 8006bbe:	8983      	ldrh	r3, [r0, #12]
 8006bc0:	b29b      	uxth	r3, r3
 8006bc2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8006bc6:	b29b      	uxth	r3, r3
 8006bc8:	8183      	strh	r3, [r0, #12]
 8006bca:	4770      	bx	lr
    USARTx->CR1 |= USART_CR1_UE;
 8006bcc:	8983      	ldrh	r3, [r0, #12]
 8006bce:	b29b      	uxth	r3, r3
 8006bd0:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8006bd4:	8183      	strh	r3, [r0, #12]
 8006bd6:	4770      	bx	lr

08006bd8 <USART_SetPrescaler>:
{ 
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Clear the USART prescaler */
  USARTx->GTPR &= USART_GTPR_GT;
 8006bd8:	8b03      	ldrh	r3, [r0, #24]
 8006bda:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8006bde:	8303      	strh	r3, [r0, #24]
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
 8006be0:	8b03      	ldrh	r3, [r0, #24]
 8006be2:	b29b      	uxth	r3, r3
 8006be4:	4319      	orrs	r1, r3
 8006be6:	8301      	strh	r1, [r0, #24]
 8006be8:	4770      	bx	lr

08006bea <USART_OverSampling8Cmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8006bea:	b921      	cbnz	r1, 8006bf6 <USART_OverSampling8Cmd+0xc>
    USARTx->CR1 |= USART_CR1_OVER8;
  }
  else
  {
    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
 8006bec:	8983      	ldrh	r3, [r0, #12]
 8006bee:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8006bf2:	8183      	strh	r3, [r0, #12]
 8006bf4:	4770      	bx	lr
    USARTx->CR1 |= USART_CR1_OVER8;
 8006bf6:	8983      	ldrh	r3, [r0, #12]
 8006bf8:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8006bfc:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8006c00:	b29b      	uxth	r3, r3
 8006c02:	8183      	strh	r3, [r0, #12]
 8006c04:	4770      	bx	lr

08006c06 <USART_OneBitMethodCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8006c06:	b931      	cbnz	r1, 8006c16 <USART_OneBitMethodCmd+0x10>
    USARTx->CR3 |= USART_CR3_ONEBIT;
  }
  else
  {
    /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
 8006c08:	8a83      	ldrh	r3, [r0, #20]
 8006c0a:	b29b      	uxth	r3, r3
 8006c0c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8006c10:	b29b      	uxth	r3, r3
 8006c12:	8283      	strh	r3, [r0, #20]
 8006c14:	4770      	bx	lr
    USARTx->CR3 |= USART_CR3_ONEBIT;
 8006c16:	8a83      	ldrh	r3, [r0, #20]
 8006c18:	b29b      	uxth	r3, r3
 8006c1a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8006c1e:	8283      	strh	r3, [r0, #20]
 8006c20:	4770      	bx	lr

08006c22 <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 8006c22:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8006c26:	8081      	strh	r1, [r0, #4]
 8006c28:	4770      	bx	lr

08006c2a <USART_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 8006c2a:	8880      	ldrh	r0, [r0, #4]
}
 8006c2c:	f3c0 0008 	ubfx	r0, r0, #0, #9
 8006c30:	4770      	bx	lr

08006c32 <USART_SetAddress>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS(USART_Address)); 
    
  /* Clear the USART address */
  USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
 8006c32:	8a03      	ldrh	r3, [r0, #16]
 8006c34:	b29b      	uxth	r3, r3
 8006c36:	f023 030f 	bic.w	r3, r3, #15
 8006c3a:	b29b      	uxth	r3, r3
 8006c3c:	8203      	strh	r3, [r0, #16]
  /* Set the USART address node */
  USARTx->CR2 |= USART_Address;
 8006c3e:	8a03      	ldrh	r3, [r0, #16]
 8006c40:	b29b      	uxth	r3, r3
 8006c42:	4319      	orrs	r1, r3
 8006c44:	8201      	strh	r1, [r0, #16]
 8006c46:	4770      	bx	lr

08006c48 <USART_ReceiverWakeUpCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
 8006c48:	b931      	cbnz	r1, 8006c58 <USART_ReceiverWakeUpCmd+0x10>
    USARTx->CR1 |= USART_CR1_RWU;
  }
  else
  {
    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
 8006c4a:	8983      	ldrh	r3, [r0, #12]
 8006c4c:	b29b      	uxth	r3, r3
 8006c4e:	f023 0302 	bic.w	r3, r3, #2
 8006c52:	b29b      	uxth	r3, r3
 8006c54:	8183      	strh	r3, [r0, #12]
 8006c56:	4770      	bx	lr
    USARTx->CR1 |= USART_CR1_RWU;
 8006c58:	8983      	ldrh	r3, [r0, #12]
 8006c5a:	b29b      	uxth	r3, r3
 8006c5c:	f043 0302 	orr.w	r3, r3, #2
 8006c60:	8183      	strh	r3, [r0, #12]
 8006c62:	4770      	bx	lr

08006c64 <USART_WakeUpConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_WAKEUP(USART_WakeUp));
  
  USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
 8006c64:	8983      	ldrh	r3, [r0, #12]
 8006c66:	b29b      	uxth	r3, r3
 8006c68:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8006c6c:	b29b      	uxth	r3, r3
 8006c6e:	8183      	strh	r3, [r0, #12]
  USARTx->CR1 |= USART_WakeUp;
 8006c70:	8983      	ldrh	r3, [r0, #12]
 8006c72:	b29b      	uxth	r3, r3
 8006c74:	4319      	orrs	r1, r3
 8006c76:	8181      	strh	r1, [r0, #12]
 8006c78:	4770      	bx	lr

08006c7a <USART_LINBreakDetectLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
  
  USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
 8006c7a:	8a03      	ldrh	r3, [r0, #16]
 8006c7c:	b29b      	uxth	r3, r3
 8006c7e:	f023 0320 	bic.w	r3, r3, #32
 8006c82:	b29b      	uxth	r3, r3
 8006c84:	8203      	strh	r3, [r0, #16]
  USARTx->CR2 |= USART_LINBreakDetectLength;  
 8006c86:	8a03      	ldrh	r3, [r0, #16]
 8006c88:	b29b      	uxth	r3, r3
 8006c8a:	4319      	orrs	r1, r3
 8006c8c:	8201      	strh	r1, [r0, #16]
 8006c8e:	4770      	bx	lr

08006c90 <USART_LINCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8006c90:	b931      	cbnz	r1, 8006ca0 <USART_LINCmd+0x10>
    USARTx->CR2 |= USART_CR2_LINEN;
  }
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
 8006c92:	8a03      	ldrh	r3, [r0, #16]
 8006c94:	b29b      	uxth	r3, r3
 8006c96:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8006c9a:	b29b      	uxth	r3, r3
 8006c9c:	8203      	strh	r3, [r0, #16]
 8006c9e:	4770      	bx	lr
    USARTx->CR2 |= USART_CR2_LINEN;
 8006ca0:	8a03      	ldrh	r3, [r0, #16]
 8006ca2:	b29b      	uxth	r3, r3
 8006ca4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8006ca8:	8203      	strh	r3, [r0, #16]
 8006caa:	4770      	bx	lr

08006cac <USART_SendBreak>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Send break characters */
  USARTx->CR1 |= USART_CR1_SBK;
 8006cac:	8983      	ldrh	r3, [r0, #12]
 8006cae:	b29b      	uxth	r3, r3
 8006cb0:	f043 0301 	orr.w	r3, r3, #1
 8006cb4:	8183      	strh	r3, [r0, #12]
 8006cb6:	4770      	bx	lr

08006cb8 <USART_HalfDuplexCmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8006cb8:	b931      	cbnz	r1, 8006cc8 <USART_HalfDuplexCmd+0x10>
    USARTx->CR3 |= USART_CR3_HDSEL;
  }
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
 8006cba:	8a83      	ldrh	r3, [r0, #20]
 8006cbc:	b29b      	uxth	r3, r3
 8006cbe:	f023 0308 	bic.w	r3, r3, #8
 8006cc2:	b29b      	uxth	r3, r3
 8006cc4:	8283      	strh	r3, [r0, #20]
 8006cc6:	4770      	bx	lr
    USARTx->CR3 |= USART_CR3_HDSEL;
 8006cc8:	8a83      	ldrh	r3, [r0, #20]
 8006cca:	b29b      	uxth	r3, r3
 8006ccc:	f043 0308 	orr.w	r3, r3, #8
 8006cd0:	8283      	strh	r3, [r0, #20]
 8006cd2:	4770      	bx	lr

08006cd4 <USART_SetGuardTime>:
{    
  /* Check the parameters */
  assert_param(IS_USART_1236_PERIPH(USARTx));
  
  /* Clear the USART Guard time */
  USARTx->GTPR &= USART_GTPR_PSC;
 8006cd4:	8b03      	ldrh	r3, [r0, #24]
 8006cd6:	b2db      	uxtb	r3, r3
 8006cd8:	8303      	strh	r3, [r0, #24]
  /* Set the USART guard time */
  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 8006cda:	8b03      	ldrh	r3, [r0, #24]
 8006cdc:	b29b      	uxth	r3, r3
 8006cde:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8006ce2:	8301      	strh	r1, [r0, #24]
 8006ce4:	4770      	bx	lr

08006ce6 <USART_SmartCardCmd>:
void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_1236_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8006ce6:	b931      	cbnz	r1, 8006cf6 <USART_SmartCardCmd+0x10>
    USARTx->CR3 |= USART_CR3_SCEN;
  }
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
 8006ce8:	8a83      	ldrh	r3, [r0, #20]
 8006cea:	b29b      	uxth	r3, r3
 8006cec:	f023 0320 	bic.w	r3, r3, #32
 8006cf0:	b29b      	uxth	r3, r3
 8006cf2:	8283      	strh	r3, [r0, #20]
 8006cf4:	4770      	bx	lr
    USARTx->CR3 |= USART_CR3_SCEN;
 8006cf6:	8a83      	ldrh	r3, [r0, #20]
 8006cf8:	b29b      	uxth	r3, r3
 8006cfa:	f043 0320 	orr.w	r3, r3, #32
 8006cfe:	8283      	strh	r3, [r0, #20]
 8006d00:	4770      	bx	lr

08006d02 <USART_SmartCardNACKCmd>:
void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_1236_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8006d02:	b931      	cbnz	r1, 8006d12 <USART_SmartCardNACKCmd+0x10>
    USARTx->CR3 |= USART_CR3_NACK;
  }
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
 8006d04:	8a83      	ldrh	r3, [r0, #20]
 8006d06:	b29b      	uxth	r3, r3
 8006d08:	f023 0310 	bic.w	r3, r3, #16
 8006d0c:	b29b      	uxth	r3, r3
 8006d0e:	8283      	strh	r3, [r0, #20]
 8006d10:	4770      	bx	lr
    USARTx->CR3 |= USART_CR3_NACK;
 8006d12:	8a83      	ldrh	r3, [r0, #20]
 8006d14:	b29b      	uxth	r3, r3
 8006d16:	f043 0310 	orr.w	r3, r3, #16
 8006d1a:	8283      	strh	r3, [r0, #20]
 8006d1c:	4770      	bx	lr

08006d1e <USART_IrDAConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
    
  USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
 8006d1e:	8a83      	ldrh	r3, [r0, #20]
 8006d20:	b29b      	uxth	r3, r3
 8006d22:	f023 0304 	bic.w	r3, r3, #4
 8006d26:	b29b      	uxth	r3, r3
 8006d28:	8283      	strh	r3, [r0, #20]
  USARTx->CR3 |= USART_IrDAMode;
 8006d2a:	8a83      	ldrh	r3, [r0, #20]
 8006d2c:	b29b      	uxth	r3, r3
 8006d2e:	4319      	orrs	r1, r3
 8006d30:	8281      	strh	r1, [r0, #20]
 8006d32:	4770      	bx	lr

08006d34 <USART_IrDACmd>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 8006d34:	b931      	cbnz	r1, 8006d44 <USART_IrDACmd+0x10>
    USARTx->CR3 |= USART_CR3_IREN;
  }
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
 8006d36:	8a83      	ldrh	r3, [r0, #20]
 8006d38:	b29b      	uxth	r3, r3
 8006d3a:	f023 0302 	bic.w	r3, r3, #2
 8006d3e:	b29b      	uxth	r3, r3
 8006d40:	8283      	strh	r3, [r0, #20]
 8006d42:	4770      	bx	lr
    USARTx->CR3 |= USART_CR3_IREN;
 8006d44:	8a83      	ldrh	r3, [r0, #20]
 8006d46:	b29b      	uxth	r3, r3
 8006d48:	f043 0302 	orr.w	r3, r3, #2
 8006d4c:	8283      	strh	r3, [r0, #20]
 8006d4e:	4770      	bx	lr

08006d50 <USART_DMACmd>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 8006d50:	b92a      	cbnz	r2, 8006d5e <USART_DMACmd+0xe>
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 8006d52:	8a83      	ldrh	r3, [r0, #20]
 8006d54:	43c9      	mvns	r1, r1
 8006d56:	b289      	uxth	r1, r1
 8006d58:	4019      	ands	r1, r3
 8006d5a:	8281      	strh	r1, [r0, #20]
 8006d5c:	4770      	bx	lr
    USARTx->CR3 |= USART_DMAReq;
 8006d5e:	8a83      	ldrh	r3, [r0, #20]
 8006d60:	b29b      	uxth	r3, r3
 8006d62:	4319      	orrs	r1, r3
 8006d64:	8281      	strh	r1, [r0, #20]
 8006d66:	4770      	bx	lr

08006d68 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 8006d68:	b410      	push	{r4}
  } 
    
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8006d6a:	f3c1 1442 	ubfx	r4, r1, #5, #3

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 8006d6e:	f001 011f 	and.w	r1, r1, #31
  itmask = (((uint32_t)0x01) << itpos);
 8006d72:	2301      	movs	r3, #1
 8006d74:	fa03 f101 	lsl.w	r1, r3, r1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 8006d78:	429c      	cmp	r4, r3
 8006d7a:	d00a      	beq.n	8006d92 <USART_ITConfig+0x2a>
  {
    usartxbase += 0x0C;
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 8006d7c:	2c02      	cmp	r4, #2
 8006d7e:	d00a      	beq.n	8006d96 <USART_ITConfig+0x2e>
  {
    usartxbase += 0x10;
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 8006d80:	3014      	adds	r0, #20
  }
  if (NewState != DISABLE)
 8006d82:	b952      	cbnz	r2, 8006d9a <USART_ITConfig+0x32>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8006d84:	6803      	ldr	r3, [r0, #0]
 8006d86:	ea23 0101 	bic.w	r1, r3, r1
 8006d8a:	6001      	str	r1, [r0, #0]
  }
}
 8006d8c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006d90:	4770      	bx	lr
    usartxbase += 0x0C;
 8006d92:	300c      	adds	r0, #12
 8006d94:	e7f5      	b.n	8006d82 <USART_ITConfig+0x1a>
    usartxbase += 0x10;
 8006d96:	3010      	adds	r0, #16
 8006d98:	e7f3      	b.n	8006d82 <USART_ITConfig+0x1a>
    *(__IO uint32_t*)usartxbase  |= itmask;
 8006d9a:	6803      	ldr	r3, [r0, #0]
 8006d9c:	4319      	orrs	r1, r3
 8006d9e:	6001      	str	r1, [r0, #0]
 8006da0:	e7f4      	b.n	8006d8c <USART_ITConfig+0x24>

08006da2 <USART_GetFlagStatus>:
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 8006da2:	8803      	ldrh	r3, [r0, #0]
 8006da4:	4219      	tst	r1, r3
 8006da6:	d101      	bne.n	8006dac <USART_GetFlagStatus+0xa>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8006da8:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 8006daa:	4770      	bx	lr
    bitstatus = SET;
 8006dac:	2001      	movs	r0, #1
 8006dae:	4770      	bx	lr

08006db0 <USART_ClearFlag>:
  if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
       
  USARTx->SR = (uint16_t)~USART_FLAG;
 8006db0:	43c9      	mvns	r1, r1
 8006db2:	b289      	uxth	r1, r1
 8006db4:	8001      	strh	r1, [r0, #0]
 8006db6:	4770      	bx	lr

08006db8 <USART_GetITStatus>:
  *            @arg USART_IT_FE:   Framing Error interrupt
  *            @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8006db8:	b410      	push	{r4}
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8006dba:	f3c1 1242 	ubfx	r2, r1, #5, #3
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 8006dbe:	f001 041f 	and.w	r4, r1, #31
  itmask = (uint32_t)0x01 << itmask;
 8006dc2:	2301      	movs	r3, #1
 8006dc4:	40a3      	lsls	r3, r4
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8006dc6:	2a01      	cmp	r2, #1
 8006dc8:	d00f      	beq.n	8006dea <USART_GetITStatus+0x32>
  {
    itmask &= USARTx->CR1;
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 8006dca:	2a02      	cmp	r2, #2
 8006dcc:	d011      	beq.n	8006df2 <USART_GetITStatus+0x3a>
  {
    itmask &= USARTx->CR2;
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8006dce:	8a82      	ldrh	r2, [r0, #20]
 8006dd0:	b292      	uxth	r2, r2
 8006dd2:	4013      	ands	r3, r2
  }
  
  bitpos = USART_IT >> 0x08;
 8006dd4:	0a09      	lsrs	r1, r1, #8
  bitpos = (uint32_t)0x01 << bitpos;
 8006dd6:	2201      	movs	r2, #1
 8006dd8:	fa02 f101 	lsl.w	r1, r2, r1
  bitpos &= USARTx->SR;
 8006ddc:	8802      	ldrh	r2, [r0, #0]
 8006dde:	b292      	uxth	r2, r2
 8006de0:	4011      	ands	r1, r2
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8006de2:	b153      	cbz	r3, 8006dfa <USART_GetITStatus+0x42>
 8006de4:	b969      	cbnz	r1, 8006e02 <USART_GetITStatus+0x4a>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8006de6:	2000      	movs	r0, #0
 8006de8:	e008      	b.n	8006dfc <USART_GetITStatus+0x44>
    itmask &= USARTx->CR1;
 8006dea:	8982      	ldrh	r2, [r0, #12]
 8006dec:	b292      	uxth	r2, r2
 8006dee:	4013      	ands	r3, r2
 8006df0:	e7f0      	b.n	8006dd4 <USART_GetITStatus+0x1c>
    itmask &= USARTx->CR2;
 8006df2:	8a02      	ldrh	r2, [r0, #16]
 8006df4:	b292      	uxth	r2, r2
 8006df6:	4013      	ands	r3, r2
 8006df8:	e7ec      	b.n	8006dd4 <USART_GetITStatus+0x1c>
    bitstatus = RESET;
 8006dfa:	2000      	movs	r0, #0
  }
  
  return bitstatus;  
}
 8006dfc:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006e00:	4770      	bx	lr
    bitstatus = SET;
 8006e02:	2001      	movs	r0, #1
 8006e04:	e7fa      	b.n	8006dfc <USART_GetITStatus+0x44>

08006e06 <USART_ClearITPendingBit>:
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  bitpos = USART_IT >> 0x08;
 8006e06:	0a09      	lsrs	r1, r1, #8
  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 8006e08:	2301      	movs	r3, #1
 8006e0a:	408b      	lsls	r3, r1
 8006e0c:	b29b      	uxth	r3, r3
  USARTx->SR = (uint16_t)~itmask;
 8006e0e:	43db      	mvns	r3, r3
 8006e10:	b29b      	uxth	r3, r3
 8006e12:	8003      	strh	r3, [r0, #0]
 8006e14:	4770      	bx	lr
 8006e16:	bf00      	nop

08006e18 <WWDG_DeInit>:
  * @brief  Deinitializes the WWDG peripheral registers to their default reset values.
  * @param  None
  * @retval None
  */
void WWDG_DeInit(void)
{
 8006e18:	b508      	push	{r3, lr}
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);
 8006e1a:	2101      	movs	r1, #1
 8006e1c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8006e20:	f7fd fdc2 	bl	80049a8 <RCC_APB1PeriphResetCmd>
  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);
 8006e24:	2100      	movs	r1, #0
 8006e26:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8006e2a:	f7fd fdbd 	bl	80049a8 <RCC_APB1PeriphResetCmd>
 8006e2e:	bd08      	pop	{r3, pc}

08006e30 <WWDG_SetPrescaler>:
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));
  /* Clear WDGTB[1:0] bits */
  tmpreg = WWDG->CFR & CFR_WDGTB_MASK;
 8006e30:	4a03      	ldr	r2, [pc, #12]	; (8006e40 <WWDG_SetPrescaler+0x10>)
 8006e32:	6853      	ldr	r3, [r2, #4]
 8006e34:	f423 73c0 	bic.w	r3, r3, #384	; 0x180
  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */
  tmpreg |= WWDG_Prescaler;
 8006e38:	4318      	orrs	r0, r3
  /* Store the new value */
  WWDG->CFR = tmpreg;
 8006e3a:	6050      	str	r0, [r2, #4]
 8006e3c:	4770      	bx	lr
 8006e3e:	bf00      	nop
 8006e40:	40002c00 	.word	0x40002c00

08006e44 <WWDG_SetWindowValue>:
  * @param  WindowValue: specifies the window value to be compared to the downcounter.
  *   This parameter value must be lower than 0x80.
  * @retval None
  */
void WWDG_SetWindowValue(uint8_t WindowValue)
{
 8006e44:	b082      	sub	sp, #8
  __IO uint32_t tmpreg = 0;
 8006e46:	2300      	movs	r3, #0
 8006e48:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));
  /* Clear W[6:0] bits */

  tmpreg = WWDG->CFR & CFR_W_MASK;
 8006e4a:	4a07      	ldr	r2, [pc, #28]	; (8006e68 <WWDG_SetWindowValue+0x24>)
 8006e4c:	6853      	ldr	r3, [r2, #4]
 8006e4e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8006e52:	9301      	str	r3, [sp, #4]

  /* Set W[6:0] bits according to WindowValue value */
  tmpreg |= WindowValue & (uint32_t) BIT_MASK;
 8006e54:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 8006e58:	9b01      	ldr	r3, [sp, #4]
 8006e5a:	4318      	orrs	r0, r3
 8006e5c:	9001      	str	r0, [sp, #4]

  /* Store the new value */
  WWDG->CFR = tmpreg;
 8006e5e:	9b01      	ldr	r3, [sp, #4]
 8006e60:	6053      	str	r3, [r2, #4]
}
 8006e62:	b002      	add	sp, #8
 8006e64:	4770      	bx	lr
 8006e66:	bf00      	nop
 8006e68:	40002c00 	.word	0x40002c00

08006e6c <WWDG_EnableIT>:
  * @param  None
  * @retval None
  */
void WWDG_EnableIT(void)
{
  *(__IO uint32_t *) CFR_EWI_BB = (uint32_t)ENABLE;
 8006e6c:	2201      	movs	r2, #1
 8006e6e:	4b01      	ldr	r3, [pc, #4]	; (8006e74 <WWDG_EnableIT+0x8>)
 8006e70:	601a      	str	r2, [r3, #0]
 8006e72:	4770      	bx	lr
 8006e74:	420580a4 	.word	0x420580a4

08006e78 <WWDG_SetCounter>:
{
  /* Check the parameters */
  assert_param(IS_WWDG_COUNTER(Counter));
  /* Write to T[6:0] bits to configure the counter value, no need to do
     a read-modify-write; writing a 0 to WDGA bit does nothing */
  WWDG->CR = Counter & BIT_MASK;
 8006e78:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 8006e7c:	4b01      	ldr	r3, [pc, #4]	; (8006e84 <WWDG_SetCounter+0xc>)
 8006e7e:	6018      	str	r0, [r3, #0]
 8006e80:	4770      	bx	lr
 8006e82:	bf00      	nop
 8006e84:	40002c00 	.word	0x40002c00

08006e88 <WWDG_Enable>:
  */
void WWDG_Enable(uint8_t Counter)
{
  /* Check the parameters */
  assert_param(IS_WWDG_COUNTER(Counter));
  WWDG->CR = WWDG_CR_WDGA | Counter;
 8006e88:	f040 0080 	orr.w	r0, r0, #128	; 0x80
 8006e8c:	4b01      	ldr	r3, [pc, #4]	; (8006e94 <WWDG_Enable+0xc>)
 8006e8e:	6018      	str	r0, [r3, #0]
 8006e90:	4770      	bx	lr
 8006e92:	bf00      	nop
 8006e94:	40002c00 	.word	0x40002c00

08006e98 <WWDG_GetFlagStatus>:
  */
FlagStatus WWDG_GetFlagStatus(void)
{
  FlagStatus bitstatus = RESET;
    
  if ((WWDG->SR) != (uint32_t)RESET)
 8006e98:	4b03      	ldr	r3, [pc, #12]	; (8006ea8 <WWDG_GetFlagStatus+0x10>)
 8006e9a:	689b      	ldr	r3, [r3, #8]
 8006e9c:	b90b      	cbnz	r3, 8006ea2 <WWDG_GetFlagStatus+0xa>
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 8006e9e:	2000      	movs	r0, #0
  }
  return bitstatus;
}
 8006ea0:	4770      	bx	lr
    bitstatus = SET;
 8006ea2:	2001      	movs	r0, #1
 8006ea4:	4770      	bx	lr
 8006ea6:	bf00      	nop
 8006ea8:	40002c00 	.word	0x40002c00

08006eac <WWDG_ClearFlag>:
  * @param  None
  * @retval None
  */
void WWDG_ClearFlag(void)
{
  WWDG->SR = (uint32_t)RESET;
 8006eac:	2200      	movs	r2, #0
 8006eae:	4b01      	ldr	r3, [pc, #4]	; (8006eb4 <WWDG_ClearFlag+0x8>)
 8006eb0:	609a      	str	r2, [r3, #8]
 8006eb2:	4770      	bx	lr
 8006eb4:	40002c00 	.word	0x40002c00

08006eb8 <CAT25512_SendByte>:

/*
Send one byte to eeprom via SPI
*/
void CAT25512_SendByte(unsigned char mData)
{
 8006eb8:	b510      	push	{r4, lr}
 8006eba:	4604      	mov	r4, r0
	while(!SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_TXE)); 
 8006ebc:	2102      	movs	r1, #2
 8006ebe:	4809      	ldr	r0, [pc, #36]	; (8006ee4 <CAT25512_SendByte+0x2c>)
 8006ec0:	f7fe ff3c 	bl	8005d3c <SPI_I2S_GetFlagStatus>
 8006ec4:	2800      	cmp	r0, #0
 8006ec6:	d0f9      	beq.n	8006ebc <CAT25512_SendByte+0x4>
	SPI_I2S_SendData(SPI3, mData);
 8006ec8:	4621      	mov	r1, r4
 8006eca:	4806      	ldr	r0, [pc, #24]	; (8006ee4 <CAT25512_SendByte+0x2c>)
 8006ecc:	f7fe fef9 	bl	8005cc2 <SPI_I2S_SendData>
	while(!SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_RXNE));
 8006ed0:	2101      	movs	r1, #1
 8006ed2:	4804      	ldr	r0, [pc, #16]	; (8006ee4 <CAT25512_SendByte+0x2c>)
 8006ed4:	f7fe ff32 	bl	8005d3c <SPI_I2S_GetFlagStatus>
 8006ed8:	2800      	cmp	r0, #0
 8006eda:	d0f9      	beq.n	8006ed0 <CAT25512_SendByte+0x18>
	SPI_I2S_ReceiveData(SPI3);
 8006edc:	4801      	ldr	r0, [pc, #4]	; (8006ee4 <CAT25512_SendByte+0x2c>)
 8006ede:	f7fe feed 	bl	8005cbc <SPI_I2S_ReceiveData>
 8006ee2:	bd10      	pop	{r4, pc}
 8006ee4:	40003c00 	.word	0x40003c00

08006ee8 <CAT25512_RecieveData>:

/*
Receive one byte from eeprom via SPI
*/
unsigned short int CAT25512_RecieveData(void)
{
 8006ee8:	b508      	push	{r3, lr}
	while(!SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_TXE)){}; 
 8006eea:	2102      	movs	r1, #2
 8006eec:	4809      	ldr	r0, [pc, #36]	; (8006f14 <CAT25512_RecieveData+0x2c>)
 8006eee:	f7fe ff25 	bl	8005d3c <SPI_I2S_GetFlagStatus>
 8006ef2:	2800      	cmp	r0, #0
 8006ef4:	d0f9      	beq.n	8006eea <CAT25512_RecieveData+0x2>
	SPI_I2S_SendData(SPI3, 0x00); 
 8006ef6:	2100      	movs	r1, #0
 8006ef8:	4806      	ldr	r0, [pc, #24]	; (8006f14 <CAT25512_RecieveData+0x2c>)
 8006efa:	f7fe fee2 	bl	8005cc2 <SPI_I2S_SendData>
	while(!SPI_I2S_GetFlagStatus(SPI3, SPI_I2S_FLAG_RXNE)){};
 8006efe:	2101      	movs	r1, #1
 8006f00:	4804      	ldr	r0, [pc, #16]	; (8006f14 <CAT25512_RecieveData+0x2c>)
 8006f02:	f7fe ff1b 	bl	8005d3c <SPI_I2S_GetFlagStatus>
 8006f06:	2800      	cmp	r0, #0
 8006f08:	d0f9      	beq.n	8006efe <CAT25512_RecieveData+0x16>
	return SPI_ReceiveData(SPI3);
 8006f0a:	4802      	ldr	r0, [pc, #8]	; (8006f14 <CAT25512_RecieveData+0x2c>)
 8006f0c:	f7fe fed6 	bl	8005cbc <SPI_I2S_ReceiveData>
};
 8006f10:	bd08      	pop	{r3, pc}
 8006f12:	bf00      	nop
 8006f14:	40003c00 	.word	0x40003c00

08006f18 <CAT25512_init>:

/*
Initialization of CAT25512 eeprom
*/
void CAT25512_init(void)
{
 8006f18:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8006f1c:	b089      	sub	sp, #36	; 0x24
	/* SPI2 setting up*/	
	GPIO_InitTypeDef mGPIO_InitStructure;
	SPI_InitTypeDef mSPI;
		
	/*GPIO Init*/
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 8006f1e:	2101      	movs	r1, #1
 8006f20:	2004      	movs	r0, #4
 8006f22:	f7fd fcd1 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	
	GPIO_StructInit(&mGPIO_InitStructure);
 8006f26:	a806      	add	r0, sp, #24
 8006f28:	f7fc fd61 	bl	80039ee <GPIO_StructInit>
	mGPIO_InitStructure.GPIO_Pin 		= GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12;
 8006f2c:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8006f30:	9306      	str	r3, [sp, #24]
	mGPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_AF;
 8006f32:	2702      	movs	r7, #2
 8006f34:	f88d 701c 	strb.w	r7, [sp, #28]
	mGPIO_InitStructure.GPIO_OType	= GPIO_OType_PP;
 8006f38:	2500      	movs	r5, #0
 8006f3a:	f88d 501e 	strb.w	r5, [sp, #30]
	mGPIO_InitStructure.GPIO_PuPd 	= GPIO_PuPd_UP;
 8006f3e:	2401      	movs	r4, #1
 8006f40:	f88d 401f 	strb.w	r4, [sp, #31]
	mGPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_50MHz;
 8006f44:	f88d 701d 	strb.w	r7, [sp, #29]
	GPIO_Init(GPIOC, &mGPIO_InitStructure);
 8006f48:	4e32      	ldr	r6, [pc, #200]	; (8007014 <CAT25512_init+0xfc>)
 8006f4a:	a906      	add	r1, sp, #24
 8006f4c:	4630      	mov	r0, r6
 8006f4e:	f7fc fd09 	bl	8003964 <GPIO_Init>
	
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 8006f52:	4621      	mov	r1, r4
 8006f54:	2008      	movs	r0, #8
 8006f56:	f7fd fcb7 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	GPIO_StructInit(&mGPIO_InitStructure);
 8006f5a:	a806      	add	r0, sp, #24
 8006f5c:	f7fc fd47 	bl	80039ee <GPIO_StructInit>
	mGPIO_InitStructure.GPIO_Pin 		= GPIO_Pin_2;
 8006f60:	f04f 0904 	mov.w	r9, #4
 8006f64:	f8cd 9018 	str.w	r9, [sp, #24]
	mGPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_OUT;
 8006f68:	f88d 401c 	strb.w	r4, [sp, #28]
	mGPIO_InitStructure.GPIO_OType	= GPIO_OType_PP;
 8006f6c:	f88d 501e 	strb.w	r5, [sp, #30]
	mGPIO_InitStructure.GPIO_PuPd 	= GPIO_PuPd_UP;
 8006f70:	f88d 401f 	strb.w	r4, [sp, #31]
	mGPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_100MHz;
 8006f74:	2303      	movs	r3, #3
 8006f76:	f88d 301d 	strb.w	r3, [sp, #29]
	GPIO_Init(GPIOD, &mGPIO_InitStructure);
 8006f7a:	f8df 809c 	ldr.w	r8, [pc, #156]	; 8007018 <CAT25512_init+0x100>
 8006f7e:	a906      	add	r1, sp, #24
 8006f80:	4640      	mov	r0, r8
 8006f82:	f7fc fcef 	bl	8003964 <GPIO_Init>
	
	GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_SPI3);
 8006f86:	2206      	movs	r2, #6
 8006f88:	210a      	movs	r1, #10
 8006f8a:	4630      	mov	r0, r6
 8006f8c:	f7fc fd6d 	bl	8003a6a <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_SPI3);
 8006f90:	2206      	movs	r2, #6
 8006f92:	210b      	movs	r1, #11
 8006f94:	4630      	mov	r0, r6
 8006f96:	f7fc fd68 	bl	8003a6a <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOC, GPIO_PinSource12, GPIO_AF_SPI3);	
 8006f9a:	2206      	movs	r2, #6
 8006f9c:	210c      	movs	r1, #12
 8006f9e:	4630      	mov	r0, r6
 8006fa0:	f7fc fd63 	bl	8003a6a <GPIO_PinAFConfig>
		
	CAT25512_CS_CLEAR;
 8006fa4:	4649      	mov	r1, r9
 8006fa6:	4640      	mov	r0, r8
 8006fa8:	f7fc fd50 	bl	8003a4c <GPIO_SetBits>
	
	/*SPI init*/
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3, ENABLE);
 8006fac:	4621      	mov	r1, r4
 8006fae:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8006fb2:	f7fd fcb3 	bl	800491c <RCC_APB1PeriphClockCmd>
	SPI_I2S_DeInit(SPI3);
 8006fb6:	f5a6 36e6 	sub.w	r6, r6, #117760	; 0x1cc00
 8006fba:	4630      	mov	r0, r6
 8006fbc:	f7fe fce2 	bl	8005984 <SPI_I2S_DeInit>
	SPI_StructInit(&mSPI);
 8006fc0:	eb0d 0009 	add.w	r0, sp, r9
 8006fc4:	f7fe fddc 	bl	8005b80 <SPI_StructInit>
	
	mSPI.SPI_Direction 					= SPI_Direction_2Lines_FullDuplex;
 8006fc8:	f8ad 5004 	strh.w	r5, [sp, #4]
	mSPI.SPI_BaudRatePrescaler 	= SPI_BaudRatePrescaler_8;
 8006fcc:	2310      	movs	r3, #16
 8006fce:	f8ad 3010 	strh.w	r3, [sp, #16]
	mSPI.SPI_Mode 							= SPI_Mode_Master;
 8006fd2:	f44f 7382 	mov.w	r3, #260	; 0x104
 8006fd6:	f8ad 3006 	strh.w	r3, [sp, #6]
	mSPI.SPI_DataSize 					= SPI_DataSize_8b;
 8006fda:	f8ad 5008 	strh.w	r5, [sp, #8]
	mSPI.SPI_CPOL 							= SPI_CPOL_High;
 8006fde:	f8ad 700a 	strh.w	r7, [sp, #10]
	mSPI.SPI_CPHA 							= SPI_CPHA_2Edge;
 8006fe2:	f8ad 400c 	strh.w	r4, [sp, #12]
	mSPI.SPI_FirstBit 					= SPI_FirstBit_MSB;	
 8006fe6:	f8ad 5012 	strh.w	r5, [sp, #18]
	mSPI.SPI_NSS 								= SPI_NSS_Soft;
 8006fea:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006fee:	f8ad 300e 	strh.w	r3, [sp, #14]
	
	SPI_Init(SPI3, &mSPI);
 8006ff2:	eb0d 0109 	add.w	r1, sp, r9
 8006ff6:	4630      	mov	r0, r6
 8006ff8:	f7fe fd26 	bl	8005a48 <SPI_Init>
	SPI_Cmd(SPI3, ENABLE);
 8006ffc:	4621      	mov	r1, r4
 8006ffe:	4630      	mov	r0, r6
 8007000:	f7fe fdd3 	bl	8005baa <SPI_Cmd>
	SPI_NSSInternalSoftwareConfig(SPI3, SPI_NSSInternalSoft_Set);
 8007004:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007008:	4630      	mov	r0, r6
 800700a:	f7fe fe05 	bl	8005c18 <SPI_NSSInternalSoftwareConfig>
};
 800700e:	b009      	add	sp, #36	; 0x24
 8007010:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8007014:	40020800 	.word	0x40020800
 8007018:	40020c00 	.word	0x40020c00

0800701c <CAT25512_ReadStatusRegister>:

/*Returns the contents of eeprom status register*/
unsigned char CAT25512_ReadStatusRegister()
{
 800701c:	b538      	push	{r3, r4, r5, lr}
	unsigned char mData = 0;
	CAT25512_CS_SET;
 800701e:	4c0b      	ldr	r4, [pc, #44]	; (800704c <CAT25512_ReadStatusRegister+0x30>)
 8007020:	2104      	movs	r1, #4
 8007022:	4620      	mov	r0, r4
 8007024:	f7fc fd14 	bl	8003a50 <GPIO_ResetBits>
	CAT25512_SendByte( INTSRUCTION_RDSR );
 8007028:	2005      	movs	r0, #5
 800702a:	f7ff ff45 	bl	8006eb8 <CAT25512_SendByte>
	delay_ns(2);
 800702e:	2002      	movs	r0, #2
 8007030:	f004 fb26 	bl	800b680 <delay_ns>
	mData = CAT25512_RecieveData();
 8007034:	f7ff ff58 	bl	8006ee8 <CAT25512_RecieveData>
 8007038:	b2c5      	uxtb	r5, r0
	delay_ns(200);
 800703a:	20c8      	movs	r0, #200	; 0xc8
 800703c:	f004 fb20 	bl	800b680 <delay_ns>
	CAT25512_CS_CLEAR;
 8007040:	2104      	movs	r1, #4
 8007042:	4620      	mov	r0, r4
 8007044:	f7fc fd02 	bl	8003a4c <GPIO_SetBits>
	return mData;
};
 8007048:	4628      	mov	r0, r5
 800704a:	bd38      	pop	{r3, r4, r5, pc}
 800704c:	40020c00 	.word	0x40020c00

08007050 <CAT25512_WriteStatusRegister>:

/*Writes a byte to eeprom status register*/
void CAT25512_WriteStatusRegister(unsigned char mData)
{
 8007050:	b538      	push	{r3, r4, r5, lr}
 8007052:	4605      	mov	r5, r0
	CAT25512_CS_SET;
 8007054:	4c0a      	ldr	r4, [pc, #40]	; (8007080 <CAT25512_WriteStatusRegister+0x30>)
 8007056:	2104      	movs	r1, #4
 8007058:	4620      	mov	r0, r4
 800705a:	f7fc fcf9 	bl	8003a50 <GPIO_ResetBits>
	CAT25512_SendByte(INTSRUCTION_WRSR);
 800705e:	2001      	movs	r0, #1
 8007060:	f7ff ff2a 	bl	8006eb8 <CAT25512_SendByte>
	delay_ns(2);
 8007064:	2002      	movs	r0, #2
 8007066:	f004 fb0b 	bl	800b680 <delay_ns>
	CAT25512_SendByte(mData);
 800706a:	4628      	mov	r0, r5
 800706c:	f7ff ff24 	bl	8006eb8 <CAT25512_SendByte>
	delay_ns(200);
 8007070:	20c8      	movs	r0, #200	; 0xc8
 8007072:	f004 fb05 	bl	800b680 <delay_ns>
	CAT25512_CS_CLEAR;
 8007076:	2104      	movs	r1, #4
 8007078:	4620      	mov	r0, r4
 800707a:	f7fc fce7 	bl	8003a4c <GPIO_SetBits>
 800707e:	bd38      	pop	{r3, r4, r5, pc}
 8007080:	40020c00 	.word	0x40020c00

08007084 <CAT25512_WREN>:
};

/*Write enable command*/
void CAT25512_WREN(void)
{
 8007084:	b510      	push	{r4, lr}
	CAT25512_CS_SET;
 8007086:	4c08      	ldr	r4, [pc, #32]	; (80070a8 <CAT25512_WREN+0x24>)
 8007088:	2104      	movs	r1, #4
 800708a:	4620      	mov	r0, r4
 800708c:	f7fc fce0 	bl	8003a50 <GPIO_ResetBits>
	CAT25512_SendByte(INTSRUCTION_WREN);
 8007090:	2006      	movs	r0, #6
 8007092:	f7ff ff11 	bl	8006eb8 <CAT25512_SendByte>
	delay_ns(200);
 8007096:	20c8      	movs	r0, #200	; 0xc8
 8007098:	f004 faf2 	bl	800b680 <delay_ns>
	CAT25512_CS_CLEAR;
 800709c:	2104      	movs	r1, #4
 800709e:	4620      	mov	r0, r4
 80070a0:	f7fc fcd4 	bl	8003a4c <GPIO_SetBits>
 80070a4:	bd10      	pop	{r4, pc}
 80070a6:	bf00      	nop
 80070a8:	40020c00 	.word	0x40020c00

080070ac <CAT25512_WRDI>:
};

/*Write disable command*/
void CAT25512_WRDI(void)
{
 80070ac:	b510      	push	{r4, lr}
	CAT25512_CS_SET;
 80070ae:	4c08      	ldr	r4, [pc, #32]	; (80070d0 <CAT25512_WRDI+0x24>)
 80070b0:	2104      	movs	r1, #4
 80070b2:	4620      	mov	r0, r4
 80070b4:	f7fc fccc 	bl	8003a50 <GPIO_ResetBits>
	CAT25512_SendByte(INTSRUCTION_WRDI);
 80070b8:	2004      	movs	r0, #4
 80070ba:	f7ff fefd 	bl	8006eb8 <CAT25512_SendByte>
	delay_ns(200);
 80070be:	20c8      	movs	r0, #200	; 0xc8
 80070c0:	f004 fade 	bl	800b680 <delay_ns>
	CAT25512_CS_CLEAR;
 80070c4:	2104      	movs	r1, #4
 80070c6:	4620      	mov	r0, r4
 80070c8:	f7fc fcc0 	bl	8003a4c <GPIO_SetBits>
 80070cc:	bd10      	pop	{r4, pc}
 80070ce:	bf00      	nop
 80070d0:	40020c00 	.word	0x40020c00

080070d4 <CAT25512_WriteByte>:
};

/*Writes one byte of Data to CAT25512 memory*/
void CAT25512_WriteByte(unsigned short int Address, unsigned char Data)
{
 80070d4:	b570      	push	{r4, r5, r6, lr}
 80070d6:	4605      	mov	r5, r0
 80070d8:	460e      	mov	r6, r1
	CAT25512_CS_SET;
 80070da:	4c0c      	ldr	r4, [pc, #48]	; (800710c <CAT25512_WriteByte+0x38>)
 80070dc:	2104      	movs	r1, #4
 80070de:	4620      	mov	r0, r4
 80070e0:	f7fc fcb6 	bl	8003a50 <GPIO_ResetBits>
	CAT25512_SendByte(INTSRUCTION_WRITE);
 80070e4:	2002      	movs	r0, #2
 80070e6:	f7ff fee7 	bl	8006eb8 <CAT25512_SendByte>
	CAT25512_SendByte((Address&0xFF00)>>8);
 80070ea:	0a28      	lsrs	r0, r5, #8
 80070ec:	f7ff fee4 	bl	8006eb8 <CAT25512_SendByte>
	CAT25512_SendByte((Address&0x00FF));
 80070f0:	b2e8      	uxtb	r0, r5
 80070f2:	f7ff fee1 	bl	8006eb8 <CAT25512_SendByte>
	CAT25512_SendByte(Data);
 80070f6:	4630      	mov	r0, r6
 80070f8:	f7ff fede 	bl	8006eb8 <CAT25512_SendByte>
	delay_ns(200);
 80070fc:	20c8      	movs	r0, #200	; 0xc8
 80070fe:	f004 fabf 	bl	800b680 <delay_ns>
	CAT25512_CS_CLEAR;
 8007102:	2104      	movs	r1, #4
 8007104:	4620      	mov	r0, r4
 8007106:	f7fc fca1 	bl	8003a4c <GPIO_SetBits>
 800710a:	bd70      	pop	{r4, r5, r6, pc}
 800710c:	40020c00 	.word	0x40020c00

08007110 <CAT25512_ReadByte>:
};

/*Reads one byte of Data from CAT25512 memory*/
unsigned char CAT25512_ReadByte(unsigned short int Address)
{
 8007110:	b538      	push	{r3, r4, r5, lr}
 8007112:	4605      	mov	r5, r0
	unsigned char Data;
	CAT25512_CS_SET;
 8007114:	4c0c      	ldr	r4, [pc, #48]	; (8007148 <CAT25512_ReadByte+0x38>)
 8007116:	2104      	movs	r1, #4
 8007118:	4620      	mov	r0, r4
 800711a:	f7fc fc99 	bl	8003a50 <GPIO_ResetBits>
	CAT25512_SendByte(INTSRUCTION_READ);
 800711e:	2003      	movs	r0, #3
 8007120:	f7ff feca 	bl	8006eb8 <CAT25512_SendByte>
	CAT25512_SendByte((Address&0xFF00)>>8);
 8007124:	0a28      	lsrs	r0, r5, #8
 8007126:	f7ff fec7 	bl	8006eb8 <CAT25512_SendByte>
	CAT25512_SendByte((Address&0x00FF));
 800712a:	b2e8      	uxtb	r0, r5
 800712c:	f7ff fec4 	bl	8006eb8 <CAT25512_SendByte>
	Data = CAT25512_RecieveData();
 8007130:	f7ff feda 	bl	8006ee8 <CAT25512_RecieveData>
 8007134:	b2c5      	uxtb	r5, r0
	delay_ns(200);
 8007136:	20c8      	movs	r0, #200	; 0xc8
 8007138:	f004 faa2 	bl	800b680 <delay_ns>
	CAT25512_CS_CLEAR;
 800713c:	2104      	movs	r1, #4
 800713e:	4620      	mov	r0, r4
 8007140:	f7fc fc84 	bl	8003a4c <GPIO_SetBits>
	return Data;
};
 8007144:	4628      	mov	r0, r5
 8007146:	bd38      	pop	{r3, r4, r5, pc}
 8007148:	40020c00 	.word	0x40020c00

0800714c <CAT25512_write_block>:

/*Writes the Length bytes of Data started from certain Address*/
void CAT25512_write_block(unsigned short int Address, unsigned char *Data, unsigned short int length)
{
 800714c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007150:	4607      	mov	r7, r0
 8007152:	460e      	mov	r6, r1
 8007154:	4615      	mov	r5, r2
	unsigned short int totalcnt=0;
	
	CAT25512_WREN();
 8007156:	f7ff ff95 	bl	8007084 <CAT25512_WREN>
	
	CAT25512_CS_SET;
 800715a:	2104      	movs	r1, #4
 800715c:	482c      	ldr	r0, [pc, #176]	; (8007210 <CAT25512_write_block+0xc4>)
 800715e:	f7fc fc77 	bl	8003a50 <GPIO_ResetBits>
	CAT25512_SendByte(INTSRUCTION_WRITE);
 8007162:	2002      	movs	r0, #2
 8007164:	f7ff fea8 	bl	8006eb8 <CAT25512_SendByte>
	CAT25512_SendByte((Address&0xFF00)>>8);
 8007168:	0a38      	lsrs	r0, r7, #8
 800716a:	f7ff fea5 	bl	8006eb8 <CAT25512_SendByte>
	CAT25512_SendByte((Address&0x00FF));
 800716e:	fa5f f887 	uxtb.w	r8, r7
 8007172:	4640      	mov	r0, r8
 8007174:	f7ff fea0 	bl	8006eb8 <CAT25512_SendByte>
	unsigned short int totalcnt=0;
 8007178:	2400      	movs	r4, #0
	
	while(totalcnt<length) {
 800717a:	e022      	b.n	80071c2 <CAT25512_write_block+0x76>
			CAT25512_CS_CLEAR;
			
			//read status register
			delay_ms(1);
			while ((CAT25512_ReadStatusRegister() & (SR_RDY) ) != 0) {
				delay_ms(1);
 800717c:	2001      	movs	r0, #1
 800717e:	f003 fc7f 	bl	800aa80 <delay_ms>
			while ((CAT25512_ReadStatusRegister() & (SR_RDY) ) != 0) {
 8007182:	f7ff ff4b 	bl	800701c <CAT25512_ReadStatusRegister>
 8007186:	f010 0f01 	tst.w	r0, #1
 800718a:	d1f7      	bne.n	800717c <CAT25512_write_block+0x30>
			};
			
			delay_ms(1);	
 800718c:	2001      	movs	r0, #1
 800718e:	f003 fc77 	bl	800aa80 <delay_ms>

			CAT25512_WREN();			
 8007192:	f7ff ff77 	bl	8007084 <CAT25512_WREN>
			
			CAT25512_CS_SET;
 8007196:	2104      	movs	r1, #4
 8007198:	481d      	ldr	r0, [pc, #116]	; (8007210 <CAT25512_write_block+0xc4>)
 800719a:	f7fc fc59 	bl	8003a50 <GPIO_ResetBits>
			CAT25512_SendByte(INTSRUCTION_WRITE);
 800719e:	2002      	movs	r0, #2
 80071a0:	f7ff fe8a 	bl	8006eb8 <CAT25512_SendByte>
			CAT25512_SendByte(((Address+totalcnt)&0xFF00)>>8);
 80071a4:	19e0      	adds	r0, r4, r7
 80071a6:	f3c0 2007 	ubfx	r0, r0, #8, #8
 80071aa:	f7ff fe85 	bl	8006eb8 <CAT25512_SendByte>
			CAT25512_SendByte(((Address+totalcnt)&0x00FF));			
 80071ae:	eb08 0004 	add.w	r0, r8, r4
 80071b2:	b2c0      	uxtb	r0, r0
 80071b4:	f7ff fe80 	bl	8006eb8 <CAT25512_SendByte>
		};
		
		CAT25512_SendByte(Data[totalcnt]);	
 80071b8:	5d30      	ldrb	r0, [r6, r4]
 80071ba:	f7ff fe7d 	bl	8006eb8 <CAT25512_SendByte>
		
		totalcnt++;
 80071be:	3401      	adds	r4, #1
 80071c0:	b2a4      	uxth	r4, r4
	while(totalcnt<length) {
 80071c2:	42ac      	cmp	r4, r5
 80071c4:	d20f      	bcs.n	80071e6 <CAT25512_write_block+0x9a>
		if ( (((/*Address+*/totalcnt)&0x007F) == 0) && (totalcnt != 0) ) {
 80071c6:	f014 0f7f 	tst.w	r4, #127	; 0x7f
 80071ca:	d1f5      	bne.n	80071b8 <CAT25512_write_block+0x6c>
 80071cc:	2c00      	cmp	r4, #0
 80071ce:	d0f3      	beq.n	80071b8 <CAT25512_write_block+0x6c>
			delay_ns(200);
 80071d0:	20c8      	movs	r0, #200	; 0xc8
 80071d2:	f004 fa55 	bl	800b680 <delay_ns>
			CAT25512_CS_CLEAR;
 80071d6:	2104      	movs	r1, #4
 80071d8:	480d      	ldr	r0, [pc, #52]	; (8007210 <CAT25512_write_block+0xc4>)
 80071da:	f7fc fc37 	bl	8003a4c <GPIO_SetBits>
			delay_ms(1);
 80071de:	2001      	movs	r0, #1
 80071e0:	f003 fc4e 	bl	800aa80 <delay_ms>
			while ((CAT25512_ReadStatusRegister() & (SR_RDY) ) != 0) {
 80071e4:	e7cd      	b.n	8007182 <CAT25512_write_block+0x36>
	};
	
	delay_ns(200);
 80071e6:	20c8      	movs	r0, #200	; 0xc8
 80071e8:	f004 fa4a 	bl	800b680 <delay_ns>
	CAT25512_CS_CLEAR;
 80071ec:	2104      	movs	r1, #4
 80071ee:	4808      	ldr	r0, [pc, #32]	; (8007210 <CAT25512_write_block+0xc4>)
 80071f0:	f7fc fc2c 	bl	8003a4c <GPIO_SetBits>
	
	delay_ms(1);
 80071f4:	2001      	movs	r0, #1
 80071f6:	f003 fc43 	bl	800aa80 <delay_ms>
	while ((CAT25512_ReadStatusRegister() & (SR_RDY) ) != 0) {
 80071fa:	e002      	b.n	8007202 <CAT25512_write_block+0xb6>
		delay_ms(1);
 80071fc:	2001      	movs	r0, #1
 80071fe:	f003 fc3f 	bl	800aa80 <delay_ms>
	while ((CAT25512_ReadStatusRegister() & (SR_RDY) ) != 0) {
 8007202:	f7ff ff0b 	bl	800701c <CAT25512_ReadStatusRegister>
 8007206:	f010 0f01 	tst.w	r0, #1
 800720a:	d1f7      	bne.n	80071fc <CAT25512_write_block+0xb0>
	};
};
 800720c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007210:	40020c00 	.word	0x40020c00

08007214 <CAT25512_read_block>:

/*Reads the Length bytes of Data started from certain Address*/
void CAT25512_read_block(unsigned short int Address, unsigned char *Data, unsigned short int length)
{
 8007214:	b570      	push	{r4, r5, r6, lr}
 8007216:	4604      	mov	r4, r0
 8007218:	460e      	mov	r6, r1
 800721a:	4615      	mov	r5, r2
	unsigned short int cnt=0, totalcnt=0;
	
	CAT25512_CS_SET;
 800721c:	2104      	movs	r1, #4
 800721e:	480e      	ldr	r0, [pc, #56]	; (8007258 <CAT25512_read_block+0x44>)
 8007220:	f7fc fc16 	bl	8003a50 <GPIO_ResetBits>
	CAT25512_SendByte(INTSRUCTION_READ);
 8007224:	2003      	movs	r0, #3
 8007226:	f7ff fe47 	bl	8006eb8 <CAT25512_SendByte>
	CAT25512_SendByte((Address&0xFF00)>>8);
 800722a:	0a20      	lsrs	r0, r4, #8
 800722c:	f7ff fe44 	bl	8006eb8 <CAT25512_SendByte>
	CAT25512_SendByte((Address&0x00FF));
 8007230:	b2e0      	uxtb	r0, r4
 8007232:	f7ff fe41 	bl	8006eb8 <CAT25512_SendByte>
	unsigned short int cnt=0, totalcnt=0;
 8007236:	2400      	movs	r4, #0
	while(totalcnt<length) {
 8007238:	e004      	b.n	8007244 <CAT25512_read_block+0x30>
			CAT25512_SendByte(INTSRUCTION_READ);
			CAT25512_SendByte(((Address+totalcnt)&0xFF00)>>8);
			CAT25512_SendByte(((Address+totalcnt)&0x00FF));	
		};*/
		
		Data[totalcnt] = CAT25512_RecieveData();
 800723a:	f7ff fe55 	bl	8006ee8 <CAT25512_RecieveData>
 800723e:	5530      	strb	r0, [r6, r4]
		totalcnt++;
 8007240:	3401      	adds	r4, #1
 8007242:	b2a4      	uxth	r4, r4
	while(totalcnt<length) {
 8007244:	42ac      	cmp	r4, r5
 8007246:	d3f8      	bcc.n	800723a <CAT25512_read_block+0x26>
		cnt++;
	}
	
	delay_ns(200);
 8007248:	20c8      	movs	r0, #200	; 0xc8
 800724a:	f004 fa19 	bl	800b680 <delay_ns>
	CAT25512_CS_CLEAR;
 800724e:	2104      	movs	r1, #4
 8007250:	4801      	ldr	r0, [pc, #4]	; (8007258 <CAT25512_read_block+0x44>)
 8007252:	f7fc fbfb 	bl	8003a4c <GPIO_SetBits>
 8007256:	bd70      	pop	{r4, r5, r6, pc}
 8007258:	40020c00 	.word	0x40020c00

0800725c <init_HC165>:

#define _BV(x)  (1<<x);

///Setting up PORTs IO
void init_HC165(void)
{
 800725c:	b570      	push	{r4, r5, r6, lr}
 800725e:	b084      	sub	sp, #16
	
	/* init pins struct*/
	GPIO_InitTypeDef mGPIO_InitStructure;
	GPIO_InitTypeDef mGPIO_InitStructure2;
	
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 8007260:	2101      	movs	r1, #1
 8007262:	2004      	movs	r0, #4
 8007264:	f7fd fb30 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	
	memset(&mGPIO_InitStructure, 0, sizeof(mGPIO_InitStructure));
 8007268:	2600      	movs	r6, #0
 800726a:	9603      	str	r6, [sp, #12]
	mGPIO_InitStructure.GPIO_Pin 		= SW_CP|SW_PL|SW_CE;
 800726c:	230e      	movs	r3, #14
 800726e:	9302      	str	r3, [sp, #8]
	mGPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_OUT;
 8007270:	2501      	movs	r5, #1
 8007272:	f88d 500c 	strb.w	r5, [sp, #12]
	mGPIO_InitStructure.GPIO_OType 	= GPIO_OType_PP;
	mGPIO_InitStructure.GPIO_PuPd 	= GPIO_PuPd_NOPULL;
	mGPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_100MHz;
 8007276:	2303      	movs	r3, #3
 8007278:	f88d 300d 	strb.w	r3, [sp, #13]
	
	GPIO_Init(GPIOC, &mGPIO_InitStructure);
 800727c:	4c0c      	ldr	r4, [pc, #48]	; (80072b0 <init_HC165+0x54>)
 800727e:	a902      	add	r1, sp, #8
 8007280:	4620      	mov	r0, r4
 8007282:	f7fc fb6f 	bl	8003964 <GPIO_Init>
	
	memset(&mGPIO_InitStructure2, 0, sizeof(mGPIO_InitStructure2));
 8007286:	9601      	str	r6, [sp, #4]
	mGPIO_InitStructure2.GPIO_Pin 		= SW_DAT;
 8007288:	9500      	str	r5, [sp, #0]
	mGPIO_InitStructure2.GPIO_Mode 		= GPIO_Mode_IN;

	GPIO_Init(GPIOC, &mGPIO_InitStructure2);
 800728a:	4669      	mov	r1, sp
 800728c:	4620      	mov	r0, r4
 800728e:	f7fc fb69 	bl	8003964 <GPIO_Init>
	
	SS_HIGH;
 8007292:	2108      	movs	r1, #8
 8007294:	4620      	mov	r0, r4
 8007296:	f7fc fbd9 	bl	8003a4c <GPIO_SetBits>
	CE_LOW;
 800729a:	2104      	movs	r1, #4
 800729c:	4620      	mov	r0, r4
 800729e:	f7fc fbd7 	bl	8003a50 <GPIO_ResetBits>
	CLK_LOW;
 80072a2:	2102      	movs	r1, #2
 80072a4:	4620      	mov	r0, r4
 80072a6:	f7fc fbd3 	bl	8003a50 <GPIO_ResetBits>
}
 80072aa:	b004      	add	sp, #16
 80072ac:	bd70      	pop	{r4, r5, r6, pc}
 80072ae:	bf00      	nop
 80072b0:	40020800 	.word	0x40020800

080072b4 <HC165_LatchUp>:

//Close latch and load data to internal registers 165
void HC165_LatchUp(void)
{
 80072b4:	b510      	push	{r4, lr}
	CE_LOW;
 80072b6:	4c0a      	ldr	r4, [pc, #40]	; (80072e0 <HC165_LatchUp+0x2c>)
 80072b8:	2104      	movs	r1, #4
 80072ba:	4620      	mov	r0, r4
 80072bc:	f7fc fbc8 	bl	8003a50 <GPIO_ResetBits>
	CLK_LOW;
 80072c0:	2102      	movs	r1, #2
 80072c2:	4620      	mov	r0, r4
 80072c4:	f7fc fbc4 	bl	8003a50 <GPIO_ResetBits>

	SS_LOW;
 80072c8:	2108      	movs	r1, #8
 80072ca:	4620      	mov	r0, r4
 80072cc:	f7fc fbc0 	bl	8003a50 <GPIO_ResetBits>
	delay_us(1);
 80072d0:	2001      	movs	r0, #1
 80072d2:	f003 ff3d 	bl	800b150 <delay_us>
	SS_HIGH;	
 80072d6:	2108      	movs	r1, #8
 80072d8:	4620      	mov	r0, r4
 80072da:	f7fc fbb7 	bl	8003a4c <GPIO_SetBits>
 80072de:	bd10      	pop	{r4, pc}
 80072e0:	40020800 	.word	0x40020800

080072e4 <HC165_GetByte>:
}


unsigned char HC165_GetByte(void)
{
 80072e4:	b570      	push	{r4, r5, r6, lr}
	unsigned char data = 0x00, cnt = 0;	

	if (  GPIO_ReadInputDataBit(GPIOC, SW_DAT) == 1 ) {
 80072e6:	2101      	movs	r1, #1
 80072e8:	4818      	ldr	r0, [pc, #96]	; (800734c <HC165_GetByte+0x68>)
 80072ea:	f7fc fb9b 	bl	8003a24 <GPIO_ReadInputDataBit>
 80072ee:	2801      	cmp	r0, #1
 80072f0:	d006      	beq.n	8007300 <HC165_GetByte+0x1c>
	unsigned char data = 0x00, cnt = 0;	
 80072f2:	2500      	movs	r5, #0
		data = data | (0x01);
	};

	CLK_HIGH;	
 80072f4:	2102      	movs	r1, #2
 80072f6:	4815      	ldr	r0, [pc, #84]	; (800734c <HC165_GetByte+0x68>)
 80072f8:	f7fc fba8 	bl	8003a4c <GPIO_SetBits>

	for(cnt=0; cnt<7;cnt++)
 80072fc:	2400      	movs	r4, #0
 80072fe:	e00a      	b.n	8007316 <HC165_GetByte+0x32>
		data = data | (0x01);
 8007300:	2501      	movs	r5, #1
 8007302:	e7f7      	b.n	80072f4 <HC165_GetByte+0x10>

		data = data << 1;		
		if (  GPIO_ReadInputDataBit(GPIOC, SW_DAT) == 1 ) {
			data = data | (0x01);
		};
		CLK_HIGH;		
 8007304:	2102      	movs	r1, #2
 8007306:	4811      	ldr	r0, [pc, #68]	; (800734c <HC165_GetByte+0x68>)
 8007308:	f7fc fba0 	bl	8003a4c <GPIO_SetBits>
		delay_us(1);		
 800730c:	2001      	movs	r0, #1
 800730e:	f003 ff1f 	bl	800b150 <delay_us>
	for(cnt=0; cnt<7;cnt++)
 8007312:	3401      	adds	r4, #1
 8007314:	b2e4      	uxtb	r4, r4
 8007316:	2c06      	cmp	r4, #6
 8007318:	d812      	bhi.n	8007340 <HC165_GetByte+0x5c>
		CLK_LOW;
 800731a:	4e0c      	ldr	r6, [pc, #48]	; (800734c <HC165_GetByte+0x68>)
 800731c:	2102      	movs	r1, #2
 800731e:	4630      	mov	r0, r6
 8007320:	f7fc fb96 	bl	8003a50 <GPIO_ResetBits>
		delay_us(1);
 8007324:	2001      	movs	r0, #1
 8007326:	f003 ff13 	bl	800b150 <delay_us>
		data = data << 1;		
 800732a:	006d      	lsls	r5, r5, #1
 800732c:	b2ed      	uxtb	r5, r5
		if (  GPIO_ReadInputDataBit(GPIOC, SW_DAT) == 1 ) {
 800732e:	2101      	movs	r1, #1
 8007330:	4630      	mov	r0, r6
 8007332:	f7fc fb77 	bl	8003a24 <GPIO_ReadInputDataBit>
 8007336:	2801      	cmp	r0, #1
 8007338:	d1e4      	bne.n	8007304 <HC165_GetByte+0x20>
			data = data | (0x01);
 800733a:	f045 0501 	orr.w	r5, r5, #1
 800733e:	e7e1      	b.n	8007304 <HC165_GetByte+0x20>
	}

	CLK_LOW;
 8007340:	2102      	movs	r1, #2
 8007342:	4802      	ldr	r0, [pc, #8]	; (800734c <HC165_GetByte+0x68>)
 8007344:	f7fc fb84 	bl	8003a50 <GPIO_ResetBits>
	return data;
}
 8007348:	4628      	mov	r0, r5
 800734a:	bd70      	pop	{r4, r5, r6, pc}
 800734c:	40020800 	.word	0x40020800

08007350 <HC165_GetDWord>:

unsigned long int HC165_GetDWord(void)
{
 8007350:	b570      	push	{r4, r5, r6, lr}
	unsigned char tmp[4] = {0,0,0,0};
	
	tmp[0] = HC165_GetByte();
 8007352:	f7ff ffc7 	bl	80072e4 <HC165_GetByte>
 8007356:	4605      	mov	r5, r0
	tmp[1] = HC165_GetByte();
 8007358:	f7ff ffc4 	bl	80072e4 <HC165_GetByte>
 800735c:	4606      	mov	r6, r0
	tmp[2] = HC165_GetByte();
 800735e:	f7ff ffc1 	bl	80072e4 <HC165_GetByte>
 8007362:	4604      	mov	r4, r0
	tmp[3] = HC165_GetByte();
 8007364:	f7ff ffbe 	bl	80072e4 <HC165_GetByte>

	return (unsigned long int) ((((unsigned long int) (tmp[3]))<<24)|(((unsigned long int) (tmp[2]))<<16)|((unsigned long int) (tmp[1])<<8)|(unsigned long int) (tmp[0]));
 8007368:	0424      	lsls	r4, r4, #16
 800736a:	ea44 6000 	orr.w	r0, r4, r0, lsl #24
 800736e:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
}
 8007372:	4328      	orrs	r0, r5
 8007374:	bd70      	pop	{r4, r5, r6, pc}

08007376 <HC165_GetDWord1>:

unsigned long int HC165_GetDWord1(void)
{
 8007376:	b538      	push	{r3, r4, r5, lr}
	unsigned char tmp[4] = {0,0,0,0};

	tmp[0] = HC165_GetByte();
 8007378:	f7ff ffb4 	bl	80072e4 <HC165_GetByte>
 800737c:	4605      	mov	r5, r0
	tmp[1] = HC165_GetByte();
 800737e:	f7ff ffb1 	bl	80072e4 <HC165_GetByte>
 8007382:	4604      	mov	r4, r0
	tmp[2] = HC165_GetByte();
 8007384:	f7ff ffae 	bl	80072e4 <HC165_GetByte>

	return (unsigned long int) ((((unsigned long int) (tmp[3]))<<24)|(((unsigned long int) (tmp[2]))<<16)|((unsigned long int) (tmp[1])<<8)|(unsigned long int) (tmp[0]));
 8007388:	0224      	lsls	r4, r4, #8
 800738a:	ea44 4000 	orr.w	r0, r4, r0, lsl #16
}
 800738e:	4328      	orrs	r0, r5
 8007390:	bd38      	pop	{r3, r4, r5, pc}

08007392 <GetButton>:

//Get buttons state
unsigned long long int GetButton(void)
{
 8007392:	b570      	push	{r4, r5, r6, lr}
	unsigned long int keys_state_1, keys_state_2;
	
	CE_LOW;
 8007394:	4c0b      	ldr	r4, [pc, #44]	; (80073c4 <GetButton+0x32>)
 8007396:	2104      	movs	r1, #4
 8007398:	4620      	mov	r0, r4
 800739a:	f7fc fb59 	bl	8003a50 <GPIO_ResetBits>
	delay_us(10);
 800739e:	200a      	movs	r0, #10
 80073a0:	f003 fed6 	bl	800b150 <delay_us>
	HC165_LatchUp();
 80073a4:	f7ff ff86 	bl	80072b4 <HC165_LatchUp>
	keys_state_1 = HC165_GetDWord();
 80073a8:	f7ff ffd2 	bl	8007350 <HC165_GetDWord>
 80073ac:	4605      	mov	r5, r0
	keys_state_2 = HC165_GetDWord1();
 80073ae:	f7ff ffe2 	bl	8007376 <HC165_GetDWord1>
 80073b2:	4606      	mov	r6, r0
	CE_HIGH;
 80073b4:	2104      	movs	r1, #4
 80073b6:	4620      	mov	r0, r4
 80073b8:	f7fc fb48 	bl	8003a4c <GPIO_SetBits>

	return (unsigned long long int) ( ((unsigned long long int) (keys_state_1)) |  ( ((unsigned long long int) keys_state_2)<<32) );
 80073bc:	2000      	movs	r0, #0
}
 80073be:	4328      	orrs	r0, r5
 80073c0:	4631      	mov	r1, r6
 80073c2:	bd70      	pop	{r4, r5, r6, pc}
 80073c4:	40020800 	.word	0x40020800

080073c8 <SendData>:
#include <stm32f4xx_gpio.h>

#include "MAX5135.h"

void SendData(unsigned char mData)
{
 80073c8:	b510      	push	{r4, lr}
 80073ca:	4604      	mov	r4, r0
	while(!SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE)); 
 80073cc:	2102      	movs	r1, #2
 80073ce:	4809      	ldr	r0, [pc, #36]	; (80073f4 <SendData+0x2c>)
 80073d0:	f7fe fcb4 	bl	8005d3c <SPI_I2S_GetFlagStatus>
 80073d4:	2800      	cmp	r0, #0
 80073d6:	d0f9      	beq.n	80073cc <SendData+0x4>
	SPI_I2S_SendData(SPI2, mData);
 80073d8:	4621      	mov	r1, r4
 80073da:	4806      	ldr	r0, [pc, #24]	; (80073f4 <SendData+0x2c>)
 80073dc:	f7fe fc71 	bl	8005cc2 <SPI_I2S_SendData>
	while(!SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE));
 80073e0:	2101      	movs	r1, #1
 80073e2:	4804      	ldr	r0, [pc, #16]	; (80073f4 <SendData+0x2c>)
 80073e4:	f7fe fcaa 	bl	8005d3c <SPI_I2S_GetFlagStatus>
 80073e8:	2800      	cmp	r0, #0
 80073ea:	d0f9      	beq.n	80073e0 <SendData+0x18>
	SPI_I2S_ReceiveData(SPI2);
 80073ec:	4801      	ldr	r0, [pc, #4]	; (80073f4 <SendData+0x2c>)
 80073ee:	f7fe fc65 	bl	8005cbc <SPI_I2S_ReceiveData>
 80073f2:	bd10      	pop	{r4, pc}
 80073f4:	40003800 	.word	0x40003800

080073f8 <MAX5135_SendPack>:
	;
};

void MAX5135_SendPack(unsigned char _data1, unsigned char _data2)
{
 80073f8:	b570      	push	{r4, r5, r6, lr}
 80073fa:	4606      	mov	r6, r0
 80073fc:	460d      	mov	r5, r1
	GPIO_ResetBits(GPIOB, GPIO_Pin_12);
 80073fe:	4c09      	ldr	r4, [pc, #36]	; (8007424 <MAX5135_SendPack+0x2c>)
 8007400:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8007404:	4620      	mov	r0, r4
 8007406:	f7fc fb23 	bl	8003a50 <GPIO_ResetBits>
	
	SendData(_data1);
 800740a:	4630      	mov	r0, r6
 800740c:	f7ff ffdc 	bl	80073c8 <SendData>
	SendData(_data2);
 8007410:	4628      	mov	r0, r5
 8007412:	f7ff ffd9 	bl	80073c8 <SendData>
	
	;	
	//delay_us(1);
	
	GPIO_SetBits(GPIOB, GPIO_Pin_12);
 8007416:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800741a:	4620      	mov	r0, r4
 800741c:	f7fc fb16 	bl	8003a4c <GPIO_SetBits>
 8007420:	bd70      	pop	{r4, r5, r6, pc}
 8007422:	bf00      	nop
 8007424:	40020400 	.word	0x40020400

08007428 <MAX5135init>:
}

void MAX5135init(void)
{
 8007428:	b5f0      	push	{r4, r5, r6, r7, lr}
 800742a:	b089      	sub	sp, #36	; 0x24
	/* SPI2 setting up*/
	
	GPIO_InitTypeDef mGPIO_InitStructure;
	SPI_InitTypeDef mSPI;
		
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 800742c:	2101      	movs	r1, #1
 800742e:	2002      	movs	r0, #2
 8007430:	f7fd fa4a 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	
	//GPIO_PinAFConfig(GPIOB, GPIO_PinSource12, GPIO_AF_SPI2);
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_SPI2);
 8007434:	4d2f      	ldr	r5, [pc, #188]	; (80074f4 <MAX5135init+0xcc>)
 8007436:	2205      	movs	r2, #5
 8007438:	210d      	movs	r1, #13
 800743a:	4628      	mov	r0, r5
 800743c:	f7fc fb15 	bl	8003a6a <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource15, GPIO_AF_SPI2);
 8007440:	2205      	movs	r2, #5
 8007442:	210f      	movs	r1, #15
 8007444:	4628      	mov	r0, r5
 8007446:	f7fc fb10 	bl	8003a6a <GPIO_PinAFConfig>
	
	mGPIO_InitStructure.GPIO_Pin 		= /*GPIO_Pin_12|*/GPIO_Pin_13|GPIO_Pin_15;
 800744a:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 800744e:	9306      	str	r3, [sp, #24]
	mGPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_AF;
 8007450:	2702      	movs	r7, #2
 8007452:	f88d 701c 	strb.w	r7, [sp, #28]
	mGPIO_InitStructure.GPIO_OType	= GPIO_OType_PP;
 8007456:	2400      	movs	r4, #0
 8007458:	f88d 401e 	strb.w	r4, [sp, #30]
	mGPIO_InitStructure.GPIO_PuPd 	= GPIO_PuPd_NOPULL;
 800745c:	f88d 401f 	strb.w	r4, [sp, #31]
	mGPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_50MHz;
 8007460:	f88d 701d 	strb.w	r7, [sp, #29]
	GPIO_Init(GPIOB, &mGPIO_InitStructure);
 8007464:	a906      	add	r1, sp, #24
 8007466:	4628      	mov	r0, r5
 8007468:	f7fc fa7c 	bl	8003964 <GPIO_Init>
	
	mGPIO_InitStructure.GPIO_Pin 		= GPIO_Pin_12/*|GPIO_Pin_0*/;
 800746c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8007470:	9306      	str	r3, [sp, #24]
	mGPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_OUT;
 8007472:	2601      	movs	r6, #1
 8007474:	f88d 601c 	strb.w	r6, [sp, #28]
	mGPIO_InitStructure.GPIO_OType	= GPIO_OType_PP;
 8007478:	f88d 401e 	strb.w	r4, [sp, #30]
	mGPIO_InitStructure.GPIO_PuPd 	= GPIO_PuPd_UP;
 800747c:	f88d 601f 	strb.w	r6, [sp, #31]
	mGPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_50MHz;
 8007480:	f88d 701d 	strb.w	r7, [sp, #29]
	GPIO_Init(GPIOB, &mGPIO_InitStructure);
 8007484:	a906      	add	r1, sp, #24
 8007486:	4628      	mov	r0, r5
 8007488:	f7fc fa6c 	bl	8003964 <GPIO_Init>
	
	//GPIO_SetBits(GPIOB, GPIO_Pin_0);
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
 800748c:	4631      	mov	r1, r6
 800748e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8007492:	f7fd fa43 	bl	800491c <RCC_APB1PeriphClockCmd>
	
	SPI_I2S_DeInit(SPI2);
 8007496:	f5a5 35e6 	sub.w	r5, r5, #117760	; 0x1cc00
 800749a:	4628      	mov	r0, r5
 800749c:	f7fe fa72 	bl	8005984 <SPI_I2S_DeInit>
	SPI_StructInit(&mSPI);
 80074a0:	a801      	add	r0, sp, #4
 80074a2:	f7fe fb6d 	bl	8005b80 <SPI_StructInit>
	
	mSPI.SPI_Direction = SPI_Direction_Tx;
 80074a6:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80074aa:	f8ad 3004 	strh.w	r3, [sp, #4]
	mSPI.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 80074ae:	f8ad 4010 	strh.w	r4, [sp, #16]
	mSPI.SPI_Mode = SPI_Mode_Master;
 80074b2:	f44f 7382 	mov.w	r3, #260	; 0x104
 80074b6:	f8ad 3006 	strh.w	r3, [sp, #6]
	mSPI.SPI_DataSize = 8;
 80074ba:	2308      	movs	r3, #8
 80074bc:	f8ad 3008 	strh.w	r3, [sp, #8]
	mSPI.SPI_CPOL = SPI_CPOL_Low;
 80074c0:	f8ad 400a 	strh.w	r4, [sp, #10]
	mSPI.SPI_CPHA = SPI_CPHA_1Edge;
 80074c4:	f8ad 400c 	strh.w	r4, [sp, #12]
	mSPI.SPI_FirstBit = SPI_FirstBit_MSB;	
 80074c8:	f8ad 4012 	strh.w	r4, [sp, #18]
	mSPI.SPI_NSS = SPI_NSS_Soft;
 80074cc:	f44f 7300 	mov.w	r3, #512	; 0x200
 80074d0:	f8ad 300e 	strh.w	r3, [sp, #14]
	
	SPI_Init(SPI2, &mSPI);
 80074d4:	a901      	add	r1, sp, #4
 80074d6:	4628      	mov	r0, r5
 80074d8:	f7fe fab6 	bl	8005a48 <SPI_Init>
	SPI_Cmd(SPI2, ENABLE);
 80074dc:	4631      	mov	r1, r6
 80074de:	4628      	mov	r0, r5
 80074e0:	f7fe fb63 	bl	8005baa <SPI_Cmd>
	SPI_NSSInternalSoftwareConfig(SPI2, SPI_NSSInternalSoft_Set);
 80074e4:	f44f 7180 	mov.w	r1, #256	; 0x100
 80074e8:	4628      	mov	r0, r5
 80074ea:	f7fe fb95 	bl	8005c18 <SPI_NSSInternalSoftwareConfig>
	//delay_ms(10);
	////Clr linearity bit
	//MAX5135_SendPack(MAX5135_CMD_LINEARITY, MAX5135_DATA_NONE, MAX5135_DATA_NONE);
	
	//init END
}
 80074ee:	b009      	add	sp, #36	; 0x24
 80074f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80074f2:	bf00      	nop
 80074f4:	40020400 	.word	0x40020400

080074f8 <MAX5135_DAC_send>:


void MAX5135_DAC_send(unsigned char DAC_Ch, unsigned int DAC_val)
{
 80074f8:	b508      	push	{r3, lr}
	uint8_t msb, lsb;
	if(DAC_val > 1023) DAC_val = 1023;
 80074fa:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 80074fe:	d301      	bcc.n	8007504 <MAX5135_DAC_send+0xc>
 8007500:	f240 31ff 	movw	r1, #1023	; 0x3ff
	
	switch(DAC_Ch)
 8007504:	2803      	cmp	r0, #3
 8007506:	d80a      	bhi.n	800751e <MAX5135_DAC_send+0x26>
 8007508:	e8df f000 	tbb	[pc, r0]
 800750c:	1e160e02 	.word	0x1e160e02
	{
		case 0:
		{
			msb = 0x30 | ((DAC_val >> 6) & 0x0F);
 8007510:	f3c1 1383 	ubfx	r3, r1, #6, #4
 8007514:	f043 0330 	orr.w	r3, r3, #48	; 0x30
			lsb = (DAC_val << 2) & 0xFC;
 8007518:	b2c9      	uxtb	r1, r1
 800751a:	0089      	lsls	r1, r1, #2
 800751c:	b2ca      	uxtb	r2, r1
			msb = 0xF0 | ((DAC_val >> 6) & 0x0F);
			lsb = (DAC_val << 2) & 0xFC;
			break;
		}
	}
	MAX5135_SendPack(msb, lsb);
 800751e:	4611      	mov	r1, r2
 8007520:	4618      	mov	r0, r3
 8007522:	f7ff ff69 	bl	80073f8 <MAX5135_SendPack>
 8007526:	bd08      	pop	{r3, pc}
			msb = 0x70 | ((DAC_val >> 6) & 0x0F);
 8007528:	f3c1 1383 	ubfx	r3, r1, #6, #4
 800752c:	f043 0370 	orr.w	r3, r3, #112	; 0x70
			lsb = (DAC_val << 2) & 0xFC;
 8007530:	b2c9      	uxtb	r1, r1
 8007532:	0089      	lsls	r1, r1, #2
 8007534:	b2ca      	uxtb	r2, r1
			break;
 8007536:	e7f2      	b.n	800751e <MAX5135_DAC_send+0x26>
			msb = 0xB0 | ((DAC_val >> 6) & 0x0F);
 8007538:	f3c1 1383 	ubfx	r3, r1, #6, #4
 800753c:	f043 03b0 	orr.w	r3, r3, #176	; 0xb0
			lsb = (DAC_val << 2) & 0xFC;
 8007540:	b2c9      	uxtb	r1, r1
 8007542:	0089      	lsls	r1, r1, #2
 8007544:	b2ca      	uxtb	r2, r1
			break;
 8007546:	e7ea      	b.n	800751e <MAX5135_DAC_send+0x26>
			msb = 0xF0 | ((DAC_val >> 6) & 0x0F);
 8007548:	f3c1 1387 	ubfx	r3, r1, #6, #8
 800754c:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
			lsb = (DAC_val << 2) & 0xFC;
 8007550:	b2c9      	uxtb	r1, r1
 8007552:	0089      	lsls	r1, r1, #2
 8007554:	b2ca      	uxtb	r2, r1
			break;
 8007556:	e7e2      	b.n	800751e <MAX5135_DAC_send+0x26>

08007558 <ADC_POTS_selector_init>:
};


//Init GPIOs for ADC channels multiplexers
void ADC_POTS_selector_init(void)
{
 8007558:	b500      	push	{lr}
 800755a:	b083      	sub	sp, #12
	GPIO_InitTypeDef GPIO_InitStructure;
	
	/* Setting up peripherial */
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 800755c:	2101      	movs	r1, #1
 800755e:	2004      	movs	r0, #4
 8007560:	f7fd f9b2 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	
	memset(&GPIO_InitStructure, 0, sizeof(GPIO_InitStructure));
 8007564:	2300      	movs	r3, #0
 8007566:	9301      	str	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Pin 	= ADC_PS_SH_PIN|ADC_PS_ST_PIN|ADC_PS_DS_PIN;
 8007568:	f44f 4360 	mov.w	r3, #57344	; 0xe000
 800756c:	9300      	str	r3, [sp, #0]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800756e:	2302      	movs	r3, #2
 8007570:	f88d 3005 	strb.w	r3, [sp, #5]
	GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_OUT;
 8007574:	2301      	movs	r3, #1
 8007576:	f88d 3004 	strb.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd	= GPIO_PuPd_UP;
 800757a:	f88d 3007 	strb.w	r3, [sp, #7]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 800757e:	4669      	mov	r1, sp
 8007580:	4802      	ldr	r0, [pc, #8]	; (800758c <ADC_POTS_selector_init+0x34>)
 8007582:	f7fc f9ef 	bl	8003964 <GPIO_Init>
}
 8007586:	b003      	add	sp, #12
 8007588:	f85d fb04 	ldr.w	pc, [sp], #4
 800758c:	40020800 	.word	0x40020800

08007590 <ADC_POTS_selector_SendByte>:
void ADC_POTS_selector_SendByte(unsigned char data)
{
	unsigned char dat, cnt;
	
	dat = data;
	for(cnt=0; cnt<8; cnt++)
 8007590:	2300      	movs	r3, #0
 8007592:	e00c      	b.n	80075ae <ADC_POTS_selector_SendByte+0x1e>
	{
		if ((dat & 0x80) > 0) {
			ADC_POTS_SELECTOR_DATA_HIGH;
		} else {
			ADC_POTS_SELECTOR_DATA_LOW;
 8007594:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8007598:	4a0c      	ldr	r2, [pc, #48]	; (80075cc <ADC_POTS_selector_SendByte+0x3c>)
 800759a:	8351      	strh	r1, [r2, #26]
		}

		ADC_POTS_SELECTOR_SHIFT_LOW;
 800759c:	4a0b      	ldr	r2, [pc, #44]	; (80075cc <ADC_POTS_selector_SendByte+0x3c>)
 800759e:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80075a2:	8351      	strh	r1, [r2, #26]
 
		ADC_POTS_SELECTOR_SHIFT_HIGH;
 80075a4:	8311      	strh	r1, [r2, #24]
   
		dat = dat << 1;
 80075a6:	0040      	lsls	r0, r0, #1
 80075a8:	b2c0      	uxtb	r0, r0
	for(cnt=0; cnt<8; cnt++)
 80075aa:	3301      	adds	r3, #1
 80075ac:	b2db      	uxtb	r3, r3
 80075ae:	2b07      	cmp	r3, #7
 80075b0:	d807      	bhi.n	80075c2 <ADC_POTS_selector_SendByte+0x32>
		if ((dat & 0x80) > 0) {
 80075b2:	f010 0f80 	tst.w	r0, #128	; 0x80
 80075b6:	d0ed      	beq.n	8007594 <ADC_POTS_selector_SendByte+0x4>
			ADC_POTS_SELECTOR_DATA_HIGH;
 80075b8:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80075bc:	4a03      	ldr	r2, [pc, #12]	; (80075cc <ADC_POTS_selector_SendByte+0x3c>)
 80075be:	8311      	strh	r1, [r2, #24]
 80075c0:	e7ec      	b.n	800759c <ADC_POTS_selector_SendByte+0xc>
	}
	
	ADC_POTS_SELECTOR_DATA_LOW;
 80075c2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80075c6:	4b01      	ldr	r3, [pc, #4]	; (80075cc <ADC_POTS_selector_SendByte+0x3c>)
 80075c8:	835a      	strh	r2, [r3, #26]
 80075ca:	4770      	bx	lr
 80075cc:	40020800 	.word	0x40020800

080075d0 <ADC_POTS_selector_SendDWord>:
}

//Send 5 bytes to ADC channels multiplexers
void ADC_POTS_selector_SendDWord(unsigned long long int data)
{	
 80075d0:	b510      	push	{r4, lr}
 80075d2:	4604      	mov	r4, r0
	ADC_POTS_selector_SendByte((unsigned char) ((data&0xFF00000000)>>32));
 80075d4:	b2c8      	uxtb	r0, r1
 80075d6:	f7ff ffdb 	bl	8007590 <ADC_POTS_selector_SendByte>
	ADC_POTS_selector_SendByte((unsigned char) ((data&0xFF000000)>>24));
 80075da:	0e20      	lsrs	r0, r4, #24
 80075dc:	f7ff ffd8 	bl	8007590 <ADC_POTS_selector_SendByte>
	ADC_POTS_selector_SendByte((unsigned char) ( data&0x000000FF));
 80075e0:	b2e0      	uxtb	r0, r4
 80075e2:	f7ff ffd5 	bl	8007590 <ADC_POTS_selector_SendByte>
	ADC_POTS_selector_SendByte((unsigned char) ((data&0x0000FF00)>>8));
 80075e6:	f3c4 2007 	ubfx	r0, r4, #8, #8
 80075ea:	f7ff ffd1 	bl	8007590 <ADC_POTS_selector_SendByte>
	ADC_POTS_selector_SendByte((unsigned char) ((data&0x00FF0000)>>16));
 80075ee:	f3c4 4007 	ubfx	r0, r4, #16, #8
 80075f2:	f7ff ffcd 	bl	8007590 <ADC_POTS_selector_SendByte>

	
	ADC_POTS_SELECTOR_STORAGE_LOW;
 80075f6:	4b03      	ldr	r3, [pc, #12]	; (8007604 <ADC_POTS_selector_SendDWord+0x34>)
 80075f8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80075fc:	835a      	strh	r2, [r3, #26]
	
	ADC_POTS_SELECTOR_STORAGE_HIGH;
 80075fe:	831a      	strh	r2, [r3, #24]
 8007600:	bd10      	pop	{r4, pc}
 8007602:	bf00      	nop
 8007604:	40020800 	.word	0x40020800

08007608 <ADC_POTS_selector_Ch>:
}

//Select ADC channel
void ADC_POTS_selector_Ch(unsigned char Ch)
{
 8007608:	b508      	push	{r3, lr}
	ADC_POTS_selector_SendDWord((unsigned long long int) ChSelData[Ch]);
 800760a:	4b04      	ldr	r3, [pc, #16]	; (800761c <ADC_POTS_selector_Ch+0x14>)
 800760c:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 8007610:	e9d0 0100 	ldrd	r0, r1, [r0]
 8007614:	f7ff ffdc 	bl	80075d0 <ADC_POTS_selector_SendDWord>
 8007618:	bd08      	pop	{r3, pc}
 800761a:	bf00      	nop
 800761c:	20000018 	.word	0x20000018

08007620 <DipConfig_init>:
#define DipConfigPin3 GPIO_Pin_13
#define DipConfigPin4 GPIO_Pin_8

/*Init GPIOs for configuration dip switch*/
void DipConfig_init(void)
{
 8007620:	b500      	push	{lr}
 8007622:	b083      	sub	sp, #12
	GPIO_InitTypeDef mGPIO_InitStructure;
	
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8007624:	2101      	movs	r1, #1
 8007626:	4608      	mov	r0, r1
 8007628:	f7fd f94e 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	
	//setup gpio speed


	mGPIO_InitStructure.GPIO_Pin 		= DipConfigPin1|DipConfigPin2|/*DipConfigPin3|*/DipConfigPin4;
 800762c:	f44f 4309 	mov.w	r3, #35072	; 0x8900
 8007630:	9300      	str	r3, [sp, #0]
	mGPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_IN;
 8007632:	2300      	movs	r3, #0
 8007634:	f88d 3004 	strb.w	r3, [sp, #4]
	mGPIO_InitStructure.GPIO_PuPd 	= GPIO_PuPd_UP;
 8007638:	2201      	movs	r2, #1
 800763a:	f88d 2007 	strb.w	r2, [sp, #7]
	mGPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_2MHz;
 800763e:	f88d 3005 	strb.w	r3, [sp, #5]
	


	GPIO_Init(GPIOA, &mGPIO_InitStructure);
 8007642:	4669      	mov	r1, sp
 8007644:	4802      	ldr	r0, [pc, #8]	; (8007650 <DipConfig_init+0x30>)
 8007646:	f7fc f98d 	bl	8003964 <GPIO_Init>
};
 800764a:	b003      	add	sp, #12
 800764c:	f85d fb04 	ldr.w	pc, [sp], #4
 8007650:	40020000 	.word	0x40020000

08007654 <GetDipConfig>:

/*Returns the state of dip switch*/
uDipConfig GetDipConfig(void)
{
 8007654:	b538      	push	{r3, r4, r5, lr}
	uDipConfig lDipConfig;
	
	lDipConfig.b.V_OUT_1V2 		= ~GPIO_ReadInputDataBit(GPIOA, DipConfigPin1);
 8007656:	4d0f      	ldr	r5, [pc, #60]	; (8007694 <GetDipConfig+0x40>)
 8007658:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800765c:	4628      	mov	r0, r5
 800765e:	f7fc f9e1 	bl	8003a24 <GPIO_ReadInputDataBit>
 8007662:	43c0      	mvns	r0, r0
 8007664:	f04f 0400 	mov.w	r4, #0
 8007668:	f360 0400 	bfi	r4, r0, #0, #1
	//lDipConfig.b.SAVE_V_LEVEL = ~GPIO_ReadInputDataBit(GPIOA, DipConfigPin3);
	lDipConfig.b.SAVE_V_LEVEL = 1;
 800766c:	f044 0404 	orr.w	r4, r4, #4
	lDipConfig.b.V_OUT_1V 		= ~GPIO_ReadInputDataBit(GPIOA, DipConfigPin2);
 8007670:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8007674:	4628      	mov	r0, r5
 8007676:	f7fc f9d5 	bl	8003a24 <GPIO_ReadInputDataBit>
 800767a:	43c0      	mvns	r0, r0
 800767c:	f360 0441 	bfi	r4, r0, #1, #1
	lDipConfig.b.EXPANDER_ON 	= ~GPIO_ReadInputDataBit(GPIOA, DipConfigPin4);
 8007680:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007684:	4628      	mov	r0, r5
 8007686:	f7fc f9cd 	bl	8003a24 <GPIO_ReadInputDataBit>
 800768a:	43c0      	mvns	r0, r0
 800768c:	f360 04c3 	bfi	r4, r0, #3, #1
	
	return lDipConfig;
}
 8007690:	4620      	mov	r0, r4
 8007692:	bd38      	pop	{r3, r4, r5, pc}
 8007694:	40020000 	.word	0x40020000

08007698 <Init_Expander_GPIO>:
#include "expander.h"
#include "dip_config.h"


void Init_Expander_GPIO(void)
{
 8007698:	b500      	push	{lr}
 800769a:	b083      	sub	sp, #12
	GPIO_InitTypeDef mGPIO_InitStructure;
	
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 800769c:	2101      	movs	r1, #1
 800769e:	2002      	movs	r0, #2
 80076a0:	f7fd f912 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	
	mGPIO_InitStructure.GPIO_Pin 		= EXPANDER_PIN;
 80076a4:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80076a8:	9300      	str	r3, [sp, #0]
	mGPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_IN;
 80076aa:	2300      	movs	r3, #0
 80076ac:	f88d 3004 	strb.w	r3, [sp, #4]
	mGPIO_InitStructure.GPIO_PuPd 	= GPIO_PuPd_DOWN;
 80076b0:	2202      	movs	r2, #2
 80076b2:	f88d 2007 	strb.w	r2, [sp, #7]
	mGPIO_InitStructure.GPIO_Speed 	= GPIO_Speed_2MHz;
 80076b6:	f88d 3005 	strb.w	r3, [sp, #5]
	
	GPIO_Init(EXPANDER_GPIO, &mGPIO_InitStructure);
 80076ba:	4669      	mov	r1, sp
 80076bc:	4802      	ldr	r0, [pc, #8]	; (80076c8 <Init_Expander_GPIO+0x30>)
 80076be:	f7fc f951 	bl	8003964 <GPIO_Init>
}
 80076c2:	b003      	add	sp, #12
 80076c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80076c8:	40020400 	.word	0x40020400

080076cc <Is_Expander_Present>:

/*Returns 1 if expander is connected, otherwise returns 0*/
uint8_t Is_Expander_Present(void)
{
 80076cc:	b508      	push	{r3, lr}
	uDipConfig DipConfig;
	
	DipConfig = GetDipConfig();
 80076ce:	f7ff ffc1 	bl	8007654 <GetDipConfig>
	if(DipConfig.b.EXPANDER_ON) return 1;
 80076d2:	f010 0f08 	tst.w	r0, #8
 80076d6:	d101      	bne.n	80076dc <Is_Expander_Present+0x10>
	else return 0;
 80076d8:	2000      	movs	r0, #0
}
 80076da:	bd08      	pop	{r3, pc}
	if(DipConfig.b.EXPANDER_ON) return 1;
 80076dc:	2001      	movs	r0, #1
 80076de:	bd08      	pop	{r3, pc}

080076e0 <LEDS_modes_init>:

#define LEDS_MODES_DATA_HIGH		GPIO_SetBits(GPIOC, GPIO_Pin_5)
#define LEDS_MODES_DATA_LOW			GPIO_ResetBits(GPIOC, GPIO_Pin_5)

void LEDS_modes_init(void)
{
 80076e0:	b500      	push	{lr}
 80076e2:	b083      	sub	sp, #12
	GPIO_InitTypeDef GPIO_InitStructure;
	
	/* Setting up peripherial */
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 80076e4:	2101      	movs	r1, #1
 80076e6:	2004      	movs	r0, #4
 80076e8:	f7fd f8ee 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	memset(&GPIO_InitStructure, 0, sizeof(GPIO_InitStructure));
 80076ec:	2300      	movs	r3, #0
 80076ee:	9301      	str	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Pin 	= GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6;
 80076f0:	2370      	movs	r3, #112	; 0x70
 80076f2:	9300      	str	r3, [sp, #0]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80076f4:	2302      	movs	r3, #2
 80076f6:	f88d 3005 	strb.w	r3, [sp, #5]
	GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_OUT; 
 80076fa:	2301      	movs	r3, #1
 80076fc:	f88d 3004 	strb.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd	= GPIO_PuPd_UP;
 8007700:	f88d 3007 	strb.w	r3, [sp, #7]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8007704:	4669      	mov	r1, sp
 8007706:	4803      	ldr	r0, [pc, #12]	; (8007714 <LEDS_modes_init+0x34>)
 8007708:	f7fc f92c 	bl	8003964 <GPIO_Init>
}
 800770c:	b003      	add	sp, #12
 800770e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007712:	bf00      	nop
 8007714:	40020800 	.word	0x40020800

08007718 <LEDS_modes_SendByte>:

void LEDS_modes_SendByte(unsigned char data)
{
 8007718:	b570      	push	{r4, r5, r6, lr}
 800771a:	4605      	mov	r5, r0
	unsigned char dat, cnt;
	dat = data;
	for(cnt=0; cnt<8; cnt++)
 800771c:	2400      	movs	r4, #0
 800771e:	e010      	b.n	8007742 <LEDS_modes_SendByte+0x2a>
	{
		if ((dat & 0x80) > 0) {
			LEDS_MODES_DATA_HIGH;
		} else {
			LEDS_MODES_DATA_LOW;
 8007720:	2120      	movs	r1, #32
 8007722:	480f      	ldr	r0, [pc, #60]	; (8007760 <LEDS_modes_SendByte+0x48>)
 8007724:	f7fc f994 	bl	8003a50 <GPIO_ResetBits>
		}
		
		LEDS_MODES_SHIFT_LOW;		
 8007728:	4e0d      	ldr	r6, [pc, #52]	; (8007760 <LEDS_modes_SendByte+0x48>)
 800772a:	2110      	movs	r1, #16
 800772c:	4630      	mov	r0, r6
 800772e:	f7fc f98f 	bl	8003a50 <GPIO_ResetBits>
		LEDS_MODES_SHIFT_HIGH;
 8007732:	2110      	movs	r1, #16
 8007734:	4630      	mov	r0, r6
 8007736:	f7fc f989 	bl	8003a4c <GPIO_SetBits>

		dat = dat << 1;
 800773a:	006d      	lsls	r5, r5, #1
 800773c:	b2ed      	uxtb	r5, r5
	for(cnt=0; cnt<8; cnt++)
 800773e:	3401      	adds	r4, #1
 8007740:	b2e4      	uxtb	r4, r4
 8007742:	2c07      	cmp	r4, #7
 8007744:	d807      	bhi.n	8007756 <LEDS_modes_SendByte+0x3e>
		if ((dat & 0x80) > 0) {
 8007746:	f015 0f80 	tst.w	r5, #128	; 0x80
 800774a:	d0e9      	beq.n	8007720 <LEDS_modes_SendByte+0x8>
			LEDS_MODES_DATA_HIGH;
 800774c:	2120      	movs	r1, #32
 800774e:	4804      	ldr	r0, [pc, #16]	; (8007760 <LEDS_modes_SendByte+0x48>)
 8007750:	f7fc f97c 	bl	8003a4c <GPIO_SetBits>
 8007754:	e7e8      	b.n	8007728 <LEDS_modes_SendByte+0x10>
	}
	LEDS_MODES_DATA_LOW;
 8007756:	2120      	movs	r1, #32
 8007758:	4801      	ldr	r0, [pc, #4]	; (8007760 <LEDS_modes_SendByte+0x48>)
 800775a:	f7fc f979 	bl	8003a50 <GPIO_ResetBits>
 800775e:	bd70      	pop	{r4, r5, r6, pc}
 8007760:	40020800 	.word	0x40020800

08007764 <LEDS_modes_SendDWord>:
	
}

void LEDS_modes_SendDWord(unsigned long int data)
{
 8007764:	b510      	push	{r4, lr}
 8007766:	4604      	mov	r4, r0
	LEDS_modes_SendByte( data&0x000000FF);
 8007768:	b2c0      	uxtb	r0, r0
 800776a:	f7ff ffd5 	bl	8007718 <LEDS_modes_SendByte>
	LEDS_modes_SendByte((data&0x0000FF00)>>8);
 800776e:	f3c4 2007 	ubfx	r0, r4, #8, #8
 8007772:	f7ff ffd1 	bl	8007718 <LEDS_modes_SendByte>
	LEDS_modes_SendByte((data&0x00FF0000)>>16);
 8007776:	f3c4 4007 	ubfx	r0, r4, #16, #8
 800777a:	f7ff ffcd 	bl	8007718 <LEDS_modes_SendByte>
	LEDS_modes_SendByte((data&0xFF000000)>>24);
 800777e:	0e20      	lsrs	r0, r4, #24
 8007780:	f7ff ffca 	bl	8007718 <LEDS_modes_SendByte>

	LEDS_MODES_STORAGE_LOW;
 8007784:	4c04      	ldr	r4, [pc, #16]	; (8007798 <LEDS_modes_SendDWord+0x34>)
 8007786:	2140      	movs	r1, #64	; 0x40
 8007788:	4620      	mov	r0, r4
 800778a:	f7fc f961 	bl	8003a50 <GPIO_ResetBits>
	LEDS_MODES_STORAGE_HIGH;
 800778e:	2140      	movs	r1, #64	; 0x40
 8007790:	4620      	mov	r0, r4
 8007792:	f7fc f95b 	bl	8003a4c <GPIO_SetBits>
 8007796:	bd10      	pop	{r4, pc}
 8007798:	40020800 	.word	0x40020800

0800779c <LEDS_modes_SendStruct>:
}


void LEDS_modes_SendStruct(uLeds *_Leds)
{
 800779c:	b510      	push	{r4, lr}
 800779e:	4604      	mov	r4, r0
	LEDS_modes_SendByte(_Leds->value[0]);
 80077a0:	7800      	ldrb	r0, [r0, #0]
 80077a2:	f7ff ffb9 	bl	8007718 <LEDS_modes_SendByte>
	LEDS_modes_SendByte(_Leds->value[1]);
 80077a6:	7860      	ldrb	r0, [r4, #1]
 80077a8:	f7ff ffb6 	bl	8007718 <LEDS_modes_SendByte>
	LEDS_modes_SendByte(_Leds->value[2]);
 80077ac:	78a0      	ldrb	r0, [r4, #2]
 80077ae:	f7ff ffb3 	bl	8007718 <LEDS_modes_SendByte>
	LEDS_modes_SendByte(_Leds->value[3]);
 80077b2:	78e0      	ldrb	r0, [r4, #3]
 80077b4:	f7ff ffb0 	bl	8007718 <LEDS_modes_SendByte>

	LEDS_MODES_STORAGE_LOW;
 80077b8:	4c04      	ldr	r4, [pc, #16]	; (80077cc <LEDS_modes_SendStruct+0x30>)
 80077ba:	2140      	movs	r1, #64	; 0x40
 80077bc:	4620      	mov	r0, r4
 80077be:	f7fc f947 	bl	8003a50 <GPIO_ResetBits>
	LEDS_MODES_STORAGE_HIGH;
 80077c2:	2140      	movs	r1, #64	; 0x40
 80077c4:	4620      	mov	r0, r4
 80077c6:	f7fc f941 	bl	8003a4c <GPIO_SetBits>
 80077ca:	bd10      	pop	{r4, pc}
 80077cc:	40020800 	.word	0x40020800

080077d0 <LED_STEP_init>:
#define LED_STEP_DATA_HIGH			GPIO_SetBits(GPIOC, GPIO_Pin_8)
#define LED_STEP_DATA_LOW				GPIO_ResetBits(GPIOC, GPIO_Pin_8)

/*Init GPIO for LEDs control via HC595 shift registers*/
void LED_STEP_init(void)
{
 80077d0:	b500      	push	{lr}
 80077d2:	b083      	sub	sp, #12
	GPIO_InitTypeDef GPIO_InitStructure;
	
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 80077d4:	2101      	movs	r1, #1
 80077d6:	2004      	movs	r0, #4
 80077d8:	f7fd f876 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	memset(&GPIO_InitStructure, 0, sizeof(GPIO_InitStructure));
 80077dc:	2300      	movs	r3, #0
 80077de:	9301      	str	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Pin 	= GPIO_Pin_7|GPIO_Pin_8|GPIO_Pin_9;
 80077e0:	f44f 7360 	mov.w	r3, #896	; 0x380
 80077e4:	9300      	str	r3, [sp, #0]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz; //100mhz default
 80077e6:	2303      	movs	r3, #3
 80077e8:	f88d 3005 	strb.w	r3, [sp, #5]
	GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_OUT;	 
 80077ec:	2301      	movs	r3, #1
 80077ee:	f88d 3004 	strb.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd	= GPIO_PuPd_UP;
 80077f2:	f88d 3007 	strb.w	r3, [sp, #7]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 80077f6:	4669      	mov	r1, sp
 80077f8:	4802      	ldr	r0, [pc, #8]	; (8007804 <LED_STEP_init+0x34>)
 80077fa:	f7fc f8b3 	bl	8003964 <GPIO_Init>
}
 80077fe:	b003      	add	sp, #12
 8007800:	f85d fb04 	ldr.w	pc, [sp], #4
 8007804:	40020800 	.word	0x40020800

08007808 <LED_STEP_SendByte>:

/*Shift one byte to HC595 registers which control LEDs*/
void LED_STEP_SendByte(unsigned char data)
{
 8007808:	b570      	push	{r4, r5, r6, lr}
 800780a:	4605      	mov	r5, r0
	unsigned char dat, cnt;
	dat = data;
	for(cnt=0; cnt<8; cnt++)
 800780c:	2400      	movs	r4, #0
 800780e:	e011      	b.n	8007834 <LED_STEP_SendByte+0x2c>
	{
		if ((dat & 0x80) > 0) {
			LED_STEP_DATA_HIGH;
		} else {
			LED_STEP_DATA_LOW;
 8007810:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007814:	4810      	ldr	r0, [pc, #64]	; (8007858 <LED_STEP_SendByte+0x50>)
 8007816:	f7fc f91b 	bl	8003a50 <GPIO_ResetBits>
		}

		LED_STEP_SHIFT_LOW;
 800781a:	4e0f      	ldr	r6, [pc, #60]	; (8007858 <LED_STEP_SendByte+0x50>)
 800781c:	2180      	movs	r1, #128	; 0x80
 800781e:	4630      	mov	r0, r6
 8007820:	f7fc f916 	bl	8003a50 <GPIO_ResetBits>
		LED_STEP_SHIFT_HIGH;
 8007824:	2180      	movs	r1, #128	; 0x80
 8007826:	4630      	mov	r0, r6
 8007828:	f7fc f910 	bl	8003a4c <GPIO_SetBits>

		dat = dat << 1;
 800782c:	006d      	lsls	r5, r5, #1
 800782e:	b2ed      	uxtb	r5, r5
	for(cnt=0; cnt<8; cnt++)
 8007830:	3401      	adds	r4, #1
 8007832:	b2e4      	uxtb	r4, r4
 8007834:	2c07      	cmp	r4, #7
 8007836:	d808      	bhi.n	800784a <LED_STEP_SendByte+0x42>
		if ((dat & 0x80) > 0) {
 8007838:	f015 0f80 	tst.w	r5, #128	; 0x80
 800783c:	d0e8      	beq.n	8007810 <LED_STEP_SendByte+0x8>
			LED_STEP_DATA_HIGH;
 800783e:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007842:	4805      	ldr	r0, [pc, #20]	; (8007858 <LED_STEP_SendByte+0x50>)
 8007844:	f7fc f902 	bl	8003a4c <GPIO_SetBits>
 8007848:	e7e7      	b.n	800781a <LED_STEP_SendByte+0x12>
	}
	LED_STEP_DATA_LOW;
 800784a:	f44f 7180 	mov.w	r1, #256	; 0x100
 800784e:	4802      	ldr	r0, [pc, #8]	; (8007858 <LED_STEP_SendByte+0x50>)
 8007850:	f7fc f8fe 	bl	8003a50 <GPIO_ResetBits>
 8007854:	bd70      	pop	{r4, r5, r6, pc}
 8007856:	bf00      	nop
 8007858:	40020800 	.word	0x40020800

0800785c <LED_STEP_SendWord>:
}

/*Shift two bytes to HC595 registers which control LEDs*/
void LED_STEP_SendWord(unsigned long int data)
{
 800785c:	b510      	push	{r4, lr}
 800785e:	4604      	mov	r4, r0
	LED_STEP_SendByte((unsigned char) ((data&0xFF00)>>8) );
 8007860:	f3c0 2007 	ubfx	r0, r0, #8, #8
 8007864:	f7ff ffd0 	bl	8007808 <LED_STEP_SendByte>
	LED_STEP_SendByte((unsigned char) (data&0x00FF) );
 8007868:	b2e0      	uxtb	r0, r4
 800786a:	f7ff ffcd 	bl	8007808 <LED_STEP_SendByte>

	LED_STEP_STORAGE_LOW;
 800786e:	4c06      	ldr	r4, [pc, #24]	; (8007888 <LED_STEP_SendWord+0x2c>)
 8007870:	f44f 7100 	mov.w	r1, #512	; 0x200
 8007874:	4620      	mov	r0, r4
 8007876:	f7fc f8eb 	bl	8003a50 <GPIO_ResetBits>
	LED_STEP_STORAGE_HIGH;
 800787a:	f44f 7100 	mov.w	r1, #512	; 0x200
 800787e:	4620      	mov	r0, r4
 8007880:	f7fc f8e4 	bl	8003a4c <GPIO_SetBits>
 8007884:	bd10      	pop	{r4, pc}
 8007886:	bf00      	nop
 8007888:	40020800 	.word	0x40020800

0800788c <LED_STEP_LightStep>:
}

/*Turn on the LED which indicates the step number StepNum*/
void LED_STEP_LightStep(unsigned int StepNum)
{
 800788c:	b538      	push	{r3, r4, r5, lr}
	unsigned long dat = 0xFFFFFFFF;
	unsigned char cnt, tmp1, tmp2;
	
	dat &= ~(1<<0);
	for(cnt=0;cnt<StepNum;cnt++)
 800788e:	2300      	movs	r3, #0
	dat &= ~(1<<0);
 8007890:	f06f 0401 	mvn.w	r4, #1
	for(cnt=0;cnt<StepNum;cnt++)
 8007894:	e004      	b.n	80078a0 <LED_STEP_LightStep+0x14>
	{		
		dat = dat<<1;
 8007896:	0064      	lsls	r4, r4, #1
		dat |= (1<<0);		
 8007898:	f044 0401 	orr.w	r4, r4, #1
	for(cnt=0;cnt<StepNum;cnt++)
 800789c:	3301      	adds	r3, #1
 800789e:	b2db      	uxtb	r3, r3
 80078a0:	4283      	cmp	r3, r0
 80078a2:	d3f8      	bcc.n	8007896 <LED_STEP_LightStep+0xa>
	};
		
	if(!Is_Expander_Present())
 80078a4:	f7ff ff12 	bl	80076cc <Is_Expander_Present>
 80078a8:	b1d0      	cbz	r0, 80078e0 <LED_STEP_LightStep+0x54>
		LED_STEP_SendWord(dat & 0xFFFF);
	}
	else
	{
		//if expander is presented we should control 32 LEDs instead of 16
		tmp1 = dat >> 24;
 80078aa:	0e25      	lsrs	r5, r4, #24
		tmp2 = dat >> 16;
		
		LED_STEP_SendByte((unsigned char) (tmp2) );
 80078ac:	f3c4 4007 	ubfx	r0, r4, #16, #8
 80078b0:	f7ff ffaa 	bl	8007808 <LED_STEP_SendByte>
		LED_STEP_SendByte((unsigned char) (tmp1) );
 80078b4:	4628      	mov	r0, r5
 80078b6:	f7ff ffa7 	bl	8007808 <LED_STEP_SendByte>
		LED_STEP_SendByte((unsigned char) (dat >> 8) );
 80078ba:	f3c4 2007 	ubfx	r0, r4, #8, #8
 80078be:	f7ff ffa3 	bl	8007808 <LED_STEP_SendByte>
		LED_STEP_SendByte((unsigned char) (dat) );
 80078c2:	b2e0      	uxtb	r0, r4
 80078c4:	f7ff ffa0 	bl	8007808 <LED_STEP_SendByte>
		
		LED_STEP_STORAGE_LOW;
 80078c8:	4c07      	ldr	r4, [pc, #28]	; (80078e8 <LED_STEP_LightStep+0x5c>)
 80078ca:	f44f 7100 	mov.w	r1, #512	; 0x200
 80078ce:	4620      	mov	r0, r4
 80078d0:	f7fc f8be 	bl	8003a50 <GPIO_ResetBits>
		LED_STEP_STORAGE_HIGH;
 80078d4:	f44f 7100 	mov.w	r1, #512	; 0x200
 80078d8:	4620      	mov	r0, r4
 80078da:	f7fc f8b7 	bl	8003a4c <GPIO_SetBits>
 80078de:	bd38      	pop	{r3, r4, r5, pc}
		LED_STEP_SendWord(dat & 0xFFFF);
 80078e0:	b2a0      	uxth	r0, r4
 80078e2:	f7ff ffbb 	bl	800785c <LED_STEP_SendWord>
 80078e6:	bd38      	pop	{r3, r4, r5, pc}
 80078e8:	40020800 	.word	0x40020800
 80078ec:	00000000 	.word	0x00000000

080078f0 <mADC_init>:
/*
	Setting up acts Timer 2 as source for ADC start conversion
	with 40 ksamples per second.
*/
void mADC_init(void)
{
 80078f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80078f4:	b08c      	sub	sp, #48	; 0x30
	ADC_InitTypeDef ADC_InitType;
	TIM_TimeBaseInitTypeDef TimeBaseInit;
	NVIC_InitTypeDef nvicStructure;
	
	//Timer init
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE); 
 80078f6:	2101      	movs	r1, #1
 80078f8:	4608      	mov	r0, r1
 80078fa:	f7fd f80f 	bl	800491c <RCC_APB1PeriphClockCmd>
		
	TIM_TimeBaseStructInit(&TimeBaseInit);
 80078fe:	a801      	add	r0, sp, #4
 8007900:	f7fe fc0c 	bl	800611c <TIM_TimeBaseStructInit>
  TimeBaseInit.TIM_Prescaler 			= 0;
 8007904:	2400      	movs	r4, #0
 8007906:	f8ad 4004 	strh.w	r4, [sp, #4]
	TimeBaseInit.TIM_CounterMode 		= TIM_CounterMode_Up;
 800790a:	f8ad 4006 	strh.w	r4, [sp, #6]
  TimeBaseInit.TIM_Period 				= 4200-1;// for 40kHz
 800790e:	f241 0367 	movw	r3, #4199	; 0x1067
 8007912:	9302      	str	r3, [sp, #8]
	TimeBaseInit.TIM_ClockDivision 	= TIM_CKD_DIV1;	
 8007914:	f8ad 400c 	strh.w	r4, [sp, #12]
  TIM_TimeBaseInit(TIM2, &TimeBaseInit); 
 8007918:	a901      	add	r1, sp, #4
 800791a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800791e:	f7fe fbbf 	bl	80060a0 <TIM_TimeBaseInit>

	TIM_SelectOutputTrigger(TIM2, TIM_TRGOSource_OC2Ref);
 8007922:	2150      	movs	r1, #80	; 0x50
 8007924:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8007928:	f7fe ffd1 	bl	80068ce <TIM_SelectOutputTrigger>
	TIM_CCxCmd(TIM2, TIM_Channel_2, TIM_CCx_Enable);
 800792c:	2201      	movs	r2, #1
 800792e:	2104      	movs	r1, #4
 8007930:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8007934:	f7fe fe40 	bl	80065b8 <TIM_CCxCmd>
	TIM_SetCompare2(TIM2, 1);	
 8007938:	2101      	movs	r1, #1
 800793a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800793e:	f7fe fd7c 	bl	800643a <TIM_SetCompare2>
	TIM2->CCMR1 |= TIM_CCMR1_OC2M;
 8007942:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8007946:	8b03      	ldrh	r3, [r0, #24]
 8007948:	b29b      	uxth	r3, r3
 800794a:	f443 43e0 	orr.w	r3, r3, #28672	; 0x7000
 800794e:	8303      	strh	r3, [r0, #24]
  TIM_Cmd(TIM2, ENABLE); 
 8007950:	2101      	movs	r1, #1
 8007952:	f7fe fc3f 	bl	80061d4 <TIM_Cmd>
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8007956:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 8007a48 <mADC_init+0x158>
 800795a:	2310      	movs	r3, #16
 800795c:	f888 3312 	strb.w	r3, [r8, #786]	; 0x312
	
	//ADC Init
	NVIC_SetPriority (ADC_IRQn, 1);  
	
	//ADC GPIO Init
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8007960:	2101      	movs	r1, #1
 8007962:	4608      	mov	r0, r1
 8007964:	f7fc ffb0 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	memset(&GPIO_Init_user, 0, sizeof(GPIO_Init_user));
 8007968:	940b      	str	r4, [sp, #44]	; 0x2c
	GPIO_Init_user.GPIO_Pin 	= GPIO_Pin_0|GPIO_Pin_1;
 800796a:	2303      	movs	r3, #3
 800796c:	930a      	str	r3, [sp, #40]	; 0x28
	GPIO_Init_user.GPIO_Mode 	= GPIO_Mode_AN; //Analog mode
 800796e:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
	GPIO_Init(GPIOA, & GPIO_Init_user);	
 8007972:	a90a      	add	r1, sp, #40	; 0x28
 8007974:	4830      	ldr	r0, [pc, #192]	; (8007a38 <mADC_init+0x148>)
 8007976:	f7fb fff5 	bl	8003964 <GPIO_Init>
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
 800797a:	2101      	movs	r1, #1
 800797c:	f44f 7080 	mov.w	r0, #256	; 0x100
 8007980:	f7fc ffda 	bl	8004938 <RCC_APB2PeriphClockCmd>
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE);
 8007984:	2101      	movs	r1, #1
 8007986:	f44f 7000 	mov.w	r0, #512	; 0x200
 800798a:	f7fc ffd5 	bl	8004938 <RCC_APB2PeriphClockCmd>
	
	ADC_StructInit(&ADC_InitType);
 800798e:	a804      	add	r0, sp, #16
 8007990:	f7f8 fcb8 	bl	8000304 <ADC_StructInit>
	ADC_InitType.ADC_ContinuousConvMode 	= DISABLE;
 8007994:	f88d 4015 	strb.w	r4, [sp, #21]
	ADC_InitType.ADC_DataAlign 						= ADC_DataAlign_Right;
 8007998:	9408      	str	r4, [sp, #32]
	ADC_InitType.ADC_ExternalTrigConv 		= ADC_ExternalTrigConv_T2_TRGO;
 800799a:	f04f 63c0 	mov.w	r3, #100663296	; 0x6000000
 800799e:	9307      	str	r3, [sp, #28]
	ADC_InitType.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_Rising;
 80079a0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80079a4:	9306      	str	r3, [sp, #24]
	ADC_InitType.ADC_NbrOfConversion 			= 1;
 80079a6:	2501      	movs	r5, #1
 80079a8:	f88d 5024 	strb.w	r5, [sp, #36]	; 0x24
	ADC_InitType.ADC_Resolution 					= ADC_Resolution_12b;
 80079ac:	9404      	str	r4, [sp, #16]
	ADC_InitType.ADC_ScanConvMode 				= DISABLE;
 80079ae:	f88d 4014 	strb.w	r4, [sp, #20]

	ADC_Init(ADC1, &ADC_InitType);
 80079b2:	4f22      	ldr	r7, [pc, #136]	; (8007a3c <mADC_init+0x14c>)
 80079b4:	a904      	add	r1, sp, #16
 80079b6:	4638      	mov	r0, r7
 80079b8:	f7f8 fc7c 	bl	80002b4 <ADC_Init>
	ADC_Init(ADC2, &ADC_InitType);	
 80079bc:	4e20      	ldr	r6, [pc, #128]	; (8007a40 <mADC_init+0x150>)
 80079be:	a904      	add	r1, sp, #16
 80079c0:	4630      	mov	r0, r6
 80079c2:	f7f8 fc77 	bl	80002b4 <ADC_Init>
	ADC_RegularChannelConfig(ADC1, ADC_Channel_0 ,1, ADC_SampleTime_480Cycles);
 80079c6:	2307      	movs	r3, #7
 80079c8:	462a      	mov	r2, r5
 80079ca:	4621      	mov	r1, r4
 80079cc:	4638      	mov	r0, r7
 80079ce:	f7f8 fcfb 	bl	80003c8 <ADC_RegularChannelConfig>
	ADC_RegularChannelConfig(ADC2, ADC_Channel_1 ,1, ADC_SampleTime_480Cycles);
 80079d2:	2307      	movs	r3, #7
 80079d4:	462a      	mov	r2, r5
 80079d6:	4629      	mov	r1, r5
 80079d8:	4630      	mov	r0, r6
 80079da:	f7f8 fcf5 	bl	80003c8 <ADC_RegularChannelConfig>
	
	//ADC interrupts init
	nvicStructure.NVIC_IRQChannel = ADC_IRQn;
 80079de:	2312      	movs	r3, #18
 80079e0:	f88d 3000 	strb.w	r3, [sp]
	nvicStructure.NVIC_IRQChannelPreemptionPriority = 1;
 80079e4:	f88d 5001 	strb.w	r5, [sp, #1]
	nvicStructure.NVIC_IRQChannelSubPriority = 0;
 80079e8:	f88d 4002 	strb.w	r4, [sp, #2]
	nvicStructure.NVIC_IRQChannelCmd = ENABLE;
 80079ec:	f88d 5003 	strb.w	r5, [sp, #3]
	NVIC_Init(&nvicStructure);
 80079f0:	4668      	mov	r0, sp
 80079f2:	f7f8 fbf3 	bl	80001dc <NVIC_Init>
	
	ADC_POT_sel_cnt = 0;
 80079f6:	4b13      	ldr	r3, [pc, #76]	; (8007a44 <mADC_init+0x154>)
 80079f8:	701c      	strb	r4, [r3, #0]
	ADC_POTS_selector_Ch(0);
 80079fa:	4620      	mov	r0, r4
 80079fc:	f7ff fe04 	bl	8007608 <ADC_POTS_selector_Ch>
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 8007a00:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8007a04:	f8c8 3000 	str.w	r3, [r8]
	
	NVIC_EnableIRQ(ADC_IRQn);
	ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);
 8007a08:	462a      	mov	r2, r5
 8007a0a:	f240 2105 	movw	r1, #517	; 0x205
 8007a0e:	4638      	mov	r0, r7
 8007a10:	f7f8 fe02 	bl	8000618 <ADC_ITConfig>
	ADC_ITConfig(ADC2, ADC_IT_EOC, ENABLE);
 8007a14:	462a      	mov	r2, r5
 8007a16:	f240 2105 	movw	r1, #517	; 0x205
 8007a1a:	4630      	mov	r0, r6
 8007a1c:	f7f8 fdfc 	bl	8000618 <ADC_ITConfig>
	ADC_Cmd(ADC1, ENABLE);	
 8007a20:	4629      	mov	r1, r5
 8007a22:	4638      	mov	r0, r7
 8007a24:	f7f8 fc94 	bl	8000350 <ADC_Cmd>
	ADC_Cmd(ADC2, ENABLE);	
 8007a28:	4629      	mov	r1, r5
 8007a2a:	4630      	mov	r0, r6
 8007a2c:	f7f8 fc90 	bl	8000350 <ADC_Cmd>
};
 8007a30:	b00c      	add	sp, #48	; 0x30
 8007a32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007a36:	bf00      	nop
 8007a38:	40020000 	.word	0x40020000
 8007a3c:	40012000 	.word	0x40012000
 8007a40:	40012100 	.word	0x40012100
 8007a44:	200006b4 	.word	0x200006b4
 8007a48:	e000e100 	.word	0xe000e100

08007a4c <ADCPause>:
  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
 8007a4c:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8007a50:	4b01      	ldr	r3, [pc, #4]	; (8007a58 <ADCPause+0xc>)
 8007a52:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
 8007a56:	4770      	bx	lr
 8007a58:	e000e100 	.word	0xe000e100

08007a5c <ADCResume>:
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 8007a5c:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 8007a60:	4b01      	ldr	r3, [pc, #4]	; (8007a68 <ADCResume+0xc>)
 8007a62:	601a      	str	r2, [r3, #0]
 8007a64:	4770      	bx	lr
 8007a66:	bf00      	nop
 8007a68:	e000e100 	.word	0xe000e100

08007a6c <mInterruptInit>:
	NVIC_EnableIRQ(ADC_IRQn);
};

//External interrupts init for start and stop switches
void mInterruptInit(void)
{
 8007a6c:	b530      	push	{r4, r5, lr}
 8007a6e:	b087      	sub	sp, #28
	GPIO_InitTypeDef mGPIO;
	EXTI_InitTypeDef mInt;
	NVIC_InitTypeDef NVIC_InitStructure;
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 8007a70:	2101      	movs	r1, #1
 8007a72:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8007a76:	f7fc ff5f 	bl	8004938 <RCC_APB2PeriphClockCmd>
	
	mGPIO.GPIO_Mode = GPIO_Mode_IN;
 8007a7a:	2400      	movs	r4, #0
 8007a7c:	f88d 4014 	strb.w	r4, [sp, #20]
	mGPIO.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_8;
 8007a80:	f240 15e3 	movw	r5, #483	; 0x1e3
 8007a84:	9504      	str	r5, [sp, #16]
	mGPIO.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8007a86:	f88d 4017 	strb.w	r4, [sp, #23]
	mGPIO.GPIO_Speed = GPIO_Speed_100MHz;	
 8007a8a:	2303      	movs	r3, #3
 8007a8c:	f88d 3015 	strb.w	r3, [sp, #21]
	GPIO_Init(GPIOB, &mGPIO);
 8007a90:	a904      	add	r1, sp, #16
 8007a92:	4831      	ldr	r0, [pc, #196]	; (8007b58 <mInterruptInit+0xec>)
 8007a94:	f7fb ff66 	bl	8003964 <GPIO_Init>

	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, GPIO_PinSource0);
 8007a98:	4621      	mov	r1, r4
 8007a9a:	2001      	movs	r0, #1
 8007a9c:	f7fe f98c 	bl	8005db8 <SYSCFG_EXTILineConfig>
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, GPIO_PinSource1);
 8007aa0:	2101      	movs	r1, #1
 8007aa2:	4608      	mov	r0, r1
 8007aa4:	f7fe f988 	bl	8005db8 <SYSCFG_EXTILineConfig>
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, GPIO_PinSource5);
 8007aa8:	2105      	movs	r1, #5
 8007aaa:	2001      	movs	r0, #1
 8007aac:	f7fe f984 	bl	8005db8 <SYSCFG_EXTILineConfig>
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, GPIO_PinSource6);
 8007ab0:	2106      	movs	r1, #6
 8007ab2:	2001      	movs	r0, #1
 8007ab4:	f7fe f980 	bl	8005db8 <SYSCFG_EXTILineConfig>
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, GPIO_PinSource7);
 8007ab8:	2107      	movs	r1, #7
 8007aba:	2001      	movs	r0, #1
 8007abc:	f7fe f97c 	bl	8005db8 <SYSCFG_EXTILineConfig>
	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, GPIO_PinSource8);
 8007ac0:	2108      	movs	r1, #8
 8007ac2:	2001      	movs	r0, #1
 8007ac4:	f7fe f978 	bl	8005db8 <SYSCFG_EXTILineConfig>

	
	//START-STOP LINE INIT Interrupt
	EXTI_DeInit();
 8007ac8:	f7fb f952 	bl	8002d70 <EXTI_DeInit>
	mInt.EXTI_Line = EXTI_Line0|EXTI_Line1|EXTI_Line5|EXTI_Line6|EXTI_Line7|EXTI_Line8;
 8007acc:	9502      	str	r5, [sp, #8]
	mInt.EXTI_Mode = EXTI_Mode_Interrupt;
 8007ace:	f88d 400c 	strb.w	r4, [sp, #12]
	mInt.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 8007ad2:	2310      	movs	r3, #16
 8007ad4:	f88d 300d 	strb.w	r3, [sp, #13]
	mInt.EXTI_LineCmd = ENABLE;	
 8007ad8:	2501      	movs	r5, #1
 8007ada:	f88d 500e 	strb.w	r5, [sp, #14]
	EXTI_Init(&mInt);
 8007ade:	a802      	add	r0, sp, #8
 8007ae0:	f7fb f954 	bl	8002d8c <EXTI_Init>
	
	NVIC_InitStructure.NVIC_IRQChannel = EXTI0_IRQn; 						
 8007ae4:	2306      	movs	r3, #6
 8007ae6:	f88d 3004 	strb.w	r3, [sp, #4]
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority 	= 0x00; 
 8007aea:	f88d 4005 	strb.w	r4, [sp, #5]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority 				= 0x00; 
 8007aee:	f88d 4006 	strb.w	r4, [sp, #6]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 
 8007af2:	f88d 5007 	strb.w	r5, [sp, #7]
  NVIC_Init(&NVIC_InitStructure);
 8007af6:	a801      	add	r0, sp, #4
 8007af8:	f7f8 fb70 	bl	80001dc <NVIC_Init>
	
	NVIC_InitStructure.NVIC_IRQChannel = EXTI1_IRQn; 						
 8007afc:	2307      	movs	r3, #7
 8007afe:	f88d 3004 	strb.w	r3, [sp, #4]
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority 	= 0x00; 
 8007b02:	f88d 4005 	strb.w	r4, [sp, #5]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority 				= 0x00; 
 8007b06:	f88d 4006 	strb.w	r4, [sp, #6]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 
 8007b0a:	f88d 5007 	strb.w	r5, [sp, #7]
  NVIC_Init(&NVIC_InitStructure);
 8007b0e:	a801      	add	r0, sp, #4
 8007b10:	f7f8 fb64 	bl	80001dc <NVIC_Init>
	
	NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn; 						
 8007b14:	2317      	movs	r3, #23
 8007b16:	f88d 3004 	strb.w	r3, [sp, #4]
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority 	= 0x00; 
 8007b1a:	f88d 4005 	strb.w	r4, [sp, #5]
  NVIC_InitStructure.NVIC_IRQChannelSubPriority 				= 0x00; 
 8007b1e:	f88d 4006 	strb.w	r4, [sp, #6]
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; 
 8007b22:	f88d 5007 	strb.w	r5, [sp, #7]
  NVIC_Init(&NVIC_InitStructure);
 8007b26:	a801      	add	r0, sp, #4
 8007b28:	f7f8 fb58 	bl	80001dc <NVIC_Init>
	
	EXTI_ClearITPendingBit(EXTI_Line0);	
 8007b2c:	4628      	mov	r0, r5
 8007b2e:	f7fb f9a3 	bl	8002e78 <EXTI_ClearITPendingBit>
	EXTI_ClearITPendingBit(EXTI_Line1);	
 8007b32:	2002      	movs	r0, #2
 8007b34:	f7fb f9a0 	bl	8002e78 <EXTI_ClearITPendingBit>
	EXTI_ClearITPendingBit(EXTI_Line5);	
 8007b38:	2020      	movs	r0, #32
 8007b3a:	f7fb f99d 	bl	8002e78 <EXTI_ClearITPendingBit>
	EXTI_ClearITPendingBit(EXTI_Line6);	
 8007b3e:	2040      	movs	r0, #64	; 0x40
 8007b40:	f7fb f99a 	bl	8002e78 <EXTI_ClearITPendingBit>
	EXTI_ClearITPendingBit(EXTI_Line7);	
 8007b44:	2080      	movs	r0, #128	; 0x80
 8007b46:	f7fb f997 	bl	8002e78 <EXTI_ClearITPendingBit>
	EXTI_ClearITPendingBit(EXTI_Line8);
 8007b4a:	f44f 7080 	mov.w	r0, #256	; 0x100
 8007b4e:	f7fb f993 	bl	8002e78 <EXTI_ClearITPendingBit>
};
 8007b52:	b007      	add	sp, #28
 8007b54:	bd30      	pop	{r4, r5, pc}
 8007b56:	bf00      	nop
 8007b58:	40020400 	.word	0x40020400

08007b5c <EXTI0_IRQHandler>:


//STOP KEY-BANANA Interrupt handler
//1 SECTION
void EXTI0_IRQHandler()
{
 8007b5c:	b508      	push	{r3, lr}
	if ( !(GPIOB->IDR & GPIO_IDR_IDR_0) && 
 8007b5e:	4b13      	ldr	r3, [pc, #76]	; (8007bac <EXTI0_IRQHandler+0x50>)
 8007b60:	691b      	ldr	r3, [r3, #16]
 8007b62:	f013 0f01 	tst.w	r3, #1
 8007b66:	d11c      	bne.n	8007ba2 <EXTI0_IRQHandler+0x46>
		(gSequencerMode_1 != SEQUENCER_MODE_WAIT && gSequencerMode_1 != SEQUENCER_MODE_WAIT_HI_Z && gSequencerMode_1 != SEQUENCER_MODE_STAY_HI_Z)
 8007b68:	4b11      	ldr	r3, [pc, #68]	; (8007bb0 <EXTI0_IRQHandler+0x54>)
 8007b6a:	785b      	ldrb	r3, [r3, #1]
 8007b6c:	b2db      	uxtb	r3, r3
	if ( !(GPIOB->IDR & GPIO_IDR_IDR_0) && 
 8007b6e:	2b01      	cmp	r3, #1
 8007b70:	d017      	beq.n	8007ba2 <EXTI0_IRQHandler+0x46>
		(gSequencerMode_1 != SEQUENCER_MODE_WAIT && gSequencerMode_1 != SEQUENCER_MODE_WAIT_HI_Z && gSequencerMode_1 != SEQUENCER_MODE_STAY_HI_Z)
 8007b72:	4b0f      	ldr	r3, [pc, #60]	; (8007bb0 <EXTI0_IRQHandler+0x54>)
 8007b74:	785b      	ldrb	r3, [r3, #1]
 8007b76:	b2db      	uxtb	r3, r3
 8007b78:	2b04      	cmp	r3, #4
 8007b7a:	d012      	beq.n	8007ba2 <EXTI0_IRQHandler+0x46>
 8007b7c:	4b0c      	ldr	r3, [pc, #48]	; (8007bb0 <EXTI0_IRQHandler+0x54>)
 8007b7e:	785b      	ldrb	r3, [r3, #1]
 8007b80:	b2db      	uxtb	r3, r3
 8007b82:	2b05      	cmp	r3, #5
 8007b84:	d00d      	beq.n	8007ba2 <EXTI0_IRQHandler+0x46>
	) {
		gPrevSequencerMode_1 = SEQUENCER_MODE_RUN;
 8007b86:	4b0a      	ldr	r3, [pc, #40]	; (8007bb0 <EXTI0_IRQHandler+0x54>)
 8007b88:	2200      	movs	r2, #0
 8007b8a:	709a      	strb	r2, [r3, #2]
		gSequencerMode_1 = SEQUENCER_MODE_STOP;	
 8007b8c:	2202      	movs	r2, #2
 8007b8e:	705a      	strb	r2, [r3, #1]
		
		DisplayUpdateFlags.b.MainDisplay 	= 1;
 8007b90:	4b08      	ldr	r3, [pc, #32]	; (8007bb4 <EXTI0_IRQHandler+0x58>)
 8007b92:	781a      	ldrb	r2, [r3, #0]
 8007b94:	f042 0201 	orr.w	r2, r2, #1
 8007b98:	701a      	strb	r2, [r3, #0]
		DisplayUpdateFlags.b.StepsDisplay = 1;
 8007b9a:	781a      	ldrb	r2, [r3, #0]
 8007b9c:	f042 0202 	orr.w	r2, r2, #2
 8007ba0:	701a      	strb	r2, [r3, #0]
	};
	
	EXTI_ClearITPendingBit(EXTI_Line0);	
 8007ba2:	2001      	movs	r0, #1
 8007ba4:	f7fb f968 	bl	8002e78 <EXTI_ClearITPendingBit>
 8007ba8:	bd08      	pop	{r3, pc}
 8007baa:	bf00      	nop
 8007bac:	40020400 	.word	0x40020400
 8007bb0:	200006b4 	.word	0x200006b4
 8007bb4:	20000708 	.word	0x20000708

08007bb8 <InitStart_1_SignalTimer>:

/*
	Init timer for start pulse (section 1) duration measurement 
*/
void InitStart_1_SignalTimer()
{
 8007bb8:	b508      	push	{r3, lr}
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
 8007bba:	2101      	movs	r1, #1
 8007bbc:	2002      	movs	r0, #2
 8007bbe:	f7fc fead 	bl	800491c <RCC_APB1PeriphClockCmd>
	
	TIM3->PSC = STEP_TIMER_PRESCALER;
 8007bc2:	4b0a      	ldr	r3, [pc, #40]	; (8007bec <InitStart_1_SignalTimer+0x34>)
 8007bc4:	f642 1204 	movw	r2, #10500	; 0x2904
 8007bc8:	851a      	strh	r2, [r3, #40]	; 0x28
	TIM3->ARR = START_TIMER_SUSTAIN;
 8007bca:	2228      	movs	r2, #40	; 0x28
 8007bcc:	62da      	str	r2, [r3, #44]	; 0x2c
	TIM3->CNT = 0;
 8007bce:	2200      	movs	r2, #0
 8007bd0:	625a      	str	r2, [r3, #36]	; 0x24
	TIM3->DIER = TIM_DIER_UIE;
 8007bd2:	2201      	movs	r2, #1
 8007bd4:	819a      	strh	r2, [r3, #12]
	TIM3->CR1 |= TIM_CR1_CEN;
 8007bd6:	881a      	ldrh	r2, [r3, #0]
 8007bd8:	b292      	uxth	r2, r2
 8007bda:	f042 0201 	orr.w	r2, r2, #1
 8007bde:	801a      	strh	r2, [r3, #0]
 8007be0:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 8007be4:	4b02      	ldr	r3, [pc, #8]	; (8007bf0 <InitStart_1_SignalTimer+0x38>)
 8007be6:	601a      	str	r2, [r3, #0]
 8007be8:	bd08      	pop	{r3, pc}
 8007bea:	bf00      	nop
 8007bec:	40000400 	.word	0x40000400
 8007bf0:	e000e100 	.word	0xe000e100

08007bf4 <InitStart_2_SignalTimer>:

/*
	Init timer for start pulse (section 2) duration measurement 
*/
void InitStart_2_SignalTimer()
{
 8007bf4:	b508      	push	{r3, lr}
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE);
 8007bf6:	2101      	movs	r1, #1
 8007bf8:	2020      	movs	r0, #32
 8007bfa:	f7fc fe8f 	bl	800491c <RCC_APB1PeriphClockCmd>
	
	TIM7->PSC = STEP_TIMER_PRESCALER;
 8007bfe:	4b0a      	ldr	r3, [pc, #40]	; (8007c28 <InitStart_2_SignalTimer+0x34>)
 8007c00:	f642 1204 	movw	r2, #10500	; 0x2904
 8007c04:	851a      	strh	r2, [r3, #40]	; 0x28
	TIM7->ARR = START_TIMER_SUSTAIN;
 8007c06:	2228      	movs	r2, #40	; 0x28
 8007c08:	62da      	str	r2, [r3, #44]	; 0x2c
	TIM7->CNT = 0;
 8007c0a:	2200      	movs	r2, #0
 8007c0c:	625a      	str	r2, [r3, #36]	; 0x24
	TIM7->DIER = TIM_DIER_UIE;
 8007c0e:	2201      	movs	r2, #1
 8007c10:	819a      	strh	r2, [r3, #12]
	TIM7->CR1 |= TIM_CR1_CEN;
 8007c12:	881a      	ldrh	r2, [r3, #0]
 8007c14:	b292      	uxth	r2, r2
 8007c16:	f042 0201 	orr.w	r2, r2, #1
 8007c1a:	801a      	strh	r2, [r3, #0]
 8007c1c:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 8007c20:	4b02      	ldr	r3, [pc, #8]	; (8007c2c <InitStart_2_SignalTimer+0x38>)
 8007c22:	605a      	str	r2, [r3, #4]
 8007c24:	bd08      	pop	{r3, pc}
 8007c26:	bf00      	nop
 8007c28:	40001400 	.word	0x40001400
 8007c2c:	e000e100 	.word	0xe000e100

08007c30 <InitClear_Timer>:
	
	NVIC_EnableIRQ(TIM7_IRQn);	
};

void InitClear_Timer()
{
 8007c30:	b508      	push	{r3, lr}
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
 8007c32:	2101      	movs	r1, #1
 8007c34:	2010      	movs	r0, #16
 8007c36:	f7fc fe71 	bl	800491c <RCC_APB1PeriphClockCmd>
	
	TIM6->PSC = 21000;
 8007c3a:	480b      	ldr	r0, [pc, #44]	; (8007c68 <InitClear_Timer+0x38>)
 8007c3c:	f245 2308 	movw	r3, #21000	; 0x5208
 8007c40:	8503      	strh	r3, [r0, #40]	; 0x28
	TIM6->ARR = 200;
 8007c42:	23c8      	movs	r3, #200	; 0xc8
 8007c44:	62c3      	str	r3, [r0, #44]	; 0x2c
	TIM6->CNT = 0;
 8007c46:	2300      	movs	r3, #0
 8007c48:	6243      	str	r3, [r0, #36]	; 0x24
	TIM6->DIER = TIM_DIER_UIE;
 8007c4a:	2101      	movs	r1, #1
 8007c4c:	8181      	strh	r1, [r0, #12]
	TIM6->CR1 |= TIM_CR1_CEN;
 8007c4e:	8803      	ldrh	r3, [r0, #0]
 8007c50:	b29b      	uxth	r3, r3
 8007c52:	430b      	orrs	r3, r1
 8007c54:	8003      	strh	r3, [r0, #0]
 8007c56:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 8007c5a:	4b04      	ldr	r3, [pc, #16]	; (8007c6c <InitClear_Timer+0x3c>)
 8007c5c:	605a      	str	r2, [r3, #4]
	
	NVIC_EnableIRQ(TIM6_DAC_IRQn);	
	TIM_ITConfig(TIM6, TIM_IT_Update, ENABLE);
 8007c5e:	460a      	mov	r2, r1
 8007c60:	f7fe fdbf 	bl	80067e2 <TIM_ITConfig>
 8007c64:	bd08      	pop	{r3, pc}
 8007c66:	bf00      	nop
 8007c68:	40001000 	.word	0x40001000
 8007c6c:	e000e100 	.word	0xe000e100

08007c70 <EXTI1_IRQHandler>:
};

//STOP KEY-BANANA Interrupt handler
//2 SECTION
void EXTI1_IRQHandler()
{
 8007c70:	b508      	push	{r3, lr}
	//if we are not in wait condition then stop the sequenser
	if ( !(GPIOB->IDR & GPIO_IDR_IDR_1)  && 
 8007c72:	4b13      	ldr	r3, [pc, #76]	; (8007cc0 <EXTI1_IRQHandler+0x50>)
 8007c74:	691b      	ldr	r3, [r3, #16]
 8007c76:	f013 0f02 	tst.w	r3, #2
 8007c7a:	d11c      	bne.n	8007cb6 <EXTI1_IRQHandler+0x46>
		(gSequencerMode_2 != SEQUENCER_MODE_WAIT && gSequencerMode_2 != SEQUENCER_MODE_WAIT_HI_Z && gSequencerMode_2 != SEQUENCER_MODE_STAY_HI_Z)
 8007c7c:	4b11      	ldr	r3, [pc, #68]	; (8007cc4 <EXTI1_IRQHandler+0x54>)
 8007c7e:	78db      	ldrb	r3, [r3, #3]
 8007c80:	b2db      	uxtb	r3, r3
	if ( !(GPIOB->IDR & GPIO_IDR_IDR_1)  && 
 8007c82:	2b01      	cmp	r3, #1
 8007c84:	d017      	beq.n	8007cb6 <EXTI1_IRQHandler+0x46>
		(gSequencerMode_2 != SEQUENCER_MODE_WAIT && gSequencerMode_2 != SEQUENCER_MODE_WAIT_HI_Z && gSequencerMode_2 != SEQUENCER_MODE_STAY_HI_Z)
 8007c86:	4b0f      	ldr	r3, [pc, #60]	; (8007cc4 <EXTI1_IRQHandler+0x54>)
 8007c88:	78db      	ldrb	r3, [r3, #3]
 8007c8a:	b2db      	uxtb	r3, r3
 8007c8c:	2b04      	cmp	r3, #4
 8007c8e:	d012      	beq.n	8007cb6 <EXTI1_IRQHandler+0x46>
 8007c90:	4b0c      	ldr	r3, [pc, #48]	; (8007cc4 <EXTI1_IRQHandler+0x54>)
 8007c92:	78db      	ldrb	r3, [r3, #3]
 8007c94:	b2db      	uxtb	r3, r3
 8007c96:	2b05      	cmp	r3, #5
 8007c98:	d00d      	beq.n	8007cb6 <EXTI1_IRQHandler+0x46>
	) {
		gPrevSequencerMode_2 = SEQUENCER_MODE_RUN;
 8007c9a:	4b0a      	ldr	r3, [pc, #40]	; (8007cc4 <EXTI1_IRQHandler+0x54>)
 8007c9c:	2200      	movs	r2, #0
 8007c9e:	711a      	strb	r2, [r3, #4]
		gSequencerMode_2 = SEQUENCER_MODE_STOP;	
 8007ca0:	2202      	movs	r2, #2
 8007ca2:	70da      	strb	r2, [r3, #3]
		
		//Update both
		DisplayUpdateFlags.b.MainDisplay = 1;
 8007ca4:	4b08      	ldr	r3, [pc, #32]	; (8007cc8 <EXTI1_IRQHandler+0x58>)
 8007ca6:	781a      	ldrb	r2, [r3, #0]
 8007ca8:	f042 0201 	orr.w	r2, r2, #1
 8007cac:	701a      	strb	r2, [r3, #0]
		DisplayUpdateFlags.b.StepsDisplay = 1;
 8007cae:	781a      	ldrb	r2, [r3, #0]
 8007cb0:	f042 0202 	orr.w	r2, r2, #2
 8007cb4:	701a      	strb	r2, [r3, #0]
	};
	
	EXTI_ClearITPendingBit(EXTI_Line1);
 8007cb6:	2002      	movs	r0, #2
 8007cb8:	f7fb f8de 	bl	8002e78 <EXTI_ClearITPendingBit>
 8007cbc:	bd08      	pop	{r3, pc}
 8007cbe:	bf00      	nop
 8007cc0:	40020400 	.word	0x40020400
 8007cc4:	200006b4 	.word	0x200006b4
 8007cc8:	20000708 	.word	0x20000708

08007ccc <SaveSequence>:

/*
	Save current sequence to memory
*/
unsigned char SaveSequence(unsigned char SequenceCell)
{	
 8007ccc:	b570      	push	{r4, r5, r6, lr}
 8007cce:	4604      	mov	r4, r0
	ADCPause();
 8007cd0:	f7ff febc 	bl	8007a4c <ADCPause>
	if(!Is_Expander_Present())
 8007cd4:	f7ff fcfa 	bl	80076cc <Is_Expander_Present>
 8007cd8:	b1b0      	cbz	r0, 8007d08 <SaveSequence+0x3c>
		CAT25512_write_block(bank*SequenceCell*sizeof(Steps), (unsigned char *) Steps[0], sizeof(Steps[0]));
		CAT25512_write_block(bank*SequenceCell*sizeof(Steps)+sizeof(Steps[0]), (unsigned char *) Steps[1], sizeof(Steps[1]));
	}
	else
	{
		CAT25512_write_block((SequenceCell+32)*sizeof(Steps), (unsigned char *) Steps[0], sizeof(Steps[0]));
 8007cda:	3420      	adds	r4, #32
 8007cdc:	0264      	lsls	r4, r4, #9
 8007cde:	b2a4      	uxth	r4, r4
 8007ce0:	4d17      	ldr	r5, [pc, #92]	; (8007d40 <SaveSequence+0x74>)
 8007ce2:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007ce6:	4629      	mov	r1, r5
 8007ce8:	4620      	mov	r0, r4
 8007cea:	f7ff fa2f 	bl	800714c <CAT25512_write_block>
		CAT25512_write_block((SequenceCell+32)*sizeof(Steps)+sizeof(Steps[0]), (unsigned char *) Steps[1], sizeof(Steps[1]));		
 8007cee:	f504 7080 	add.w	r0, r4, #256	; 0x100
 8007cf2:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007cf6:	18a9      	adds	r1, r5, r2
 8007cf8:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
 8007cfc:	f7ff fa26 	bl	800714c <CAT25512_write_block>
	}
	mADC_init();
 8007d00:	f7ff fdf6 	bl	80078f0 <mADC_init>
	return 0;
};
 8007d04:	2000      	movs	r0, #0
 8007d06:	bd70      	pop	{r4, r5, r6, pc}
		CAT25512_write_block(bank*SequenceCell*sizeof(Steps), (unsigned char *) Steps[0], sizeof(Steps[0]));
 8007d08:	4e0e      	ldr	r6, [pc, #56]	; (8007d44 <SaveSequence+0x78>)
 8007d0a:	7830      	ldrb	r0, [r6, #0]
 8007d0c:	b2a4      	uxth	r4, r4
 8007d0e:	4d0c      	ldr	r5, [pc, #48]	; (8007d40 <SaveSequence+0x74>)
 8007d10:	fb00 f004 	mul.w	r0, r0, r4
 8007d14:	0240      	lsls	r0, r0, #9
 8007d16:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007d1a:	4629      	mov	r1, r5
 8007d1c:	f400 407e 	and.w	r0, r0, #65024	; 0xfe00
 8007d20:	f7ff fa14 	bl	800714c <CAT25512_write_block>
		CAT25512_write_block(bank*SequenceCell*sizeof(Steps)+sizeof(Steps[0]), (unsigned char *) Steps[1], sizeof(Steps[1]));
 8007d24:	7830      	ldrb	r0, [r6, #0]
 8007d26:	fb00 f004 	mul.w	r0, r0, r4
 8007d2a:	0240      	lsls	r0, r0, #9
 8007d2c:	f500 7080 	add.w	r0, r0, #256	; 0x100
 8007d30:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007d34:	18a9      	adds	r1, r5, r2
 8007d36:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
 8007d3a:	f7ff fa07 	bl	800714c <CAT25512_write_block>
 8007d3e:	e7df      	b.n	8007d00 <SaveSequence+0x34>
 8007d40:	20000cb4 	.word	0x20000cb4
 8007d44:	20000258 	.word	0x20000258

08007d48 <LoadSequence>:

//Load a sequence from cell number SequenceCell
void LoadSequence(unsigned char SequenceCell)
{
 8007d48:	b570      	push	{r4, r5, r6, lr}
 8007d4a:	4604      	mov	r4, r0
	unsigned char cnt;

	ADCPause();
 8007d4c:	f7ff fe7e 	bl	8007a4c <ADCPause>
	if(!Is_Expander_Present())
 8007d50:	f7ff fcbc 	bl	80076cc <Is_Expander_Present>
 8007d54:	bb30      	cbnz	r0, 8007da4 <LoadSequence+0x5c>
	{
		CAT25512_read_block(bank*SequenceCell*sizeof(Steps), (unsigned char *) Steps[0], sizeof(Steps[0]));
 8007d56:	4e38      	ldr	r6, [pc, #224]	; (8007e38 <LoadSequence+0xf0>)
 8007d58:	7830      	ldrb	r0, [r6, #0]
 8007d5a:	b2a4      	uxth	r4, r4
 8007d5c:	4d37      	ldr	r5, [pc, #220]	; (8007e3c <LoadSequence+0xf4>)
 8007d5e:	fb00 f004 	mul.w	r0, r0, r4
 8007d62:	0240      	lsls	r0, r0, #9
 8007d64:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007d68:	4629      	mov	r1, r5
 8007d6a:	f400 407e 	and.w	r0, r0, #65024	; 0xfe00
 8007d6e:	f7ff fa51 	bl	8007214 <CAT25512_read_block>
		CAT25512_read_block(bank*SequenceCell*sizeof(Steps)+sizeof(Steps[0]), (unsigned char *) Steps[1], sizeof(Steps[1]));
 8007d72:	7830      	ldrb	r0, [r6, #0]
 8007d74:	fb00 f004 	mul.w	r0, r0, r4
 8007d78:	0240      	lsls	r0, r0, #9
 8007d7a:	f500 7080 	add.w	r0, r0, #256	; 0x100
 8007d7e:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007d82:	18a9      	adds	r1, r5, r2
 8007d84:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
 8007d88:	f7ff fa44 	bl	8007214 <CAT25512_read_block>
		CAT25512_read_block((SequenceCell+32)*sizeof(Steps), (unsigned char *) Steps[0], sizeof(Steps[0]));
		CAT25512_read_block((SequenceCell+32)*sizeof(Steps)+sizeof(Steps[0]), (unsigned char *) Steps[1], sizeof(Steps[1]));
	}
	
	//Block sliders scanning while voltages from slider and preset aren't equal
	if (gDipConfig.b.SAVE_V_LEVEL == 1) {
 8007d8c:	4b2c      	ldr	r3, [pc, #176]	; (8007e40 <LoadSequence+0xf8>)
 8007d8e:	781b      	ldrb	r3, [r3, #0]
 8007d90:	f013 0f04 	tst.w	r3, #4
 8007d94:	d14e      	bne.n	8007e34 <LoadSequence+0xec>
			Steps[1][cnt+16].b.WaitVoltageSlider = 1;
			Steps[1][cnt+16].b.WaitTimeSlider = 1;				
		};		
	};
	
	gSequencerMode_1 = SEQUENCER_MODE_STOP;
 8007d96:	4b2b      	ldr	r3, [pc, #172]	; (8007e44 <LoadSequence+0xfc>)
 8007d98:	2202      	movs	r2, #2
 8007d9a:	705a      	strb	r2, [r3, #1]
	gSequencerMode_2 = SEQUENCER_MODE_STOP;
 8007d9c:	70da      	strb	r2, [r3, #3]
	
	mADC_init();
 8007d9e:	f7ff fda7 	bl	80078f0 <mADC_init>
 8007da2:	bd70      	pop	{r4, r5, r6, pc}
		CAT25512_read_block((SequenceCell+32)*sizeof(Steps), (unsigned char *) Steps[0], sizeof(Steps[0]));
 8007da4:	3420      	adds	r4, #32
 8007da6:	0264      	lsls	r4, r4, #9
 8007da8:	b2a4      	uxth	r4, r4
 8007daa:	4d24      	ldr	r5, [pc, #144]	; (8007e3c <LoadSequence+0xf4>)
 8007dac:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007db0:	4629      	mov	r1, r5
 8007db2:	4620      	mov	r0, r4
 8007db4:	f7ff fa2e 	bl	8007214 <CAT25512_read_block>
		CAT25512_read_block((SequenceCell+32)*sizeof(Steps)+sizeof(Steps[0]), (unsigned char *) Steps[1], sizeof(Steps[1]));
 8007db8:	f504 7080 	add.w	r0, r4, #256	; 0x100
 8007dbc:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007dc0:	18a9      	adds	r1, r5, r2
 8007dc2:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
 8007dc6:	f7ff fa25 	bl	8007214 <CAT25512_read_block>
 8007dca:	e7df      	b.n	8007d8c <LoadSequence+0x44>
			Steps[0][cnt].b.WaitVoltageSlider = 1;
 8007dcc:	4b1b      	ldr	r3, [pc, #108]	; (8007e3c <LoadSequence+0xf4>)
 8007dce:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
 8007dd2:	6848      	ldr	r0, [r1, #4]
 8007dd4:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
 8007dd8:	6048      	str	r0, [r1, #4]
			Steps[0][cnt].b.WaitTimeSlider = 1;
 8007dda:	6848      	ldr	r0, [r1, #4]
 8007ddc:	f440 4080 	orr.w	r0, r0, #16384	; 0x4000
 8007de0:	6048      	str	r0, [r1, #4]
			Steps[1][cnt].b.WaitVoltageSlider = 1;
 8007de2:	f102 0120 	add.w	r1, r2, #32
 8007de6:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8007dea:	6848      	ldr	r0, [r1, #4]
 8007dec:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
 8007df0:	6048      	str	r0, [r1, #4]
			Steps[1][cnt].b.WaitTimeSlider = 1;	
 8007df2:	6848      	ldr	r0, [r1, #4]
 8007df4:	f440 4080 	orr.w	r0, r0, #16384	; 0x4000
 8007df8:	6048      	str	r0, [r1, #4]
			Steps[0][cnt+16].b.WaitVoltageSlider = 1;
 8007dfa:	f102 0110 	add.w	r1, r2, #16
 8007dfe:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8007e02:	6848      	ldr	r0, [r1, #4]
 8007e04:	f440 5000 	orr.w	r0, r0, #8192	; 0x2000
 8007e08:	6048      	str	r0, [r1, #4]
			Steps[0][cnt+16].b.WaitTimeSlider = 1;
 8007e0a:	6848      	ldr	r0, [r1, #4]
 8007e0c:	f440 4080 	orr.w	r0, r0, #16384	; 0x4000
 8007e10:	6048      	str	r0, [r1, #4]
			Steps[1][cnt+16].b.WaitVoltageSlider = 1;
 8007e12:	f102 0130 	add.w	r1, r2, #48	; 0x30
 8007e16:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8007e1a:	6859      	ldr	r1, [r3, #4]
 8007e1c:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8007e20:	6059      	str	r1, [r3, #4]
			Steps[1][cnt+16].b.WaitTimeSlider = 1;				
 8007e22:	6859      	ldr	r1, [r3, #4]
 8007e24:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8007e28:	6059      	str	r1, [r3, #4]
		for(cnt=0; cnt<16; cnt++)
 8007e2a:	3201      	adds	r2, #1
 8007e2c:	b2d2      	uxtb	r2, r2
 8007e2e:	2a0f      	cmp	r2, #15
 8007e30:	d9cc      	bls.n	8007dcc <LoadSequence+0x84>
 8007e32:	e7b0      	b.n	8007d96 <LoadSequence+0x4e>
 8007e34:	2200      	movs	r2, #0
 8007e36:	e7fa      	b.n	8007e2e <LoadSequence+0xe6>
 8007e38:	20000258 	.word	0x20000258
 8007e3c:	20000cb4 	.word	0x20000cb4
 8007e40:	20000700 	.word	0x20000700
 8007e44:	200006b4 	.word	0x200006b4

08007e48 <GetStepWidth>:
	Returns the duration of step number _StepNum in section _Section
*/
	#define EXT_VOLTAGE_STEP_SELECT	1023

unsigned long int GetStepWidth(unsigned char _Section, unsigned char _StepNum)
{
 8007e48:	b410      	push	{r4}
 8007e4a:	b083      	sub	sp, #12
	unsigned long int ret_val = 0;
	unsigned long int time_level = 0;
	unsigned char ext_ban_num = 0;

	if (Steps[_Section][_StepNum].b.TimeSource) {
 8007e4c:	eb01 1240 	add.w	r2, r1, r0, lsl #5
 8007e50:	4b57      	ldr	r3, [pc, #348]	; (8007fb0 <GetStepWidth+0x168>)
 8007e52:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8007e56:	685b      	ldr	r3, [r3, #4]
 8007e58:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8007e5c:	d051      	beq.n	8007f02 <GetStepWidth+0xba>
		
		//Step time is set externally
		ext_ban_num = Steps[_Section][_StepNum].b.TLevel/EXT_VOLTAGE_STEP_SELECT;
 8007e5e:	4613      	mov	r3, r2
 8007e60:	4a53      	ldr	r2, [pc, #332]	; (8007fb0 <GetStepWidth+0x168>)
 8007e62:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8007e66:	f342 320b 	sbfx	r2, r2, #12, #12
 8007e6a:	4b52      	ldr	r3, [pc, #328]	; (8007fb4 <GetStepWidth+0x16c>)
 8007e6c:	fb83 4302 	smull	r4, r3, r3, r2
 8007e70:	189c      	adds	r4, r3, r2
 8007e72:	17d3      	asrs	r3, r2, #31
 8007e74:	ebc3 2364 	rsb	r3, r3, r4, asr #9
 8007e78:	b2db      	uxtb	r3, r3
		if(ext_ban_num > 3) ext_ban_num = 3;
 8007e7a:	2b03      	cmp	r3, #3
 8007e7c:	d900      	bls.n	8007e80 <GetStepWidth+0x38>
 8007e7e:	2303      	movs	r3, #3
		
		time_level = AddData[ext_ban_num]*(4095.0f/((float)CalConstants[ext_ban_num]));
 8007e80:	4a4d      	ldr	r2, [pc, #308]	; (8007fb8 <GetStepWidth+0x170>)
 8007e82:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8007e86:	ee07 2a90 	vmov	s15, r2
 8007e8a:	4a4c      	ldr	r2, [pc, #304]	; (8007fbc <GetStepWidth+0x174>)
 8007e8c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8007e90:	ed93 7a01 	vldr	s14, [r3, #4]
 8007e94:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8007e98:	ed9f 6a49 	vldr	s12, [pc, #292]	; 8007fc0 <GetStepWidth+0x178>
 8007e9c:	eec6 6a07 	vdiv.f32	s13, s12, s14
 8007ea0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8007ea4:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8007ea8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	} else {
		//Step time is set on panel
		time_level = (Steps[_Section][_StepNum].b.TLevel + 1);
	};
	
	if (Steps[_Section][_StepNum].b.TimeRange_p03 == 1) {
 8007eac:	eb01 1340 	add.w	r3, r1, r0, lsl #5
 8007eb0:	4a3f      	ldr	r2, [pc, #252]	; (8007fb0 <GetStepWidth+0x168>)
 8007eb2:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8007eb6:	685b      	ldr	r3, [r3, #4]
 8007eb8:	f013 0f40 	tst.w	r3, #64	; 0x40
 8007ebc:	d12c      	bne.n	8007f18 <GetStepWidth+0xd0>
	unsigned long int ret_val = 0;
 8007ebe:	2300      	movs	r3, #0
 8007ec0:	9301      	str	r3, [sp, #4]
		ret_val = (unsigned long int) ((((float) time_level * 112)/4095) +8);
	};
	
	if (Steps[_Section][_StepNum].b.TimeRange_p3 == 1) {
 8007ec2:	eb01 1340 	add.w	r3, r1, r0, lsl #5
 8007ec6:	4a3a      	ldr	r2, [pc, #232]	; (8007fb0 <GetStepWidth+0x168>)
 8007ec8:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8007ecc:	685b      	ldr	r3, [r3, #4]
 8007ece:	f013 0f80 	tst.w	r3, #128	; 0x80
 8007ed2:	d134      	bne.n	8007f3e <GetStepWidth+0xf6>
		ret_val = (unsigned long int) ((((float) time_level * 1120)/4095) +80);
	};
	
	if (Steps[_Section][_StepNum].b.TimeRange_3 == 1) {
 8007ed4:	eb01 1340 	add.w	r3, r1, r0, lsl #5
 8007ed8:	4a35      	ldr	r2, [pc, #212]	; (8007fb0 <GetStepWidth+0x168>)
 8007eda:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8007ede:	685b      	ldr	r3, [r3, #4]
 8007ee0:	f413 7f80 	tst.w	r3, #256	; 0x100
 8007ee4:	d13e      	bne.n	8007f64 <GetStepWidth+0x11c>
		ret_val = (unsigned long int) ((((float) time_level * 11200)/4095) +800);
	};
	
	if (Steps[_Section][_StepNum].b.TimeRange_30 == 1) {
 8007ee6:	eb01 1140 	add.w	r1, r1, r0, lsl #5
 8007eea:	4831      	ldr	r0, [pc, #196]	; (8007fb0 <GetStepWidth+0x168>)
 8007eec:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
 8007ef0:	684b      	ldr	r3, [r1, #4]
 8007ef2:	f413 7f00 	tst.w	r3, #512	; 0x200
 8007ef6:	d148      	bne.n	8007f8a <GetStepWidth+0x142>
		ret_val = (unsigned long int) ((((float) time_level * 112000)/4095) +8000);
	};
	
	return ret_val;
};
 8007ef8:	9801      	ldr	r0, [sp, #4]
 8007efa:	b003      	add	sp, #12
 8007efc:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007f00:	4770      	bx	lr
		time_level = (Steps[_Section][_StepNum].b.TLevel + 1);
 8007f02:	eb01 1340 	add.w	r3, r1, r0, lsl #5
 8007f06:	4a2a      	ldr	r2, [pc, #168]	; (8007fb0 <GetStepWidth+0x168>)
 8007f08:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8007f0c:	f343 330b 	sbfx	r3, r3, #12, #12
 8007f10:	3301      	adds	r3, #1
 8007f12:	ee07 3a90 	vmov	s15, r3
 8007f16:	e7c9      	b.n	8007eac <GetStepWidth+0x64>
		ret_val = (unsigned long int) ((((float) time_level * 112)/4095) +8);
 8007f18:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8007f1c:	ed9f 7a29 	vldr	s14, [pc, #164]	; 8007fc4 <GetStepWidth+0x17c>
 8007f20:	ee66 6a87 	vmul.f32	s13, s13, s14
 8007f24:	ed9f 6a26 	vldr	s12, [pc, #152]	; 8007fc0 <GetStepWidth+0x178>
 8007f28:	ee86 7a86 	vdiv.f32	s14, s13, s12
 8007f2c:	eef2 6a00 	vmov.f32	s13, #32	; 0x41000000  8.0
 8007f30:	ee37 7a26 	vadd.f32	s14, s14, s13
 8007f34:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 8007f38:	ed8d 7a01 	vstr	s14, [sp, #4]
 8007f3c:	e7c1      	b.n	8007ec2 <GetStepWidth+0x7a>
		ret_val = (unsigned long int) ((((float) time_level * 1120)/4095) +80);
 8007f3e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8007f42:	ed9f 7a21 	vldr	s14, [pc, #132]	; 8007fc8 <GetStepWidth+0x180>
 8007f46:	ee66 6a87 	vmul.f32	s13, s13, s14
 8007f4a:	ed9f 6a1d 	vldr	s12, [pc, #116]	; 8007fc0 <GetStepWidth+0x178>
 8007f4e:	ee86 7a86 	vdiv.f32	s14, s13, s12
 8007f52:	eddf 6a1e 	vldr	s13, [pc, #120]	; 8007fcc <GetStepWidth+0x184>
 8007f56:	ee37 7a26 	vadd.f32	s14, s14, s13
 8007f5a:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 8007f5e:	ed8d 7a01 	vstr	s14, [sp, #4]
 8007f62:	e7b7      	b.n	8007ed4 <GetStepWidth+0x8c>
		ret_val = (unsigned long int) ((((float) time_level * 11200)/4095) +800);
 8007f64:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8007f68:	ed9f 7a19 	vldr	s14, [pc, #100]	; 8007fd0 <GetStepWidth+0x188>
 8007f6c:	ee66 6a87 	vmul.f32	s13, s13, s14
 8007f70:	ed9f 6a13 	vldr	s12, [pc, #76]	; 8007fc0 <GetStepWidth+0x178>
 8007f74:	ee86 7a86 	vdiv.f32	s14, s13, s12
 8007f78:	eddf 6a16 	vldr	s13, [pc, #88]	; 8007fd4 <GetStepWidth+0x18c>
 8007f7c:	ee37 7a26 	vadd.f32	s14, s14, s13
 8007f80:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 8007f84:	ed8d 7a01 	vstr	s14, [sp, #4]
 8007f88:	e7ad      	b.n	8007ee6 <GetStepWidth+0x9e>
		ret_val = (unsigned long int) ((((float) time_level * 112000)/4095) +8000);
 8007f8a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8007f8e:	ed9f 7a12 	vldr	s14, [pc, #72]	; 8007fd8 <GetStepWidth+0x190>
 8007f92:	ee67 7a87 	vmul.f32	s15, s15, s14
 8007f96:	eddf 6a0a 	vldr	s13, [pc, #40]	; 8007fc0 <GetStepWidth+0x178>
 8007f9a:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8007f9e:	eddf 7a0f 	vldr	s15, [pc, #60]	; 8007fdc <GetStepWidth+0x194>
 8007fa2:	ee77 7a27 	vadd.f32	s15, s14, s15
 8007fa6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8007faa:	edcd 7a01 	vstr	s15, [sp, #4]
	return ret_val;
 8007fae:	e7a3      	b.n	8007ef8 <GetStepWidth+0xb0>
 8007fb0:	20000cb4 	.word	0x20000cb4
 8007fb4:	80200803 	.word	0x80200803
 8007fb8:	20000c0c 	.word	0x20000c0c
 8007fbc:	20000258 	.word	0x20000258
 8007fc0:	457ff000 	.word	0x457ff000
 8007fc4:	42e00000 	.word	0x42e00000
 8007fc8:	448c0000 	.word	0x448c0000
 8007fcc:	42a00000 	.word	0x42a00000
 8007fd0:	462f0000 	.word	0x462f0000
 8007fd4:	44480000 	.word	0x44480000
 8007fd8:	47dac000 	.word	0x47dac000
 8007fdc:	45fa0000 	.word	0x45fa0000

08007fe0 <GetStepVoltage>:
	#define MAX_DAC_VALUE			0xFFF 	
	#define FULL_RANGE_STEPS	60		
	#define QUANTIZE_DIVIDER	MAX_DAC_VALUE/FULL_RANGE_STEPS 
	
unsigned int GetStepVoltage(unsigned char _Section, unsigned char _StepNum)
{
 8007fe0:	b530      	push	{r4, r5, lr}
	unsigned int ret_val = 0;
	unsigned int voltage_level = 0;
	unsigned char ext_ban_num = 0;

	if (Steps[_Section][_StepNum].b.VoltageSource) {
 8007fe2:	eb01 1240 	add.w	r2, r1, r0, lsl #5
 8007fe6:	4ba1      	ldr	r3, [pc, #644]	; (800826c <GetStepVoltage+0x28c>)
 8007fe8:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007fec:	f013 6f00 	tst.w	r3, #134217728	; 0x8000000
 8007ff0:	d053      	beq.n	800809a <GetStepVoltage+0xba>
		//Step voltage is set externally
		ext_ban_num = Steps[_Section][_StepNum].b.VLevel/EXT_VOLTAGE_STEP_SELECT;
 8007ff2:	4613      	mov	r3, r2
 8007ff4:	4a9d      	ldr	r2, [pc, #628]	; (800826c <GetStepVoltage+0x28c>)
 8007ff6:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 8007ffa:	f342 020b 	sbfx	r2, r2, #0, #12
 8007ffe:	4b9c      	ldr	r3, [pc, #624]	; (8008270 <GetStepVoltage+0x290>)
 8008000:	fb83 4302 	smull	r4, r3, r3, r2
 8008004:	189c      	adds	r4, r3, r2
 8008006:	17d3      	asrs	r3, r2, #31
 8008008:	ebc3 2364 	rsb	r3, r3, r4, asr #9
 800800c:	b2db      	uxtb	r3, r3
		if(ext_ban_num > 3) ext_ban_num = 3;
 800800e:	2b03      	cmp	r3, #3
 8008010:	d900      	bls.n	8008014 <GetStepVoltage+0x34>
 8008012:	2303      	movs	r3, #3
		
		voltage_level = AddData[ext_ban_num]*(4095.0f/((float)CalConstants[ext_ban_num]));
 8008014:	4a97      	ldr	r2, [pc, #604]	; (8008274 <GetStepVoltage+0x294>)
 8008016:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800801a:	ee07 2a90 	vmov	s15, r2
 800801e:	4a96      	ldr	r2, [pc, #600]	; (8008278 <GetStepVoltage+0x298>)
 8008020:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8008024:	ed93 7a01 	vldr	s14, [r3, #4]
 8008028:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 800802c:	ed9f 6a93 	vldr	s12, [pc, #588]	; 800827c <GetStepVoltage+0x29c>
 8008030:	eec6 6a07 	vdiv.f32	s13, s12, s14
 8008034:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8008038:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800803c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	} else {
		//Step voltage is set on panel
		voltage_level = Steps[_Section][_StepNum].b.VLevel;
	};
	
	if(voltage_level > 4095) voltage_level = 4095;
 8008040:	ee17 3a90 	vmov	r3, s15
 8008044:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8008048:	d301      	bcc.n	800804e <GetStepVoltage+0x6e>
 800804a:	eddf 7a8d 	vldr	s15, [pc, #564]	; 8008280 <GetStepVoltage+0x2a0>

	if (Steps[_Section][_StepNum].b.FullRange) {		
 800804e:	eb01 1340 	add.w	r3, r1, r0, lsl #5
 8008052:	4a86      	ldr	r2, [pc, #536]	; (800826c <GetStepVoltage+0x28c>)
 8008054:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8008058:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
 800805c:	d027      	beq.n	80080ae <GetStepVoltage+0xce>
		ret_val = voltage_level;
		// if quantization mode is on
		if (Steps[_Section][_StepNum].b.Quantize) {
 800805e:	eb01 1340 	add.w	r3, r1, r0, lsl #5
 8008062:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8008066:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
 800806a:	f000 80fb 	beq.w	8008264 <GetStepVoltage+0x284>
		//Calculate the quantized voltage
			ret_val =  (ret_val / (12*divider)) ;
 800806e:	4b85      	ldr	r3, [pc, #532]	; (8008284 <GetStepVoltage+0x2a4>)
 8008070:	ed93 7a00 	vldr	s14, [r3]
 8008074:	eef2 6a08 	vmov.f32	s13, #40	; 0x41400000  12.0
 8008078:	ee67 6a26 	vmul.f32	s13, s14, s13
 800807c:	eeb8 6a67 	vcvt.f32.u32	s12, s15
 8008080:	ee86 7a26 	vdiv.f32	s14, s12, s13
 8008084:	eebc 7ac7 	vcvt.u32.f32	s14, s14
			ret_val = ret_val * (12*divider);
 8008088:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 800808c:	ee27 7a26 	vmul.f32	s14, s14, s13
 8008090:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 8008094:	ee17 3a10 	vmov	r3, s14
 8008098:	e00a      	b.n	80080b0 <GetStepVoltage+0xd0>
		voltage_level = Steps[_Section][_StepNum].b.VLevel;
 800809a:	eb01 1340 	add.w	r3, r1, r0, lsl #5
 800809e:	4a73      	ldr	r2, [pc, #460]	; (800826c <GetStepVoltage+0x28c>)
 80080a0:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 80080a4:	f343 030b 	sbfx	r3, r3, #0, #12
 80080a8:	ee07 3a90 	vmov	s15, r3
 80080ac:	e7c8      	b.n	8008040 <GetStepVoltage+0x60>
	unsigned int ret_val = 0;
 80080ae:	2300      	movs	r3, #0
		};
	};
	
	if (Steps[_Section][_StepNum].b.Voltage0) {	
 80080b0:	eb01 1240 	add.w	r2, r1, r0, lsl #5
 80080b4:	4c6d      	ldr	r4, [pc, #436]	; (800826c <GetStepVoltage+0x28c>)
 80080b6:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
 80080ba:	f012 5f80 	tst.w	r2, #268435456	; 0x10000000
 80080be:	d01f      	beq.n	8008100 <GetStepVoltage+0x120>
		ret_val = (voltage_level/divider);
 80080c0:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 80080c4:	4b6f      	ldr	r3, [pc, #444]	; (8008284 <GetStepVoltage+0x2a4>)
 80080c6:	ed93 6a00 	vldr	s12, [r3]
 80080ca:	eec7 6a06 	vdiv.f32	s13, s14, s12
 80080ce:	eebc 7ae6 	vcvt.u32.f32	s14, s13
 80080d2:	ee17 3a10 	vmov	r3, s14
		if (Steps[_Section][_StepNum].b.Quantize) {
 80080d6:	eb01 1240 	add.w	r2, r1, r0, lsl #5
 80080da:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
 80080de:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
 80080e2:	d00d      	beq.n	8008100 <GetStepVoltage+0x120>

			ret_val =  (ret_val / (offset/12)) ;
 80080e4:	4d68      	ldr	r5, [pc, #416]	; (8008288 <GetStepVoltage+0x2a8>)
 80080e6:	682a      	ldr	r2, [r5, #0]
 80080e8:	4c68      	ldr	r4, [pc, #416]	; (800828c <GetStepVoltage+0x2ac>)
 80080ea:	fba4 e202 	umull	lr, r2, r4, r2
 80080ee:	08d2      	lsrs	r2, r2, #3
 80080f0:	fbb3 f3f2 	udiv	r3, r3, r2
			ret_val = ret_val * (offset/12);
 80080f4:	682a      	ldr	r2, [r5, #0]
 80080f6:	fba4 4202 	umull	r4, r2, r4, r2
 80080fa:	08d2      	lsrs	r2, r2, #3
 80080fc:	fb02 f303 	mul.w	r3, r2, r3
		};
	};
	
	if (Steps[_Section][_StepNum].b.Voltage2) {		
 8008100:	eb01 1240 	add.w	r2, r1, r0, lsl #5
 8008104:	4c59      	ldr	r4, [pc, #356]	; (800826c <GetStepVoltage+0x28c>)
 8008106:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
 800810a:	f012 5f00 	tst.w	r2, #536870912	; 0x20000000
 800810e:	d022      	beq.n	8008156 <GetStepVoltage+0x176>
		ret_val = (voltage_level/divider);
 8008110:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8008114:	4b5b      	ldr	r3, [pc, #364]	; (8008284 <GetStepVoltage+0x2a4>)
 8008116:	ed93 6a00 	vldr	s12, [r3]
 800811a:	ee86 7a86 	vdiv.f32	s14, s13, s12
 800811e:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 8008122:	ee17 3a10 	vmov	r3, s14
		if (Steps[_Section][_StepNum].b.Quantize) {
 8008126:	eb01 1240 	add.w	r2, r1, r0, lsl #5
 800812a:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
 800812e:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
 8008132:	d00d      	beq.n	8008150 <GetStepVoltage+0x170>
			ret_val =  (ret_val / (offset/12)) ;
 8008134:	4a54      	ldr	r2, [pc, #336]	; (8008288 <GetStepVoltage+0x2a8>)
 8008136:	6814      	ldr	r4, [r2, #0]
 8008138:	4d54      	ldr	r5, [pc, #336]	; (800828c <GetStepVoltage+0x2ac>)
 800813a:	fba5 e404 	umull	lr, r4, r5, r4
 800813e:	08e4      	lsrs	r4, r4, #3
 8008140:	fbb3 f3f4 	udiv	r3, r3, r4
			ret_val = ret_val * (offset/12);
 8008144:	6812      	ldr	r2, [r2, #0]
 8008146:	fba5 4202 	umull	r4, r2, r5, r2
 800814a:	08d2      	lsrs	r2, r2, #3
 800814c:	fb02 f303 	mul.w	r3, r2, r3
		};
		ret_val +=offset;
 8008150:	4a4d      	ldr	r2, [pc, #308]	; (8008288 <GetStepVoltage+0x2a8>)
 8008152:	6812      	ldr	r2, [r2, #0]
 8008154:	4413      	add	r3, r2
	};
	
	if (Steps[_Section][_StepNum].b.Voltage4) {		
 8008156:	eb01 1240 	add.w	r2, r1, r0, lsl #5
 800815a:	4c44      	ldr	r4, [pc, #272]	; (800826c <GetStepVoltage+0x28c>)
 800815c:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
 8008160:	f012 4f80 	tst.w	r2, #1073741824	; 0x40000000
 8008164:	d023      	beq.n	80081ae <GetStepVoltage+0x1ce>
		ret_val = (voltage_level/divider);
 8008166:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800816a:	4b46      	ldr	r3, [pc, #280]	; (8008284 <GetStepVoltage+0x2a4>)
 800816c:	ed93 6a00 	vldr	s12, [r3]
 8008170:	ee86 7a86 	vdiv.f32	s14, s13, s12
 8008174:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 8008178:	ee17 3a10 	vmov	r3, s14
		if (Steps[_Section][_StepNum].b.Quantize) {
 800817c:	eb01 1240 	add.w	r2, r1, r0, lsl #5
 8008180:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
 8008184:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
 8008188:	d00d      	beq.n	80081a6 <GetStepVoltage+0x1c6>
			ret_val =  (ret_val / (offset/12)) ;
 800818a:	4a3f      	ldr	r2, [pc, #252]	; (8008288 <GetStepVoltage+0x2a8>)
 800818c:	6814      	ldr	r4, [r2, #0]
 800818e:	4d3f      	ldr	r5, [pc, #252]	; (800828c <GetStepVoltage+0x2ac>)
 8008190:	fba5 e404 	umull	lr, r4, r5, r4
 8008194:	08e4      	lsrs	r4, r4, #3
 8008196:	fbb3 f3f4 	udiv	r3, r3, r4
			ret_val = ret_val * (offset/12);
 800819a:	6812      	ldr	r2, [r2, #0]
 800819c:	fba5 4202 	umull	r4, r2, r5, r2
 80081a0:	08d2      	lsrs	r2, r2, #3
 80081a2:	fb02 f303 	mul.w	r3, r2, r3
		};
		ret_val +=offset*2;
 80081a6:	4a38      	ldr	r2, [pc, #224]	; (8008288 <GetStepVoltage+0x2a8>)
 80081a8:	6812      	ldr	r2, [r2, #0]
 80081aa:	eb03 0342 	add.w	r3, r3, r2, lsl #1
	};
	
	if (Steps[_Section][_StepNum].b.Voltage6) {		
 80081ae:	eb01 1240 	add.w	r2, r1, r0, lsl #5
 80081b2:	4c2e      	ldr	r4, [pc, #184]	; (800826c <GetStepVoltage+0x28c>)
 80081b4:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
 80081b8:	2a00      	cmp	r2, #0
 80081ba:	da24      	bge.n	8008206 <GetStepVoltage+0x226>
		ret_val = (voltage_level/divider);
 80081bc:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80081c0:	4b30      	ldr	r3, [pc, #192]	; (8008284 <GetStepVoltage+0x2a4>)
 80081c2:	ed93 6a00 	vldr	s12, [r3]
 80081c6:	ee86 7a86 	vdiv.f32	s14, s13, s12
 80081ca:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 80081ce:	ee17 3a10 	vmov	r3, s14
		if (Steps[_Section][_StepNum].b.Quantize) {
 80081d2:	eb01 1240 	add.w	r2, r1, r0, lsl #5
 80081d6:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
 80081da:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
 80081de:	d00d      	beq.n	80081fc <GetStepVoltage+0x21c>
			ret_val =  (ret_val / (offset/12)) ;
 80081e0:	4a29      	ldr	r2, [pc, #164]	; (8008288 <GetStepVoltage+0x2a8>)
 80081e2:	6814      	ldr	r4, [r2, #0]
 80081e4:	4d29      	ldr	r5, [pc, #164]	; (800828c <GetStepVoltage+0x2ac>)
 80081e6:	fba5 e404 	umull	lr, r4, r5, r4
 80081ea:	08e4      	lsrs	r4, r4, #3
 80081ec:	fbb3 f3f4 	udiv	r3, r3, r4
			ret_val = ret_val * (offset/12);
 80081f0:	6812      	ldr	r2, [r2, #0]
 80081f2:	fba5 4202 	umull	r4, r2, r5, r2
 80081f6:	08d2      	lsrs	r2, r2, #3
 80081f8:	fb02 f303 	mul.w	r3, r2, r3
		};
		ret_val +=offset*3;
 80081fc:	4a22      	ldr	r2, [pc, #136]	; (8008288 <GetStepVoltage+0x2a8>)
 80081fe:	6812      	ldr	r2, [r2, #0]
 8008200:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8008204:	4413      	add	r3, r2
	};
	
	if (Steps[_Section][_StepNum].b.Voltage8) {		
 8008206:	eb01 1240 	add.w	r2, r1, r0, lsl #5
 800820a:	4c18      	ldr	r4, [pc, #96]	; (800826c <GetStepVoltage+0x28c>)
 800820c:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8008210:	6852      	ldr	r2, [r2, #4]
 8008212:	f012 0f01 	tst.w	r2, #1
 8008216:	d023      	beq.n	8008260 <GetStepVoltage+0x280>
		ret_val = (voltage_level/divider);
 8008218:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800821c:	4b19      	ldr	r3, [pc, #100]	; (8008284 <GetStepVoltage+0x2a4>)
 800821e:	edd3 6a00 	vldr	s13, [r3]
 8008222:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8008226:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 800822a:	ee17 3a90 	vmov	r3, s15
		if (Steps[_Section][_StepNum].b.Quantize) {
 800822e:	eb01 1140 	add.w	r1, r1, r0, lsl #5
 8008232:	f854 2031 	ldr.w	r2, [r4, r1, lsl #3]
 8008236:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
 800823a:	d00d      	beq.n	8008258 <GetStepVoltage+0x278>
			ret_val =  (ret_val / (offset/12)) ;
 800823c:	4812      	ldr	r0, [pc, #72]	; (8008288 <GetStepVoltage+0x2a8>)
 800823e:	6802      	ldr	r2, [r0, #0]
 8008240:	4912      	ldr	r1, [pc, #72]	; (800828c <GetStepVoltage+0x2ac>)
 8008242:	fba1 4202 	umull	r4, r2, r1, r2
 8008246:	08d2      	lsrs	r2, r2, #3
 8008248:	fbb3 f3f2 	udiv	r3, r3, r2
			ret_val = ret_val * (offset/12);
 800824c:	6800      	ldr	r0, [r0, #0]
 800824e:	fba1 2000 	umull	r2, r0, r1, r0
 8008252:	08c0      	lsrs	r0, r0, #3
 8008254:	fb00 f303 	mul.w	r3, r0, r3
		};
		ret_val +=offset*4;
 8008258:	4a0b      	ldr	r2, [pc, #44]	; (8008288 <GetStepVoltage+0x2a8>)
 800825a:	6810      	ldr	r0, [r2, #0]
 800825c:	eb03 0380 	add.w	r3, r3, r0, lsl #2
	};

	return ret_val;
};
 8008260:	4618      	mov	r0, r3
 8008262:	bd30      	pop	{r4, r5, pc}
		ret_val = voltage_level;
 8008264:	ee17 3a90 	vmov	r3, s15
 8008268:	e722      	b.n	80080b0 <GetStepVoltage+0xd0>
 800826a:	bf00      	nop
 800826c:	20000cb4 	.word	0x20000cb4
 8008270:	80200803 	.word	0x80200803
 8008274:	20000c0c 	.word	0x20000c0c
 8008278:	20000258 	.word	0x20000258
 800827c:	457ff000 	.word	0x457ff000
 8008280:	00000fff 	.word	0x00000fff
 8008284:	20000cac 	.word	0x20000cac
 8008288:	20000cb0 	.word	0x20000cb0
 800828c:	aaaaaaab 	.word	0xaaaaaaab

08008290 <GetNextStep>:
/*
	Calculate the number of next step
	_StepNum - current step number in section _Section
*/
unsigned char GetNextStep(unsigned char _Section, unsigned char _StepNum)
{
 8008290:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008292:	4604      	mov	r4, r0
 8008294:	460d      	mov	r5, r1
	unsigned char ret_val = 0;
	unsigned char isLastStage = 0;
	unsigned char tmp=0;
	unsigned char max_step;

	if(Is_Expander_Present()) max_step = 31;
 8008296:	f7ff fa19 	bl	80076cc <Is_Expander_Present>
 800829a:	b918      	cbnz	r0, 80082a4 <GetNextStep+0x14>
	else 
	{
		max_step = 15;
		if(_StepNum > 15) return 0;
 800829c:	2d0f      	cmp	r5, #15
 800829e:	d842      	bhi.n	8008326 <GetNextStep+0x96>
		max_step = 15;
 80082a0:	210f      	movs	r1, #15
 80082a2:	e000      	b.n	80082a6 <GetNextStep+0x16>
	if(Is_Expander_Present()) max_step = 31;
 80082a4:	211f      	movs	r1, #31
	}
	
	isLastStage = Steps[_Section][_StepNum].b.CycleLast;
 80082a6:	4626      	mov	r6, r4
 80082a8:	462f      	mov	r7, r5
 80082aa:	eb05 1444 	add.w	r4, r5, r4, lsl #5
 80082ae:	4b20      	ldr	r3, [pc, #128]	; (8008330 <GetNextStep+0xa0>)
 80082b0:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
 80082b4:	6860      	ldr	r0, [r4, #4]
 80082b6:	f3c0 1040 	ubfx	r0, r0, #5, #1
	
	if (isLastStage != 0) {      
 80082ba:	bb78      	cbnz	r0, 800831c <GetNextStep+0x8c>
	isLastStage = Steps[_Section][_StepNum].b.CycleLast;
 80082bc:	4602      	mov	r2, r0
			  isLastStage = 0;
			};
		};
    } 

    if (isLastStage == 0) {		
 80082be:	bbaa      	cbnz	r2, 800832c <GetNextStep+0x9c>
		if ( _StepNum >= max_step ) {
 80082c0:	42a9      	cmp	r1, r5
 80082c2:	d932      	bls.n	800832a <GetNextStep+0x9a>
			ret_val = 0;
		} else {
			ret_val = _StepNum+1;
 80082c4:	1c68      	adds	r0, r5, #1
 80082c6:	b2c0      	uxtb	r0, r0
 80082c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			  if (Steps[_Section][max_step-(tmp-_StepNum)].b.CycleFirst) {
 80082ca:	1bda      	subs	r2, r3, r7
 80082cc:	1a8a      	subs	r2, r1, r2
 80082ce:	eb02 1246 	add.w	r2, r2, r6, lsl #5
 80082d2:	4c17      	ldr	r4, [pc, #92]	; (8008330 <GetNextStep+0xa0>)
 80082d4:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 80082d8:	6852      	ldr	r2, [r2, #4]
 80082da:	f012 0f10 	tst.w	r2, #16
 80082de:	d115      	bne.n	800830c <GetNextStep+0x7c>
			if (tmp == max_step) {
 80082e0:	428b      	cmp	r3, r1
 80082e2:	d019      	beq.n	8008318 <GetNextStep+0x88>
		for(tmp = 0; tmp <= max_step; tmp++)
 80082e4:	3301      	adds	r3, #1
 80082e6:	b2db      	uxtb	r3, r3
 80082e8:	428b      	cmp	r3, r1
 80082ea:	d819      	bhi.n	8008320 <GetNextStep+0x90>
			if (tmp<=_StepNum) {
 80082ec:	42ab      	cmp	r3, r5
 80082ee:	d8ec      	bhi.n	80082ca <GetNextStep+0x3a>
			  if (Steps[_Section][_StepNum-tmp].b.CycleFirst) {
 80082f0:	1afa      	subs	r2, r7, r3
 80082f2:	eb02 1446 	add.w	r4, r2, r6, lsl #5
 80082f6:	4a0e      	ldr	r2, [pc, #56]	; (8008330 <GetNextStep+0xa0>)
 80082f8:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
 80082fc:	6852      	ldr	r2, [r2, #4]
 80082fe:	f012 0f10 	tst.w	r2, #16
 8008302:	d0ed      	beq.n	80082e0 <GetNextStep+0x50>
			    ret_val = _StepNum-tmp;
 8008304:	1aeb      	subs	r3, r5, r3
			    break;
 8008306:	4602      	mov	r2, r0
			    ret_val = _StepNum-tmp;
 8008308:	b2d8      	uxtb	r0, r3
			    break;
 800830a:	e7d8      	b.n	80082be <GetNextStep+0x2e>
			    ret_val = max_step-(tmp-_StepNum);
 800830c:	1aeb      	subs	r3, r5, r3
 800830e:	fa51 f383 	uxtab	r3, r1, r3
			    break;
 8008312:	4602      	mov	r2, r0
			    ret_val = max_step-(tmp-_StepNum);
 8008314:	b2d8      	uxtb	r0, r3
			    break;
 8008316:	e7d2      	b.n	80082be <GetNextStep+0x2e>
			  isLastStage = 0;
 8008318:	2000      	movs	r0, #0
 800831a:	e7e3      	b.n	80082e4 <GetNextStep+0x54>
 800831c:	2300      	movs	r3, #0
 800831e:	e7e3      	b.n	80082e8 <GetNextStep+0x58>
 8008320:	4602      	mov	r2, r0
	unsigned char ret_val = 0;
 8008322:	2000      	movs	r0, #0
 8008324:	e7cb      	b.n	80082be <GetNextStep+0x2e>
		if(_StepNum > 15) return 0;
 8008326:	2000      	movs	r0, #0
 8008328:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			ret_val = 0;
 800832a:	4610      	mov	r0, r2
		};
	};
	/* ENDOF: Ã�â€¢Ã‘ï¿½Ã�Â»Ã�Â¸ Ã‘Ë†Ã�Â°Ã�Â³ Ã�Â·Ã�Â°Ã�ÂºÃ�Â¾Ã�Â½Ã‘â€¡Ã�Â¸Ã�Â»Ã‘ï¿½Ã‘ï¿½ - Ã�Â¿Ã�ÂµÃ‘â‚¬Ã�ÂµÃ‘â€¦Ã�Â¾Ã�Â´Ã�Â¸Ã�Â¼ Ã�Â½Ã�Â° Ã‘ï¿½Ã�Â»Ã�ÂµÃ�Â´Ã‘Æ’Ã‘Å½Ã‘â€°Ã�Â¸Ã�Â¹ */
	return ret_val;
};
 800832c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800832e:	bf00      	nop
 8008330:	20000cb4 	.word	0x20000cb4

08008334 <EXTI9_5_IRQHandler>:
{
 8008334:	b510      	push	{r4, lr}
	if (EXTI->PR & (1<<8)) {	 
 8008336:	4b7b      	ldr	r3, [pc, #492]	; (8008524 <EXTI9_5_IRQHandler+0x1f0>)
 8008338:	695b      	ldr	r3, [r3, #20]
 800833a:	f413 7f80 	tst.w	r3, #256	; 0x100
 800833e:	d01d      	beq.n	800837c <EXTI9_5_IRQHandler+0x48>
		if((gSequencerMode_1 != SEQUENCER_MODE_STAY_HI_Z && gSequencerMode_1 != SEQUENCER_MODE_WAIT_HI_Z) && (gSequencerMode_1 != SEQUENCER_MODE_WAIT) && (gSequencerMode_1 != SEQUENCER_MODE_RUN))
 8008340:	4b79      	ldr	r3, [pc, #484]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 8008342:	785b      	ldrb	r3, [r3, #1]
 8008344:	b2db      	uxtb	r3, r3
 8008346:	2b05      	cmp	r3, #5
 8008348:	d00e      	beq.n	8008368 <EXTI9_5_IRQHandler+0x34>
 800834a:	4b77      	ldr	r3, [pc, #476]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 800834c:	785b      	ldrb	r3, [r3, #1]
 800834e:	b2db      	uxtb	r3, r3
 8008350:	2b04      	cmp	r3, #4
 8008352:	d009      	beq.n	8008368 <EXTI9_5_IRQHandler+0x34>
 8008354:	4b74      	ldr	r3, [pc, #464]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 8008356:	785b      	ldrb	r3, [r3, #1]
 8008358:	b2db      	uxtb	r3, r3
 800835a:	2b01      	cmp	r3, #1
 800835c:	d004      	beq.n	8008368 <EXTI9_5_IRQHandler+0x34>
 800835e:	4b72      	ldr	r3, [pc, #456]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 8008360:	785b      	ldrb	r3, [r3, #1]
 8008362:	2b00      	cmp	r3, #0
 8008364:	f040 80a6 	bne.w	80084b4 <EXTI9_5_IRQHandler+0x180>
		if(gSequencerMode_1 == SEQUENCER_MODE_WAIT_HI_Z)
 8008368:	4b6f      	ldr	r3, [pc, #444]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 800836a:	785b      	ldrb	r3, [r3, #1]
 800836c:	b2db      	uxtb	r3, r3
 800836e:	2b04      	cmp	r3, #4
 8008370:	f000 80a8 	beq.w	80084c4 <EXTI9_5_IRQHandler+0x190>
		EXTI_ClearITPendingBit(EXTI_Line8);
 8008374:	f44f 7080 	mov.w	r0, #256	; 0x100
 8008378:	f7fa fd7e 	bl	8002e78 <EXTI_ClearITPendingBit>
	 if (EXTI->PR & (1<<6)) {
 800837c:	4b69      	ldr	r3, [pc, #420]	; (8008524 <EXTI9_5_IRQHandler+0x1f0>)
 800837e:	695b      	ldr	r3, [r3, #20]
 8008380:	f013 0f40 	tst.w	r3, #64	; 0x40
 8008384:	d01c      	beq.n	80083c0 <EXTI9_5_IRQHandler+0x8c>
		 if((gSequencerMode_2 != SEQUENCER_MODE_STAY_HI_Z && gSequencerMode_2 != SEQUENCER_MODE_WAIT_HI_Z) && (gSequencerMode_2 != SEQUENCER_MODE_WAIT) && (gSequencerMode_2 != SEQUENCER_MODE_RUN))
 8008386:	4b68      	ldr	r3, [pc, #416]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 8008388:	78db      	ldrb	r3, [r3, #3]
 800838a:	b2db      	uxtb	r3, r3
 800838c:	2b05      	cmp	r3, #5
 800838e:	d00e      	beq.n	80083ae <EXTI9_5_IRQHandler+0x7a>
 8008390:	4b65      	ldr	r3, [pc, #404]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 8008392:	78db      	ldrb	r3, [r3, #3]
 8008394:	b2db      	uxtb	r3, r3
 8008396:	2b04      	cmp	r3, #4
 8008398:	d009      	beq.n	80083ae <EXTI9_5_IRQHandler+0x7a>
 800839a:	4b63      	ldr	r3, [pc, #396]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 800839c:	78db      	ldrb	r3, [r3, #3]
 800839e:	b2db      	uxtb	r3, r3
 80083a0:	2b01      	cmp	r3, #1
 80083a2:	d004      	beq.n	80083ae <EXTI9_5_IRQHandler+0x7a>
 80083a4:	4b60      	ldr	r3, [pc, #384]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 80083a6:	78db      	ldrb	r3, [r3, #3]
 80083a8:	2b00      	cmp	r3, #0
 80083aa:	f040 808e 	bne.w	80084ca <EXTI9_5_IRQHandler+0x196>
		if(gSequencerMode_2 == SEQUENCER_MODE_WAIT_HI_Z)
 80083ae:	4b5e      	ldr	r3, [pc, #376]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 80083b0:	78db      	ldrb	r3, [r3, #3]
 80083b2:	b2db      	uxtb	r3, r3
 80083b4:	2b04      	cmp	r3, #4
 80083b6:	f000 8091 	beq.w	80084dc <EXTI9_5_IRQHandler+0x1a8>
		EXTI_ClearITPendingBit(EXTI_Line6);
 80083ba:	2040      	movs	r0, #64	; 0x40
 80083bc:	f7fa fd5c 	bl	8002e78 <EXTI_ClearITPendingBit>
	 	if (EXTI->PR & (1<<5)) {
 80083c0:	4b58      	ldr	r3, [pc, #352]	; (8008524 <EXTI9_5_IRQHandler+0x1f0>)
 80083c2:	695b      	ldr	r3, [r3, #20]
 80083c4:	f013 0f20 	tst.w	r3, #32
 80083c8:	d034      	beq.n	8008434 <EXTI9_5_IRQHandler+0x100>
			gSequenceStepNumber_1 = (unsigned int) (pots_step[0]-1);
 80083ca:	4b58      	ldr	r3, [pc, #352]	; (800852c <EXTI9_5_IRQHandler+0x1f8>)
 80083cc:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80083d0:	3b01      	subs	r3, #1
 80083d2:	b2db      	uxtb	r3, r3
 80083d4:	4a54      	ldr	r2, [pc, #336]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 80083d6:	7153      	strb	r3, [r2, #5]
			if ( gDisplayMode == DISPLAY_MODE_VIEW_1 ) {
 80083d8:	79d3      	ldrb	r3, [r2, #7]
 80083da:	b943      	cbnz	r3, 80083ee <EXTI9_5_IRQHandler+0xba>
				DisplayUpdateFlags.b.MainDisplay = 1;
 80083dc:	4b54      	ldr	r3, [pc, #336]	; (8008530 <EXTI9_5_IRQHandler+0x1fc>)
 80083de:	781a      	ldrb	r2, [r3, #0]
 80083e0:	f042 0201 	orr.w	r2, r2, #1
 80083e4:	701a      	strb	r2, [r3, #0]
				DisplayUpdateFlags.b.StepsDisplay = 1;
 80083e6:	781a      	ldrb	r2, [r3, #0]
 80083e8:	f042 0202 	orr.w	r2, r2, #2
 80083ec:	701a      	strb	r2, [r3, #0]
				PULSE_LED_I_ALL_ON;
 80083ee:	f44f 7100 	mov.w	r1, #512	; 0x200
 80083f2:	4850      	ldr	r0, [pc, #320]	; (8008534 <EXTI9_5_IRQHandler+0x200>)
 80083f4:	f7fb fb2c 	bl	8003a50 <GPIO_ResetBits>
				if (Steps[0][gSequenceStepNumber_1].b.OutputPulse1) {
 80083f8:	4b4b      	ldr	r3, [pc, #300]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 80083fa:	795a      	ldrb	r2, [r3, #5]
 80083fc:	4b4e      	ldr	r3, [pc, #312]	; (8008538 <EXTI9_5_IRQHandler+0x204>)
 80083fe:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008402:	685b      	ldr	r3, [r3, #4]
 8008404:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8008408:	d16b      	bne.n	80084e2 <EXTI9_5_IRQHandler+0x1ae>
				if (Steps[0][gSequenceStepNumber_1].b.OutputPulse2) {
 800840a:	4b47      	ldr	r3, [pc, #284]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 800840c:	795a      	ldrb	r2, [r3, #5]
 800840e:	4b4a      	ldr	r3, [pc, #296]	; (8008538 <EXTI9_5_IRQHandler+0x204>)
 8008410:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008414:	685b      	ldr	r3, [r3, #4]
 8008416:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 800841a:	d168      	bne.n	80084ee <EXTI9_5_IRQHandler+0x1ba>
				TIM_Cmd(TIM14, ENABLE);
 800841c:	4c47      	ldr	r4, [pc, #284]	; (800853c <EXTI9_5_IRQHandler+0x208>)
 800841e:	2101      	movs	r1, #1
 8008420:	4620      	mov	r0, r4
 8008422:	f7fd fed7 	bl	80061d4 <TIM_Cmd>
				TIM_SetCounter(TIM14, 0x00);
 8008426:	2100      	movs	r1, #0
 8008428:	4620      	mov	r0, r4
 800842a:	f7fd fe8a 	bl	8006142 <TIM_SetCounter>
		EXTI_ClearITPendingBit(EXTI_Line5);
 800842e:	2020      	movs	r0, #32
 8008430:	f7fa fd22 	bl	8002e78 <EXTI_ClearITPendingBit>
	 	if (EXTI->PR & (1<<7)) {
 8008434:	4b3b      	ldr	r3, [pc, #236]	; (8008524 <EXTI9_5_IRQHandler+0x1f0>)
 8008436:	695b      	ldr	r3, [r3, #20]
 8008438:	f013 0f80 	tst.w	r3, #128	; 0x80
 800843c:	d030      	beq.n	80084a0 <EXTI9_5_IRQHandler+0x16c>
		gSequenceStepNumber_2 = (unsigned int) (pots_step[1]-1);
 800843e:	4b3b      	ldr	r3, [pc, #236]	; (800852c <EXTI9_5_IRQHandler+0x1f8>)
 8008440:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8008444:	3b01      	subs	r3, #1
 8008446:	b2db      	uxtb	r3, r3
 8008448:	4a37      	ldr	r2, [pc, #220]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 800844a:	7193      	strb	r3, [r2, #6]
		if ( gDisplayMode == DISPLAY_MODE_VIEW_2 ) {
 800844c:	79d3      	ldrb	r3, [r2, #7]
 800844e:	b2db      	uxtb	r3, r3
 8008450:	2b01      	cmp	r3, #1
 8008452:	d052      	beq.n	80084fa <EXTI9_5_IRQHandler+0x1c6>
				PULSE_LED_II_ALL_ON;
 8008454:	2104      	movs	r1, #4
 8008456:	483a      	ldr	r0, [pc, #232]	; (8008540 <EXTI9_5_IRQHandler+0x20c>)
 8008458:	f7fb fafa 	bl	8003a50 <GPIO_ResetBits>
				if (Steps[1][gSequenceStepNumber_2].b.OutputPulse1) {
 800845c:	4b32      	ldr	r3, [pc, #200]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 800845e:	799b      	ldrb	r3, [r3, #6]
 8008460:	f103 0220 	add.w	r2, r3, #32
 8008464:	4b34      	ldr	r3, [pc, #208]	; (8008538 <EXTI9_5_IRQHandler+0x204>)
 8008466:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800846a:	685b      	ldr	r3, [r3, #4]
 800846c:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8008470:	d14d      	bne.n	800850e <EXTI9_5_IRQHandler+0x1da>
				if (Steps[1][gSequenceStepNumber_2].b.OutputPulse2) {
 8008472:	4b2d      	ldr	r3, [pc, #180]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 8008474:	799b      	ldrb	r3, [r3, #6]
 8008476:	f103 0220 	add.w	r2, r3, #32
 800847a:	4b2f      	ldr	r3, [pc, #188]	; (8008538 <EXTI9_5_IRQHandler+0x204>)
 800847c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008480:	685b      	ldr	r3, [r3, #4]
 8008482:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8008486:	d147      	bne.n	8008518 <EXTI9_5_IRQHandler+0x1e4>
				TIM_Cmd(TIM8, ENABLE);
 8008488:	4c2e      	ldr	r4, [pc, #184]	; (8008544 <EXTI9_5_IRQHandler+0x210>)
 800848a:	2101      	movs	r1, #1
 800848c:	4620      	mov	r0, r4
 800848e:	f7fd fea1 	bl	80061d4 <TIM_Cmd>
			TIM_SetCounter(TIM8, 0x00);
 8008492:	2100      	movs	r1, #0
 8008494:	4620      	mov	r0, r4
 8008496:	f7fd fe54 	bl	8006142 <TIM_SetCounter>
		EXTI_ClearITPendingBit(EXTI_Line7);
 800849a:	2080      	movs	r0, #128	; 0x80
 800849c:	f7fa fcec 	bl	8002e78 <EXTI_ClearITPendingBit>
	DisplayUpdateFlags.b.MainDisplay = 1;
 80084a0:	4b23      	ldr	r3, [pc, #140]	; (8008530 <EXTI9_5_IRQHandler+0x1fc>)
 80084a2:	781a      	ldrb	r2, [r3, #0]
 80084a4:	f042 0201 	orr.w	r2, r2, #1
 80084a8:	701a      	strb	r2, [r3, #0]
	DisplayUpdateFlags.b.StepsDisplay = 1;	 
 80084aa:	781a      	ldrb	r2, [r3, #0]
 80084ac:	f042 0202 	orr.w	r2, r2, #2
 80084b0:	701a      	strb	r2, [r3, #0]
 80084b2:	bd10      	pop	{r4, pc}
			gSequencerMode_1 = SEQUENCER_MODE_RUN;
 80084b4:	4c1c      	ldr	r4, [pc, #112]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 80084b6:	2000      	movs	r0, #0
 80084b8:	7060      	strb	r0, [r4, #1]
			gSequenceStepNumber_1 = GetNextStep(0, gSequenceStepNumber_1);
 80084ba:	7961      	ldrb	r1, [r4, #5]
 80084bc:	f7ff fee8 	bl	8008290 <GetNextStep>
 80084c0:	7160      	strb	r0, [r4, #5]
 80084c2:	e751      	b.n	8008368 <EXTI9_5_IRQHandler+0x34>
			InitStart_1_SignalTimer();
 80084c4:	f7ff fb78 	bl	8007bb8 <InitStart_1_SignalTimer>
 80084c8:	e754      	b.n	8008374 <EXTI9_5_IRQHandler+0x40>
			gSequencerMode_2 = SEQUENCER_MODE_RUN;
 80084ca:	4c17      	ldr	r4, [pc, #92]	; (8008528 <EXTI9_5_IRQHandler+0x1f4>)
 80084cc:	2300      	movs	r3, #0
 80084ce:	70e3      	strb	r3, [r4, #3]
			gSequenceStepNumber_2 = GetNextStep(1, gSequenceStepNumber_2);
 80084d0:	79a1      	ldrb	r1, [r4, #6]
 80084d2:	2001      	movs	r0, #1
 80084d4:	f7ff fedc 	bl	8008290 <GetNextStep>
 80084d8:	71a0      	strb	r0, [r4, #6]
 80084da:	e768      	b.n	80083ae <EXTI9_5_IRQHandler+0x7a>
			InitStart_2_SignalTimer();
 80084dc:	f7ff fb8a 	bl	8007bf4 <InitStart_2_SignalTimer>
 80084e0:	e76b      	b.n	80083ba <EXTI9_5_IRQHandler+0x86>
					PULSE_LED_I_1_ON;
 80084e2:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80084e6:	4813      	ldr	r0, [pc, #76]	; (8008534 <EXTI9_5_IRQHandler+0x200>)
 80084e8:	f7fb fab2 	bl	8003a50 <GPIO_ResetBits>
 80084ec:	e78d      	b.n	800840a <EXTI9_5_IRQHandler+0xd6>
					PULSE_LED_I_2_ON;
 80084ee:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80084f2:	4810      	ldr	r0, [pc, #64]	; (8008534 <EXTI9_5_IRQHandler+0x200>)
 80084f4:	f7fb faac 	bl	8003a50 <GPIO_ResetBits>
 80084f8:	e790      	b.n	800841c <EXTI9_5_IRQHandler+0xe8>
		DisplayUpdateFlags.b.MainDisplay = 1;
 80084fa:	4b0d      	ldr	r3, [pc, #52]	; (8008530 <EXTI9_5_IRQHandler+0x1fc>)
 80084fc:	781a      	ldrb	r2, [r3, #0]
 80084fe:	f042 0201 	orr.w	r2, r2, #1
 8008502:	701a      	strb	r2, [r3, #0]
		DisplayUpdateFlags.b.StepsDisplay = 1;
 8008504:	781a      	ldrb	r2, [r3, #0]
 8008506:	f042 0202 	orr.w	r2, r2, #2
 800850a:	701a      	strb	r2, [r3, #0]
 800850c:	e7a2      	b.n	8008454 <EXTI9_5_IRQHandler+0x120>
					PULSE_LED_II_1_ON;
 800850e:	2108      	movs	r1, #8
 8008510:	480b      	ldr	r0, [pc, #44]	; (8008540 <EXTI9_5_IRQHandler+0x20c>)
 8008512:	f7fb fa9d 	bl	8003a50 <GPIO_ResetBits>
 8008516:	e7ac      	b.n	8008472 <EXTI9_5_IRQHandler+0x13e>
					PULSE_LED_II_2_ON;
 8008518:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800851c:	4808      	ldr	r0, [pc, #32]	; (8008540 <EXTI9_5_IRQHandler+0x20c>)
 800851e:	f7fb fa97 	bl	8003a50 <GPIO_ResetBits>
 8008522:	e7b1      	b.n	8008488 <EXTI9_5_IRQHandler+0x154>
 8008524:	40013c00 	.word	0x40013c00
 8008528:	200006b4 	.word	0x200006b4
 800852c:	20000258 	.word	0x20000258
 8008530:	20000708 	.word	0x20000708
 8008534:	40020400 	.word	0x40020400
 8008538:	20000cb4 	.word	0x20000cb4
 800853c:	40002000 	.word	0x40002000
 8008540:	40020000 	.word	0x40020000
 8008544:	40010400 	.word	0x40010400

08008548 <TIM4_IRQHandler>:

/*
	Timer interrupt handler for 1 section steps
*/
void TIM4_IRQHandler()
{
 8008548:	b5f0      	push	{r4, r5, r6, r7, lr}
 800854a:	b083      	sub	sp, #12
	float deltaVoltage;
	unsigned long CurStep;
	
	
	/* Clear interrupt flag */
	TIM4->SR = (uint16_t) ~TIM_IT_Update;
 800854c:	4eae      	ldr	r6, [pc, #696]	; (8008808 <TIM4_IRQHandler+0x2c0>)
 800854e:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8008552:	8233      	strh	r3, [r6, #16]

	/* Calculate next step duration */		
	StepWidth_1 = GetStepWidth(0, gSequenceStepNumber_1);
 8008554:	4cad      	ldr	r4, [pc, #692]	; (800880c <TIM4_IRQHandler+0x2c4>)
 8008556:	7961      	ldrb	r1, [r4, #5]
 8008558:	2000      	movs	r0, #0
 800855a:	f7ff fc75 	bl	8007e48 <GetStepWidth>
 800855e:	4605      	mov	r5, r0
					
					
		/* Calculate prescaler/multiplier*/
		TIM4->PSC = (uint16_t) ((((((float) AddData[ADC_TIMEMULTIPLY_Ch_1])*3.5f)/CalConstants[ADC_TIMEMULTIPLY_Ch_1])+0.5f)*STEP_TIMER_PRESCALER);
 8008560:	4bab      	ldr	r3, [pc, #684]	; (8008810 <TIM4_IRQHandler+0x2c8>)
 8008562:	ed93 7a04 	vldr	s14, [r3, #16]
 8008566:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 800856a:	eef0 7a0c 	vmov.f32	s15, #12	; 0x40600000  3.5
 800856e:	ee27 7a27 	vmul.f32	s14, s14, s15
 8008572:	4ba8      	ldr	r3, [pc, #672]	; (8008814 <TIM4_IRQHandler+0x2cc>)
 8008574:	edd3 6a05 	vldr	s13, [r3, #20]
 8008578:	eef8 6a66 	vcvt.f32.u32	s13, s13
 800857c:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8008580:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 8008584:	ee77 7a87 	vadd.f32	s15, s15, s14
 8008588:	ed9f 7aa3 	vldr	s14, [pc, #652]	; 8008818 <TIM4_IRQHandler+0x2d0>
 800858c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8008590:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8008594:	edcd 7a01 	vstr	s15, [sp, #4]
 8008598:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 800859c:	8533      	strh	r3, [r6, #40]	; 0x28
		

		if (Steps[0][gSequenceStepNumber_1].b.Sloped) {
 800859e:	7963      	ldrb	r3, [r4, #5]
 80085a0:	b2db      	uxtb	r3, r3
 80085a2:	4a9e      	ldr	r2, [pc, #632]	; (800881c <TIM4_IRQHandler+0x2d4>)
 80085a4:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 80085a8:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80085ac:	d059      	beq.n	8008662 <TIM4_IRQHandler+0x11a>
			//Calculate the voltage in slope mode
			CurStep = GetStepVoltage(0, gSequenceStepNumber_1);
 80085ae:	4626      	mov	r6, r4
 80085b0:	7961      	ldrb	r1, [r4, #5]
 80085b2:	2000      	movs	r0, #0
 80085b4:	f7ff fd14 	bl	8007fe0 <GetStepVoltage>
 80085b8:	4604      	mov	r4, r0
			if(gSequencerMode_1 == SEQUENCER_MODE_RUN || gSequencerMode_1 == SEQUENCER_MODE_ADVANCE)
 80085ba:	7873      	ldrb	r3, [r6, #1]
 80085bc:	b16b      	cbz	r3, 80085da <TIM4_IRQHandler+0x92>
 80085be:	7873      	ldrb	r3, [r6, #1]
 80085c0:	b2db      	uxtb	r3, r3
 80085c2:	2b06      	cmp	r3, #6
 80085c4:	d009      	beq.n	80085da <TIM4_IRQHandler+0x92>
					DAC_SetChannel1Data(DAC_Align_12b_R, PreviousStep + (unsigned int) (deltaVoltage*gStepWidth_1) );
				};
			}			
			else 
			{
				DAC_SetChannel1Data(DAC_Align_12b_R, GetStepVoltage(0, gSequenceStepNumber_1));
 80085c6:	4b91      	ldr	r3, [pc, #580]	; (800880c <TIM4_IRQHandler+0x2c4>)
 80085c8:	7959      	ldrb	r1, [r3, #5]
 80085ca:	2000      	movs	r0, #0
 80085cc:	f7ff fd08 	bl	8007fe0 <GetStepVoltage>
 80085d0:	b281      	uxth	r1, r0
 80085d2:	2000      	movs	r0, #0
 80085d4:	f7fa f854 	bl	8002680 <DAC_SetChannel1Data>
 80085d8:	e04c      	b.n	8008674 <TIM4_IRQHandler+0x12c>
				if (PreviousStep>CurStep) {
 80085da:	4b8c      	ldr	r3, [pc, #560]	; (800880c <TIM4_IRQHandler+0x2c4>)
 80085dc:	689b      	ldr	r3, [r3, #8]
 80085de:	429c      	cmp	r4, r3
 80085e0:	d321      	bcc.n	8008626 <TIM4_IRQHandler+0xde>
				if (CurStep>PreviousStep) {
 80085e2:	4b8a      	ldr	r3, [pc, #552]	; (800880c <TIM4_IRQHandler+0x2c4>)
 80085e4:	689b      	ldr	r3, [r3, #8]
 80085e6:	429c      	cmp	r4, r3
 80085e8:	d944      	bls.n	8008674 <TIM4_IRQHandler+0x12c>
					deltaVoltage =  (float) (CurStep-PreviousStep) / StepWidth_1;
 80085ea:	4b88      	ldr	r3, [pc, #544]	; (800880c <TIM4_IRQHandler+0x2c4>)
 80085ec:	689a      	ldr	r2, [r3, #8]
 80085ee:	1aa4      	subs	r4, r4, r2
 80085f0:	ee07 4a90 	vmov	s15, r4
 80085f4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80085f8:	ee07 5a10 	vmov	s14, r5
 80085fc:	eef8 6a47 	vcvt.f32.u32	s13, s14
 8008600:	ee87 7aa6 	vdiv.f32	s14, s15, s13
					DAC_SetChannel1Data(DAC_Align_12b_R, PreviousStep + (unsigned int) (deltaVoltage*gStepWidth_1) );
 8008604:	edd3 7a03 	vldr	s15, [r3, #12]
 8008608:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800860c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8008610:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8008614:	ee17 1a90 	vmov	r1, s15
 8008618:	689b      	ldr	r3, [r3, #8]
 800861a:	4419      	add	r1, r3
 800861c:	b289      	uxth	r1, r1
 800861e:	2000      	movs	r0, #0
 8008620:	f7fa f82e 	bl	8002680 <DAC_SetChannel1Data>
 8008624:	e026      	b.n	8008674 <TIM4_IRQHandler+0x12c>
					deltaVoltage =  (float) (PreviousStep-CurStep) / StepWidth_1;
 8008626:	4a79      	ldr	r2, [pc, #484]	; (800880c <TIM4_IRQHandler+0x2c4>)
 8008628:	6893      	ldr	r3, [r2, #8]
 800862a:	1b1b      	subs	r3, r3, r4
 800862c:	ee07 3a90 	vmov	s15, r3
 8008630:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8008634:	ee07 5a90 	vmov	s15, r5
 8008638:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800863c:	eec7 6a27 	vdiv.f32	s13, s14, s15
					DAC_SetChannel1Data(DAC_Align_12b_R, PreviousStep - (unsigned int) (deltaVoltage*gStepWidth_1) );
 8008640:	6891      	ldr	r1, [r2, #8]
 8008642:	edd2 7a03 	vldr	s15, [r2, #12]
 8008646:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800864a:	ee67 7aa6 	vmul.f32	s15, s15, s13
 800864e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8008652:	ee17 3a90 	vmov	r3, s15
 8008656:	1ac9      	subs	r1, r1, r3
 8008658:	b289      	uxth	r1, r1
 800865a:	2000      	movs	r0, #0
 800865c:	f7fa f810 	bl	8002680 <DAC_SetChannel1Data>
 8008660:	e7bf      	b.n	80085e2 <TIM4_IRQHandler+0x9a>
			}
		} else {
			//Calculate the voltage in not slope mode
			DAC_SetChannel1Data(DAC_Align_12b_R, GetStepVoltage(0, gSequenceStepNumber_1));
 8008662:	4b6a      	ldr	r3, [pc, #424]	; (800880c <TIM4_IRQHandler+0x2c4>)
 8008664:	7959      	ldrb	r1, [r3, #5]
 8008666:	2000      	movs	r0, #0
 8008668:	f7ff fcba 	bl	8007fe0 <GetStepVoltage>
 800866c:	b281      	uxth	r1, r0
 800866e:	2000      	movs	r0, #0
 8008670:	f7fa f806 	bl	8002680 <DAC_SetChannel1Data>
		};
		
			/*additional channels - ref and time*/
			MAX5135_DAC_send(EXT_DAC_CH_0, Steps[0][gSequenceStepNumber_1].b.TLevel >> 2);
 8008674:	4c65      	ldr	r4, [pc, #404]	; (800880c <TIM4_IRQHandler+0x2c4>)
 8008676:	7963      	ldrb	r3, [r4, #5]
 8008678:	b2db      	uxtb	r3, r3
 800867a:	4a68      	ldr	r2, [pc, #416]	; (800881c <TIM4_IRQHandler+0x2d4>)
 800867c:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
 8008680:	f341 3189 	sbfx	r1, r1, #14, #10
 8008684:	2000      	movs	r0, #0
 8008686:	f7fe ff37 	bl	80074f8 <MAX5135_DAC_send>
			MAX5135_DAC_send(EXT_DAC_CH_1, 1023 - (unsigned int) (((double) 1023/ (double) StepWidth_1)*((double) gStepWidth_1)) );
 800868a:	4628      	mov	r0, r5
 800868c:	f003 fbc0 	bl	800be10 <__aeabi_ui2d>
 8008690:	4602      	mov	r2, r0
 8008692:	460b      	mov	r3, r1
 8008694:	a15a      	add	r1, pc, #360	; (adr r1, 8008800 <TIM4_IRQHandler+0x2b8>)
 8008696:	e9d1 0100 	ldrd	r0, r1, [r1]
 800869a:	f003 fd59 	bl	800c150 <__aeabi_ddiv>
 800869e:	4606      	mov	r6, r0
 80086a0:	460f      	mov	r7, r1
 80086a2:	68e0      	ldr	r0, [r4, #12]
 80086a4:	f003 fbb4 	bl	800be10 <__aeabi_ui2d>
 80086a8:	4602      	mov	r2, r0
 80086aa:	460b      	mov	r3, r1
 80086ac:	4630      	mov	r0, r6
 80086ae:	4639      	mov	r1, r7
 80086b0:	f003 fc24 	bl	800befc <__aeabi_dmul>
 80086b4:	f003 fe34 	bl	800c320 <__aeabi_d2uiz>
 80086b8:	f5c0 717f 	rsb	r1, r0, #1020	; 0x3fc
 80086bc:	3103      	adds	r1, #3
 80086be:	2001      	movs	r0, #1
 80086c0:	f7fe ff1a 	bl	80074f8 <MAX5135_DAC_send>
		
		
		/* Increment step counter */ 
		if ( (gSequencerMode_1 == SEQUENCER_MODE_RUN ) || 
 80086c4:	7863      	ldrb	r3, [r4, #1]
 80086c6:	b11b      	cbz	r3, 80086d0 <TIM4_IRQHandler+0x188>
			(	(gSequencerMode_1 == SEQUENCER_MODE_ADVANCE) 	) 
 80086c8:	7863      	ldrb	r3, [r4, #1]
 80086ca:	b2db      	uxtb	r3, r3
		if ( (gSequencerMode_1 == SEQUENCER_MODE_RUN ) || 
 80086cc:	2b06      	cmp	r3, #6
 80086ce:	d103      	bne.n	80086d8 <TIM4_IRQHandler+0x190>
		)
		{
			gStepWidth_1++;
 80086d0:	4a4e      	ldr	r2, [pc, #312]	; (800880c <TIM4_IRQHandler+0x2c4>)
 80086d2:	68d3      	ldr	r3, [r2, #12]
 80086d4:	3301      	adds	r3, #1
 80086d6:	60d3      	str	r3, [r2, #12]
		};

		if ((gStepWidth_1 < StepWidth_1)) {
 80086d8:	4b4c      	ldr	r3, [pc, #304]	; (800880c <TIM4_IRQHandler+0x2c4>)
 80086da:	68db      	ldr	r3, [r3, #12]
 80086dc:	429d      	cmp	r5, r3
 80086de:	d919      	bls.n	8008714 <TIM4_IRQHandler+0x1cc>
				TIM_Cmd(TIM14, ENABLE);
				TIM_SetCounter(TIM14, 0x00);
			};
		};
	
	if (gSequencerMode_1 == SEQUENCER_MODE_WAIT) {
 80086e0:	4b4a      	ldr	r3, [pc, #296]	; (800880c <TIM4_IRQHandler+0x2c4>)
 80086e2:	785b      	ldrb	r3, [r3, #1]
 80086e4:	b2db      	uxtb	r3, r3
 80086e6:	2b01      	cmp	r3, #1
 80086e8:	f000 80d5 	beq.w	8008896 <TIM4_IRQHandler+0x34e>
			TIM_Cmd(TIM14, ENABLE);
			TIM_SetCounter(TIM14, 0x00);
		}
	};	

	if (gSequencerMode_1 == SEQUENCER_MODE_WAIT_STROBE) {
 80086ec:	4b47      	ldr	r3, [pc, #284]	; (800880c <TIM4_IRQHandler+0x2c4>)
 80086ee:	785b      	ldrb	r3, [r3, #1]
 80086f0:	b2db      	uxtb	r3, r3
 80086f2:	2b03      	cmp	r3, #3
 80086f4:	f000 8114 	beq.w	8008920 <TIM4_IRQHandler+0x3d8>
			gSequenceStepNumber_1 = (unsigned int) (pots_step[0]-1); //(float) AddData[6]/(float) (CalConstants[6]/15.0)
			DAC_SetChannel1Data(DAC_Align_12b_R, GetStepVoltage(0, gSequenceStepNumber_1));
		gSequencerMode_1 = gPrevSequencerMode_1;
	}
		
	if ( gDisplayMode == DISPLAY_MODE_VIEW_1 ) {
 80086f8:	4b44      	ldr	r3, [pc, #272]	; (800880c <TIM4_IRQHandler+0x2c4>)
 80086fa:	79db      	ldrb	r3, [r3, #7]
 80086fc:	b943      	cbnz	r3, 8008710 <TIM4_IRQHandler+0x1c8>
		DisplayUpdateFlags.b.MainDisplay = 1;
 80086fe:	4b48      	ldr	r3, [pc, #288]	; (8008820 <TIM4_IRQHandler+0x2d8>)
 8008700:	781a      	ldrb	r2, [r3, #0]
 8008702:	f042 0201 	orr.w	r2, r2, #1
 8008706:	701a      	strb	r2, [r3, #0]
		DisplayUpdateFlags.b.StepsDisplay = 1;
 8008708:	781a      	ldrb	r2, [r3, #0]
 800870a:	f042 0202 	orr.w	r2, r2, #2
 800870e:	701a      	strb	r2, [r3, #0]
	};		
	
		return;
};
 8008710:	b003      	add	sp, #12
 8008712:	bdf0      	pop	{r4, r5, r6, r7, pc}
			PreviousStep = GetStepVoltage(0, gSequenceStepNumber_1);
 8008714:	4c3d      	ldr	r4, [pc, #244]	; (800880c <TIM4_IRQHandler+0x2c4>)
 8008716:	7961      	ldrb	r1, [r4, #5]
 8008718:	2000      	movs	r0, #0
 800871a:	f7ff fc61 	bl	8007fe0 <GetStepVoltage>
 800871e:	60a0      	str	r0, [r4, #8]
			if ( (gSequencerMode_1 == SEQUENCER_MODE_ADVANCE)   ) { 
 8008720:	7863      	ldrb	r3, [r4, #1]
 8008722:	b2db      	uxtb	r3, r3
 8008724:	2b06      	cmp	r3, #6
 8008726:	d064      	beq.n	80087f2 <TIM4_IRQHandler+0x2aa>
			if (Steps[0][gSequenceStepNumber_1].b.OpModeSTOP) {
 8008728:	4b38      	ldr	r3, [pc, #224]	; (800880c <TIM4_IRQHandler+0x2c4>)
 800872a:	795a      	ldrb	r2, [r3, #5]
 800872c:	4b3b      	ldr	r3, [pc, #236]	; (800881c <TIM4_IRQHandler+0x2d4>)
 800872e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008732:	685b      	ldr	r3, [r3, #4]
 8008734:	f013 0f02 	tst.w	r3, #2
 8008738:	d005      	beq.n	8008746 <TIM4_IRQHandler+0x1fe>
				gPrevSequencerMode_1 = gSequencerMode_1;
 800873a:	4b34      	ldr	r3, [pc, #208]	; (800880c <TIM4_IRQHandler+0x2c4>)
 800873c:	785a      	ldrb	r2, [r3, #1]
 800873e:	b2d2      	uxtb	r2, r2
 8008740:	709a      	strb	r2, [r3, #2]
				gSequencerMode_1 = SEQUENCER_MODE_STOP;				
 8008742:	2202      	movs	r2, #2
 8008744:	705a      	strb	r2, [r3, #1]
			if ((Steps[0][gSequenceStepNumber_1].b.OpModeENABLE))  {
 8008746:	4b31      	ldr	r3, [pc, #196]	; (800880c <TIM4_IRQHandler+0x2c4>)
 8008748:	795a      	ldrb	r2, [r3, #5]
 800874a:	4b34      	ldr	r3, [pc, #208]	; (800881c <TIM4_IRQHandler+0x2d4>)
 800874c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008750:	685b      	ldr	r3, [r3, #4]
 8008752:	f013 0f08 	tst.w	r3, #8
 8008756:	d169      	bne.n	800882c <TIM4_IRQHandler+0x2e4>
			if((Steps[0][gSequenceStepNumber_1].b.OpModeSUSTAIN))  {
 8008758:	4b2c      	ldr	r3, [pc, #176]	; (800880c <TIM4_IRQHandler+0x2c4>)
 800875a:	795a      	ldrb	r2, [r3, #5]
 800875c:	4b2f      	ldr	r3, [pc, #188]	; (800881c <TIM4_IRQHandler+0x2d4>)
 800875e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008762:	685b      	ldr	r3, [r3, #4]
 8008764:	f013 0f04 	tst.w	r3, #4
 8008768:	d173      	bne.n	8008852 <TIM4_IRQHandler+0x30a>
			if ( (!(Steps[0][gSequenceStepNumber_1].b.OpModeSTOP)) &&
 800876a:	4b28      	ldr	r3, [pc, #160]	; (800880c <TIM4_IRQHandler+0x2c4>)
 800876c:	795a      	ldrb	r2, [r3, #5]
 800876e:	4b2b      	ldr	r3, [pc, #172]	; (800881c <TIM4_IRQHandler+0x2d4>)
 8008770:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008774:	685b      	ldr	r3, [r3, #4]
 8008776:	f013 0f02 	tst.w	r3, #2
 800877a:	d10e      	bne.n	800879a <TIM4_IRQHandler+0x252>
					(!(Steps[0][gSequenceStepNumber_1].b.OpModeENABLE)) &&
 800877c:	4b23      	ldr	r3, [pc, #140]	; (800880c <TIM4_IRQHandler+0x2c4>)
 800877e:	795a      	ldrb	r2, [r3, #5]
 8008780:	4b26      	ldr	r3, [pc, #152]	; (800881c <TIM4_IRQHandler+0x2d4>)
 8008782:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008786:	685b      	ldr	r3, [r3, #4]
			if ( (!(Steps[0][gSequenceStepNumber_1].b.OpModeSTOP)) &&
 8008788:	f013 0f08 	tst.w	r3, #8
 800878c:	d105      	bne.n	800879a <TIM4_IRQHandler+0x252>
					(!(Steps[0][gSequenceStepNumber_1].b.OpModeSUSTAIN)) ) {
 800878e:	4b1f      	ldr	r3, [pc, #124]	; (800880c <TIM4_IRQHandler+0x2c4>)
 8008790:	795a      	ldrb	r2, [r3, #5]
 8008792:	4b22      	ldr	r3, [pc, #136]	; (800881c <TIM4_IRQHandler+0x2d4>)
 8008794:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008798:	685b      	ldr	r3, [r3, #4]
			gStepWidth_1 = 0;
 800879a:	4b1c      	ldr	r3, [pc, #112]	; (800880c <TIM4_IRQHandler+0x2c4>)
 800879c:	2200      	movs	r2, #0
 800879e:	60da      	str	r2, [r3, #12]
			if (gSequencerMode_1 == SEQUENCER_MODE_RUN) {		
 80087a0:	785b      	ldrb	r3, [r3, #1]
 80087a2:	2b00      	cmp	r3, #0
 80087a4:	d19c      	bne.n	80086e0 <TIM4_IRQHandler+0x198>
				gSequenceStepNumber_1 = GetNextStep(0, gSequenceStepNumber_1);
 80087a6:	4c19      	ldr	r4, [pc, #100]	; (800880c <TIM4_IRQHandler+0x2c4>)
 80087a8:	7961      	ldrb	r1, [r4, #5]
 80087aa:	4610      	mov	r0, r2
 80087ac:	f7ff fd70 	bl	8008290 <GetNextStep>
 80087b0:	7160      	strb	r0, [r4, #5]
				PULSE_LED_I_ALL_ON;
 80087b2:	f44f 7100 	mov.w	r1, #512	; 0x200
 80087b6:	481b      	ldr	r0, [pc, #108]	; (8008824 <TIM4_IRQHandler+0x2dc>)
 80087b8:	f7fb f94a 	bl	8003a50 <GPIO_ResetBits>
				if (Steps[0][gSequenceStepNumber_1].b.OutputPulse1) {
 80087bc:	7962      	ldrb	r2, [r4, #5]
 80087be:	4b17      	ldr	r3, [pc, #92]	; (800881c <TIM4_IRQHandler+0x2d4>)
 80087c0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80087c4:	685b      	ldr	r3, [r3, #4]
 80087c6:	f413 6f00 	tst.w	r3, #2048	; 0x800
 80087ca:	d158      	bne.n	800887e <TIM4_IRQHandler+0x336>
				if (Steps[0][gSequenceStepNumber_1].b.OutputPulse2) {
 80087cc:	4b0f      	ldr	r3, [pc, #60]	; (800880c <TIM4_IRQHandler+0x2c4>)
 80087ce:	795a      	ldrb	r2, [r3, #5]
 80087d0:	4b12      	ldr	r3, [pc, #72]	; (800881c <TIM4_IRQHandler+0x2d4>)
 80087d2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80087d6:	685b      	ldr	r3, [r3, #4]
 80087d8:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80087dc:	d155      	bne.n	800888a <TIM4_IRQHandler+0x342>
				TIM_Cmd(TIM14, ENABLE);
 80087de:	4c12      	ldr	r4, [pc, #72]	; (8008828 <TIM4_IRQHandler+0x2e0>)
 80087e0:	2101      	movs	r1, #1
 80087e2:	4620      	mov	r0, r4
 80087e4:	f7fd fcf6 	bl	80061d4 <TIM_Cmd>
				TIM_SetCounter(TIM14, 0x00);
 80087e8:	2100      	movs	r1, #0
 80087ea:	4620      	mov	r0, r4
 80087ec:	f7fd fca9 	bl	8006142 <TIM_SetCounter>
 80087f0:	e776      	b.n	80086e0 <TIM4_IRQHandler+0x198>
				gSequencerMode_1 = gPrevSequencerMode_1;
 80087f2:	78a3      	ldrb	r3, [r4, #2]
 80087f4:	b2db      	uxtb	r3, r3
 80087f6:	7063      	strb	r3, [r4, #1]
 80087f8:	e796      	b.n	8008728 <TIM4_IRQHandler+0x1e0>
 80087fa:	bf00      	nop
 80087fc:	f3af 8000 	nop.w
 8008800:	00000000 	.word	0x00000000
 8008804:	408ff800 	.word	0x408ff800
 8008808:	40000800 	.word	0x40000800
 800880c:	200006b4 	.word	0x200006b4
 8008810:	20000c0c 	.word	0x20000c0c
 8008814:	20000258 	.word	0x20000258
 8008818:	46241000 	.word	0x46241000
 800881c:	20000cb4 	.word	0x20000cb4
 8008820:	20000708 	.word	0x20000708
 8008824:	40020400 	.word	0x40020400
 8008828:	40002000 	.word	0x40002000
				if( (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8) == 0)) 
 800882c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008830:	4845      	ldr	r0, [pc, #276]	; (8008948 <TIM4_IRQHandler+0x400>)
 8008832:	f7fb f8f7 	bl	8003a24 <GPIO_ReadInputDataBit>
 8008836:	2800      	cmp	r0, #0
 8008838:	d18e      	bne.n	8008758 <TIM4_IRQHandler+0x210>
				if(gSequencerMode_1 != SEQUENCER_MODE_WAIT_HI_Z)
 800883a:	4b44      	ldr	r3, [pc, #272]	; (800894c <TIM4_IRQHandler+0x404>)
 800883c:	785b      	ldrb	r3, [r3, #1]
 800883e:	b2db      	uxtb	r3, r3
 8008840:	2b04      	cmp	r3, #4
 8008842:	d089      	beq.n	8008758 <TIM4_IRQHandler+0x210>
					gPrevSequencerMode_1 = gSequencerMode_1;
 8008844:	4b41      	ldr	r3, [pc, #260]	; (800894c <TIM4_IRQHandler+0x404>)
 8008846:	785a      	ldrb	r2, [r3, #1]
 8008848:	b2d2      	uxtb	r2, r2
 800884a:	709a      	strb	r2, [r3, #2]
					gSequencerMode_1 = SEQUENCER_MODE_WAIT_HI_Z;
 800884c:	2204      	movs	r2, #4
 800884e:	705a      	strb	r2, [r3, #1]
 8008850:	e782      	b.n	8008758 <TIM4_IRQHandler+0x210>
				if( (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8) == 1)) 
 8008852:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008856:	483c      	ldr	r0, [pc, #240]	; (8008948 <TIM4_IRQHandler+0x400>)
 8008858:	f7fb f8e4 	bl	8003a24 <GPIO_ReadInputDataBit>
 800885c:	2801      	cmp	r0, #1
 800885e:	d184      	bne.n	800876a <TIM4_IRQHandler+0x222>
					if(gSequencerMode_1 != SEQUENCER_MODE_STAY_HI_Z)
 8008860:	4b3a      	ldr	r3, [pc, #232]	; (800894c <TIM4_IRQHandler+0x404>)
 8008862:	785b      	ldrb	r3, [r3, #1]
 8008864:	b2db      	uxtb	r3, r3
 8008866:	2b05      	cmp	r3, #5
 8008868:	f43f af7f 	beq.w	800876a <TIM4_IRQHandler+0x222>
						gPrevSequencerMode_1 = gSequencerMode_1;
 800886c:	4b37      	ldr	r3, [pc, #220]	; (800894c <TIM4_IRQHandler+0x404>)
 800886e:	785a      	ldrb	r2, [r3, #1]
 8008870:	b2d2      	uxtb	r2, r2
 8008872:	709a      	strb	r2, [r3, #2]
						gSequencerMode_1 = SEQUENCER_MODE_STAY_HI_Z;
 8008874:	2205      	movs	r2, #5
 8008876:	705a      	strb	r2, [r3, #1]
						InitStart_1_SignalTimer();
 8008878:	f7ff f99e 	bl	8007bb8 <InitStart_1_SignalTimer>
 800887c:	e775      	b.n	800876a <TIM4_IRQHandler+0x222>
					PULSE_LED_I_1_ON;
 800887e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8008882:	4831      	ldr	r0, [pc, #196]	; (8008948 <TIM4_IRQHandler+0x400>)
 8008884:	f7fb f8e4 	bl	8003a50 <GPIO_ResetBits>
 8008888:	e7a0      	b.n	80087cc <TIM4_IRQHandler+0x284>
					PULSE_LED_I_2_ON;
 800888a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800888e:	482e      	ldr	r0, [pc, #184]	; (8008948 <TIM4_IRQHandler+0x400>)
 8008890:	f7fb f8de 	bl	8003a50 <GPIO_ResetBits>
 8008894:	e7a3      	b.n	80087de <TIM4_IRQHandler+0x296>
		if(gSequenceStepNumber_1 != (unsigned int) (pots_step[0]-1))
 8008896:	4b2d      	ldr	r3, [pc, #180]	; (800894c <TIM4_IRQHandler+0x404>)
 8008898:	795a      	ldrb	r2, [r3, #5]
 800889a:	b2d2      	uxtb	r2, r2
 800889c:	4b2c      	ldr	r3, [pc, #176]	; (8008950 <TIM4_IRQHandler+0x408>)
 800889e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80088a2:	3b01      	subs	r3, #1
 80088a4:	429a      	cmp	r2, r3
 80088a6:	f43f af21 	beq.w	80086ec <TIM4_IRQHandler+0x1a4>
			gSequenceStepNumber_1 = (unsigned int) (pots_step[0]-1); 
 80088aa:	4b29      	ldr	r3, [pc, #164]	; (8008950 <TIM4_IRQHandler+0x408>)
 80088ac:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80088b0:	3b01      	subs	r3, #1
 80088b2:	b2db      	uxtb	r3, r3
 80088b4:	4c25      	ldr	r4, [pc, #148]	; (800894c <TIM4_IRQHandler+0x404>)
 80088b6:	7163      	strb	r3, [r4, #5]
			DAC_SetChannel1Data(DAC_Align_12b_R, GetStepVoltage(0, gSequenceStepNumber_1));
 80088b8:	7961      	ldrb	r1, [r4, #5]
 80088ba:	2000      	movs	r0, #0
 80088bc:	f7ff fb90 	bl	8007fe0 <GetStepVoltage>
 80088c0:	b281      	uxth	r1, r0
 80088c2:	2000      	movs	r0, #0
 80088c4:	f7f9 fedc 	bl	8002680 <DAC_SetChannel1Data>
			PULSE_LED_I_ALL_ON;
 80088c8:	f44f 7100 	mov.w	r1, #512	; 0x200
 80088cc:	481e      	ldr	r0, [pc, #120]	; (8008948 <TIM4_IRQHandler+0x400>)
 80088ce:	f7fb f8bf 	bl	8003a50 <GPIO_ResetBits>
			if (Steps[0][gSequenceStepNumber_1].b.OutputPulse1) {
 80088d2:	7962      	ldrb	r2, [r4, #5]
 80088d4:	4b1f      	ldr	r3, [pc, #124]	; (8008954 <TIM4_IRQHandler+0x40c>)
 80088d6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80088da:	685b      	ldr	r3, [r3, #4]
 80088dc:	f413 6f00 	tst.w	r3, #2048	; 0x800
 80088e0:	d112      	bne.n	8008908 <TIM4_IRQHandler+0x3c0>
			if (Steps[0][gSequenceStepNumber_1].b.OutputPulse2) {
 80088e2:	4b1a      	ldr	r3, [pc, #104]	; (800894c <TIM4_IRQHandler+0x404>)
 80088e4:	795a      	ldrb	r2, [r3, #5]
 80088e6:	4b1b      	ldr	r3, [pc, #108]	; (8008954 <TIM4_IRQHandler+0x40c>)
 80088e8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 80088ec:	685b      	ldr	r3, [r3, #4]
 80088ee:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 80088f2:	d10f      	bne.n	8008914 <TIM4_IRQHandler+0x3cc>
			TIM_Cmd(TIM14, ENABLE);
 80088f4:	4c18      	ldr	r4, [pc, #96]	; (8008958 <TIM4_IRQHandler+0x410>)
 80088f6:	2101      	movs	r1, #1
 80088f8:	4620      	mov	r0, r4
 80088fa:	f7fd fc6b 	bl	80061d4 <TIM_Cmd>
			TIM_SetCounter(TIM14, 0x00);
 80088fe:	2100      	movs	r1, #0
 8008900:	4620      	mov	r0, r4
 8008902:	f7fd fc1e 	bl	8006142 <TIM_SetCounter>
 8008906:	e6f1      	b.n	80086ec <TIM4_IRQHandler+0x1a4>
				PULSE_LED_I_1_ON;
 8008908:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800890c:	480e      	ldr	r0, [pc, #56]	; (8008948 <TIM4_IRQHandler+0x400>)
 800890e:	f7fb f89f 	bl	8003a50 <GPIO_ResetBits>
 8008912:	e7e6      	b.n	80088e2 <TIM4_IRQHandler+0x39a>
				PULSE_LED_I_2_ON;
 8008914:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8008918:	480b      	ldr	r0, [pc, #44]	; (8008948 <TIM4_IRQHandler+0x400>)
 800891a:	f7fb f899 	bl	8003a50 <GPIO_ResetBits>
 800891e:	e7e9      	b.n	80088f4 <TIM4_IRQHandler+0x3ac>
			gSequenceStepNumber_1 = (unsigned int) (pots_step[0]-1); //(float) AddData[6]/(float) (CalConstants[6]/15.0)
 8008920:	4b0b      	ldr	r3, [pc, #44]	; (8008950 <TIM4_IRQHandler+0x408>)
 8008922:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8008926:	3b01      	subs	r3, #1
 8008928:	b2db      	uxtb	r3, r3
 800892a:	4c08      	ldr	r4, [pc, #32]	; (800894c <TIM4_IRQHandler+0x404>)
 800892c:	7163      	strb	r3, [r4, #5]
			DAC_SetChannel1Data(DAC_Align_12b_R, GetStepVoltage(0, gSequenceStepNumber_1));
 800892e:	7961      	ldrb	r1, [r4, #5]
 8008930:	2000      	movs	r0, #0
 8008932:	f7ff fb55 	bl	8007fe0 <GetStepVoltage>
 8008936:	b281      	uxth	r1, r0
 8008938:	2000      	movs	r0, #0
 800893a:	f7f9 fea1 	bl	8002680 <DAC_SetChannel1Data>
		gSequencerMode_1 = gPrevSequencerMode_1;
 800893e:	78a3      	ldrb	r3, [r4, #2]
 8008940:	b2db      	uxtb	r3, r3
 8008942:	7063      	strb	r3, [r4, #1]
 8008944:	e6d8      	b.n	80086f8 <TIM4_IRQHandler+0x1b0>
 8008946:	bf00      	nop
 8008948:	40020400 	.word	0x40020400
 800894c:	200006b4 	.word	0x200006b4
 8008950:	20000258 	.word	0x20000258
 8008954:	20000cb4 	.word	0x20000cb4
 8008958:	40002000 	.word	0x40002000

0800895c <TIM5_IRQHandler>:

/*
 Timer interrupt handler for 1 section steps
*/
void TIM5_IRQHandler()
{
 800895c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	unsigned long int StepWidth_2=0;	
	float deltaVoltage;
	unsigned long CurStep;

	/* Clear interrupt flag */
	TIM5->SR = (uint16_t) ~TIM_IT_Update;
 8008960:	4eb5      	ldr	r6, [pc, #724]	; (8008c38 <TIM5_IRQHandler+0x2dc>)
 8008962:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8008966:	8233      	strh	r3, [r6, #16]
	
	/* Calculate next step duration */	
	
		/* Calculate next step duration */
		StepWidth_2 = GetStepWidth(1, gSequenceStepNumber_2);
 8008968:	4cb4      	ldr	r4, [pc, #720]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 800896a:	79a1      	ldrb	r1, [r4, #6]
 800896c:	2001      	movs	r0, #1
 800896e:	f7ff fa6b 	bl	8007e48 <GetStepWidth>
 8008972:	4605      	mov	r5, r0

		/* Calculate prescaler/multiplier*/
		TIM5->PSC = (uint16_t) (((((AddData[ADC_TIMEMULTIPLY_Ch_2])*3.5)/CalConstants[ADC_TIMEMULTIPLY_Ch_2])+0.5)*STEP_TIMER_PRESCALER);
 8008974:	4bb2      	ldr	r3, [pc, #712]	; (8008c40 <TIM5_IRQHandler+0x2e4>)
 8008976:	6958      	ldr	r0, [r3, #20]
 8008978:	f003 fa4a 	bl	800be10 <__aeabi_ui2d>
 800897c:	2200      	movs	r2, #0
 800897e:	4bb1      	ldr	r3, [pc, #708]	; (8008c44 <TIM5_IRQHandler+0x2e8>)
 8008980:	f003 fabc 	bl	800befc <__aeabi_dmul>
 8008984:	4680      	mov	r8, r0
 8008986:	4689      	mov	r9, r1
 8008988:	4baf      	ldr	r3, [pc, #700]	; (8008c48 <TIM5_IRQHandler+0x2ec>)
 800898a:	6998      	ldr	r0, [r3, #24]
 800898c:	f003 fa40 	bl	800be10 <__aeabi_ui2d>
 8008990:	4602      	mov	r2, r0
 8008992:	460b      	mov	r3, r1
 8008994:	4640      	mov	r0, r8
 8008996:	4649      	mov	r1, r9
 8008998:	f003 fbda 	bl	800c150 <__aeabi_ddiv>
 800899c:	2200      	movs	r2, #0
 800899e:	4bab      	ldr	r3, [pc, #684]	; (8008c4c <TIM5_IRQHandler+0x2f0>)
 80089a0:	f003 f8fa 	bl	800bb98 <__adddf3>
 80089a4:	a3a0      	add	r3, pc, #640	; (adr r3, 8008c28 <TIM5_IRQHandler+0x2cc>)
 80089a6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80089aa:	f003 faa7 	bl	800befc <__aeabi_dmul>
 80089ae:	f003 fcb7 	bl	800c320 <__aeabi_d2uiz>
 80089b2:	b280      	uxth	r0, r0
 80089b4:	8530      	strh	r0, [r6, #40]	; 0x28
		
		if (Steps[1][gSequenceStepNumber_2].b.Sloped) {
 80089b6:	79a3      	ldrb	r3, [r4, #6]
 80089b8:	3320      	adds	r3, #32
 80089ba:	4aa5      	ldr	r2, [pc, #660]	; (8008c50 <TIM5_IRQHandler+0x2f4>)
 80089bc:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 80089c0:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80089c4:	d059      	beq.n	8008a7a <TIM5_IRQHandler+0x11e>
			//Calculate the voltage in slope mode
			CurStep = GetStepVoltage(1, gSequenceStepNumber_2);
 80089c6:	4626      	mov	r6, r4
 80089c8:	79a1      	ldrb	r1, [r4, #6]
 80089ca:	2001      	movs	r0, #1
 80089cc:	f7ff fb08 	bl	8007fe0 <GetStepVoltage>
 80089d0:	4604      	mov	r4, r0
			if(gSequencerMode_2 == SEQUENCER_MODE_RUN || gSequencerMode_2 == SEQUENCER_MODE_ADVANCE)
 80089d2:	78f3      	ldrb	r3, [r6, #3]
 80089d4:	b16b      	cbz	r3, 80089f2 <TIM5_IRQHandler+0x96>
 80089d6:	78f3      	ldrb	r3, [r6, #3]
 80089d8:	b2db      	uxtb	r3, r3
 80089da:	2b06      	cmp	r3, #6
 80089dc:	d009      	beq.n	80089f2 <TIM5_IRQHandler+0x96>
					DAC_SetChannel2Data(DAC_Align_12b_R, PreviousStep_2 + (unsigned int) (deltaVoltage*gStepWidth_2) );
				};	
			}
			else
			{
				DAC_SetChannel2Data(DAC_Align_12b_R, GetStepVoltage(1, gSequenceStepNumber_2));
 80089de:	4b97      	ldr	r3, [pc, #604]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 80089e0:	7999      	ldrb	r1, [r3, #6]
 80089e2:	2001      	movs	r0, #1
 80089e4:	f7ff fafc 	bl	8007fe0 <GetStepVoltage>
 80089e8:	b281      	uxth	r1, r0
 80089ea:	2000      	movs	r0, #0
 80089ec:	f7f9 fe58 	bl	80026a0 <DAC_SetChannel2Data>
 80089f0:	e04c      	b.n	8008a8c <TIM5_IRQHandler+0x130>
				if (PreviousStep_2>CurStep) {
 80089f2:	4b92      	ldr	r3, [pc, #584]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 80089f4:	691b      	ldr	r3, [r3, #16]
 80089f6:	429c      	cmp	r4, r3
 80089f8:	d321      	bcc.n	8008a3e <TIM5_IRQHandler+0xe2>
				if (CurStep>PreviousStep_2) {
 80089fa:	4b90      	ldr	r3, [pc, #576]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 80089fc:	691b      	ldr	r3, [r3, #16]
 80089fe:	429c      	cmp	r4, r3
 8008a00:	d944      	bls.n	8008a8c <TIM5_IRQHandler+0x130>
					deltaVoltage =  (float) (CurStep-PreviousStep_2) / StepWidth_2;
 8008a02:	4b8e      	ldr	r3, [pc, #568]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008a04:	691a      	ldr	r2, [r3, #16]
 8008a06:	1aa4      	subs	r4, r4, r2
 8008a08:	ee07 4a90 	vmov	s15, r4
 8008a0c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8008a10:	ee07 5a10 	vmov	s14, r5
 8008a14:	eef8 6a47 	vcvt.f32.u32	s13, s14
 8008a18:	ee87 7aa6 	vdiv.f32	s14, s15, s13
					DAC_SetChannel2Data(DAC_Align_12b_R, PreviousStep_2 + (unsigned int) (deltaVoltage*gStepWidth_2) );
 8008a1c:	edd3 7a05 	vldr	s15, [r3, #20]
 8008a20:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8008a24:	ee67 7a87 	vmul.f32	s15, s15, s14
 8008a28:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8008a2c:	ee17 1a90 	vmov	r1, s15
 8008a30:	691b      	ldr	r3, [r3, #16]
 8008a32:	4419      	add	r1, r3
 8008a34:	b289      	uxth	r1, r1
 8008a36:	2000      	movs	r0, #0
 8008a38:	f7f9 fe32 	bl	80026a0 <DAC_SetChannel2Data>
 8008a3c:	e026      	b.n	8008a8c <TIM5_IRQHandler+0x130>
					deltaVoltage =  (float) (PreviousStep_2-CurStep) / StepWidth_2;
 8008a3e:	4a7f      	ldr	r2, [pc, #508]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008a40:	6913      	ldr	r3, [r2, #16]
 8008a42:	1b1b      	subs	r3, r3, r4
 8008a44:	ee07 3a90 	vmov	s15, r3
 8008a48:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8008a4c:	ee07 5a90 	vmov	s15, r5
 8008a50:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8008a54:	eec7 6a27 	vdiv.f32	s13, s14, s15
					DAC_SetChannel2Data(DAC_Align_12b_R, PreviousStep_2 - (unsigned int) (deltaVoltage*gStepWidth_2) );
 8008a58:	6911      	ldr	r1, [r2, #16]
 8008a5a:	edd2 7a05 	vldr	s15, [r2, #20]
 8008a5e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8008a62:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8008a66:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8008a6a:	ee17 3a90 	vmov	r3, s15
 8008a6e:	1ac9      	subs	r1, r1, r3
 8008a70:	b289      	uxth	r1, r1
 8008a72:	2000      	movs	r0, #0
 8008a74:	f7f9 fe14 	bl	80026a0 <DAC_SetChannel2Data>
 8008a78:	e7bf      	b.n	80089fa <TIM5_IRQHandler+0x9e>
			}
			
		} else {
			//Calculate the voltage in not slope mode
			DAC_SetChannel2Data(DAC_Align_12b_R, GetStepVoltage(1, gSequenceStepNumber_2));
 8008a7a:	4b70      	ldr	r3, [pc, #448]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008a7c:	7999      	ldrb	r1, [r3, #6]
 8008a7e:	2001      	movs	r0, #1
 8008a80:	f7ff faae 	bl	8007fe0 <GetStepVoltage>
 8008a84:	b281      	uxth	r1, r0
 8008a86:	2000      	movs	r0, #0
 8008a88:	f7f9 fe0a 	bl	80026a0 <DAC_SetChannel2Data>
		};

			MAX5135_DAC_send(EXT_DAC_CH_2, Steps[1][gSequenceStepNumber_2].b.TLevel >> 2);
 8008a8c:	4c6b      	ldr	r4, [pc, #428]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008a8e:	79a3      	ldrb	r3, [r4, #6]
 8008a90:	3320      	adds	r3, #32
 8008a92:	4a6f      	ldr	r2, [pc, #444]	; (8008c50 <TIM5_IRQHandler+0x2f4>)
 8008a94:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
 8008a98:	f341 3189 	sbfx	r1, r1, #14, #10
 8008a9c:	2002      	movs	r0, #2
 8008a9e:	f7fe fd2b 	bl	80074f8 <MAX5135_DAC_send>
			MAX5135_DAC_send(EXT_DAC_CH_3, 0x3FF - (unsigned int) (((double) 0x3FF/ (double) StepWidth_2)*((double) gStepWidth_2)) );
 8008aa2:	4628      	mov	r0, r5
 8008aa4:	f003 f9b4 	bl	800be10 <__aeabi_ui2d>
 8008aa8:	4602      	mov	r2, r0
 8008aaa:	460b      	mov	r3, r1
 8008aac:	a160      	add	r1, pc, #384	; (adr r1, 8008c30 <TIM5_IRQHandler+0x2d4>)
 8008aae:	e9d1 0100 	ldrd	r0, r1, [r1]
 8008ab2:	f003 fb4d 	bl	800c150 <__aeabi_ddiv>
 8008ab6:	4606      	mov	r6, r0
 8008ab8:	460f      	mov	r7, r1
 8008aba:	6960      	ldr	r0, [r4, #20]
 8008abc:	f003 f9a8 	bl	800be10 <__aeabi_ui2d>
 8008ac0:	4602      	mov	r2, r0
 8008ac2:	460b      	mov	r3, r1
 8008ac4:	4630      	mov	r0, r6
 8008ac6:	4639      	mov	r1, r7
 8008ac8:	f003 fa18 	bl	800befc <__aeabi_dmul>
 8008acc:	f003 fc28 	bl	800c320 <__aeabi_d2uiz>
 8008ad0:	f5c0 717f 	rsb	r1, r0, #1020	; 0x3fc
 8008ad4:	3103      	adds	r1, #3
 8008ad6:	2003      	movs	r0, #3
 8008ad8:	f7fe fd0e 	bl	80074f8 <MAX5135_DAC_send>

	/* Increment step counter */
		if ((gSequencerMode_2 == SEQUENCER_MODE_RUN ) || ((gSequencerMode_2 == SEQUENCER_MODE_ADVANCE)))
 8008adc:	78e3      	ldrb	r3, [r4, #3]
 8008ade:	b11b      	cbz	r3, 8008ae8 <TIM5_IRQHandler+0x18c>
 8008ae0:	78e3      	ldrb	r3, [r4, #3]
 8008ae2:	b2db      	uxtb	r3, r3
 8008ae4:	2b06      	cmp	r3, #6
 8008ae6:	d103      	bne.n	8008af0 <TIM5_IRQHandler+0x194>
		{
			gStepWidth_2++;
 8008ae8:	4a54      	ldr	r2, [pc, #336]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008aea:	6953      	ldr	r3, [r2, #20]
 8008aec:	3301      	adds	r3, #1
 8008aee:	6153      	str	r3, [r2, #20]
		};

		if ((gStepWidth_2 < StepWidth_2)) {
 8008af0:	4b52      	ldr	r3, [pc, #328]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008af2:	695b      	ldr	r3, [r3, #20]
 8008af4:	429d      	cmp	r5, r3
 8008af6:	d913      	bls.n	8008b20 <TIM5_IRQHandler+0x1c4>
				TIM_SetCounter(TIM8, 0x00);
			}; 
		};
	

	if (gSequencerMode_2 == SEQUENCER_MODE_WAIT) {
 8008af8:	4b50      	ldr	r3, [pc, #320]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008afa:	78db      	ldrb	r3, [r3, #3]
 8008afc:	b2db      	uxtb	r3, r3
 8008afe:	2b01      	cmp	r3, #1
 8008b00:	f000 80e0 	beq.w	8008cc4 <TIM5_IRQHandler+0x368>
			TIM_Cmd(TIM8, ENABLE);
			TIM_SetCounter(TIM8, 0x00);
		}
	};	
	
		if (gSequencerMode_2 == SEQUENCER_MODE_WAIT_STROBE) {
 8008b04:	4b4d      	ldr	r3, [pc, #308]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008b06:	78db      	ldrb	r3, [r3, #3]
 8008b08:	b2db      	uxtb	r3, r3
 8008b0a:	2b03      	cmp	r3, #3
 8008b0c:	f000 8121 	beq.w	8008d52 <TIM5_IRQHandler+0x3f6>

		gSequencerMode_2 = gPrevSequencerMode_2;
	}
	
	
	if ( gDisplayMode == DISPLAY_MODE_VIEW_2 ) {
 8008b10:	4b4a      	ldr	r3, [pc, #296]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008b12:	79db      	ldrb	r3, [r3, #7]
 8008b14:	b2db      	uxtb	r3, r3
 8008b16:	2b01      	cmp	r3, #1
 8008b18:	f000 812e 	beq.w	8008d78 <TIM5_IRQHandler+0x41c>
 8008b1c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			PreviousStep_2 = GetStepVoltage(1, gSequenceStepNumber_2);	
 8008b20:	4c46      	ldr	r4, [pc, #280]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008b22:	79a1      	ldrb	r1, [r4, #6]
 8008b24:	2001      	movs	r0, #1
 8008b26:	f7ff fa5b 	bl	8007fe0 <GetStepVoltage>
 8008b2a:	6120      	str	r0, [r4, #16]
			if((gSequencerMode_2 == SEQUENCER_MODE_ADVANCE)) { 
 8008b2c:	78e3      	ldrb	r3, [r4, #3]
 8008b2e:	b2db      	uxtb	r3, r3
 8008b30:	2b06      	cmp	r3, #6
 8008b32:	d073      	beq.n	8008c1c <TIM5_IRQHandler+0x2c0>
			if (Steps[1][gSequenceStepNumber_2].b.OpModeSTOP) {
 8008b34:	4b41      	ldr	r3, [pc, #260]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008b36:	799b      	ldrb	r3, [r3, #6]
 8008b38:	f103 0220 	add.w	r2, r3, #32
 8008b3c:	4b44      	ldr	r3, [pc, #272]	; (8008c50 <TIM5_IRQHandler+0x2f4>)
 8008b3e:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008b42:	685b      	ldr	r3, [r3, #4]
 8008b44:	f013 0f02 	tst.w	r3, #2
 8008b48:	d005      	beq.n	8008b56 <TIM5_IRQHandler+0x1fa>
				gPrevSequencerMode_2 = gSequencerMode_2;
 8008b4a:	4b3c      	ldr	r3, [pc, #240]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008b4c:	78da      	ldrb	r2, [r3, #3]
 8008b4e:	b2d2      	uxtb	r2, r2
 8008b50:	711a      	strb	r2, [r3, #4]
				gSequencerMode_2 = SEQUENCER_MODE_STOP;				
 8008b52:	2202      	movs	r2, #2
 8008b54:	70da      	strb	r2, [r3, #3]
			if ( (Steps[1][gSequenceStepNumber_2].b.OpModeENABLE))  {
 8008b56:	4b39      	ldr	r3, [pc, #228]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008b58:	799b      	ldrb	r3, [r3, #6]
 8008b5a:	f103 0220 	add.w	r2, r3, #32
 8008b5e:	4b3c      	ldr	r3, [pc, #240]	; (8008c50 <TIM5_IRQHandler+0x2f4>)
 8008b60:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008b64:	685b      	ldr	r3, [r3, #4]
 8008b66:	f013 0f08 	tst.w	r3, #8
 8008b6a:	d177      	bne.n	8008c5c <TIM5_IRQHandler+0x300>
			if ( (Steps[1][gSequenceStepNumber_2].b.OpModeSUSTAIN)) {
 8008b6c:	4b33      	ldr	r3, [pc, #204]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008b6e:	799b      	ldrb	r3, [r3, #6]
 8008b70:	f103 0220 	add.w	r2, r3, #32
 8008b74:	4b36      	ldr	r3, [pc, #216]	; (8008c50 <TIM5_IRQHandler+0x2f4>)
 8008b76:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008b7a:	685b      	ldr	r3, [r3, #4]
 8008b7c:	f013 0f04 	tst.w	r3, #4
 8008b80:	d17f      	bne.n	8008c82 <TIM5_IRQHandler+0x326>
			if ( (!(Steps[1][gSequenceStepNumber_2].b.OpModeSTOP)) &&
 8008b82:	4b2e      	ldr	r3, [pc, #184]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008b84:	799b      	ldrb	r3, [r3, #6]
 8008b86:	f103 0220 	add.w	r2, r3, #32
 8008b8a:	4b31      	ldr	r3, [pc, #196]	; (8008c50 <TIM5_IRQHandler+0x2f4>)
 8008b8c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008b90:	685b      	ldr	r3, [r3, #4]
 8008b92:	f013 0f02 	tst.w	r3, #2
 8008b96:	d112      	bne.n	8008bbe <TIM5_IRQHandler+0x262>
					(!(Steps[1][gSequenceStepNumber_2].b.OpModeENABLE)) &&
 8008b98:	4b28      	ldr	r3, [pc, #160]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008b9a:	799b      	ldrb	r3, [r3, #6]
 8008b9c:	f103 0220 	add.w	r2, r3, #32
 8008ba0:	4b2b      	ldr	r3, [pc, #172]	; (8008c50 <TIM5_IRQHandler+0x2f4>)
 8008ba2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008ba6:	685b      	ldr	r3, [r3, #4]
			if ( (!(Steps[1][gSequenceStepNumber_2].b.OpModeSTOP)) &&
 8008ba8:	f013 0f08 	tst.w	r3, #8
 8008bac:	d107      	bne.n	8008bbe <TIM5_IRQHandler+0x262>
					(!(Steps[1][gSequenceStepNumber_2].b.OpModeSUSTAIN)) ) {
 8008bae:	4b23      	ldr	r3, [pc, #140]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008bb0:	799b      	ldrb	r3, [r3, #6]
 8008bb2:	f103 0220 	add.w	r2, r3, #32
 8008bb6:	4b26      	ldr	r3, [pc, #152]	; (8008c50 <TIM5_IRQHandler+0x2f4>)
 8008bb8:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008bbc:	685b      	ldr	r3, [r3, #4]
			gStepWidth_2 = 0;
 8008bbe:	4b1f      	ldr	r3, [pc, #124]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008bc0:	2200      	movs	r2, #0
 8008bc2:	615a      	str	r2, [r3, #20]
			if (gSequencerMode_2 == SEQUENCER_MODE_RUN) {
 8008bc4:	78db      	ldrb	r3, [r3, #3]
 8008bc6:	2b00      	cmp	r3, #0
 8008bc8:	d196      	bne.n	8008af8 <TIM5_IRQHandler+0x19c>
					gSequenceStepNumber_2 = GetNextStep(1, gSequenceStepNumber_2);
 8008bca:	4c1c      	ldr	r4, [pc, #112]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008bcc:	79a1      	ldrb	r1, [r4, #6]
 8008bce:	2001      	movs	r0, #1
 8008bd0:	f7ff fb5e 	bl	8008290 <GetNextStep>
 8008bd4:	71a0      	strb	r0, [r4, #6]
				PULSE_LED_II_ALL_ON;
 8008bd6:	2104      	movs	r1, #4
 8008bd8:	481e      	ldr	r0, [pc, #120]	; (8008c54 <TIM5_IRQHandler+0x2f8>)
 8008bda:	f7fa ff39 	bl	8003a50 <GPIO_ResetBits>
				if (Steps[1][gSequenceStepNumber_2].b.OutputPulse1) {
 8008bde:	79a3      	ldrb	r3, [r4, #6]
 8008be0:	f103 0220 	add.w	r2, r3, #32
 8008be4:	4b1a      	ldr	r3, [pc, #104]	; (8008c50 <TIM5_IRQHandler+0x2f4>)
 8008be6:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008bea:	685b      	ldr	r3, [r3, #4]
 8008bec:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8008bf0:	d15d      	bne.n	8008cae <TIM5_IRQHandler+0x352>
				if (Steps[1][gSequenceStepNumber_2].b.OutputPulse2) {
 8008bf2:	4b12      	ldr	r3, [pc, #72]	; (8008c3c <TIM5_IRQHandler+0x2e0>)
 8008bf4:	799b      	ldrb	r3, [r3, #6]
 8008bf6:	f103 0220 	add.w	r2, r3, #32
 8008bfa:	4b15      	ldr	r3, [pc, #84]	; (8008c50 <TIM5_IRQHandler+0x2f4>)
 8008bfc:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008c00:	685b      	ldr	r3, [r3, #4]
 8008c02:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8008c06:	d157      	bne.n	8008cb8 <TIM5_IRQHandler+0x35c>
				TIM_Cmd(TIM8, ENABLE);
 8008c08:	4c13      	ldr	r4, [pc, #76]	; (8008c58 <TIM5_IRQHandler+0x2fc>)
 8008c0a:	2101      	movs	r1, #1
 8008c0c:	4620      	mov	r0, r4
 8008c0e:	f7fd fae1 	bl	80061d4 <TIM_Cmd>
				TIM_SetCounter(TIM8, 0x00);
 8008c12:	2100      	movs	r1, #0
 8008c14:	4620      	mov	r0, r4
 8008c16:	f7fd fa94 	bl	8006142 <TIM_SetCounter>
 8008c1a:	e76d      	b.n	8008af8 <TIM5_IRQHandler+0x19c>
				gSequencerMode_2 = gPrevSequencerMode_2;
 8008c1c:	7923      	ldrb	r3, [r4, #4]
 8008c1e:	b2db      	uxtb	r3, r3
 8008c20:	70e3      	strb	r3, [r4, #3]
 8008c22:	e787      	b.n	8008b34 <TIM5_IRQHandler+0x1d8>
 8008c24:	f3af 8000 	nop.w
 8008c28:	00000000 	.word	0x00000000
 8008c2c:	40c48200 	.word	0x40c48200
 8008c30:	00000000 	.word	0x00000000
 8008c34:	408ff800 	.word	0x408ff800
 8008c38:	40000c00 	.word	0x40000c00
 8008c3c:	200006b4 	.word	0x200006b4
 8008c40:	20000c0c 	.word	0x20000c0c
 8008c44:	400c0000 	.word	0x400c0000
 8008c48:	20000258 	.word	0x20000258
 8008c4c:	3fe00000 	.word	0x3fe00000
 8008c50:	20000cb4 	.word	0x20000cb4
 8008c54:	40020000 	.word	0x40020000
 8008c58:	40010400 	.word	0x40010400
				if( (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_6) == 0)) 
 8008c5c:	2140      	movs	r1, #64	; 0x40
 8008c5e:	484b      	ldr	r0, [pc, #300]	; (8008d8c <TIM5_IRQHandler+0x430>)
 8008c60:	f7fa fee0 	bl	8003a24 <GPIO_ReadInputDataBit>
 8008c64:	2800      	cmp	r0, #0
 8008c66:	d181      	bne.n	8008b6c <TIM5_IRQHandler+0x210>
					if(gSequencerMode_2 != SEQUENCER_MODE_WAIT_HI_Z)
 8008c68:	4b49      	ldr	r3, [pc, #292]	; (8008d90 <TIM5_IRQHandler+0x434>)
 8008c6a:	78db      	ldrb	r3, [r3, #3]
 8008c6c:	b2db      	uxtb	r3, r3
 8008c6e:	2b04      	cmp	r3, #4
 8008c70:	f43f af7c 	beq.w	8008b6c <TIM5_IRQHandler+0x210>
						gPrevSequencerMode_2 = gSequencerMode_2;
 8008c74:	4b46      	ldr	r3, [pc, #280]	; (8008d90 <TIM5_IRQHandler+0x434>)
 8008c76:	78da      	ldrb	r2, [r3, #3]
 8008c78:	b2d2      	uxtb	r2, r2
 8008c7a:	711a      	strb	r2, [r3, #4]
						gSequencerMode_2 = SEQUENCER_MODE_WAIT_HI_Z;
 8008c7c:	2204      	movs	r2, #4
 8008c7e:	70da      	strb	r2, [r3, #3]
 8008c80:	e774      	b.n	8008b6c <TIM5_IRQHandler+0x210>
				if( (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_6) == 1)) 
 8008c82:	2140      	movs	r1, #64	; 0x40
 8008c84:	4841      	ldr	r0, [pc, #260]	; (8008d8c <TIM5_IRQHandler+0x430>)
 8008c86:	f7fa fecd 	bl	8003a24 <GPIO_ReadInputDataBit>
 8008c8a:	2801      	cmp	r0, #1
 8008c8c:	f47f af79 	bne.w	8008b82 <TIM5_IRQHandler+0x226>
					if(gSequencerMode_2 != SEQUENCER_MODE_STAY_HI_Z)
 8008c90:	4b3f      	ldr	r3, [pc, #252]	; (8008d90 <TIM5_IRQHandler+0x434>)
 8008c92:	78db      	ldrb	r3, [r3, #3]
 8008c94:	b2db      	uxtb	r3, r3
 8008c96:	2b05      	cmp	r3, #5
 8008c98:	f43f af73 	beq.w	8008b82 <TIM5_IRQHandler+0x226>
						gPrevSequencerMode_2 = gSequencerMode_2;
 8008c9c:	4b3c      	ldr	r3, [pc, #240]	; (8008d90 <TIM5_IRQHandler+0x434>)
 8008c9e:	78da      	ldrb	r2, [r3, #3]
 8008ca0:	b2d2      	uxtb	r2, r2
 8008ca2:	711a      	strb	r2, [r3, #4]
						gSequencerMode_2 = SEQUENCER_MODE_STAY_HI_Z;
 8008ca4:	2205      	movs	r2, #5
 8008ca6:	70da      	strb	r2, [r3, #3]
						InitStart_2_SignalTimer();
 8008ca8:	f7fe ffa4 	bl	8007bf4 <InitStart_2_SignalTimer>
 8008cac:	e769      	b.n	8008b82 <TIM5_IRQHandler+0x226>
					PULSE_LED_II_1_ON;
 8008cae:	2108      	movs	r1, #8
 8008cb0:	4838      	ldr	r0, [pc, #224]	; (8008d94 <TIM5_IRQHandler+0x438>)
 8008cb2:	f7fa fecd 	bl	8003a50 <GPIO_ResetBits>
 8008cb6:	e79c      	b.n	8008bf2 <TIM5_IRQHandler+0x296>
					PULSE_LED_II_2_ON;
 8008cb8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008cbc:	4835      	ldr	r0, [pc, #212]	; (8008d94 <TIM5_IRQHandler+0x438>)
 8008cbe:	f7fa fec7 	bl	8003a50 <GPIO_ResetBits>
 8008cc2:	e7a1      	b.n	8008c08 <TIM5_IRQHandler+0x2ac>
		if(gSequenceStepNumber_2 != (unsigned int)(pots_step[1]-1))
 8008cc4:	4b32      	ldr	r3, [pc, #200]	; (8008d90 <TIM5_IRQHandler+0x434>)
 8008cc6:	799a      	ldrb	r2, [r3, #6]
 8008cc8:	b2d2      	uxtb	r2, r2
 8008cca:	4b33      	ldr	r3, [pc, #204]	; (8008d98 <TIM5_IRQHandler+0x43c>)
 8008ccc:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8008cd0:	3b01      	subs	r3, #1
 8008cd2:	429a      	cmp	r2, r3
 8008cd4:	f43f af16 	beq.w	8008b04 <TIM5_IRQHandler+0x1a8>
			gSequenceStepNumber_2 = (unsigned int)(pots_step[1]-1);
 8008cd8:	4b2f      	ldr	r3, [pc, #188]	; (8008d98 <TIM5_IRQHandler+0x43c>)
 8008cda:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8008cde:	3b01      	subs	r3, #1
 8008ce0:	b2db      	uxtb	r3, r3
 8008ce2:	4c2b      	ldr	r4, [pc, #172]	; (8008d90 <TIM5_IRQHandler+0x434>)
 8008ce4:	71a3      	strb	r3, [r4, #6]
			DAC_SetChannel2Data(DAC_Align_12b_R, GetStepVoltage(1, gSequenceStepNumber_2));
 8008ce6:	79a1      	ldrb	r1, [r4, #6]
 8008ce8:	2001      	movs	r0, #1
 8008cea:	f7ff f979 	bl	8007fe0 <GetStepVoltage>
 8008cee:	b281      	uxth	r1, r0
 8008cf0:	2000      	movs	r0, #0
 8008cf2:	f7f9 fcd5 	bl	80026a0 <DAC_SetChannel2Data>
			PULSE_LED_II_ALL_ON;
 8008cf6:	2104      	movs	r1, #4
 8008cf8:	4826      	ldr	r0, [pc, #152]	; (8008d94 <TIM5_IRQHandler+0x438>)
 8008cfa:	f7fa fea9 	bl	8003a50 <GPIO_ResetBits>
			if (Steps[1][gSequenceStepNumber_2].b.OutputPulse1) {
 8008cfe:	79a3      	ldrb	r3, [r4, #6]
 8008d00:	f103 0220 	add.w	r2, r3, #32
 8008d04:	4b25      	ldr	r3, [pc, #148]	; (8008d9c <TIM5_IRQHandler+0x440>)
 8008d06:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008d0a:	685b      	ldr	r3, [r3, #4]
 8008d0c:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8008d10:	d114      	bne.n	8008d3c <TIM5_IRQHandler+0x3e0>
			if (Steps[1][gSequenceStepNumber_2].b.OutputPulse2) {
 8008d12:	4b1f      	ldr	r3, [pc, #124]	; (8008d90 <TIM5_IRQHandler+0x434>)
 8008d14:	799b      	ldrb	r3, [r3, #6]
 8008d16:	f103 0220 	add.w	r2, r3, #32
 8008d1a:	4b20      	ldr	r3, [pc, #128]	; (8008d9c <TIM5_IRQHandler+0x440>)
 8008d1c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8008d20:	685b      	ldr	r3, [r3, #4]
 8008d22:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8008d26:	d10e      	bne.n	8008d46 <TIM5_IRQHandler+0x3ea>
			TIM_Cmd(TIM8, ENABLE);
 8008d28:	4c1d      	ldr	r4, [pc, #116]	; (8008da0 <TIM5_IRQHandler+0x444>)
 8008d2a:	2101      	movs	r1, #1
 8008d2c:	4620      	mov	r0, r4
 8008d2e:	f7fd fa51 	bl	80061d4 <TIM_Cmd>
			TIM_SetCounter(TIM8, 0x00);
 8008d32:	2100      	movs	r1, #0
 8008d34:	4620      	mov	r0, r4
 8008d36:	f7fd fa04 	bl	8006142 <TIM_SetCounter>
 8008d3a:	e6e3      	b.n	8008b04 <TIM5_IRQHandler+0x1a8>
				PULSE_LED_II_1_ON;
 8008d3c:	2108      	movs	r1, #8
 8008d3e:	4815      	ldr	r0, [pc, #84]	; (8008d94 <TIM5_IRQHandler+0x438>)
 8008d40:	f7fa fe86 	bl	8003a50 <GPIO_ResetBits>
 8008d44:	e7e5      	b.n	8008d12 <TIM5_IRQHandler+0x3b6>
				PULSE_LED_II_2_ON;
 8008d46:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008d4a:	4812      	ldr	r0, [pc, #72]	; (8008d94 <TIM5_IRQHandler+0x438>)
 8008d4c:	f7fa fe80 	bl	8003a50 <GPIO_ResetBits>
 8008d50:	e7ea      	b.n	8008d28 <TIM5_IRQHandler+0x3cc>
			gSequenceStepNumber_2 = (unsigned int)(pots_step[1]-1);
 8008d52:	4b11      	ldr	r3, [pc, #68]	; (8008d98 <TIM5_IRQHandler+0x43c>)
 8008d54:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8008d58:	3b01      	subs	r3, #1
 8008d5a:	b2db      	uxtb	r3, r3
 8008d5c:	4c0c      	ldr	r4, [pc, #48]	; (8008d90 <TIM5_IRQHandler+0x434>)
 8008d5e:	71a3      	strb	r3, [r4, #6]
			DAC_SetChannel2Data(DAC_Align_12b_R, GetStepVoltage(1, gSequenceStepNumber_2));
 8008d60:	79a1      	ldrb	r1, [r4, #6]
 8008d62:	2001      	movs	r0, #1
 8008d64:	f7ff f93c 	bl	8007fe0 <GetStepVoltage>
 8008d68:	b281      	uxth	r1, r0
 8008d6a:	2000      	movs	r0, #0
 8008d6c:	f7f9 fc98 	bl	80026a0 <DAC_SetChannel2Data>
		gSequencerMode_2 = gPrevSequencerMode_2;
 8008d70:	7923      	ldrb	r3, [r4, #4]
 8008d72:	b2db      	uxtb	r3, r3
 8008d74:	70e3      	strb	r3, [r4, #3]
 8008d76:	e6cb      	b.n	8008b10 <TIM5_IRQHandler+0x1b4>
		DisplayUpdateFlags.b.MainDisplay = 1;
 8008d78:	4b0a      	ldr	r3, [pc, #40]	; (8008da4 <TIM5_IRQHandler+0x448>)
 8008d7a:	781a      	ldrb	r2, [r3, #0]
 8008d7c:	f042 0201 	orr.w	r2, r2, #1
 8008d80:	701a      	strb	r2, [r3, #0]
		DisplayUpdateFlags.b.StepsDisplay = 1;
 8008d82:	781a      	ldrb	r2, [r3, #0]
 8008d84:	f042 0202 	orr.w	r2, r2, #2
 8008d88:	701a      	strb	r2, [r3, #0]
	};	
		return;
 8008d8a:	e6c7      	b.n	8008b1c <TIM5_IRQHandler+0x1c0>
 8008d8c:	40020400 	.word	0x40020400
 8008d90:	200006b4 	.word	0x200006b4
 8008d94:	40020000 	.word	0x40020000
 8008d98:	20000258 	.word	0x20000258
 8008d9c:	20000cb4 	.word	0x20000cb4
 8008da0:	40010400 	.word	0x40010400
 8008da4:	20000708 	.word	0x20000708

08008da8 <mTimersInit>:

/*
	Init 2 timers to control steps
*/
void mTimersInit(void)
{
 8008da8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8008dac:	b084      	sub	sp, #16
	TIM_TimeBaseInitTypeDef myTimer;
	NVIC_InitTypeDef nvicStructure;
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
 8008dae:	2101      	movs	r1, #1
 8008db0:	2004      	movs	r0, #4
 8008db2:	f7fb fdb3 	bl	800491c <RCC_APB1PeriphClockCmd>

	TIM_TimeBaseStructInit(&myTimer);
 8008db6:	a801      	add	r0, sp, #4
 8008db8:	f7fd f9b0 	bl	800611c <TIM_TimeBaseStructInit>
	myTimer.TIM_Prescaler = STEP_TIMER_PRESCALER;
 8008dbc:	f642 1304 	movw	r3, #10500	; 0x2904
 8008dc0:	f8ad 3004 	strh.w	r3, [sp, #4]
	myTimer.TIM_Period = 1;
 8008dc4:	2401      	movs	r4, #1
 8008dc6:	9402      	str	r4, [sp, #8]
	myTimer.TIM_ClockDivision = TIM_CKD_DIV1;
 8008dc8:	2500      	movs	r5, #0
 8008dca:	f8ad 500c 	strh.w	r5, [sp, #12]
	myTimer.TIM_CounterMode = TIM_CounterMode_Up;
 8008dce:	f8ad 5006 	strh.w	r5, [sp, #6]
	
	TIM_TimeBaseInit(TIM4, &myTimer);	
 8008dd2:	4f4c      	ldr	r7, [pc, #304]	; (8008f04 <mTimersInit+0x15c>)
 8008dd4:	a901      	add	r1, sp, #4
 8008dd6:	4638      	mov	r0, r7
 8008dd8:	f7fd f962 	bl	80060a0 <TIM_TimeBaseInit>
	TIM_ARRPreloadConfig(TIM4, ENABLE);
 8008ddc:	4621      	mov	r1, r4
 8008dde:	4638      	mov	r0, r7
 8008de0:	f7fd f9d4 	bl	800618c <TIM_ARRPreloadConfig>
	TIM_Cmd(TIM4, ENABLE);
 8008de4:	4621      	mov	r1, r4
 8008de6:	4638      	mov	r0, r7
 8008de8:	f7fd f9f4 	bl	80061d4 <TIM_Cmd>
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);
 8008dec:	4621      	mov	r1, r4
 8008dee:	2008      	movs	r0, #8
 8008df0:	f7fb fd94 	bl	800491c <RCC_APB1PeriphClockCmd>
	TIM_TimeBaseInit(TIM5, &myTimer);
 8008df4:	4e44      	ldr	r6, [pc, #272]	; (8008f08 <mTimersInit+0x160>)
 8008df6:	a901      	add	r1, sp, #4
 8008df8:	4630      	mov	r0, r6
 8008dfa:	f7fd f951 	bl	80060a0 <TIM_TimeBaseInit>
	TIM_ARRPreloadConfig(TIM5, ENABLE);
 8008dfe:	4621      	mov	r1, r4
 8008e00:	4630      	mov	r0, r6
 8008e02:	f7fd f9c3 	bl	800618c <TIM_ARRPreloadConfig>
	TIM_Cmd(TIM5, ENABLE);
 8008e06:	4621      	mov	r1, r4
 8008e08:	4630      	mov	r0, r6
 8008e0a:	f7fd f9e3 	bl	80061d4 <TIM_Cmd>
	
	TIM_ITConfig(TIM4, TIM_IT_Update, ENABLE);
 8008e0e:	4622      	mov	r2, r4
 8008e10:	4621      	mov	r1, r4
 8008e12:	4638      	mov	r0, r7
 8008e14:	f7fd fce5 	bl	80067e2 <TIM_ITConfig>
	TIM_ITConfig(TIM5, TIM_IT_Update, ENABLE);
 8008e18:	4622      	mov	r2, r4
 8008e1a:	4621      	mov	r1, r4
 8008e1c:	4630      	mov	r0, r6
 8008e1e:	f7fd fce0 	bl	80067e2 <TIM_ITConfig>
	
	
	
	nvicStructure.NVIC_IRQChannel = TIM4_IRQn;
 8008e22:	231e      	movs	r3, #30
 8008e24:	f88d 3000 	strb.w	r3, [sp]
	nvicStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8008e28:	f88d 5001 	strb.w	r5, [sp, #1]
	nvicStructure.NVIC_IRQChannelSubPriority = 0;
 8008e2c:	f88d 5002 	strb.w	r5, [sp, #2]
	nvicStructure.NVIC_IRQChannelCmd = ENABLE;
 8008e30:	f88d 4003 	strb.w	r4, [sp, #3]
	NVIC_Init(&nvicStructure);
 8008e34:	4668      	mov	r0, sp
 8008e36:	f7f7 f9d1 	bl	80001dc <NVIC_Init>
	
	nvicStructure.NVIC_IRQChannel = TIM5_IRQn;
 8008e3a:	2332      	movs	r3, #50	; 0x32
 8008e3c:	f88d 3000 	strb.w	r3, [sp]
	nvicStructure.NVIC_IRQChannelPreemptionPriority = 0;
 8008e40:	f88d 5001 	strb.w	r5, [sp, #1]
	nvicStructure.NVIC_IRQChannelSubPriority = 0;
 8008e44:	f88d 5002 	strb.w	r5, [sp, #2]
	nvicStructure.NVIC_IRQChannelCmd = ENABLE;
 8008e48:	f88d 4003 	strb.w	r4, [sp, #3]
	NVIC_Init(&nvicStructure);
 8008e4c:	4668      	mov	r0, sp
 8008e4e:	f7f7 f9c5 	bl	80001dc <NVIC_Init>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
 8008e52:	4e2e      	ldr	r6, [pc, #184]	; (8008f0c <mTimersInit+0x164>)
 8008e54:	f886 531e 	strb.w	r5, [r6, #798]	; 0x31e
 8008e58:	f886 5332 	strb.w	r5, [r6, #818]	; 0x332
	
	NVIC_SetPriority (TIM4_IRQn, 0);
	NVIC_SetPriority (TIM5_IRQn, 0);
	
	SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup_0;
 8008e5c:	4a2c      	ldr	r2, [pc, #176]	; (8008f10 <mTimersInit+0x168>)
 8008e5e:	4b2d      	ldr	r3, [pc, #180]	; (8008f14 <mTimersInit+0x16c>)
 8008e60:	60da      	str	r2, [r3, #12]
	
	gStepWidth_1 = 8;
 8008e62:	4b2d      	ldr	r3, [pc, #180]	; (8008f18 <mTimersInit+0x170>)
 8008e64:	2208      	movs	r2, #8
 8008e66:	60da      	str	r2, [r3, #12]
	gStepWidth_2 = 8;
 8008e68:	615a      	str	r2, [r3, #20]
	gFullStepWidth_1 = 8;
 8008e6a:	619a      	str	r2, [r3, #24]
	gFullStepWidth_2 = 8;
 8008e6c:	61da      	str	r2, [r3, #28]
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM14, ENABLE);
 8008e6e:	4621      	mov	r1, r4
 8008e70:	f44f 7080 	mov.w	r0, #256	; 0x100
 8008e74:	f7fb fd52 	bl	800491c <RCC_APB1PeriphClockCmd>
	
	TIM_TimeBaseStructInit(&myTimer);
 8008e78:	a801      	add	r0, sp, #4
 8008e7a:	f7fd f94f 	bl	800611c <TIM_TimeBaseStructInit>
	myTimer.TIM_Prescaler = 210;
 8008e7e:	f04f 08d2 	mov.w	r8, #210	; 0xd2
 8008e82:	f8ad 8004 	strh.w	r8, [sp, #4]
	myTimer.TIM_Period = 320;
 8008e86:	f44f 73a0 	mov.w	r3, #320	; 0x140
 8008e8a:	9302      	str	r3, [sp, #8]
	myTimer.TIM_ClockDivision = TIM_CKD_DIV1;
 8008e8c:	f8ad 500c 	strh.w	r5, [sp, #12]
	myTimer.TIM_CounterMode = TIM_CounterMode_Up;
 8008e90:	f8ad 5006 	strh.w	r5, [sp, #6]
	
	TIM_TimeBaseInit(TIM14, &myTimer);	
 8008e94:	f507 57c0 	add.w	r7, r7, #6144	; 0x1800
 8008e98:	a901      	add	r1, sp, #4
 8008e9a:	4638      	mov	r0, r7
 8008e9c:	f7fd f900 	bl	80060a0 <TIM_TimeBaseInit>
	
	TIM_Cmd(TIM14, DISABLE);
 8008ea0:	4629      	mov	r1, r5
 8008ea2:	4638      	mov	r0, r7
 8008ea4:	f7fd f996 	bl	80061d4 <TIM_Cmd>
	TIM_ITConfig(TIM14, TIM_IT_Update, ENABLE);
 8008ea8:	4622      	mov	r2, r4
 8008eaa:	4621      	mov	r1, r4
 8008eac:	4638      	mov	r0, r7
 8008eae:	f7fd fc98 	bl	80067e2 <TIM_ITConfig>
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
 8008eb2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8008eb6:	6073      	str	r3, [r6, #4]
	NVIC_EnableIRQ(TIM8_TRG_COM_TIM14_IRQn);
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);
 8008eb8:	4621      	mov	r1, r4
 8008eba:	2002      	movs	r0, #2
 8008ebc:	f7fb fd3c 	bl	8004938 <RCC_APB2PeriphClockCmd>
	
	TIM_TimeBaseStructInit(&myTimer);
 8008ec0:	a801      	add	r0, sp, #4
 8008ec2:	f7fd f92b 	bl	800611c <TIM_TimeBaseStructInit>
	myTimer.TIM_Prescaler = 210;
 8008ec6:	f8ad 8004 	strh.w	r8, [sp, #4]
	myTimer.TIM_Period = 640;
 8008eca:	f44f 7320 	mov.w	r3, #640	; 0x280
 8008ece:	9302      	str	r3, [sp, #8]
	myTimer.TIM_ClockDivision = TIM_CKD_DIV1;
 8008ed0:	f8ad 500c 	strh.w	r5, [sp, #12]
	myTimer.TIM_CounterMode = TIM_CounterMode_Up;
 8008ed4:	f8ad 5006 	strh.w	r5, [sp, #6]
	
	TIM_TimeBaseInit(TIM8, &myTimer);	
 8008ed8:	f507 4764 	add.w	r7, r7, #58368	; 0xe400
 8008edc:	a901      	add	r1, sp, #4
 8008ede:	4638      	mov	r0, r7
 8008ee0:	f7fd f8de 	bl	80060a0 <TIM_TimeBaseInit>
	
	TIM_Cmd(TIM8, DISABLE);
 8008ee4:	4629      	mov	r1, r5
 8008ee6:	4638      	mov	r0, r7
 8008ee8:	f7fd f974 	bl	80061d4 <TIM_Cmd>
	TIM_ITConfig(TIM8, TIM_IT_Update, ENABLE);
 8008eec:	4622      	mov	r2, r4
 8008eee:	4621      	mov	r1, r4
 8008ef0:	4638      	mov	r0, r7
 8008ef2:	f7fd fc76 	bl	80067e2 <TIM_ITConfig>
 8008ef6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8008efa:	6073      	str	r3, [r6, #4]
	NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);
	
};
 8008efc:	b004      	add	sp, #16
 8008efe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008f02:	bf00      	nop
 8008f04:	40000800 	.word	0x40000800
 8008f08:	40000c00 	.word	0x40000c00
 8008f0c:	e000e100 	.word	0xe000e100
 8008f10:	05fa0700 	.word	0x05fa0700
 8008f14:	e000ed00 	.word	0xe000ed00
 8008f18:	200006b4 	.word	0x200006b4

08008f1c <TIM8_UP_TIM13_IRQHandler>:

//Turn off pulses
//Section 1
void TIM8_UP_TIM13_IRQHandler(void)
{
 8008f1c:	b538      	push	{r3, r4, r5, lr}
	if(TIM_GetITStatus(TIM8, TIM_IT_Update) != RESET)
 8008f1e:	2101      	movs	r1, #1
 8008f20:	480e      	ldr	r0, [pc, #56]	; (8008f5c <TIM8_UP_TIM13_IRQHandler+0x40>)
 8008f22:	f7fd fc77 	bl	8006814 <TIM_GetITStatus>
 8008f26:	b900      	cbnz	r0, 8008f2a <TIM8_UP_TIM13_IRQHandler+0xe>
 8008f28:	bd38      	pop	{r3, r4, r5, pc}
	{
		TIM_Cmd(TIM8, DISABLE);
 8008f2a:	4d0c      	ldr	r5, [pc, #48]	; (8008f5c <TIM8_UP_TIM13_IRQHandler+0x40>)
 8008f2c:	2100      	movs	r1, #0
 8008f2e:	4628      	mov	r0, r5
 8008f30:	f7fd f950 	bl	80061d4 <TIM_Cmd>
		PULSE_LED_II_ALL_OFF;
 8008f34:	4c0a      	ldr	r4, [pc, #40]	; (8008f60 <TIM8_UP_TIM13_IRQHandler+0x44>)
 8008f36:	2104      	movs	r1, #4
 8008f38:	4620      	mov	r0, r4
 8008f3a:	f7fa fd87 	bl	8003a4c <GPIO_SetBits>
		PULSE_LED_II_1_OFF;
 8008f3e:	2108      	movs	r1, #8
 8008f40:	4620      	mov	r0, r4
 8008f42:	f7fa fd83 	bl	8003a4c <GPIO_SetBits>
		PULSE_LED_II_2_OFF;
 8008f46:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008f4a:	4620      	mov	r0, r4
 8008f4c:	f7fa fd7e 	bl	8003a4c <GPIO_SetBits>
		TIM_ClearITPendingBit(TIM8, TIM_IT_Update);
 8008f50:	2101      	movs	r1, #1
 8008f52:	4628      	mov	r0, r5
 8008f54:	f7fd fc6a 	bl	800682c <TIM_ClearITPendingBit>
	}		
}
 8008f58:	e7e6      	b.n	8008f28 <TIM8_UP_TIM13_IRQHandler+0xc>
 8008f5a:	bf00      	nop
 8008f5c:	40010400 	.word	0x40010400
 8008f60:	40020000 	.word	0x40020000

08008f64 <TIM8_TRG_COM_TIM14_IRQHandler>:

//Section 2
void TIM8_TRG_COM_TIM14_IRQHandler(void)
{
 8008f64:	b538      	push	{r3, r4, r5, lr}
	if(TIM_GetITStatus(TIM14, TIM_IT_Update) != RESET)
 8008f66:	2101      	movs	r1, #1
 8008f68:	480f      	ldr	r0, [pc, #60]	; (8008fa8 <TIM8_TRG_COM_TIM14_IRQHandler+0x44>)
 8008f6a:	f7fd fc53 	bl	8006814 <TIM_GetITStatus>
 8008f6e:	b900      	cbnz	r0, 8008f72 <TIM8_TRG_COM_TIM14_IRQHandler+0xe>
 8008f70:	bd38      	pop	{r3, r4, r5, pc}
	{
		TIM_Cmd(TIM14, DISABLE);
 8008f72:	4d0d      	ldr	r5, [pc, #52]	; (8008fa8 <TIM8_TRG_COM_TIM14_IRQHandler+0x44>)
 8008f74:	2100      	movs	r1, #0
 8008f76:	4628      	mov	r0, r5
 8008f78:	f7fd f92c 	bl	80061d4 <TIM_Cmd>
		PULSE_LED_I_ALL_OFF;
 8008f7c:	4c0b      	ldr	r4, [pc, #44]	; (8008fac <TIM8_TRG_COM_TIM14_IRQHandler+0x48>)
 8008f7e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8008f82:	4620      	mov	r0, r4
 8008f84:	f7fa fd62 	bl	8003a4c <GPIO_SetBits>
		PULSE_LED_I_1_OFF;
 8008f88:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8008f8c:	4620      	mov	r0, r4
 8008f8e:	f7fa fd5d 	bl	8003a4c <GPIO_SetBits>
		PULSE_LED_I_2_OFF;
 8008f92:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8008f96:	4620      	mov	r0, r4
 8008f98:	f7fa fd58 	bl	8003a4c <GPIO_SetBits>
		TIM_ClearITPendingBit(TIM14, TIM_IT_Update);
 8008f9c:	2101      	movs	r1, #1
 8008f9e:	4628      	mov	r0, r5
 8008fa0:	f7fd fc44 	bl	800682c <TIM_ClearITPendingBit>
	}		
}
 8008fa4:	e7e4      	b.n	8008f70 <TIM8_TRG_COM_TIM14_IRQHandler+0xc>
 8008fa6:	bf00      	nop
 8008fa8:	40002000 	.word	0x40002000
 8008fac:	40020400 	.word	0x40020400

08008fb0 <TIM3_IRQHandler>:

//Timer Interrupt handler for start switch scan
//Section 1
void TIM3_IRQHandler()
{
 8008fb0:	b510      	push	{r4, lr}
	TIM3->SR = (uint16_t) ~TIM_IT_Update;	
 8008fb2:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 8008fb6:	4b29      	ldr	r3, [pc, #164]	; (800905c <TIM3_IRQHandler+0xac>)
 8008fb8:	821a      	strh	r2, [r3, #16]
	
	if ( (gSequencerMode_1 == SEQUENCER_MODE_WAIT_HI_Z) 
 8008fba:	4b29      	ldr	r3, [pc, #164]	; (8009060 <TIM3_IRQHandler+0xb0>)
 8008fbc:	785b      	ldrb	r3, [r3, #1]
 8008fbe:	b2db      	uxtb	r3, r3
 8008fc0:	2b04      	cmp	r3, #4
 8008fc2:	d00f      	beq.n	8008fe4 <TIM3_IRQHandler+0x34>
			&& (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8) == 0) ) {
	}
	else if((gSequencerMode_1 == SEQUENCER_MODE_WAIT_HI_Z) 
 8008fc4:	4b26      	ldr	r3, [pc, #152]	; (8009060 <TIM3_IRQHandler+0xb0>)
 8008fc6:	785b      	ldrb	r3, [r3, #1]
 8008fc8:	b2db      	uxtb	r3, r3
 8008fca:	2b04      	cmp	r3, #4
 8008fcc:	d012      	beq.n	8008ff4 <TIM3_IRQHandler+0x44>
		gSequencerMode_1 = SEQUENCER_MODE_RUN;
		gSequenceStepNumber_1 = GetNextStep(0, gSequenceStepNumber_1);
		TIM3->CR1 &= ~TIM_CR1_CEN;
	}
	
	if((gSequencerMode_1 == SEQUENCER_MODE_STAY_HI_Z) 
 8008fce:	4b24      	ldr	r3, [pc, #144]	; (8009060 <TIM3_IRQHandler+0xb0>)
 8008fd0:	785b      	ldrb	r3, [r3, #1]
 8008fd2:	b2db      	uxtb	r3, r3
 8008fd4:	2b05      	cmp	r3, #5
 8008fd6:	d023      	beq.n	8009020 <TIM3_IRQHandler+0x70>
			&& (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8) == 1))
	{

	}
	else if((gSequencerMode_1 == SEQUENCER_MODE_STAY_HI_Z) 
 8008fd8:	4b21      	ldr	r3, [pc, #132]	; (8009060 <TIM3_IRQHandler+0xb0>)
 8008fda:	785b      	ldrb	r3, [r3, #1]
 8008fdc:	b2db      	uxtb	r3, r3
 8008fde:	2b05      	cmp	r3, #5
 8008fe0:	d026      	beq.n	8009030 <TIM3_IRQHandler+0x80>
 8008fe2:	bd10      	pop	{r4, pc}
			&& (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8) == 0) ) {
 8008fe4:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008fe8:	481e      	ldr	r0, [pc, #120]	; (8009064 <TIM3_IRQHandler+0xb4>)
 8008fea:	f7fa fd1b 	bl	8003a24 <GPIO_ReadInputDataBit>
 8008fee:	2800      	cmp	r0, #0
 8008ff0:	d0ed      	beq.n	8008fce <TIM3_IRQHandler+0x1e>
 8008ff2:	e7e7      	b.n	8008fc4 <TIM3_IRQHandler+0x14>
			&& (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8) == 1))
 8008ff4:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008ff8:	481a      	ldr	r0, [pc, #104]	; (8009064 <TIM3_IRQHandler+0xb4>)
 8008ffa:	f7fa fd13 	bl	8003a24 <GPIO_ReadInputDataBit>
 8008ffe:	2801      	cmp	r0, #1
 8009000:	d1e5      	bne.n	8008fce <TIM3_IRQHandler+0x1e>
		gSequencerMode_1 = SEQUENCER_MODE_RUN;
 8009002:	4c17      	ldr	r4, [pc, #92]	; (8009060 <TIM3_IRQHandler+0xb0>)
 8009004:	2000      	movs	r0, #0
 8009006:	7060      	strb	r0, [r4, #1]
		gSequenceStepNumber_1 = GetNextStep(0, gSequenceStepNumber_1);
 8009008:	7961      	ldrb	r1, [r4, #5]
 800900a:	f7ff f941 	bl	8008290 <GetNextStep>
 800900e:	7160      	strb	r0, [r4, #5]
		TIM3->CR1 &= ~TIM_CR1_CEN;
 8009010:	4a12      	ldr	r2, [pc, #72]	; (800905c <TIM3_IRQHandler+0xac>)
 8009012:	8813      	ldrh	r3, [r2, #0]
 8009014:	b29b      	uxth	r3, r3
 8009016:	f023 0301 	bic.w	r3, r3, #1
 800901a:	b29b      	uxth	r3, r3
 800901c:	8013      	strh	r3, [r2, #0]
 800901e:	e7d6      	b.n	8008fce <TIM3_IRQHandler+0x1e>
			&& (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8) == 1))
 8009020:	f44f 7180 	mov.w	r1, #256	; 0x100
 8009024:	480f      	ldr	r0, [pc, #60]	; (8009064 <TIM3_IRQHandler+0xb4>)
 8009026:	f7fa fcfd 	bl	8003a24 <GPIO_ReadInputDataBit>
 800902a:	2801      	cmp	r0, #1
 800902c:	d1d4      	bne.n	8008fd8 <TIM3_IRQHandler+0x28>
 800902e:	e7d8      	b.n	8008fe2 <TIM3_IRQHandler+0x32>
			&& (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8) == 0))
 8009030:	f44f 7180 	mov.w	r1, #256	; 0x100
 8009034:	480b      	ldr	r0, [pc, #44]	; (8009064 <TIM3_IRQHandler+0xb4>)
 8009036:	f7fa fcf5 	bl	8003a24 <GPIO_ReadInputDataBit>
 800903a:	2800      	cmp	r0, #0
 800903c:	d1d1      	bne.n	8008fe2 <TIM3_IRQHandler+0x32>
	{
		gSequencerMode_1 = SEQUENCER_MODE_RUN;
 800903e:	4c08      	ldr	r4, [pc, #32]	; (8009060 <TIM3_IRQHandler+0xb0>)
 8009040:	7060      	strb	r0, [r4, #1]
		gSequenceStepNumber_1 = GetNextStep(0, gSequenceStepNumber_1);
 8009042:	7961      	ldrb	r1, [r4, #5]
 8009044:	f7ff f924 	bl	8008290 <GetNextStep>
 8009048:	7160      	strb	r0, [r4, #5]
		TIM3->CR1 &= ~TIM_CR1_CEN;
 800904a:	4a04      	ldr	r2, [pc, #16]	; (800905c <TIM3_IRQHandler+0xac>)
 800904c:	8813      	ldrh	r3, [r2, #0]
 800904e:	b29b      	uxth	r3, r3
 8009050:	f023 0301 	bic.w	r3, r3, #1
 8009054:	b29b      	uxth	r3, r3
 8009056:	8013      	strh	r3, [r2, #0]
	}
};
 8009058:	e7c3      	b.n	8008fe2 <TIM3_IRQHandler+0x32>
 800905a:	bf00      	nop
 800905c:	40000400 	.word	0x40000400
 8009060:	200006b4 	.word	0x200006b4
 8009064:	40020400 	.word	0x40020400

08009068 <TIM7_IRQHandler>:

//Section 2
void TIM7_IRQHandler()
{
 8009068:	b510      	push	{r4, lr}
	TIM7->SR = (uint16_t) ~TIM_IT_Update;	
 800906a:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 800906e:	4b28      	ldr	r3, [pc, #160]	; (8009110 <TIM7_IRQHandler+0xa8>)
 8009070:	821a      	strh	r2, [r3, #16]
	
	if ( (gSequencerMode_2 == SEQUENCER_MODE_WAIT_HI_Z) 
 8009072:	4b28      	ldr	r3, [pc, #160]	; (8009114 <TIM7_IRQHandler+0xac>)
 8009074:	78db      	ldrb	r3, [r3, #3]
 8009076:	b2db      	uxtb	r3, r3
 8009078:	2b04      	cmp	r3, #4
 800907a:	d00f      	beq.n	800909c <TIM7_IRQHandler+0x34>
			&& (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_6) == 0) ) {
	}
	else if((gSequencerMode_2 == SEQUENCER_MODE_WAIT_HI_Z) 
 800907c:	4b25      	ldr	r3, [pc, #148]	; (8009114 <TIM7_IRQHandler+0xac>)
 800907e:	78db      	ldrb	r3, [r3, #3]
 8009080:	b2db      	uxtb	r3, r3
 8009082:	2b04      	cmp	r3, #4
 8009084:	d011      	beq.n	80090aa <TIM7_IRQHandler+0x42>
		gSequencerMode_2 = SEQUENCER_MODE_RUN;
		gSequenceStepNumber_2 = GetNextStep(1, gSequenceStepNumber_2);
		TIM7->CR1 &= ~TIM_CR1_CEN;
	}
	
	if((gSequencerMode_2 == SEQUENCER_MODE_STAY_HI_Z) 
 8009086:	4b23      	ldr	r3, [pc, #140]	; (8009114 <TIM7_IRQHandler+0xac>)
 8009088:	78db      	ldrb	r3, [r3, #3]
 800908a:	b2db      	uxtb	r3, r3
 800908c:	2b05      	cmp	r3, #5
 800908e:	d021      	beq.n	80090d4 <TIM7_IRQHandler+0x6c>
			&& (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_6) == 1))
	{
	}
	else if((gSequencerMode_2 == SEQUENCER_MODE_STAY_HI_Z) 
 8009090:	4b20      	ldr	r3, [pc, #128]	; (8009114 <TIM7_IRQHandler+0xac>)
 8009092:	78db      	ldrb	r3, [r3, #3]
 8009094:	b2db      	uxtb	r3, r3
 8009096:	2b05      	cmp	r3, #5
 8009098:	d023      	beq.n	80090e2 <TIM7_IRQHandler+0x7a>
 800909a:	bd10      	pop	{r4, pc}
			&& (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_6) == 0) ) {
 800909c:	2140      	movs	r1, #64	; 0x40
 800909e:	481e      	ldr	r0, [pc, #120]	; (8009118 <TIM7_IRQHandler+0xb0>)
 80090a0:	f7fa fcc0 	bl	8003a24 <GPIO_ReadInputDataBit>
 80090a4:	2800      	cmp	r0, #0
 80090a6:	d0ee      	beq.n	8009086 <TIM7_IRQHandler+0x1e>
 80090a8:	e7e8      	b.n	800907c <TIM7_IRQHandler+0x14>
			&& (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_6) == 1))
 80090aa:	2140      	movs	r1, #64	; 0x40
 80090ac:	481a      	ldr	r0, [pc, #104]	; (8009118 <TIM7_IRQHandler+0xb0>)
 80090ae:	f7fa fcb9 	bl	8003a24 <GPIO_ReadInputDataBit>
 80090b2:	2801      	cmp	r0, #1
 80090b4:	d1e7      	bne.n	8009086 <TIM7_IRQHandler+0x1e>
		gSequencerMode_2 = SEQUENCER_MODE_RUN;
 80090b6:	4c17      	ldr	r4, [pc, #92]	; (8009114 <TIM7_IRQHandler+0xac>)
 80090b8:	2300      	movs	r3, #0
 80090ba:	70e3      	strb	r3, [r4, #3]
		gSequenceStepNumber_2 = GetNextStep(1, gSequenceStepNumber_2);
 80090bc:	79a1      	ldrb	r1, [r4, #6]
 80090be:	f7ff f8e7 	bl	8008290 <GetNextStep>
 80090c2:	71a0      	strb	r0, [r4, #6]
		TIM7->CR1 &= ~TIM_CR1_CEN;
 80090c4:	4a12      	ldr	r2, [pc, #72]	; (8009110 <TIM7_IRQHandler+0xa8>)
 80090c6:	8813      	ldrh	r3, [r2, #0]
 80090c8:	b29b      	uxth	r3, r3
 80090ca:	f023 0301 	bic.w	r3, r3, #1
 80090ce:	b29b      	uxth	r3, r3
 80090d0:	8013      	strh	r3, [r2, #0]
 80090d2:	e7d8      	b.n	8009086 <TIM7_IRQHandler+0x1e>
			&& (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_6) == 1))
 80090d4:	2140      	movs	r1, #64	; 0x40
 80090d6:	4810      	ldr	r0, [pc, #64]	; (8009118 <TIM7_IRQHandler+0xb0>)
 80090d8:	f7fa fca4 	bl	8003a24 <GPIO_ReadInputDataBit>
 80090dc:	2801      	cmp	r0, #1
 80090de:	d1d7      	bne.n	8009090 <TIM7_IRQHandler+0x28>
 80090e0:	e7db      	b.n	800909a <TIM7_IRQHandler+0x32>
			&& (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_6) == 0))
 80090e2:	2140      	movs	r1, #64	; 0x40
 80090e4:	480c      	ldr	r0, [pc, #48]	; (8009118 <TIM7_IRQHandler+0xb0>)
 80090e6:	f7fa fc9d 	bl	8003a24 <GPIO_ReadInputDataBit>
 80090ea:	2800      	cmp	r0, #0
 80090ec:	d1d5      	bne.n	800909a <TIM7_IRQHandler+0x32>
	{
		gSequencerMode_2 = SEQUENCER_MODE_RUN;
 80090ee:	4c09      	ldr	r4, [pc, #36]	; (8009114 <TIM7_IRQHandler+0xac>)
 80090f0:	2300      	movs	r3, #0
 80090f2:	70e3      	strb	r3, [r4, #3]
		gSequenceStepNumber_2 = GetNextStep(1, gSequenceStepNumber_2);
 80090f4:	79a1      	ldrb	r1, [r4, #6]
 80090f6:	2001      	movs	r0, #1
 80090f8:	f7ff f8ca 	bl	8008290 <GetNextStep>
 80090fc:	71a0      	strb	r0, [r4, #6]
		TIM7->CR1 &= ~TIM_CR1_CEN;
 80090fe:	4a04      	ldr	r2, [pc, #16]	; (8009110 <TIM7_IRQHandler+0xa8>)
 8009100:	8813      	ldrh	r3, [r2, #0]
 8009102:	b29b      	uxth	r3, r3
 8009104:	f023 0301 	bic.w	r3, r3, #1
 8009108:	b29b      	uxth	r3, r3
 800910a:	8013      	strh	r3, [r2, #0]
	}
};
 800910c:	e7c5      	b.n	800909a <TIM7_IRQHandler+0x32>
 800910e:	bf00      	nop
 8009110:	40001400 	.word	0x40001400
 8009114:	200006b4 	.word	0x200006b4
 8009118:	40020400 	.word	0x40020400

0800911c <PulsesInit>:

/*
Init GPIO for pulses generation
*/
void PulsesInit()
{
 800911c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800911e:	b083      	sub	sp, #12
	GPIO_InitTypeDef GPIO_Pulses;
	
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 8009120:	2101      	movs	r1, #1
 8009122:	2002      	movs	r0, #2
 8009124:	f7fb fbd0 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	memset(&GPIO_Pulses, 0, sizeof(GPIO_Pulses));
 8009128:	2700      	movs	r7, #0
 800912a:	9701      	str	r7, [sp, #4]
	GPIO_Pulses.GPIO_Pin 		= PULSE_LED_I_ALL|PULSE_LED_I_1|PULSE_LED_I_2;
 800912c:	f44f 6360 	mov.w	r3, #3584	; 0xe00
 8009130:	9300      	str	r3, [sp, #0]
	GPIO_Pulses.GPIO_Mode 	= GPIO_Mode_OUT;
 8009132:	2401      	movs	r4, #1
 8009134:	f88d 4004 	strb.w	r4, [sp, #4]
	GPIO_Pulses.GPIO_OType	= GPIO_OType_PP;
	GPIO_Pulses.GPIO_PuPd		= GPIO_PuPd_NOPULL;
	GPIO_Pulses.GPIO_Speed	= GPIO_Speed_100MHz;
 8009138:	2603      	movs	r6, #3
 800913a:	f88d 6005 	strb.w	r6, [sp, #5]
	
	GPIO_Init(GPIOB, &GPIO_Pulses);
 800913e:	4d1a      	ldr	r5, [pc, #104]	; (80091a8 <PulsesInit+0x8c>)
 8009140:	4669      	mov	r1, sp
 8009142:	4628      	mov	r0, r5
 8009144:	f7fa fc0e 	bl	8003964 <GPIO_Init>
	
	PULSE_LED_I_ALL_OFF;
 8009148:	f44f 7100 	mov.w	r1, #512	; 0x200
 800914c:	4628      	mov	r0, r5
 800914e:	f7fa fc7d 	bl	8003a4c <GPIO_SetBits>
	PULSE_LED_I_1_OFF;
 8009152:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8009156:	4628      	mov	r0, r5
 8009158:	f7fa fc78 	bl	8003a4c <GPIO_SetBits>
	PULSE_LED_I_2_OFF;
 800915c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8009160:	4628      	mov	r0, r5
 8009162:	f7fa fc73 	bl	8003a4c <GPIO_SetBits>
		
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8009166:	4621      	mov	r1, r4
 8009168:	4620      	mov	r0, r4
 800916a:	f7fb fbad 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	memset(&GPIO_Pulses, 0, sizeof(GPIO_Pulses));
 800916e:	9701      	str	r7, [sp, #4]
	GPIO_Pulses.GPIO_Pin 		= PULSE_LED_II_ALL|PULSE_LED_II_1|PULSE_LED_II_2;
 8009170:	f241 030c 	movw	r3, #4108	; 0x100c
 8009174:	9300      	str	r3, [sp, #0]
	GPIO_Pulses.GPIO_Mode 	= GPIO_Mode_OUT;
 8009176:	f88d 4004 	strb.w	r4, [sp, #4]
	GPIO_Pulses.GPIO_OType	= GPIO_OType_PP;
	GPIO_Pulses.GPIO_PuPd		= GPIO_PuPd_NOPULL;
	GPIO_Pulses.GPIO_Speed	= GPIO_Speed_100MHz;
 800917a:	f88d 6005 	strb.w	r6, [sp, #5]
	
	GPIO_Init(GPIOA, &GPIO_Pulses);
 800917e:	4c0b      	ldr	r4, [pc, #44]	; (80091ac <PulsesInit+0x90>)
 8009180:	4669      	mov	r1, sp
 8009182:	4620      	mov	r0, r4
 8009184:	f7fa fbee 	bl	8003964 <GPIO_Init>
	
	PULSE_LED_II_ALL_OFF;
 8009188:	2104      	movs	r1, #4
 800918a:	4620      	mov	r0, r4
 800918c:	f7fa fc5e 	bl	8003a4c <GPIO_SetBits>
	PULSE_LED_II_1_OFF;
 8009190:	2108      	movs	r1, #8
 8009192:	4620      	mov	r0, r4
 8009194:	f7fa fc5a 	bl	8003a4c <GPIO_SetBits>
	PULSE_LED_II_2_OFF;
 8009198:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800919c:	4620      	mov	r0, r4
 800919e:	f7fa fc55 	bl	8003a4c <GPIO_SetBits>
};
 80091a2:	b003      	add	sp, #12
 80091a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80091a6:	bf00      	nop
 80091a8:	40020400 	.word	0x40020400
 80091ac:	40020000 	.word	0x40020000

080091b0 <DisplayLedsIOInit>:

/*
Init GPIOs for display leds
*/
void DisplayLedsIOInit(void)
{
 80091b0:	b500      	push	{lr}
 80091b2:	b083      	sub	sp, #12
	GPIO_InitTypeDef GPIO_InitStructure;
	
	//Ã�ËœÃ�Â½Ã�Â¸Ã‘â€ Ã�Â¸Ã�Â°Ã�Â»Ã�Â¸Ã�Â·Ã�Â°Ã‘ï¿½ Ã�Â¿Ã�ÂµÃ‘â‚¬Ã�Â¸Ã‘â€žÃ�ÂµÃ‘â‚¬Ã�Â¸Ã�Â¸ Ã�Â´Ã�Â»Ã‘ï¿½ Ã‘Æ’Ã�Â¿Ã‘â‚¬Ã�Â°Ã�Â²Ã�Â»Ã�ÂµÃ�Â½Ã�Â¸Ã‘ï¿½ Ã‘ï¿½Ã�Â²Ã�ÂµÃ‘â€šÃ�Â¾Ã�Â´Ã�Â¸Ã�Â¾Ã�Â´Ã�Â°Ã�Â¼Ã�Â¸ DISPLAY
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 80091b4:	2101      	movs	r1, #1
 80091b6:	4608      	mov	r0, r1
 80091b8:	f7fb fb86 	bl	80048c8 <RCC_AHB1PeriphClockCmd>
	
	GPIO_InitStructure.GPIO_Pin 	= DISPLAY_LED_I|DISPLAY_LED_II;
 80091bc:	23c0      	movs	r3, #192	; 0xc0
 80091be:	9300      	str	r3, [sp, #0]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 80091c0:	2303      	movs	r3, #3
 80091c2:	f88d 3005 	strb.w	r3, [sp, #5]
	GPIO_InitStructure.GPIO_Mode 	= GPIO_Mode_OUT;
 80091c6:	2301      	movs	r3, #1
 80091c8:	f88d 3004 	strb.w	r3, [sp, #4]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80091cc:	2300      	movs	r3, #0
 80091ce:	f88d 3006 	strb.w	r3, [sp, #6]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80091d2:	4669      	mov	r1, sp
 80091d4:	4802      	ldr	r0, [pc, #8]	; (80091e0 <DisplayLedsIOInit+0x30>)
 80091d6:	f7fa fbc5 	bl	8003964 <GPIO_Init>
};
 80091da:	b003      	add	sp, #12
 80091dc:	f85d fb04 	ldr.w	pc, [sp], #4
 80091e0:	40020000 	.word	0x40020000

080091e4 <InternalDACInit>:

/*
 Init internal DAC
*/
void InternalDACInit(void)
{
 80091e4:	b510      	push	{r4, lr}
 80091e6:	b086      	sub	sp, #24
	DAC_InitTypeDef mDacInit;
	GPIO_InitTypeDef mGPIO_InitStructure;
	
	DAC_StructInit(&mDacInit);
 80091e8:	a802      	add	r0, sp, #8
 80091ea:	f7f9 f9f9 	bl	80025e0 <DAC_StructInit>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 80091ee:	2101      	movs	r1, #1
 80091f0:	4608      	mov	r0, r1
 80091f2:	f7fb fb69 	bl	80048c8 <RCC_AHB1PeriphClockCmd>

	//GPIOs init
	
	mGPIO_InitStructure.GPIO_Pin 	= GPIO_Pin_4|GPIO_Pin_5;
 80091f6:	2330      	movs	r3, #48	; 0x30
 80091f8:	9300      	str	r3, [sp, #0]
	mGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 80091fa:	2303      	movs	r3, #3
 80091fc:	f88d 3004 	strb.w	r3, [sp, #4]
	GPIO_Init(GPIOA, &mGPIO_InitStructure);
 8009200:	4669      	mov	r1, sp
 8009202:	4814      	ldr	r0, [pc, #80]	; (8009254 <InternalDACInit+0x70>)
 8009204:	f7fa fbae 	bl	8003964 <GPIO_Init>
		
	/* DAC Periph clock enable */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC, ENABLE);
 8009208:	2101      	movs	r1, #1
 800920a:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 800920e:	f7fb fb85 	bl	800491c <RCC_APB1PeriphClockCmd>
	
	//DAC init
	mDacInit.DAC_Trigger 				= DAC_Trigger_None;
 8009212:	2400      	movs	r4, #0
 8009214:	9402      	str	r4, [sp, #8]
	mDacInit.DAC_OutputBuffer 	= DAC_OutputBuffer_Disable;
 8009216:	2302      	movs	r3, #2
 8009218:	9305      	str	r3, [sp, #20]
	mDacInit.DAC_WaveGeneration = DAC_WaveGeneration_None;
 800921a:	9403      	str	r4, [sp, #12]

	DAC_DeInit();
 800921c:	f7f9 f9bc 	bl	8002598 <DAC_DeInit>
	
	DAC_Init(DAC_Channel_1, &mDacInit);
 8009220:	a902      	add	r1, sp, #8
 8009222:	4620      	mov	r0, r4
 8009224:	f7f9 f9c4 	bl	80025b0 <DAC_Init>
	DAC_Init(DAC_Channel_2, &mDacInit);
 8009228:	a902      	add	r1, sp, #8
 800922a:	2010      	movs	r0, #16
 800922c:	f7f9 f9c0 	bl	80025b0 <DAC_Init>
	
	DAC_Cmd(DAC_Channel_1, ENABLE);
 8009230:	2101      	movs	r1, #1
 8009232:	4620      	mov	r0, r4
 8009234:	f7f9 f9da 	bl	80025ec <DAC_Cmd>
	DAC_Cmd(DAC_Channel_2, ENABLE);
 8009238:	2101      	movs	r1, #1
 800923a:	2010      	movs	r0, #16
 800923c:	f7f9 f9d6 	bl	80025ec <DAC_Cmd>
	
	DAC_SetChannel1Data(DAC_Align_12b_R, 0);
 8009240:	4621      	mov	r1, r4
 8009242:	4620      	mov	r0, r4
 8009244:	f7f9 fa1c 	bl	8002680 <DAC_SetChannel1Data>
	DAC_SetChannel2Data(DAC_Align_12b_R, 0);
 8009248:	4621      	mov	r1, r4
 800924a:	4620      	mov	r0, r4
 800924c:	f7f9 fa28 	bl	80026a0 <DAC_SetChannel2Data>
};
 8009250:	b006      	add	sp, #24
 8009252:	bd10      	pop	{r4, pc}
 8009254:	40020000 	.word	0x40020000

08009258 <keyb_proc>:

/*
	Scan all switches
*/
unsigned char keyb_proc(uButtons * key)
{
 8009258:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800925c:	b082      	sub	sp, #8
 800925e:	4604      	mov	r4, r0
	unsigned char StepNum = 0, Section = 0, max_step;
	uStep tmpStep;
	
	if(Is_Expander_Present()) max_step = 31;
 8009260:	f7fe fa34 	bl	80076cc <Is_Expander_Present>
 8009264:	2800      	cmp	r0, #0
 8009266:	f000 82d4 	beq.w	8009812 <keyb_proc+0x5ba>
 800926a:	261f      	movs	r6, #31
	else max_step = 15;
			 
	/* Determine step num for different DisplayModes */
	if (gDisplayMode == DISPLAY_MODE_VIEW_1) {
 800926c:	4bc6      	ldr	r3, [pc, #792]	; (8009588 <keyb_proc+0x330>)
 800926e:	79db      	ldrb	r3, [r3, #7]
 8009270:	2b00      	cmp	r3, #0
 8009272:	f040 82d0 	bne.w	8009816 <keyb_proc+0x5be>
		StepNum = gSequenceStepNumber_1;
 8009276:	4bc4      	ldr	r3, [pc, #784]	; (8009588 <keyb_proc+0x330>)
 8009278:	795b      	ldrb	r3, [r3, #5]
 800927a:	b2db      	uxtb	r3, r3
		Section = 0;
	};
	if (gDisplayMode == DISPLAY_MODE_VIEW_2) {
 800927c:	4ac2      	ldr	r2, [pc, #776]	; (8009588 <keyb_proc+0x330>)
 800927e:	79d2      	ldrb	r2, [r2, #7]
 8009280:	b2d2      	uxtb	r2, r2
 8009282:	2a01      	cmp	r2, #1
 8009284:	f000 82c9 	beq.w	800981a <keyb_proc+0x5c2>
 8009288:	2200      	movs	r2, #0
		StepNum = gSequenceStepNumber_2;
		Section = 1;
	};
	if (gDisplayMode == DISPLAY_MODE_EDIT_1) {
 800928a:	49bf      	ldr	r1, [pc, #764]	; (8009588 <keyb_proc+0x330>)
 800928c:	79c9      	ldrb	r1, [r1, #7]
 800928e:	b2c9      	uxtb	r1, r1
 8009290:	2902      	cmp	r1, #2
 8009292:	f000 82c6 	beq.w	8009822 <keyb_proc+0x5ca>
		StepNum = gEditModeStepNum;
		Section = 0;
	};
	if (gDisplayMode == DISPLAY_MODE_EDIT_2) {
 8009296:	49bc      	ldr	r1, [pc, #752]	; (8009588 <keyb_proc+0x330>)
 8009298:	79c9      	ldrb	r1, [r1, #7]
 800929a:	b2c9      	uxtb	r1, r1
 800929c:	2903      	cmp	r1, #3
 800929e:	f000 82c5 	beq.w	800982c <keyb_proc+0x5d4>
		StepNum = gEditModeStepNum;
		Section = 1;
	};
	
	if (gDisplayMode == DISPLAY_MODE_SAVE_1) {
 80092a2:	49b9      	ldr	r1, [pc, #740]	; (8009588 <keyb_proc+0x330>)
 80092a4:	79c9      	ldrb	r1, [r1, #7]
 80092a6:	b2c9      	uxtb	r1, r1
 80092a8:	2904      	cmp	r1, #4
 80092aa:	f000 82c4 	beq.w	8009836 <keyb_proc+0x5de>
		StepNum = gEditModeStepNum;
		Section = 0;
	};
	if (gDisplayMode == DISPLAY_MODE_SAVE_2) {
 80092ae:	49b6      	ldr	r1, [pc, #728]	; (8009588 <keyb_proc+0x330>)
 80092b0:	79c9      	ldrb	r1, [r1, #7]
 80092b2:	b2c9      	uxtb	r1, r1
 80092b4:	2905      	cmp	r1, #5
 80092b6:	f000 82c3 	beq.w	8009840 <keyb_proc+0x5e8>
		StepNum = gEditModeStepNum;
		Section = 1;
	};
	if (gDisplayMode == DISPLAY_MODE_LOAD_1) {
 80092ba:	49b3      	ldr	r1, [pc, #716]	; (8009588 <keyb_proc+0x330>)
 80092bc:	79c9      	ldrb	r1, [r1, #7]
 80092be:	b2c9      	uxtb	r1, r1
 80092c0:	2906      	cmp	r1, #6
 80092c2:	f000 82c2 	beq.w	800984a <keyb_proc+0x5f2>
		StepNum = gEditModeStepNum;
		Section = 0;
	};
	if (gDisplayMode == DISPLAY_MODE_LOAD_2) {
 80092c6:	49b0      	ldr	r1, [pc, #704]	; (8009588 <keyb_proc+0x330>)
 80092c8:	79c9      	ldrb	r1, [r1, #7]
 80092ca:	b2c9      	uxtb	r1, r1
 80092cc:	2907      	cmp	r1, #7
 80092ce:	f000 82c1 	beq.w	8009854 <keyb_proc+0x5fc>
		StepNum = gEditModeStepNum;
		Section = 1;
	};
	
	tmpStep = Steps[Section][StepNum];	
 80092d2:	4617      	mov	r7, r2
 80092d4:	461d      	mov	r5, r3
 80092d6:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80092da:	4aac      	ldr	r2, [pc, #688]	; (800958c <keyb_proc+0x334>)
 80092dc:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80092e0:	e893 0003 	ldmia.w	r3, {r0, r1}
 80092e4:	ab02      	add	r3, sp, #8
 80092e6:	e903 0003 	stmdb	r3, {r0, r1}
				
	
		/* Middle section */
		
		if ( !key->b.Voltage0 ) {
 80092ea:	7862      	ldrb	r2, [r4, #1]
 80092ec:	f012 0f10 	tst.w	r2, #16
 80092f0:	d10f      	bne.n	8009312 <keyb_proc+0xba>
			tmpStep.b.Voltage0 = 1;
 80092f2:	f89d 3003 	ldrb.w	r3, [sp, #3]
			tmpStep.b.Voltage2 = 0;
 80092f6:	f043 0310 	orr.w	r3, r3, #16
			tmpStep.b.Voltage4 = 0;
			tmpStep.b.Voltage6 = 0;
			tmpStep.b.Voltage8 = 0;
 80092fa:	f89d 1004 	ldrb.w	r1, [sp, #4]
 80092fe:	f36f 0100 	bfc	r1, #0, #1
 8009302:	f88d 1004 	strb.w	r1, [sp, #4]
			tmpStep.b.FullRange = 0;
 8009306:	f003 031f 	and.w	r3, r3, #31
 800930a:	f36f 0382 	bfc	r3, #2, #1
 800930e:	f88d 3003 	strb.w	r3, [sp, #3]
		};
		
		if ( !key->b.Voltage2 ) {
 8009312:	f012 0f20 	tst.w	r2, #32
 8009316:	d111      	bne.n	800933c <keyb_proc+0xe4>
			tmpStep.b.Voltage0 = 0;
 8009318:	f89d 3003 	ldrb.w	r3, [sp, #3]
			tmpStep.b.Voltage2 = 1;
 800931c:	f003 03ef 	and.w	r3, r3, #239	; 0xef
			tmpStep.b.Voltage4 = 0;
 8009320:	f043 0320 	orr.w	r3, r3, #32
			tmpStep.b.Voltage6 = 0;
			tmpStep.b.Voltage8 = 0;
 8009324:	f89d 1004 	ldrb.w	r1, [sp, #4]
 8009328:	f36f 0100 	bfc	r1, #0, #1
 800932c:	f88d 1004 	strb.w	r1, [sp, #4]
			tmpStep.b.FullRange = 0;
 8009330:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8009334:	f36f 0382 	bfc	r3, #2, #1
 8009338:	f88d 3003 	strb.w	r3, [sp, #3]
		};
		
		if ( !key->b.Voltage4 ) {
 800933c:	f012 0f40 	tst.w	r2, #64	; 0x40
 8009340:	d111      	bne.n	8009366 <keyb_proc+0x10e>
			tmpStep.b.Voltage0 = 0;
 8009342:	f89d 3003 	ldrb.w	r3, [sp, #3]
			tmpStep.b.Voltage2 = 0;
			tmpStep.b.Voltage4 = 1;
 8009346:	f003 03cf 	and.w	r3, r3, #207	; 0xcf
			tmpStep.b.Voltage6 = 0;
 800934a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
			tmpStep.b.Voltage8 = 0;
 800934e:	f89d 1004 	ldrb.w	r1, [sp, #4]
 8009352:	f36f 0100 	bfc	r1, #0, #1
 8009356:	f88d 1004 	strb.w	r1, [sp, #4]
			tmpStep.b.FullRange = 0;
 800935a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800935e:	f36f 0382 	bfc	r3, #2, #1
 8009362:	f88d 3003 	strb.w	r3, [sp, #3]
		};
		
		if ( !key->b.Voltage6 ) {
 8009366:	f012 0f80 	tst.w	r2, #128	; 0x80
 800936a:	d10f      	bne.n	800938c <keyb_proc+0x134>
			tmpStep.b.Voltage0 = 0;
 800936c:	f89d 3003 	ldrb.w	r3, [sp, #3]
			tmpStep.b.Voltage2 = 0;
			tmpStep.b.Voltage4 = 0;
			tmpStep.b.Voltage6 = 1;
 8009370:	f003 038f 	and.w	r3, r3, #143	; 0x8f
			tmpStep.b.Voltage8 = 0;
 8009374:	f89d 1004 	ldrb.w	r1, [sp, #4]
 8009378:	f36f 0100 	bfc	r1, #0, #1
 800937c:	f88d 1004 	strb.w	r1, [sp, #4]
			tmpStep.b.FullRange = 0;
 8009380:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8009384:	f36f 0382 	bfc	r3, #2, #1
 8009388:	f88d 3003 	strb.w	r3, [sp, #3]
		};
		
		if ( !key->b.Voltage8 ) {
 800938c:	78a3      	ldrb	r3, [r4, #2]
 800938e:	f013 0f01 	tst.w	r3, #1
 8009392:	d10d      	bne.n	80093b0 <keyb_proc+0x158>
			tmpStep.b.Voltage0 = 0;
 8009394:	f89d 1003 	ldrb.w	r1, [sp, #3]
			tmpStep.b.Voltage2 = 0;
			tmpStep.b.Voltage4 = 0;
			tmpStep.b.Voltage6 = 0;
			tmpStep.b.Voltage8 = 1;
 8009398:	f89d 0004 	ldrb.w	r0, [sp, #4]
 800939c:	f040 0001 	orr.w	r0, r0, #1
 80093a0:	f88d 0004 	strb.w	r0, [sp, #4]
			tmpStep.b.FullRange = 0;
 80093a4:	f001 010f 	and.w	r1, r1, #15
 80093a8:	f36f 0182 	bfc	r1, #2, #1
 80093ac:	f88d 1003 	strb.w	r1, [sp, #3]
		};
		
		if ( !key->b.FullRangeOn ) {
 80093b0:	f012 0f01 	tst.w	r2, #1
 80093b4:	d10d      	bne.n	80093d2 <keyb_proc+0x17a>
			tmpStep.b.Voltage0 = 0;
 80093b6:	f89d 1003 	ldrb.w	r1, [sp, #3]
			tmpStep.b.Voltage2 = 0;
			tmpStep.b.Voltage4 = 0;
			tmpStep.b.Voltage6 = 0;
			tmpStep.b.Voltage8 = 0;
 80093ba:	f89d 0004 	ldrb.w	r0, [sp, #4]
 80093be:	f36f 0000 	bfc	r0, #0, #1
 80093c2:	f88d 0004 	strb.w	r0, [sp, #4]
			tmpStep.b.FullRange = 1;
 80093c6:	f001 010f 	and.w	r1, r1, #15
 80093ca:	f041 0104 	orr.w	r1, r1, #4
 80093ce:	f88d 1003 	strb.w	r1, [sp, #3]
		};
		
		if ( !key->b.Pulse1On ) {
 80093d2:	78e1      	ldrb	r1, [r4, #3]
 80093d4:	f011 0f10 	tst.w	r1, #16
 80093d8:	d105      	bne.n	80093e6 <keyb_proc+0x18e>
			tmpStep.b.OutputPulse1 = 1;
 80093da:	f89d 0005 	ldrb.w	r0, [sp, #5]
 80093de:	f040 0008 	orr.w	r0, r0, #8
 80093e2:	f88d 0005 	strb.w	r0, [sp, #5]
		};
		
		if ( !key->b.Pulse1Off ) {
 80093e6:	f011 0f20 	tst.w	r1, #32
 80093ea:	d105      	bne.n	80093f8 <keyb_proc+0x1a0>
			tmpStep.b.OutputPulse1 = 0;
 80093ec:	f89d 0005 	ldrb.w	r0, [sp, #5]
 80093f0:	f36f 00c3 	bfc	r0, #3, #1
 80093f4:	f88d 0005 	strb.w	r0, [sp, #5]
		};
		
		if ( !key->b.Pulse2On ) {
 80093f8:	f011 0f40 	tst.w	r1, #64	; 0x40
 80093fc:	d105      	bne.n	800940a <keyb_proc+0x1b2>
			tmpStep.b.OutputPulse2 = 1;
 80093fe:	f89d 0005 	ldrb.w	r0, [sp, #5]
 8009402:	f040 0010 	orr.w	r0, r0, #16
 8009406:	f88d 0005 	strb.w	r0, [sp, #5]
		};
		
		if ( !key->b.Pulse2Off ) {
 800940a:	f011 0f80 	tst.w	r1, #128	; 0x80
 800940e:	d105      	bne.n	800941c <keyb_proc+0x1c4>
			tmpStep.b.OutputPulse2 = 0;
 8009410:	f89d 1005 	ldrb.w	r1, [sp, #5]
 8009414:	f36f 1104 	bfc	r1, #4, #1
 8009418:	f88d 1005 	strb.w	r1, [sp, #5]
		};
		
		if ( !key->b.OutputQuantize ) {
 800941c:	7821      	ldrb	r1, [r4, #0]
 800941e:	f011 0f10 	tst.w	r1, #16
 8009422:	d105      	bne.n	8009430 <keyb_proc+0x1d8>
			tmpStep.b.Quantize = 1;
 8009424:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8009428:	f040 0001 	orr.w	r0, r0, #1
 800942c:	f88d 0003 	strb.w	r0, [sp, #3]
		};
		
		if ( !key->b.OutputContinuous ) {
 8009430:	f011 0f20 	tst.w	r1, #32
 8009434:	d105      	bne.n	8009442 <keyb_proc+0x1ea>
			tmpStep.b.Quantize = 0;
 8009436:	f89d 0003 	ldrb.w	r0, [sp, #3]
 800943a:	f36f 0000 	bfc	r0, #0, #1
 800943e:	f88d 0003 	strb.w	r0, [sp, #3]
		};
		
		if ( !key->b.IntegrationSloped ) {
 8009442:	f011 0f40 	tst.w	r1, #64	; 0x40
 8009446:	d105      	bne.n	8009454 <keyb_proc+0x1fc>
			tmpStep.b.Sloped = 1;
 8009448:	f89d 0003 	ldrb.w	r0, [sp, #3]
 800944c:	f040 0002 	orr.w	r0, r0, #2
 8009450:	f88d 0003 	strb.w	r0, [sp, #3]
		};
		
		if ( !key->b.IntegrationStepped ) {
 8009454:	f011 0f80 	tst.w	r1, #128	; 0x80
 8009458:	d105      	bne.n	8009466 <keyb_proc+0x20e>
			tmpStep.b.Sloped = 0;
 800945a:	f89d 1003 	ldrb.w	r1, [sp, #3]
 800945e:	f36f 0141 	bfc	r1, #1, #1
 8009462:	f88d 1003 	strb.w	r1, [sp, #3]
		};
		
		if ( !key->b.SourceExternal ) {
 8009466:	f012 0f04 	tst.w	r2, #4
 800946a:	d105      	bne.n	8009478 <keyb_proc+0x220>
			tmpStep.b.VoltageSource = 1;
 800946c:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8009470:	f041 0108 	orr.w	r1, r1, #8
 8009474:	f88d 1003 	strb.w	r1, [sp, #3]
		};
		
		if ( !key->b.SourceInternal ) {
 8009478:	f012 0f08 	tst.w	r2, #8
 800947c:	d105      	bne.n	800948a <keyb_proc+0x232>
			tmpStep.b.VoltageSource = 0;
 800947e:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009482:	f36f 02c3 	bfc	r2, #3, #1
 8009486:	f88d 2003 	strb.w	r2, [sp, #3]
		};
		
		if ( !key->b.StopOn ) {
 800948a:	f013 0f02 	tst.w	r3, #2
 800948e:	d13d      	bne.n	800950c <keyb_proc+0x2b4>
			tmpStep.b.OpModeSTOP = 1;
 8009490:	f89d 2004 	ldrb.w	r2, [sp, #4]
			tmpStep.b.OpModeENABLE = 0;
 8009494:	f042 0202 	orr.w	r2, r2, #2
			tmpStep.b.OpModeSUSTAIN = 0;
 8009498:	f002 02f7 	and.w	r2, r2, #247	; 0xf7
 800949c:	f36f 0282 	bfc	r2, #2, #1
 80094a0:	f88d 2004 	strb.w	r2, [sp, #4]
			if ((gDisplayMode == DISPLAY_MODE_VIEW_1 || gDisplayMode == DISPLAY_MODE_EDIT_1) && gSequencerMode_1 == SEQUENCER_MODE_STAY_HI_Z) {
 80094a4:	4a38      	ldr	r2, [pc, #224]	; (8009588 <keyb_proc+0x330>)
 80094a6:	79d2      	ldrb	r2, [r2, #7]
 80094a8:	b122      	cbz	r2, 80094b4 <keyb_proc+0x25c>
 80094aa:	4a37      	ldr	r2, [pc, #220]	; (8009588 <keyb_proc+0x330>)
 80094ac:	79d2      	ldrb	r2, [r2, #7]
 80094ae:	b2d2      	uxtb	r2, r2
 80094b0:	2a02      	cmp	r2, #2
 80094b2:	d105      	bne.n	80094c0 <keyb_proc+0x268>
 80094b4:	4a34      	ldr	r2, [pc, #208]	; (8009588 <keyb_proc+0x330>)
 80094b6:	7852      	ldrb	r2, [r2, #1]
 80094b8:	b2d2      	uxtb	r2, r2
 80094ba:	2a05      	cmp	r2, #5
 80094bc:	f000 81cf 	beq.w	800985e <keyb_proc+0x606>
				gSequencerMode_1 = SEQUENCER_MODE_STOP;
				};
			if ((gDisplayMode == DISPLAY_MODE_VIEW_2 || gDisplayMode == DISPLAY_MODE_EDIT_2) && gSequencerMode_2 == SEQUENCER_MODE_STAY_HI_Z) {
 80094c0:	4a31      	ldr	r2, [pc, #196]	; (8009588 <keyb_proc+0x330>)
 80094c2:	79d2      	ldrb	r2, [r2, #7]
 80094c4:	b2d2      	uxtb	r2, r2
 80094c6:	2a01      	cmp	r2, #1
 80094c8:	f000 81cd 	beq.w	8009866 <keyb_proc+0x60e>
 80094cc:	4a2e      	ldr	r2, [pc, #184]	; (8009588 <keyb_proc+0x330>)
 80094ce:	79d2      	ldrb	r2, [r2, #7]
 80094d0:	b2d2      	uxtb	r2, r2
 80094d2:	2a03      	cmp	r2, #3
 80094d4:	f000 81c7 	beq.w	8009866 <keyb_proc+0x60e>
				gSequencerMode_2 = SEQUENCER_MODE_STOP;
				};
			if ((gDisplayMode == DISPLAY_MODE_VIEW_1 || gDisplayMode == DISPLAY_MODE_EDIT_1) && gSequencerMode_1 == SEQUENCER_MODE_WAIT_HI_Z) {
 80094d8:	4a2b      	ldr	r2, [pc, #172]	; (8009588 <keyb_proc+0x330>)
 80094da:	79d2      	ldrb	r2, [r2, #7]
 80094dc:	b122      	cbz	r2, 80094e8 <keyb_proc+0x290>
 80094de:	4a2a      	ldr	r2, [pc, #168]	; (8009588 <keyb_proc+0x330>)
 80094e0:	79d2      	ldrb	r2, [r2, #7]
 80094e2:	b2d2      	uxtb	r2, r2
 80094e4:	2a02      	cmp	r2, #2
 80094e6:	d105      	bne.n	80094f4 <keyb_proc+0x29c>
 80094e8:	4a27      	ldr	r2, [pc, #156]	; (8009588 <keyb_proc+0x330>)
 80094ea:	7852      	ldrb	r2, [r2, #1]
 80094ec:	b2d2      	uxtb	r2, r2
 80094ee:	2a04      	cmp	r2, #4
 80094f0:	f000 81c8 	beq.w	8009884 <keyb_proc+0x62c>
				gSequencerMode_1 = SEQUENCER_MODE_STOP;
				};
			if ((gDisplayMode == DISPLAY_MODE_VIEW_2 || gDisplayMode == DISPLAY_MODE_EDIT_2) && gSequencerMode_2 == SEQUENCER_MODE_WAIT_HI_Z) {
 80094f4:	4a24      	ldr	r2, [pc, #144]	; (8009588 <keyb_proc+0x330>)
 80094f6:	79d2      	ldrb	r2, [r2, #7]
 80094f8:	b2d2      	uxtb	r2, r2
 80094fa:	2a01      	cmp	r2, #1
 80094fc:	f000 81c6 	beq.w	800988c <keyb_proc+0x634>
 8009500:	4a21      	ldr	r2, [pc, #132]	; (8009588 <keyb_proc+0x330>)
 8009502:	79d2      	ldrb	r2, [r2, #7]
 8009504:	b2d2      	uxtb	r2, r2
 8009506:	2a03      	cmp	r2, #3
 8009508:	f000 81c0 	beq.w	800988c <keyb_proc+0x634>
				gSequencerMode_2 = SEQUENCER_MODE_STOP;
				};
		};
		
		if ( !key->b.StopOff ) {
 800950c:	f013 0f04 	tst.w	r3, #4
 8009510:	d105      	bne.n	800951e <keyb_proc+0x2c6>
			tmpStep.b.OpModeSTOP = 0;
 8009512:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8009516:	f36f 0241 	bfc	r2, #1, #1
 800951a:	f88d 2004 	strb.w	r2, [sp, #4]
			/* Determine step num for different DisplayModes */
		};
		
		if ( !key->b.SustainOn ) {
 800951e:	f013 0f08 	tst.w	r3, #8
 8009522:	d123      	bne.n	800956c <keyb_proc+0x314>
			tmpStep.b.OpModeSUSTAIN = 1;
 8009524:	f89d 2004 	ldrb.w	r2, [sp, #4]
			tmpStep.b.OpModeSTOP = 0;
 8009528:	f042 0204 	orr.w	r2, r2, #4
			tmpStep.b.OpModeENABLE = 0;
 800952c:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
 8009530:	f36f 02c3 	bfc	r2, #3, #1
 8009534:	f88d 2004 	strb.w	r2, [sp, #4]
				if ((gDisplayMode == DISPLAY_MODE_VIEW_1 || gDisplayMode == DISPLAY_MODE_EDIT_1) && gSequencerMode_1 == SEQUENCER_MODE_WAIT_HI_Z) {
 8009538:	4a13      	ldr	r2, [pc, #76]	; (8009588 <keyb_proc+0x330>)
 800953a:	79d2      	ldrb	r2, [r2, #7]
 800953c:	b122      	cbz	r2, 8009548 <keyb_proc+0x2f0>
 800953e:	4a12      	ldr	r2, [pc, #72]	; (8009588 <keyb_proc+0x330>)
 8009540:	79d2      	ldrb	r2, [r2, #7]
 8009542:	b2d2      	uxtb	r2, r2
 8009544:	2a02      	cmp	r2, #2
 8009546:	d105      	bne.n	8009554 <keyb_proc+0x2fc>
 8009548:	4a0f      	ldr	r2, [pc, #60]	; (8009588 <keyb_proc+0x330>)
 800954a:	7852      	ldrb	r2, [r2, #1]
 800954c:	b2d2      	uxtb	r2, r2
 800954e:	2a04      	cmp	r2, #4
 8009550:	f000 81a6 	beq.w	80098a0 <keyb_proc+0x648>
				gSequencerMode_1 = gPrevSequencerMode_1;
			};
			if ((gDisplayMode == DISPLAY_MODE_VIEW_2 || gDisplayMode == DISPLAY_MODE_EDIT_2) && gSequencerMode_2 == SEQUENCER_MODE_WAIT_HI_Z) {
 8009554:	4a0c      	ldr	r2, [pc, #48]	; (8009588 <keyb_proc+0x330>)
 8009556:	79d2      	ldrb	r2, [r2, #7]
 8009558:	b2d2      	uxtb	r2, r2
 800955a:	2a01      	cmp	r2, #1
 800955c:	f000 81a5 	beq.w	80098aa <keyb_proc+0x652>
 8009560:	4a09      	ldr	r2, [pc, #36]	; (8009588 <keyb_proc+0x330>)
 8009562:	79d2      	ldrb	r2, [r2, #7]
 8009564:	b2d2      	uxtb	r2, r2
 8009566:	2a03      	cmp	r2, #3
 8009568:	f000 819f 	beq.w	80098aa <keyb_proc+0x652>
				gSequencerMode_2 = gPrevSequencerMode_2;
			};
		};
		
		if ( !key->b.SustainOff ) {
 800956c:	f013 0f10 	tst.w	r3, #16
 8009570:	d125      	bne.n	80095be <keyb_proc+0x366>
			tmpStep.b.OpModeSUSTAIN = 0;
 8009572:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8009576:	f36f 0282 	bfc	r2, #2, #1
 800957a:	f88d 2004 	strb.w	r2, [sp, #4]
			if ((gDisplayMode == DISPLAY_MODE_VIEW_1 || gDisplayMode == DISPLAY_MODE_EDIT_1) && gSequencerMode_1 == SEQUENCER_MODE_STAY_HI_Z) {
 800957e:	4a02      	ldr	r2, [pc, #8]	; (8009588 <keyb_proc+0x330>)
 8009580:	79d2      	ldrb	r2, [r2, #7]
 8009582:	b152      	cbz	r2, 800959a <keyb_proc+0x342>
 8009584:	e004      	b.n	8009590 <keyb_proc+0x338>
 8009586:	bf00      	nop
 8009588:	200006b4 	.word	0x200006b4
 800958c:	20000cb4 	.word	0x20000cb4
 8009590:	4aba      	ldr	r2, [pc, #744]	; (800987c <keyb_proc+0x624>)
 8009592:	79d2      	ldrb	r2, [r2, #7]
 8009594:	b2d2      	uxtb	r2, r2
 8009596:	2a02      	cmp	r2, #2
 8009598:	d105      	bne.n	80095a6 <keyb_proc+0x34e>
 800959a:	4ab8      	ldr	r2, [pc, #736]	; (800987c <keyb_proc+0x624>)
 800959c:	7852      	ldrb	r2, [r2, #1]
 800959e:	b2d2      	uxtb	r2, r2
 80095a0:	2a05      	cmp	r2, #5
 80095a2:	f000 818d 	beq.w	80098c0 <keyb_proc+0x668>
				gSequencerMode_1 = gPrevSequencerMode_1;
			};
			if ((gDisplayMode == DISPLAY_MODE_VIEW_2 || gDisplayMode == DISPLAY_MODE_EDIT_2) && gSequencerMode_2 == SEQUENCER_MODE_STAY_HI_Z) {
 80095a6:	4ab5      	ldr	r2, [pc, #724]	; (800987c <keyb_proc+0x624>)
 80095a8:	79d2      	ldrb	r2, [r2, #7]
 80095aa:	b2d2      	uxtb	r2, r2
 80095ac:	2a01      	cmp	r2, #1
 80095ae:	f000 818c 	beq.w	80098ca <keyb_proc+0x672>
 80095b2:	4ab2      	ldr	r2, [pc, #712]	; (800987c <keyb_proc+0x624>)
 80095b4:	79d2      	ldrb	r2, [r2, #7]
 80095b6:	b2d2      	uxtb	r2, r2
 80095b8:	2a03      	cmp	r2, #3
 80095ba:	f000 8186 	beq.w	80098ca <keyb_proc+0x672>
				gSequencerMode_2 = gPrevSequencerMode_2;
			};
		};
		
		if ( !key->b.EnableOn ) {
 80095be:	f013 0f20 	tst.w	r3, #32
 80095c2:	d123      	bne.n	800960c <keyb_proc+0x3b4>
			tmpStep.b.OpModeENABLE = 1;
 80095c4:	f89d 2004 	ldrb.w	r2, [sp, #4]
			tmpStep.b.OpModeSTOP = 0;
 80095c8:	f042 0208 	orr.w	r2, r2, #8
			tmpStep.b.OpModeSUSTAIN = 0;
 80095cc:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
 80095d0:	f36f 0282 	bfc	r2, #2, #1
 80095d4:	f88d 2004 	strb.w	r2, [sp, #4]
						if ((gDisplayMode == DISPLAY_MODE_VIEW_1 || gDisplayMode == DISPLAY_MODE_EDIT_1) && gSequencerMode_1 == SEQUENCER_MODE_STAY_HI_Z) {
 80095d8:	4aa8      	ldr	r2, [pc, #672]	; (800987c <keyb_proc+0x624>)
 80095da:	79d2      	ldrb	r2, [r2, #7]
 80095dc:	b122      	cbz	r2, 80095e8 <keyb_proc+0x390>
 80095de:	4aa7      	ldr	r2, [pc, #668]	; (800987c <keyb_proc+0x624>)
 80095e0:	79d2      	ldrb	r2, [r2, #7]
 80095e2:	b2d2      	uxtb	r2, r2
 80095e4:	2a02      	cmp	r2, #2
 80095e6:	d105      	bne.n	80095f4 <keyb_proc+0x39c>
 80095e8:	4aa4      	ldr	r2, [pc, #656]	; (800987c <keyb_proc+0x624>)
 80095ea:	7852      	ldrb	r2, [r2, #1]
 80095ec:	b2d2      	uxtb	r2, r2
 80095ee:	2a05      	cmp	r2, #5
 80095f0:	f000 8176 	beq.w	80098e0 <keyb_proc+0x688>
				gSequencerMode_1 = gPrevSequencerMode_1;
			};
			if ((gDisplayMode == DISPLAY_MODE_VIEW_2 || gDisplayMode == DISPLAY_MODE_EDIT_2) && gSequencerMode_2 == SEQUENCER_MODE_STAY_HI_Z) {
 80095f4:	4aa1      	ldr	r2, [pc, #644]	; (800987c <keyb_proc+0x624>)
 80095f6:	79d2      	ldrb	r2, [r2, #7]
 80095f8:	b2d2      	uxtb	r2, r2
 80095fa:	2a01      	cmp	r2, #1
 80095fc:	f000 8175 	beq.w	80098ea <keyb_proc+0x692>
 8009600:	4a9e      	ldr	r2, [pc, #632]	; (800987c <keyb_proc+0x624>)
 8009602:	79d2      	ldrb	r2, [r2, #7]
 8009604:	b2d2      	uxtb	r2, r2
 8009606:	2a03      	cmp	r2, #3
 8009608:	f000 816f 	beq.w	80098ea <keyb_proc+0x692>
				gSequencerMode_2 = gPrevSequencerMode_2;
			};
		};
		
		if ( !key->b.EnableOff ) {
 800960c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8009610:	d11f      	bne.n	8009652 <keyb_proc+0x3fa>
			tmpStep.b.OpModeENABLE = 0;
 8009612:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8009616:	f36f 02c3 	bfc	r2, #3, #1
 800961a:	f88d 2004 	strb.w	r2, [sp, #4]
				if ((gDisplayMode == DISPLAY_MODE_VIEW_1 || gDisplayMode == DISPLAY_MODE_EDIT_1) && gSequencerMode_1 == SEQUENCER_MODE_WAIT_HI_Z) {
 800961e:	4a97      	ldr	r2, [pc, #604]	; (800987c <keyb_proc+0x624>)
 8009620:	79d2      	ldrb	r2, [r2, #7]
 8009622:	b122      	cbz	r2, 800962e <keyb_proc+0x3d6>
 8009624:	4a95      	ldr	r2, [pc, #596]	; (800987c <keyb_proc+0x624>)
 8009626:	79d2      	ldrb	r2, [r2, #7]
 8009628:	b2d2      	uxtb	r2, r2
 800962a:	2a02      	cmp	r2, #2
 800962c:	d105      	bne.n	800963a <keyb_proc+0x3e2>
 800962e:	4a93      	ldr	r2, [pc, #588]	; (800987c <keyb_proc+0x624>)
 8009630:	7852      	ldrb	r2, [r2, #1]
 8009632:	b2d2      	uxtb	r2, r2
 8009634:	2a04      	cmp	r2, #4
 8009636:	f000 8163 	beq.w	8009900 <keyb_proc+0x6a8>
				gSequencerMode_1 = gPrevSequencerMode_1;
			};
			if ((gDisplayMode == DISPLAY_MODE_VIEW_2 || gDisplayMode == DISPLAY_MODE_EDIT_2) && gSequencerMode_2 == SEQUENCER_MODE_WAIT_HI_Z) {
 800963a:	4a90      	ldr	r2, [pc, #576]	; (800987c <keyb_proc+0x624>)
 800963c:	79d2      	ldrb	r2, [r2, #7]
 800963e:	b2d2      	uxtb	r2, r2
 8009640:	2a01      	cmp	r2, #1
 8009642:	f000 8162 	beq.w	800990a <keyb_proc+0x6b2>
 8009646:	4a8d      	ldr	r2, [pc, #564]	; (800987c <keyb_proc+0x624>)
 8009648:	79d2      	ldrb	r2, [r2, #7]
 800964a:	b2d2      	uxtb	r2, r2
 800964c:	2a03      	cmp	r2, #3
 800964e:	f000 815c 	beq.w	800990a <keyb_proc+0x6b2>
				gSequencerMode_2 = gPrevSequencerMode_2;
			};
		};
		
		if ( !key->b.FirstOn ) {
 8009652:	f013 0f80 	tst.w	r3, #128	; 0x80
 8009656:	d107      	bne.n	8009668 <keyb_proc+0x410>
			tmpStep.b.CycleFirst = 1;
 8009658:	f89d 3004 	ldrb.w	r3, [sp, #4]
			tmpStep.b.CycleLast = 0;
 800965c:	f043 0310 	orr.w	r3, r3, #16
 8009660:	f36f 1345 	bfc	r3, #5, #1
 8009664:	f88d 3004 	strb.w	r3, [sp, #4]
		};
		
		if ( !key->b.FirstOff ) {
 8009668:	79a3      	ldrb	r3, [r4, #6]
 800966a:	f013 0f01 	tst.w	r3, #1
 800966e:	d105      	bne.n	800967c <keyb_proc+0x424>
			tmpStep.b.CycleFirst = 0;
 8009670:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8009674:	f36f 1204 	bfc	r2, #4, #1
 8009678:	f88d 2004 	strb.w	r2, [sp, #4]
		};
		
		if ( !key->b.LastOn ) {		
 800967c:	f013 0f02 	tst.w	r3, #2
 8009680:	d107      	bne.n	8009692 <keyb_proc+0x43a>
			tmpStep.b.CycleLast = 1;
 8009682:	f89d 2004 	ldrb.w	r2, [sp, #4]
			tmpStep.b.CycleFirst = 0;
 8009686:	f042 0220 	orr.w	r2, r2, #32
 800968a:	f36f 1204 	bfc	r2, #4, #1
 800968e:	f88d 2004 	strb.w	r2, [sp, #4]
		};
		
		if ( !key->b.LastOff ) {
 8009692:	f013 0f04 	tst.w	r3, #4
 8009696:	d105      	bne.n	80096a4 <keyb_proc+0x44c>
			tmpStep.b.CycleLast = 0;
 8009698:	f89d 2004 	ldrb.w	r2, [sp, #4]
 800969c:	f36f 1245 	bfc	r2, #5, #1
 80096a0:	f88d 2004 	strb.w	r2, [sp, #4]
		};
		
		if ( !key->b.TimeSourceExternal ) {
 80096a4:	7922      	ldrb	r2, [r4, #4]
 80096a6:	f012 0f01 	tst.w	r2, #1
 80096aa:	d105      	bne.n	80096b8 <keyb_proc+0x460>
			tmpStep.b.TimeSource = 1;
 80096ac:	f89d 1005 	ldrb.w	r1, [sp, #5]
 80096b0:	f041 0104 	orr.w	r1, r1, #4
 80096b4:	f88d 1005 	strb.w	r1, [sp, #5]
		};
		
		if ( !key->b.TimeSourceInternal ) {
 80096b8:	f012 0f02 	tst.w	r2, #2
 80096bc:	d105      	bne.n	80096ca <keyb_proc+0x472>
			tmpStep.b.TimeSource = 0;
 80096be:	f89d 2005 	ldrb.w	r2, [sp, #5]
 80096c2:	f36f 0282 	bfc	r2, #2, #1
 80096c6:	f88d 2005 	strb.w	r2, [sp, #5]
		};
		
		if (!key->b.TimeRange1) {
 80096ca:	f013 0f08 	tst.w	r3, #8
 80096ce:	d10f      	bne.n	80096f0 <keyb_proc+0x498>
			tmpStep.b.TimeRange_p03 = 1;
 80096d0:	f89d 2004 	ldrb.w	r2, [sp, #4]
			tmpStep.b.TimeRange_p3 =  0;
 80096d4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80096d8:	f36f 12c7 	bfc	r2, #7, #1
 80096dc:	f88d 2004 	strb.w	r2, [sp, #4]
			tmpStep.b.TimeRange_3 =   0;
 80096e0:	f89d 2005 	ldrb.w	r2, [sp, #5]
			tmpStep.b.TimeRange_30 =  0;                        
 80096e4:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 80096e8:	f36f 0241 	bfc	r2, #1, #1
 80096ec:	f88d 2005 	strb.w	r2, [sp, #5]
		};

		if (!key->b.TimeRange2) {
 80096f0:	f013 0f10 	tst.w	r3, #16
 80096f4:	d10f      	bne.n	8009716 <keyb_proc+0x4be>
			tmpStep.b.TimeRange_p03 = 0;
 80096f6:	f89d 2004 	ldrb.w	r2, [sp, #4]
			tmpStep.b.TimeRange_p3 =  1;
 80096fa:	f002 02bf 	and.w	r2, r2, #191	; 0xbf
 80096fe:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8009702:	f88d 2004 	strb.w	r2, [sp, #4]
			tmpStep.b.TimeRange_3 =   0;
 8009706:	f89d 2005 	ldrb.w	r2, [sp, #5]
			tmpStep.b.TimeRange_30 =  0; 
 800970a:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 800970e:	f36f 0241 	bfc	r2, #1, #1
 8009712:	f88d 2005 	strb.w	r2, [sp, #5]
		};

		if (!key->b.TimeRange3) {
 8009716:	f013 0f20 	tst.w	r3, #32
 800971a:	d10f      	bne.n	800973c <keyb_proc+0x4e4>
			tmpStep.b.TimeRange_p03 = 0;
 800971c:	f89d 2004 	ldrb.w	r2, [sp, #4]
			tmpStep.b.TimeRange_p3 =  0;
 8009720:	f002 02bf 	and.w	r2, r2, #191	; 0xbf
 8009724:	f36f 12c7 	bfc	r2, #7, #1
 8009728:	f88d 2004 	strb.w	r2, [sp, #4]
			tmpStep.b.TimeRange_3 =   1;
 800972c:	f89d 2005 	ldrb.w	r2, [sp, #5]
			tmpStep.b.TimeRange_30 =  0; 
 8009730:	f042 0201 	orr.w	r2, r2, #1
 8009734:	f36f 0241 	bfc	r2, #1, #1
 8009738:	f88d 2005 	strb.w	r2, [sp, #5]
		};

		if (!key->b.TimeRange4) {
 800973c:	f013 0f40 	tst.w	r3, #64	; 0x40
 8009740:	d10f      	bne.n	8009762 <keyb_proc+0x50a>
			tmpStep.b.TimeRange_p03 = 0;
 8009742:	f89d 3004 	ldrb.w	r3, [sp, #4]
			tmpStep.b.TimeRange_p3 =  0;
 8009746:	f003 03bf 	and.w	r3, r3, #191	; 0xbf
 800974a:	f36f 13c7 	bfc	r3, #7, #1
 800974e:	f88d 3004 	strb.w	r3, [sp, #4]
			tmpStep.b.TimeRange_3 =   0;
 8009752:	f89d 3005 	ldrb.w	r3, [sp, #5]
			tmpStep.b.TimeRange_30 =  1; 
 8009756:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 800975a:	f043 0302 	orr.w	r3, r3, #2
 800975e:	f88d 3005 	strb.w	r3, [sp, #5]
		};
		
		if (!key->b.ClearUp)  {
 8009762:	7823      	ldrb	r3, [r4, #0]
 8009764:	f013 0f01 	tst.w	r3, #1
 8009768:	f000 80da 	beq.w	8009920 <keyb_proc+0x6c8>
				DisplayUpdateFlags.b.StepsDisplay = 1;
				DisplayUpdateFlags.b.MainDisplay = 1;
			};			
		};
		
		if (!key->b.ClearDown)  {
 800976c:	7823      	ldrb	r3, [r4, #0]
 800976e:	f013 0f02 	tst.w	r3, #2
 8009772:	f000 8139 	beq.w	80099e8 <keyb_proc+0x790>
		};
		

		
		//switch to edit mode
		if ( !key->b.StepLeft ) {
 8009776:	7823      	ldrb	r3, [r4, #0]
 8009778:	f013 0f04 	tst.w	r3, #4
 800977c:	f040 8229 	bne.w	8009bd2 <keyb_proc+0x97a>
			if (gDisplayMode == DISPLAY_MODE_VIEW_1) {
 8009780:	4b3e      	ldr	r3, [pc, #248]	; (800987c <keyb_proc+0x624>)
 8009782:	79db      	ldrb	r3, [r3, #7]
 8009784:	b92b      	cbnz	r3, 8009792 <keyb_proc+0x53a>
				gDisplayMode = DISPLAY_MODE_EDIT_1;
 8009786:	4b3d      	ldr	r3, [pc, #244]	; (800987c <keyb_proc+0x624>)
 8009788:	2202      	movs	r2, #2
 800978a:	71da      	strb	r2, [r3, #7]
				gEditModeStepNum = 1;
 800978c:	2201      	movs	r2, #1
 800978e:	f883 2020 	strb.w	r2, [r3, #32]
			};
			if (gDisplayMode == DISPLAY_MODE_VIEW_2) {
 8009792:	4b3a      	ldr	r3, [pc, #232]	; (800987c <keyb_proc+0x624>)
 8009794:	79db      	ldrb	r3, [r3, #7]
 8009796:	b2db      	uxtb	r3, r3
 8009798:	2b01      	cmp	r3, #1
 800979a:	f000 816e 	beq.w	8009a7a <keyb_proc+0x822>
				gDisplayMode = DISPLAY_MODE_EDIT_2;
				gEditModeStepNum = 1;
			};
			if ( (gDisplayMode == DISPLAY_MODE_EDIT_1) ||
 800979e:	4b37      	ldr	r3, [pc, #220]	; (800987c <keyb_proc+0x624>)
 80097a0:	79db      	ldrb	r3, [r3, #7]
 80097a2:	b2db      	uxtb	r3, r3
 80097a4:	2b02      	cmp	r3, #2
 80097a6:	f000 816f 	beq.w	8009a88 <keyb_proc+0x830>
						(gDisplayMode == DISPLAY_MODE_EDIT_2) ) {
 80097aa:	4b34      	ldr	r3, [pc, #208]	; (800987c <keyb_proc+0x624>)
 80097ac:	79db      	ldrb	r3, [r3, #7]
 80097ae:	b2db      	uxtb	r3, r3
			if ( (gDisplayMode == DISPLAY_MODE_EDIT_1) ||
 80097b0:	2b03      	cmp	r3, #3
 80097b2:	f000 8169 	beq.w	8009a88 <keyb_proc+0x830>
					DisplayUpdateFlags.b.StepsDisplay = 1;
				};
			};
			
			//if in save or load mode left buttons select memory cell for save/recall
			if ( (gDisplayMode == DISPLAY_MODE_SAVE_1) || (gDisplayMode == DISPLAY_MODE_SAVE_2) ||
 80097b6:	4b31      	ldr	r3, [pc, #196]	; (800987c <keyb_proc+0x624>)
 80097b8:	79db      	ldrb	r3, [r3, #7]
 80097ba:	b2db      	uxtb	r3, r3
 80097bc:	2b04      	cmp	r3, #4
 80097be:	d00f      	beq.n	80097e0 <keyb_proc+0x588>
 80097c0:	4b2e      	ldr	r3, [pc, #184]	; (800987c <keyb_proc+0x624>)
 80097c2:	79db      	ldrb	r3, [r3, #7]
 80097c4:	b2db      	uxtb	r3, r3
 80097c6:	2b05      	cmp	r3, #5
 80097c8:	d00a      	beq.n	80097e0 <keyb_proc+0x588>
				 (gDisplayMode == DISPLAY_MODE_LOAD_1) || (gDisplayMode == DISPLAY_MODE_LOAD_2) ) {
 80097ca:	4b2c      	ldr	r3, [pc, #176]	; (800987c <keyb_proc+0x624>)
 80097cc:	79db      	ldrb	r3, [r3, #7]
 80097ce:	b2db      	uxtb	r3, r3
			if ( (gDisplayMode == DISPLAY_MODE_SAVE_1) || (gDisplayMode == DISPLAY_MODE_SAVE_2) ||
 80097d0:	2b06      	cmp	r3, #6
 80097d2:	d005      	beq.n	80097e0 <keyb_proc+0x588>
				 (gDisplayMode == DISPLAY_MODE_LOAD_1) || (gDisplayMode == DISPLAY_MODE_LOAD_2) ) {
 80097d4:	4b29      	ldr	r3, [pc, #164]	; (800987c <keyb_proc+0x624>)
 80097d6:	79db      	ldrb	r3, [r3, #7]
 80097d8:	b2db      	uxtb	r3, r3
 80097da:	2b07      	cmp	r3, #7
 80097dc:	f040 81fc 	bne.w	8009bd8 <keyb_proc+0x980>
				if (gEditModeStepNum > 0) {
 80097e0:	4b26      	ldr	r3, [pc, #152]	; (800987c <keyb_proc+0x624>)
 80097e2:	f893 3020 	ldrb.w	r3, [r3, #32]
 80097e6:	2b00      	cmp	r3, #0
 80097e8:	f000 81aa 	beq.w	8009b40 <keyb_proc+0x8e8>
					if(counterL == 0) gEditModeStepNum--;
 80097ec:	4a23      	ldr	r2, [pc, #140]	; (800987c <keyb_proc+0x624>)
 80097ee:	8c52      	ldrh	r2, [r2, #34]	; 0x22
 80097f0:	2a00      	cmp	r2, #0
 80097f2:	f040 8191 	bne.w	8009b18 <keyb_proc+0x8c0>
 80097f6:	3b01      	subs	r3, #1
 80097f8:	4a20      	ldr	r2, [pc, #128]	; (800987c <keyb_proc+0x624>)
 80097fa:	f882 3020 	strb.w	r3, [r2, #32]
						{
							counterL = 500;
							gEditModeStepNum--;
						}
					}
					counterL++;
 80097fe:	4a1f      	ldr	r2, [pc, #124]	; (800987c <keyb_proc+0x624>)
 8009800:	8c53      	ldrh	r3, [r2, #34]	; 0x22
 8009802:	3301      	adds	r3, #1
 8009804:	8453      	strh	r3, [r2, #34]	; 0x22
					DisplayUpdateFlags.b.StepsDisplay = 1;
 8009806:	4a1e      	ldr	r2, [pc, #120]	; (8009880 <keyb_proc+0x628>)
 8009808:	7813      	ldrb	r3, [r2, #0]
 800980a:	f043 0302 	orr.w	r3, r3, #2
 800980e:	7013      	strb	r3, [r2, #0]
 8009810:	e1e2      	b.n	8009bd8 <keyb_proc+0x980>
	else max_step = 15;
 8009812:	260f      	movs	r6, #15
 8009814:	e52a      	b.n	800926c <keyb_proc+0x14>
	unsigned char StepNum = 0, Section = 0, max_step;
 8009816:	2300      	movs	r3, #0
 8009818:	e530      	b.n	800927c <keyb_proc+0x24>
		StepNum = gSequenceStepNumber_2;
 800981a:	4b18      	ldr	r3, [pc, #96]	; (800987c <keyb_proc+0x624>)
 800981c:	799b      	ldrb	r3, [r3, #6]
 800981e:	b2db      	uxtb	r3, r3
 8009820:	e533      	b.n	800928a <keyb_proc+0x32>
		StepNum = gEditModeStepNum;
 8009822:	4b16      	ldr	r3, [pc, #88]	; (800987c <keyb_proc+0x624>)
 8009824:	f893 3020 	ldrb.w	r3, [r3, #32]
		Section = 0;
 8009828:	2200      	movs	r2, #0
 800982a:	e534      	b.n	8009296 <keyb_proc+0x3e>
		StepNum = gEditModeStepNum;
 800982c:	4b13      	ldr	r3, [pc, #76]	; (800987c <keyb_proc+0x624>)
 800982e:	f893 3020 	ldrb.w	r3, [r3, #32]
		Section = 1;
 8009832:	2201      	movs	r2, #1
 8009834:	e535      	b.n	80092a2 <keyb_proc+0x4a>
		StepNum = gEditModeStepNum;
 8009836:	4b11      	ldr	r3, [pc, #68]	; (800987c <keyb_proc+0x624>)
 8009838:	f893 3020 	ldrb.w	r3, [r3, #32]
		Section = 0;
 800983c:	2200      	movs	r2, #0
 800983e:	e536      	b.n	80092ae <keyb_proc+0x56>
		StepNum = gEditModeStepNum;
 8009840:	4b0e      	ldr	r3, [pc, #56]	; (800987c <keyb_proc+0x624>)
 8009842:	f893 3020 	ldrb.w	r3, [r3, #32]
		Section = 1;
 8009846:	2201      	movs	r2, #1
 8009848:	e537      	b.n	80092ba <keyb_proc+0x62>
		StepNum = gEditModeStepNum;
 800984a:	4b0c      	ldr	r3, [pc, #48]	; (800987c <keyb_proc+0x624>)
 800984c:	f893 3020 	ldrb.w	r3, [r3, #32]
		Section = 0;
 8009850:	2200      	movs	r2, #0
 8009852:	e538      	b.n	80092c6 <keyb_proc+0x6e>
		StepNum = gEditModeStepNum;
 8009854:	4b09      	ldr	r3, [pc, #36]	; (800987c <keyb_proc+0x624>)
 8009856:	f893 3020 	ldrb.w	r3, [r3, #32]
		Section = 1;
 800985a:	2201      	movs	r2, #1
 800985c:	e539      	b.n	80092d2 <keyb_proc+0x7a>
				gSequencerMode_1 = SEQUENCER_MODE_STOP;
 800985e:	2102      	movs	r1, #2
 8009860:	4a06      	ldr	r2, [pc, #24]	; (800987c <keyb_proc+0x624>)
 8009862:	7051      	strb	r1, [r2, #1]
 8009864:	e62c      	b.n	80094c0 <keyb_proc+0x268>
			if ((gDisplayMode == DISPLAY_MODE_VIEW_2 || gDisplayMode == DISPLAY_MODE_EDIT_2) && gSequencerMode_2 == SEQUENCER_MODE_STAY_HI_Z) {
 8009866:	4a05      	ldr	r2, [pc, #20]	; (800987c <keyb_proc+0x624>)
 8009868:	78d2      	ldrb	r2, [r2, #3]
 800986a:	b2d2      	uxtb	r2, r2
 800986c:	2a05      	cmp	r2, #5
 800986e:	f47f ae33 	bne.w	80094d8 <keyb_proc+0x280>
				gSequencerMode_2 = SEQUENCER_MODE_STOP;
 8009872:	2102      	movs	r1, #2
 8009874:	4a01      	ldr	r2, [pc, #4]	; (800987c <keyb_proc+0x624>)
 8009876:	70d1      	strb	r1, [r2, #3]
 8009878:	e62e      	b.n	80094d8 <keyb_proc+0x280>
 800987a:	bf00      	nop
 800987c:	200006b4 	.word	0x200006b4
 8009880:	20000708 	.word	0x20000708
				gSequencerMode_1 = SEQUENCER_MODE_STOP;
 8009884:	2102      	movs	r1, #2
 8009886:	4aac      	ldr	r2, [pc, #688]	; (8009b38 <keyb_proc+0x8e0>)
 8009888:	7051      	strb	r1, [r2, #1]
 800988a:	e633      	b.n	80094f4 <keyb_proc+0x29c>
			if ((gDisplayMode == DISPLAY_MODE_VIEW_2 || gDisplayMode == DISPLAY_MODE_EDIT_2) && gSequencerMode_2 == SEQUENCER_MODE_WAIT_HI_Z) {
 800988c:	4aaa      	ldr	r2, [pc, #680]	; (8009b38 <keyb_proc+0x8e0>)
 800988e:	78d2      	ldrb	r2, [r2, #3]
 8009890:	b2d2      	uxtb	r2, r2
 8009892:	2a04      	cmp	r2, #4
 8009894:	f47f ae3a 	bne.w	800950c <keyb_proc+0x2b4>
				gSequencerMode_2 = SEQUENCER_MODE_STOP;
 8009898:	2102      	movs	r1, #2
 800989a:	4aa7      	ldr	r2, [pc, #668]	; (8009b38 <keyb_proc+0x8e0>)
 800989c:	70d1      	strb	r1, [r2, #3]
 800989e:	e635      	b.n	800950c <keyb_proc+0x2b4>
				gSequencerMode_1 = gPrevSequencerMode_1;
 80098a0:	49a5      	ldr	r1, [pc, #660]	; (8009b38 <keyb_proc+0x8e0>)
 80098a2:	788a      	ldrb	r2, [r1, #2]
 80098a4:	b2d2      	uxtb	r2, r2
 80098a6:	704a      	strb	r2, [r1, #1]
 80098a8:	e654      	b.n	8009554 <keyb_proc+0x2fc>
			if ((gDisplayMode == DISPLAY_MODE_VIEW_2 || gDisplayMode == DISPLAY_MODE_EDIT_2) && gSequencerMode_2 == SEQUENCER_MODE_WAIT_HI_Z) {
 80098aa:	4aa3      	ldr	r2, [pc, #652]	; (8009b38 <keyb_proc+0x8e0>)
 80098ac:	78d2      	ldrb	r2, [r2, #3]
 80098ae:	b2d2      	uxtb	r2, r2
 80098b0:	2a04      	cmp	r2, #4
 80098b2:	f47f ae5b 	bne.w	800956c <keyb_proc+0x314>
				gSequencerMode_2 = gPrevSequencerMode_2;
 80098b6:	49a0      	ldr	r1, [pc, #640]	; (8009b38 <keyb_proc+0x8e0>)
 80098b8:	790a      	ldrb	r2, [r1, #4]
 80098ba:	b2d2      	uxtb	r2, r2
 80098bc:	70ca      	strb	r2, [r1, #3]
 80098be:	e655      	b.n	800956c <keyb_proc+0x314>
				gSequencerMode_1 = gPrevSequencerMode_1;
 80098c0:	499d      	ldr	r1, [pc, #628]	; (8009b38 <keyb_proc+0x8e0>)
 80098c2:	788a      	ldrb	r2, [r1, #2]
 80098c4:	b2d2      	uxtb	r2, r2
 80098c6:	704a      	strb	r2, [r1, #1]
 80098c8:	e66d      	b.n	80095a6 <keyb_proc+0x34e>
			if ((gDisplayMode == DISPLAY_MODE_VIEW_2 || gDisplayMode == DISPLAY_MODE_EDIT_2) && gSequencerMode_2 == SEQUENCER_MODE_STAY_HI_Z) {
 80098ca:	4a9b      	ldr	r2, [pc, #620]	; (8009b38 <keyb_proc+0x8e0>)
 80098cc:	78d2      	ldrb	r2, [r2, #3]
 80098ce:	b2d2      	uxtb	r2, r2
 80098d0:	2a05      	cmp	r2, #5
 80098d2:	f47f ae74 	bne.w	80095be <keyb_proc+0x366>
				gSequencerMode_2 = gPrevSequencerMode_2;
 80098d6:	4998      	ldr	r1, [pc, #608]	; (8009b38 <keyb_proc+0x8e0>)
 80098d8:	790a      	ldrb	r2, [r1, #4]
 80098da:	b2d2      	uxtb	r2, r2
 80098dc:	70ca      	strb	r2, [r1, #3]
 80098de:	e66e      	b.n	80095be <keyb_proc+0x366>
				gSequencerMode_1 = gPrevSequencerMode_1;
 80098e0:	4995      	ldr	r1, [pc, #596]	; (8009b38 <keyb_proc+0x8e0>)
 80098e2:	788a      	ldrb	r2, [r1, #2]
 80098e4:	b2d2      	uxtb	r2, r2
 80098e6:	704a      	strb	r2, [r1, #1]
 80098e8:	e684      	b.n	80095f4 <keyb_proc+0x39c>
			if ((gDisplayMode == DISPLAY_MODE_VIEW_2 || gDisplayMode == DISPLAY_MODE_EDIT_2) && gSequencerMode_2 == SEQUENCER_MODE_STAY_HI_Z) {
 80098ea:	4a93      	ldr	r2, [pc, #588]	; (8009b38 <keyb_proc+0x8e0>)
 80098ec:	78d2      	ldrb	r2, [r2, #3]
 80098ee:	b2d2      	uxtb	r2, r2
 80098f0:	2a05      	cmp	r2, #5
 80098f2:	f47f ae8b 	bne.w	800960c <keyb_proc+0x3b4>
				gSequencerMode_2 = gPrevSequencerMode_2;
 80098f6:	4990      	ldr	r1, [pc, #576]	; (8009b38 <keyb_proc+0x8e0>)
 80098f8:	790a      	ldrb	r2, [r1, #4]
 80098fa:	b2d2      	uxtb	r2, r2
 80098fc:	70ca      	strb	r2, [r1, #3]
 80098fe:	e685      	b.n	800960c <keyb_proc+0x3b4>
				gSequencerMode_1 = gPrevSequencerMode_1;
 8009900:	498d      	ldr	r1, [pc, #564]	; (8009b38 <keyb_proc+0x8e0>)
 8009902:	788a      	ldrb	r2, [r1, #2]
 8009904:	b2d2      	uxtb	r2, r2
 8009906:	704a      	strb	r2, [r1, #1]
 8009908:	e697      	b.n	800963a <keyb_proc+0x3e2>
			if ((gDisplayMode == DISPLAY_MODE_VIEW_2 || gDisplayMode == DISPLAY_MODE_EDIT_2) && gSequencerMode_2 == SEQUENCER_MODE_WAIT_HI_Z) {
 800990a:	4a8b      	ldr	r2, [pc, #556]	; (8009b38 <keyb_proc+0x8e0>)
 800990c:	78d2      	ldrb	r2, [r2, #3]
 800990e:	b2d2      	uxtb	r2, r2
 8009910:	2a04      	cmp	r2, #4
 8009912:	f47f ae9e 	bne.w	8009652 <keyb_proc+0x3fa>
				gSequencerMode_2 = gPrevSequencerMode_2;
 8009916:	4988      	ldr	r1, [pc, #544]	; (8009b38 <keyb_proc+0x8e0>)
 8009918:	790a      	ldrb	r2, [r1, #4]
 800991a:	b2d2      	uxtb	r2, r2
 800991c:	70ca      	strb	r2, [r1, #3]
 800991e:	e698      	b.n	8009652 <keyb_proc+0x3fa>
			InitClear_Timer();
 8009920:	f7fe f986 	bl	8007c30 <InitClear_Timer>
			if (gDisplayMode == DISPLAY_MODE_LOAD_1) {
 8009924:	4b84      	ldr	r3, [pc, #528]	; (8009b38 <keyb_proc+0x8e0>)
 8009926:	79db      	ldrb	r3, [r3, #7]
 8009928:	b2db      	uxtb	r3, r3
 800992a:	2b06      	cmp	r3, #6
 800992c:	d018      	beq.n	8009960 <keyb_proc+0x708>
			else if (gDisplayMode == DISPLAY_MODE_LOAD_2) {
 800992e:	4b82      	ldr	r3, [pc, #520]	; (8009b38 <keyb_proc+0x8e0>)
 8009930:	79db      	ldrb	r3, [r3, #7]
 8009932:	b2db      	uxtb	r3, r3
 8009934:	2b07      	cmp	r3, #7
 8009936:	d02a      	beq.n	800998e <keyb_proc+0x736>
			else if (gDisplayMode == DISPLAY_MODE_VIEW_1) {
 8009938:	4b7f      	ldr	r3, [pc, #508]	; (8009b38 <keyb_proc+0x8e0>)
 800993a:	79db      	ldrb	r3, [r3, #7]
 800993c:	2b00      	cmp	r3, #0
 800993e:	d13d      	bne.n	80099bc <keyb_proc+0x764>
				gDisplayMode = DISPLAY_MODE_LOAD_1;
 8009940:	4b7d      	ldr	r3, [pc, #500]	; (8009b38 <keyb_proc+0x8e0>)
 8009942:	2206      	movs	r2, #6
 8009944:	71da      	strb	r2, [r3, #7]
				gEditModeStepNum = 0;
 8009946:	2200      	movs	r2, #0
 8009948:	f883 2020 	strb.w	r2, [r3, #32]
				DisplayUpdateFlags.b.StepsDisplay = 1;
 800994c:	4b7b      	ldr	r3, [pc, #492]	; (8009b3c <keyb_proc+0x8e4>)
 800994e:	781a      	ldrb	r2, [r3, #0]
 8009950:	f042 0202 	orr.w	r2, r2, #2
 8009954:	701a      	strb	r2, [r3, #0]
				DisplayUpdateFlags.b.MainDisplay = 1;
 8009956:	781a      	ldrb	r2, [r3, #0]
 8009958:	f042 0201 	orr.w	r2, r2, #1
 800995c:	701a      	strb	r2, [r3, #0]
 800995e:	e705      	b.n	800976c <keyb_proc+0x514>
				LoadSequence(gEditModeStepNum);
 8009960:	f8df 81d4 	ldr.w	r8, [pc, #468]	; 8009b38 <keyb_proc+0x8e0>
 8009964:	f898 0020 	ldrb.w	r0, [r8, #32]
 8009968:	f7fe f9ee 	bl	8007d48 <LoadSequence>
				gKeysNotValid = 1;
 800996c:	2301      	movs	r3, #1
 800996e:	f888 3021 	strb.w	r3, [r8, #33]	; 0x21
				gDisplayMode = DISPLAY_MODE_VIEW_1;
 8009972:	2200      	movs	r2, #0
 8009974:	f888 2007 	strb.w	r2, [r8, #7]
				gPrevSequencerMode_1 = gSequencerMode_1;
 8009978:	f898 3001 	ldrb.w	r3, [r8, #1]
 800997c:	b2db      	uxtb	r3, r3
 800997e:	f888 3002 	strb.w	r3, [r8, #2]
				gSequenceStepNumber_1 = 0;
 8009982:	f888 2005 	strb.w	r2, [r8, #5]
				gSequencerMode_1 = SEQUENCER_MODE_STOP;
 8009986:	2302      	movs	r3, #2
 8009988:	f888 3001 	strb.w	r3, [r8, #1]
 800998c:	e6ee      	b.n	800976c <keyb_proc+0x514>
				LoadSequence(gEditModeStepNum);
 800998e:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8009b38 <keyb_proc+0x8e0>
 8009992:	f898 0020 	ldrb.w	r0, [r8, #32]
 8009996:	f7fe f9d7 	bl	8007d48 <LoadSequence>
				gKeysNotValid = 1;
 800999a:	2301      	movs	r3, #1
 800999c:	f888 3021 	strb.w	r3, [r8, #33]	; 0x21
				gDisplayMode = DISPLAY_MODE_VIEW_2;
 80099a0:	f888 3007 	strb.w	r3, [r8, #7]
				gPrevSequencerMode_2 = gSequencerMode_2;
 80099a4:	f898 3003 	ldrb.w	r3, [r8, #3]
 80099a8:	b2db      	uxtb	r3, r3
 80099aa:	f888 3004 	strb.w	r3, [r8, #4]
				gSequenceStepNumber_2 = 0;
 80099ae:	2300      	movs	r3, #0
 80099b0:	f888 3006 	strb.w	r3, [r8, #6]
				gSequencerMode_2 = SEQUENCER_MODE_STOP;
 80099b4:	2302      	movs	r3, #2
 80099b6:	f888 3003 	strb.w	r3, [r8, #3]
 80099ba:	e6d7      	b.n	800976c <keyb_proc+0x514>
			else if (gDisplayMode == DISPLAY_MODE_VIEW_2) {
 80099bc:	4b5e      	ldr	r3, [pc, #376]	; (8009b38 <keyb_proc+0x8e0>)
 80099be:	79db      	ldrb	r3, [r3, #7]
 80099c0:	b2db      	uxtb	r3, r3
 80099c2:	2b01      	cmp	r3, #1
 80099c4:	f47f aed2 	bne.w	800976c <keyb_proc+0x514>
				gDisplayMode = DISPLAY_MODE_LOAD_2;
 80099c8:	4b5b      	ldr	r3, [pc, #364]	; (8009b38 <keyb_proc+0x8e0>)
 80099ca:	2207      	movs	r2, #7
 80099cc:	71da      	strb	r2, [r3, #7]
				gEditModeStepNum = 0;
 80099ce:	2200      	movs	r2, #0
 80099d0:	f883 2020 	strb.w	r2, [r3, #32]
				DisplayUpdateFlags.b.StepsDisplay = 1;
 80099d4:	4b59      	ldr	r3, [pc, #356]	; (8009b3c <keyb_proc+0x8e4>)
 80099d6:	781a      	ldrb	r2, [r3, #0]
 80099d8:	f042 0202 	orr.w	r2, r2, #2
 80099dc:	701a      	strb	r2, [r3, #0]
				DisplayUpdateFlags.b.MainDisplay = 1;
 80099de:	781a      	ldrb	r2, [r3, #0]
 80099e0:	f042 0201 	orr.w	r2, r2, #1
 80099e4:	701a      	strb	r2, [r3, #0]
 80099e6:	e6c1      	b.n	800976c <keyb_proc+0x514>
			InitClear_Timer();
 80099e8:	f7fe f922 	bl	8007c30 <InitClear_Timer>
			if (gDisplayMode == DISPLAY_MODE_SAVE_1) {
 80099ec:	4b52      	ldr	r3, [pc, #328]	; (8009b38 <keyb_proc+0x8e0>)
 80099ee:	79db      	ldrb	r3, [r3, #7]
 80099f0:	b2db      	uxtb	r3, r3
 80099f2:	2b04      	cmp	r3, #4
 80099f4:	d017      	beq.n	8009a26 <keyb_proc+0x7ce>
			else if (gDisplayMode == DISPLAY_MODE_SAVE_2) {
 80099f6:	4b50      	ldr	r3, [pc, #320]	; (8009b38 <keyb_proc+0x8e0>)
 80099f8:	79db      	ldrb	r3, [r3, #7]
 80099fa:	b2db      	uxtb	r3, r3
 80099fc:	2b05      	cmp	r3, #5
 80099fe:	d01c      	beq.n	8009a3a <keyb_proc+0x7e2>
			else if (gDisplayMode == DISPLAY_MODE_VIEW_1) {
 8009a00:	4b4d      	ldr	r3, [pc, #308]	; (8009b38 <keyb_proc+0x8e0>)
 8009a02:	79db      	ldrb	r3, [r3, #7]
 8009a04:	bb1b      	cbnz	r3, 8009a4e <keyb_proc+0x7f6>
				gDisplayMode = DISPLAY_MODE_SAVE_1;
 8009a06:	4b4c      	ldr	r3, [pc, #304]	; (8009b38 <keyb_proc+0x8e0>)
 8009a08:	2204      	movs	r2, #4
 8009a0a:	71da      	strb	r2, [r3, #7]
				gEditModeStepNum = 0;
 8009a0c:	2200      	movs	r2, #0
 8009a0e:	f883 2020 	strb.w	r2, [r3, #32]
				DisplayUpdateFlags.b.StepsDisplay = 1;
 8009a12:	4b4a      	ldr	r3, [pc, #296]	; (8009b3c <keyb_proc+0x8e4>)
 8009a14:	781a      	ldrb	r2, [r3, #0]
 8009a16:	f042 0202 	orr.w	r2, r2, #2
 8009a1a:	701a      	strb	r2, [r3, #0]
				DisplayUpdateFlags.b.MainDisplay = 1;
 8009a1c:	781a      	ldrb	r2, [r3, #0]
 8009a1e:	f042 0201 	orr.w	r2, r2, #1
 8009a22:	701a      	strb	r2, [r3, #0]
 8009a24:	e6a7      	b.n	8009776 <keyb_proc+0x51e>
				SaveSequence(gEditModeStepNum);
 8009a26:	f8df 8110 	ldr.w	r8, [pc, #272]	; 8009b38 <keyb_proc+0x8e0>
 8009a2a:	f898 0020 	ldrb.w	r0, [r8, #32]
 8009a2e:	f7fe f94d 	bl	8007ccc <SaveSequence>
				gDisplayMode = DISPLAY_MODE_VIEW_1;
 8009a32:	2300      	movs	r3, #0
 8009a34:	f888 3007 	strb.w	r3, [r8, #7]
 8009a38:	e69d      	b.n	8009776 <keyb_proc+0x51e>
				SaveSequence(gEditModeStepNum);
 8009a3a:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 8009b38 <keyb_proc+0x8e0>
 8009a3e:	f898 0020 	ldrb.w	r0, [r8, #32]
 8009a42:	f7fe f943 	bl	8007ccc <SaveSequence>
				gDisplayMode = DISPLAY_MODE_VIEW_2;
 8009a46:	2301      	movs	r3, #1
 8009a48:	f888 3007 	strb.w	r3, [r8, #7]
 8009a4c:	e693      	b.n	8009776 <keyb_proc+0x51e>
			else if (gDisplayMode == DISPLAY_MODE_VIEW_2) {
 8009a4e:	4b3a      	ldr	r3, [pc, #232]	; (8009b38 <keyb_proc+0x8e0>)
 8009a50:	79db      	ldrb	r3, [r3, #7]
 8009a52:	b2db      	uxtb	r3, r3
 8009a54:	2b01      	cmp	r3, #1
 8009a56:	f47f ae8e 	bne.w	8009776 <keyb_proc+0x51e>
				gDisplayMode = DISPLAY_MODE_SAVE_2;
 8009a5a:	4b37      	ldr	r3, [pc, #220]	; (8009b38 <keyb_proc+0x8e0>)
 8009a5c:	2205      	movs	r2, #5
 8009a5e:	71da      	strb	r2, [r3, #7]
				gEditModeStepNum = 0;
 8009a60:	2200      	movs	r2, #0
 8009a62:	f883 2020 	strb.w	r2, [r3, #32]
				DisplayUpdateFlags.b.StepsDisplay = 1;
 8009a66:	4b35      	ldr	r3, [pc, #212]	; (8009b3c <keyb_proc+0x8e4>)
 8009a68:	781a      	ldrb	r2, [r3, #0]
 8009a6a:	f042 0202 	orr.w	r2, r2, #2
 8009a6e:	701a      	strb	r2, [r3, #0]
				DisplayUpdateFlags.b.MainDisplay = 1;
 8009a70:	781a      	ldrb	r2, [r3, #0]
 8009a72:	f042 0201 	orr.w	r2, r2, #1
 8009a76:	701a      	strb	r2, [r3, #0]
 8009a78:	e67d      	b.n	8009776 <keyb_proc+0x51e>
				gDisplayMode = DISPLAY_MODE_EDIT_2;
 8009a7a:	4b2f      	ldr	r3, [pc, #188]	; (8009b38 <keyb_proc+0x8e0>)
 8009a7c:	2203      	movs	r2, #3
 8009a7e:	71da      	strb	r2, [r3, #7]
				gEditModeStepNum = 1;
 8009a80:	2201      	movs	r2, #1
 8009a82:	f883 2020 	strb.w	r2, [r3, #32]
 8009a86:	e68a      	b.n	800979e <keyb_proc+0x546>
				if (gEditModeStepNum > 0) {
 8009a88:	4b2b      	ldr	r3, [pc, #172]	; (8009b38 <keyb_proc+0x8e0>)
 8009a8a:	f893 3020 	ldrb.w	r3, [r3, #32]
 8009a8e:	b313      	cbz	r3, 8009ad6 <keyb_proc+0x87e>
					if(counterL == 0) gEditModeStepNum--;
 8009a90:	4a29      	ldr	r2, [pc, #164]	; (8009b38 <keyb_proc+0x8e0>)
 8009a92:	8c52      	ldrh	r2, [r2, #34]	; 0x22
 8009a94:	b98a      	cbnz	r2, 8009aba <keyb_proc+0x862>
 8009a96:	3b01      	subs	r3, #1
 8009a98:	4a27      	ldr	r2, [pc, #156]	; (8009b38 <keyb_proc+0x8e0>)
 8009a9a:	f882 3020 	strb.w	r3, [r2, #32]
					counterL++;
 8009a9e:	4a26      	ldr	r2, [pc, #152]	; (8009b38 <keyb_proc+0x8e0>)
 8009aa0:	8c53      	ldrh	r3, [r2, #34]	; 0x22
 8009aa2:	3301      	adds	r3, #1
 8009aa4:	8453      	strh	r3, [r2, #34]	; 0x22
					DisplayUpdateFlags.b.MainDisplay = 1;
 8009aa6:	4b25      	ldr	r3, [pc, #148]	; (8009b3c <keyb_proc+0x8e4>)
 8009aa8:	781a      	ldrb	r2, [r3, #0]
 8009aaa:	f042 0201 	orr.w	r2, r2, #1
 8009aae:	701a      	strb	r2, [r3, #0]
					DisplayUpdateFlags.b.StepsDisplay = 1;
 8009ab0:	781a      	ldrb	r2, [r3, #0]
 8009ab2:	f042 0202 	orr.w	r2, r2, #2
 8009ab6:	701a      	strb	r2, [r3, #0]
 8009ab8:	e67d      	b.n	80097b6 <keyb_proc+0x55e>
					else if(counterL >= 500)
 8009aba:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
 8009abe:	d3ee      	bcc.n	8009a9e <keyb_proc+0x846>
						if(counterL > 600)
 8009ac0:	f5b2 7f16 	cmp.w	r2, #600	; 0x258
 8009ac4:	d9eb      	bls.n	8009a9e <keyb_proc+0x846>
							counterL = 500;
 8009ac6:	4a1c      	ldr	r2, [pc, #112]	; (8009b38 <keyb_proc+0x8e0>)
 8009ac8:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8009acc:	8451      	strh	r1, [r2, #34]	; 0x22
							gEditModeStepNum--;
 8009ace:	3b01      	subs	r3, #1
 8009ad0:	f882 3020 	strb.w	r3, [r2, #32]
 8009ad4:	e7e3      	b.n	8009a9e <keyb_proc+0x846>
					if(counterL == 0) gEditModeStepNum = max_step;
 8009ad6:	4b18      	ldr	r3, [pc, #96]	; (8009b38 <keyb_proc+0x8e0>)
 8009ad8:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8009ada:	b983      	cbnz	r3, 8009afe <keyb_proc+0x8a6>
 8009adc:	4b16      	ldr	r3, [pc, #88]	; (8009b38 <keyb_proc+0x8e0>)
 8009ade:	f883 6020 	strb.w	r6, [r3, #32]
					counterL++;
 8009ae2:	4a15      	ldr	r2, [pc, #84]	; (8009b38 <keyb_proc+0x8e0>)
 8009ae4:	8c53      	ldrh	r3, [r2, #34]	; 0x22
 8009ae6:	3301      	adds	r3, #1
 8009ae8:	8453      	strh	r3, [r2, #34]	; 0x22
					DisplayUpdateFlags.b.MainDisplay = 1;
 8009aea:	4b14      	ldr	r3, [pc, #80]	; (8009b3c <keyb_proc+0x8e4>)
 8009aec:	781a      	ldrb	r2, [r3, #0]
 8009aee:	f042 0201 	orr.w	r2, r2, #1
 8009af2:	701a      	strb	r2, [r3, #0]
					DisplayUpdateFlags.b.StepsDisplay = 1;
 8009af4:	781a      	ldrb	r2, [r3, #0]
 8009af6:	f042 0202 	orr.w	r2, r2, #2
 8009afa:	701a      	strb	r2, [r3, #0]
 8009afc:	e65b      	b.n	80097b6 <keyb_proc+0x55e>
					else if(counterL >= 500)
 8009afe:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8009b02:	d3ee      	bcc.n	8009ae2 <keyb_proc+0x88a>
						if(counterL > 600)
 8009b04:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 8009b08:	d9eb      	bls.n	8009ae2 <keyb_proc+0x88a>
							counterL = 500;
 8009b0a:	4b0b      	ldr	r3, [pc, #44]	; (8009b38 <keyb_proc+0x8e0>)
 8009b0c:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8009b10:	845a      	strh	r2, [r3, #34]	; 0x22
							gEditModeStepNum = max_step;
 8009b12:	f883 6020 	strb.w	r6, [r3, #32]
 8009b16:	e7e4      	b.n	8009ae2 <keyb_proc+0x88a>
					else if(counterL >= 500)
 8009b18:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
 8009b1c:	f4ff ae6f 	bcc.w	80097fe <keyb_proc+0x5a6>
						if(counterL > 600)
 8009b20:	f5b2 7f16 	cmp.w	r2, #600	; 0x258
 8009b24:	f67f ae6b 	bls.w	80097fe <keyb_proc+0x5a6>
							counterL = 500;
 8009b28:	4a03      	ldr	r2, [pc, #12]	; (8009b38 <keyb_proc+0x8e0>)
 8009b2a:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8009b2e:	8451      	strh	r1, [r2, #34]	; 0x22
							gEditModeStepNum--;
 8009b30:	3b01      	subs	r3, #1
 8009b32:	f882 3020 	strb.w	r3, [r2, #32]
 8009b36:	e662      	b.n	80097fe <keyb_proc+0x5a6>
 8009b38:	200006b4 	.word	0x200006b4
 8009b3c:	20000708 	.word	0x20000708
				} else {
					if(counterL == 0) 
 8009b40:	4b9d      	ldr	r3, [pc, #628]	; (8009db8 <keyb_proc+0xb60>)
 8009b42:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8009b44:	b17b      	cbz	r3, 8009b66 <keyb_proc+0x90e>
								bank = 1;
							}
							}
							else gEditModeStepNum = 31;
					}
					else if(counterL >= 500)
 8009b46:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8009b4a:	d302      	bcc.n	8009b52 <keyb_proc+0x8fa>
					{
						if(counterL > 600)
 8009b4c:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 8009b50:	d822      	bhi.n	8009b98 <keyb_proc+0x940>
								}
							}
							else gEditModeStepNum = 31;
						}
					}
					counterL++;
 8009b52:	4a99      	ldr	r2, [pc, #612]	; (8009db8 <keyb_proc+0xb60>)
 8009b54:	8c53      	ldrh	r3, [r2, #34]	; 0x22
 8009b56:	3301      	adds	r3, #1
 8009b58:	8453      	strh	r3, [r2, #34]	; 0x22

					DisplayUpdateFlags.b.StepsDisplay = 1;
 8009b5a:	4a98      	ldr	r2, [pc, #608]	; (8009dbc <keyb_proc+0xb64>)
 8009b5c:	7813      	ldrb	r3, [r2, #0]
 8009b5e:	f043 0302 	orr.w	r3, r3, #2
 8009b62:	7013      	strb	r3, [r2, #0]
 8009b64:	e038      	b.n	8009bd8 <keyb_proc+0x980>
							if(!Is_Expander_Present())
 8009b66:	f7fd fdb1 	bl	80076cc <Is_Expander_Present>
 8009b6a:	b980      	cbnz	r0, 8009b8e <keyb_proc+0x936>
							gEditModeStepNum = 15;
 8009b6c:	220f      	movs	r2, #15
 8009b6e:	4b92      	ldr	r3, [pc, #584]	; (8009db8 <keyb_proc+0xb60>)
 8009b70:	f883 2020 	strb.w	r2, [r3, #32]
							if(bank == 1) 
 8009b74:	4b92      	ldr	r3, [pc, #584]	; (8009dc0 <keyb_proc+0xb68>)
 8009b76:	781b      	ldrb	r3, [r3, #0]
 8009b78:	b2db      	uxtb	r3, r3
 8009b7a:	2b01      	cmp	r3, #1
 8009b7c:	d003      	beq.n	8009b86 <keyb_proc+0x92e>
								bank = 1;
 8009b7e:	2201      	movs	r2, #1
 8009b80:	4b8f      	ldr	r3, [pc, #572]	; (8009dc0 <keyb_proc+0xb68>)
 8009b82:	701a      	strb	r2, [r3, #0]
 8009b84:	e7e5      	b.n	8009b52 <keyb_proc+0x8fa>
								bank = 2;
 8009b86:	2202      	movs	r2, #2
 8009b88:	4b8d      	ldr	r3, [pc, #564]	; (8009dc0 <keyb_proc+0xb68>)
 8009b8a:	701a      	strb	r2, [r3, #0]
 8009b8c:	e7e1      	b.n	8009b52 <keyb_proc+0x8fa>
							else gEditModeStepNum = 31;
 8009b8e:	221f      	movs	r2, #31
 8009b90:	4b89      	ldr	r3, [pc, #548]	; (8009db8 <keyb_proc+0xb60>)
 8009b92:	f883 2020 	strb.w	r2, [r3, #32]
 8009b96:	e7dc      	b.n	8009b52 <keyb_proc+0x8fa>
							counterL = 500;
 8009b98:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8009b9c:	4b86      	ldr	r3, [pc, #536]	; (8009db8 <keyb_proc+0xb60>)
 8009b9e:	845a      	strh	r2, [r3, #34]	; 0x22
							if(!Is_Expander_Present())
 8009ba0:	f7fd fd94 	bl	80076cc <Is_Expander_Present>
 8009ba4:	b980      	cbnz	r0, 8009bc8 <keyb_proc+0x970>
								gEditModeStepNum = 15;
 8009ba6:	220f      	movs	r2, #15
 8009ba8:	4b83      	ldr	r3, [pc, #524]	; (8009db8 <keyb_proc+0xb60>)
 8009baa:	f883 2020 	strb.w	r2, [r3, #32]
								if(bank == 1) 
 8009bae:	4b84      	ldr	r3, [pc, #528]	; (8009dc0 <keyb_proc+0xb68>)
 8009bb0:	781b      	ldrb	r3, [r3, #0]
 8009bb2:	b2db      	uxtb	r3, r3
 8009bb4:	2b01      	cmp	r3, #1
 8009bb6:	d003      	beq.n	8009bc0 <keyb_proc+0x968>
									bank = 1;
 8009bb8:	2201      	movs	r2, #1
 8009bba:	4b81      	ldr	r3, [pc, #516]	; (8009dc0 <keyb_proc+0xb68>)
 8009bbc:	701a      	strb	r2, [r3, #0]
 8009bbe:	e7c8      	b.n	8009b52 <keyb_proc+0x8fa>
									bank = 2;
 8009bc0:	2202      	movs	r2, #2
 8009bc2:	4b7f      	ldr	r3, [pc, #508]	; (8009dc0 <keyb_proc+0xb68>)
 8009bc4:	701a      	strb	r2, [r3, #0]
 8009bc6:	e7c4      	b.n	8009b52 <keyb_proc+0x8fa>
							else gEditModeStepNum = 31;
 8009bc8:	221f      	movs	r2, #31
 8009bca:	4b7b      	ldr	r3, [pc, #492]	; (8009db8 <keyb_proc+0xb60>)
 8009bcc:	f883 2020 	strb.w	r2, [r3, #32]
 8009bd0:	e7bf      	b.n	8009b52 <keyb_proc+0x8fa>
				};
			};
		}
		else 
		{
			counterL = 0;
 8009bd2:	2200      	movs	r2, #0
 8009bd4:	4b78      	ldr	r3, [pc, #480]	; (8009db8 <keyb_proc+0xb60>)
 8009bd6:	845a      	strh	r2, [r3, #34]	; 0x22
		};
		
		if ( !key->b.StepRight ) {
 8009bd8:	7823      	ldrb	r3, [r4, #0]
 8009bda:	f013 0f08 	tst.w	r3, #8
 8009bde:	f040 80f1 	bne.w	8009dc4 <keyb_proc+0xb6c>
			if (gDisplayMode == DISPLAY_MODE_VIEW_1) {
 8009be2:	4b75      	ldr	r3, [pc, #468]	; (8009db8 <keyb_proc+0xb60>)
 8009be4:	79db      	ldrb	r3, [r3, #7]
 8009be6:	b923      	cbnz	r3, 8009bf2 <keyb_proc+0x99a>
				gDisplayMode = DISPLAY_MODE_EDIT_1;
 8009be8:	4b73      	ldr	r3, [pc, #460]	; (8009db8 <keyb_proc+0xb60>)
 8009bea:	2202      	movs	r2, #2
 8009bec:	71da      	strb	r2, [r3, #7]
				gEditModeStepNum = max_step;
 8009bee:	f883 6020 	strb.w	r6, [r3, #32]
			};
			if (gDisplayMode == DISPLAY_MODE_VIEW_2) {
 8009bf2:	4b71      	ldr	r3, [pc, #452]	; (8009db8 <keyb_proc+0xb60>)
 8009bf4:	79db      	ldrb	r3, [r3, #7]
 8009bf6:	b2db      	uxtb	r3, r3
 8009bf8:	2b01      	cmp	r3, #1
 8009bfa:	d035      	beq.n	8009c68 <keyb_proc+0xa10>
				gDisplayMode = DISPLAY_MODE_EDIT_2;
				gEditModeStepNum = max_step;
			};
			if ( (gDisplayMode == DISPLAY_MODE_EDIT_1) ||
 8009bfc:	4b6e      	ldr	r3, [pc, #440]	; (8009db8 <keyb_proc+0xb60>)
 8009bfe:	79db      	ldrb	r3, [r3, #7]
 8009c00:	b2db      	uxtb	r3, r3
 8009c02:	2b02      	cmp	r3, #2
 8009c04:	d036      	beq.n	8009c74 <keyb_proc+0xa1c>
						(gDisplayMode == DISPLAY_MODE_EDIT_2) ) {
 8009c06:	4b6c      	ldr	r3, [pc, #432]	; (8009db8 <keyb_proc+0xb60>)
 8009c08:	79db      	ldrb	r3, [r3, #7]
 8009c0a:	b2db      	uxtb	r3, r3
			if ( (gDisplayMode == DISPLAY_MODE_EDIT_1) ||
 8009c0c:	2b03      	cmp	r3, #3
 8009c0e:	d031      	beq.n	8009c74 <keyb_proc+0xa1c>
					DisplayUpdateFlags.b.StepsDisplay = 1;
				};
			};			
						
			//if in save or load mode right buttons select memory cell for save/recall
			if ( (gDisplayMode == DISPLAY_MODE_SAVE_1) || (gDisplayMode == DISPLAY_MODE_SAVE_2) ||
 8009c10:	4b69      	ldr	r3, [pc, #420]	; (8009db8 <keyb_proc+0xb60>)
 8009c12:	79db      	ldrb	r3, [r3, #7]
 8009c14:	b2db      	uxtb	r3, r3
 8009c16:	2b04      	cmp	r3, #4
 8009c18:	d00f      	beq.n	8009c3a <keyb_proc+0x9e2>
 8009c1a:	4b67      	ldr	r3, [pc, #412]	; (8009db8 <keyb_proc+0xb60>)
 8009c1c:	79db      	ldrb	r3, [r3, #7]
 8009c1e:	b2db      	uxtb	r3, r3
 8009c20:	2b05      	cmp	r3, #5
 8009c22:	d00a      	beq.n	8009c3a <keyb_proc+0x9e2>
				(gDisplayMode == DISPLAY_MODE_LOAD_1) || (gDisplayMode == DISPLAY_MODE_LOAD_2)) {
 8009c24:	4b64      	ldr	r3, [pc, #400]	; (8009db8 <keyb_proc+0xb60>)
 8009c26:	79db      	ldrb	r3, [r3, #7]
 8009c28:	b2db      	uxtb	r3, r3
			if ( (gDisplayMode == DISPLAY_MODE_SAVE_1) || (gDisplayMode == DISPLAY_MODE_SAVE_2) ||
 8009c2a:	2b06      	cmp	r3, #6
 8009c2c:	d005      	beq.n	8009c3a <keyb_proc+0x9e2>
				(gDisplayMode == DISPLAY_MODE_LOAD_1) || (gDisplayMode == DISPLAY_MODE_LOAD_2)) {
 8009c2e:	4b62      	ldr	r3, [pc, #392]	; (8009db8 <keyb_proc+0xb60>)
 8009c30:	79db      	ldrb	r3, [r3, #7]
 8009c32:	b2db      	uxtb	r3, r3
 8009c34:	2b07      	cmp	r3, #7
 8009c36:	f040 80c8 	bne.w	8009dca <keyb_proc+0xb72>
				if (gEditModeStepNum < max_step) {
 8009c3a:	4b5f      	ldr	r3, [pc, #380]	; (8009db8 <keyb_proc+0xb60>)
 8009c3c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8009c40:	429e      	cmp	r6, r3
 8009c42:	d970      	bls.n	8009d26 <keyb_proc+0xace>
					if(counterR == 0) gEditModeStepNum++;
 8009c44:	4a5c      	ldr	r2, [pc, #368]	; (8009db8 <keyb_proc+0xb60>)
 8009c46:	8c92      	ldrh	r2, [r2, #36]	; 0x24
 8009c48:	2a00      	cmp	r2, #0
 8009c4a:	d15e      	bne.n	8009d0a <keyb_proc+0xab2>
 8009c4c:	3301      	adds	r3, #1
 8009c4e:	4a5a      	ldr	r2, [pc, #360]	; (8009db8 <keyb_proc+0xb60>)
 8009c50:	f882 3020 	strb.w	r3, [r2, #32]
						{
							counterR = 500;
							gEditModeStepNum++;
						}
					}
					counterR++;
 8009c54:	4a58      	ldr	r2, [pc, #352]	; (8009db8 <keyb_proc+0xb60>)
 8009c56:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8009c58:	3301      	adds	r3, #1
 8009c5a:	8493      	strh	r3, [r2, #36]	; 0x24
					DisplayUpdateFlags.b.StepsDisplay = 1;
 8009c5c:	4a57      	ldr	r2, [pc, #348]	; (8009dbc <keyb_proc+0xb64>)
 8009c5e:	7813      	ldrb	r3, [r2, #0]
 8009c60:	f043 0302 	orr.w	r3, r3, #2
 8009c64:	7013      	strb	r3, [r2, #0]
 8009c66:	e0b0      	b.n	8009dca <keyb_proc+0xb72>
				gDisplayMode = DISPLAY_MODE_EDIT_2;
 8009c68:	4b53      	ldr	r3, [pc, #332]	; (8009db8 <keyb_proc+0xb60>)
 8009c6a:	2203      	movs	r2, #3
 8009c6c:	71da      	strb	r2, [r3, #7]
				gEditModeStepNum = max_step;
 8009c6e:	f883 6020 	strb.w	r6, [r3, #32]
 8009c72:	e7c3      	b.n	8009bfc <keyb_proc+0x9a4>
				if (gEditModeStepNum < max_step) {
 8009c74:	4b50      	ldr	r3, [pc, #320]	; (8009db8 <keyb_proc+0xb60>)
 8009c76:	f893 3020 	ldrb.w	r3, [r3, #32]
 8009c7a:	429e      	cmp	r6, r3
 8009c7c:	d922      	bls.n	8009cc4 <keyb_proc+0xa6c>
					if(counterR == 0) gEditModeStepNum++;
 8009c7e:	4a4e      	ldr	r2, [pc, #312]	; (8009db8 <keyb_proc+0xb60>)
 8009c80:	8c92      	ldrh	r2, [r2, #36]	; 0x24
 8009c82:	b98a      	cbnz	r2, 8009ca8 <keyb_proc+0xa50>
 8009c84:	3301      	adds	r3, #1
 8009c86:	4a4c      	ldr	r2, [pc, #304]	; (8009db8 <keyb_proc+0xb60>)
 8009c88:	f882 3020 	strb.w	r3, [r2, #32]
					counterR++;
 8009c8c:	4a4a      	ldr	r2, [pc, #296]	; (8009db8 <keyb_proc+0xb60>)
 8009c8e:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8009c90:	3301      	adds	r3, #1
 8009c92:	8493      	strh	r3, [r2, #36]	; 0x24
					DisplayUpdateFlags.b.MainDisplay = 1;
 8009c94:	4b49      	ldr	r3, [pc, #292]	; (8009dbc <keyb_proc+0xb64>)
 8009c96:	781a      	ldrb	r2, [r3, #0]
 8009c98:	f042 0201 	orr.w	r2, r2, #1
 8009c9c:	701a      	strb	r2, [r3, #0]
					DisplayUpdateFlags.b.StepsDisplay = 1;
 8009c9e:	781a      	ldrb	r2, [r3, #0]
 8009ca0:	f042 0202 	orr.w	r2, r2, #2
 8009ca4:	701a      	strb	r2, [r3, #0]
 8009ca6:	e7b3      	b.n	8009c10 <keyb_proc+0x9b8>
					else if(counterR >= 500)
 8009ca8:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
 8009cac:	d3ee      	bcc.n	8009c8c <keyb_proc+0xa34>
						if(counterR > 600)
 8009cae:	f5b2 7f16 	cmp.w	r2, #600	; 0x258
 8009cb2:	d9eb      	bls.n	8009c8c <keyb_proc+0xa34>
							counterR = 500;
 8009cb4:	4a40      	ldr	r2, [pc, #256]	; (8009db8 <keyb_proc+0xb60>)
 8009cb6:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8009cba:	8491      	strh	r1, [r2, #36]	; 0x24
							gEditModeStepNum++;
 8009cbc:	3301      	adds	r3, #1
 8009cbe:	f882 3020 	strb.w	r3, [r2, #32]
 8009cc2:	e7e3      	b.n	8009c8c <keyb_proc+0xa34>
					if(counterR == 0) gEditModeStepNum = 0;
 8009cc4:	4b3c      	ldr	r3, [pc, #240]	; (8009db8 <keyb_proc+0xb60>)
 8009cc6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8009cc8:	b98b      	cbnz	r3, 8009cee <keyb_proc+0xa96>
 8009cca:	2200      	movs	r2, #0
 8009ccc:	4b3a      	ldr	r3, [pc, #232]	; (8009db8 <keyb_proc+0xb60>)
 8009cce:	f883 2020 	strb.w	r2, [r3, #32]
					counterR++;
 8009cd2:	4a39      	ldr	r2, [pc, #228]	; (8009db8 <keyb_proc+0xb60>)
 8009cd4:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8009cd6:	3301      	adds	r3, #1
 8009cd8:	8493      	strh	r3, [r2, #36]	; 0x24
					DisplayUpdateFlags.b.MainDisplay = 1;
 8009cda:	4b38      	ldr	r3, [pc, #224]	; (8009dbc <keyb_proc+0xb64>)
 8009cdc:	781a      	ldrb	r2, [r3, #0]
 8009cde:	f042 0201 	orr.w	r2, r2, #1
 8009ce2:	701a      	strb	r2, [r3, #0]
					DisplayUpdateFlags.b.StepsDisplay = 1;
 8009ce4:	781a      	ldrb	r2, [r3, #0]
 8009ce6:	f042 0202 	orr.w	r2, r2, #2
 8009cea:	701a      	strb	r2, [r3, #0]
 8009cec:	e790      	b.n	8009c10 <keyb_proc+0x9b8>
					else if(counterR >= 500)
 8009cee:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8009cf2:	d3ee      	bcc.n	8009cd2 <keyb_proc+0xa7a>
						if(counterR > 600)
 8009cf4:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 8009cf8:	d9eb      	bls.n	8009cd2 <keyb_proc+0xa7a>
							counterR = 500;
 8009cfa:	4b2f      	ldr	r3, [pc, #188]	; (8009db8 <keyb_proc+0xb60>)
 8009cfc:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8009d00:	849a      	strh	r2, [r3, #36]	; 0x24
							gEditModeStepNum = 0;
 8009d02:	2200      	movs	r2, #0
 8009d04:	f883 2020 	strb.w	r2, [r3, #32]
 8009d08:	e7e3      	b.n	8009cd2 <keyb_proc+0xa7a>
					else if(counterR >= 500)
 8009d0a:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
 8009d0e:	d3a1      	bcc.n	8009c54 <keyb_proc+0x9fc>
						if(counterR > 600)
 8009d10:	f5b2 7f16 	cmp.w	r2, #600	; 0x258
 8009d14:	d99e      	bls.n	8009c54 <keyb_proc+0x9fc>
							counterR = 500;
 8009d16:	4a28      	ldr	r2, [pc, #160]	; (8009db8 <keyb_proc+0xb60>)
 8009d18:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8009d1c:	8491      	strh	r1, [r2, #36]	; 0x24
							gEditModeStepNum++;
 8009d1e:	3301      	adds	r3, #1
 8009d20:	f882 3020 	strb.w	r3, [r2, #32]
 8009d24:	e796      	b.n	8009c54 <keyb_proc+0x9fc>
				} else {
					
					if(counterR == 0) 
 8009d26:	4b24      	ldr	r3, [pc, #144]	; (8009db8 <keyb_proc+0xb60>)
 8009d28:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8009d2a:	b17b      	cbz	r3, 8009d4c <keyb_proc+0xaf4>
							else 
							{
								gEditModeStepNum = 0;
							}
					}
					else if(counterR >= 500)
 8009d2c:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8009d30:	d302      	bcc.n	8009d38 <keyb_proc+0xae0>
					{
						if(counterR > 600)
 8009d32:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 8009d36:	d822      	bhi.n	8009d7e <keyb_proc+0xb26>
							{
								gEditModeStepNum = 0;
							}
						}
					}
					counterR++;
 8009d38:	4a1f      	ldr	r2, [pc, #124]	; (8009db8 <keyb_proc+0xb60>)
 8009d3a:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 8009d3c:	3301      	adds	r3, #1
 8009d3e:	8493      	strh	r3, [r2, #36]	; 0x24

					DisplayUpdateFlags.b.StepsDisplay = 1;
 8009d40:	4a1e      	ldr	r2, [pc, #120]	; (8009dbc <keyb_proc+0xb64>)
 8009d42:	7813      	ldrb	r3, [r2, #0]
 8009d44:	f043 0302 	orr.w	r3, r3, #2
 8009d48:	7013      	strb	r3, [r2, #0]
 8009d4a:	e03e      	b.n	8009dca <keyb_proc+0xb72>
							if(!Is_Expander_Present())
 8009d4c:	f7fd fcbe 	bl	80076cc <Is_Expander_Present>
 8009d50:	b980      	cbnz	r0, 8009d74 <keyb_proc+0xb1c>
								gEditModeStepNum = 0;
 8009d52:	2200      	movs	r2, #0
 8009d54:	4b18      	ldr	r3, [pc, #96]	; (8009db8 <keyb_proc+0xb60>)
 8009d56:	f883 2020 	strb.w	r2, [r3, #32]
								if(bank == 1) 
 8009d5a:	4b19      	ldr	r3, [pc, #100]	; (8009dc0 <keyb_proc+0xb68>)
 8009d5c:	781b      	ldrb	r3, [r3, #0]
 8009d5e:	b2db      	uxtb	r3, r3
 8009d60:	2b01      	cmp	r3, #1
 8009d62:	d003      	beq.n	8009d6c <keyb_proc+0xb14>
									bank = 1;
 8009d64:	2201      	movs	r2, #1
 8009d66:	4b16      	ldr	r3, [pc, #88]	; (8009dc0 <keyb_proc+0xb68>)
 8009d68:	701a      	strb	r2, [r3, #0]
 8009d6a:	e7e5      	b.n	8009d38 <keyb_proc+0xae0>
									bank = 2;
 8009d6c:	2202      	movs	r2, #2
 8009d6e:	4b14      	ldr	r3, [pc, #80]	; (8009dc0 <keyb_proc+0xb68>)
 8009d70:	701a      	strb	r2, [r3, #0]
 8009d72:	e7e1      	b.n	8009d38 <keyb_proc+0xae0>
								gEditModeStepNum = 0;
 8009d74:	2200      	movs	r2, #0
 8009d76:	4b10      	ldr	r3, [pc, #64]	; (8009db8 <keyb_proc+0xb60>)
 8009d78:	f883 2020 	strb.w	r2, [r3, #32]
 8009d7c:	e7dc      	b.n	8009d38 <keyb_proc+0xae0>
							counterR = 500;
 8009d7e:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 8009d82:	4b0d      	ldr	r3, [pc, #52]	; (8009db8 <keyb_proc+0xb60>)
 8009d84:	849a      	strh	r2, [r3, #36]	; 0x24
							if(!Is_Expander_Present())
 8009d86:	f7fd fca1 	bl	80076cc <Is_Expander_Present>
 8009d8a:	b980      	cbnz	r0, 8009dae <keyb_proc+0xb56>
								gEditModeStepNum = 0;
 8009d8c:	2200      	movs	r2, #0
 8009d8e:	4b0a      	ldr	r3, [pc, #40]	; (8009db8 <keyb_proc+0xb60>)
 8009d90:	f883 2020 	strb.w	r2, [r3, #32]
								if(bank == 1) 
 8009d94:	4b0a      	ldr	r3, [pc, #40]	; (8009dc0 <keyb_proc+0xb68>)
 8009d96:	781b      	ldrb	r3, [r3, #0]
 8009d98:	b2db      	uxtb	r3, r3
 8009d9a:	2b01      	cmp	r3, #1
 8009d9c:	d003      	beq.n	8009da6 <keyb_proc+0xb4e>
									bank = 1;
 8009d9e:	2201      	movs	r2, #1
 8009da0:	4b07      	ldr	r3, [pc, #28]	; (8009dc0 <keyb_proc+0xb68>)
 8009da2:	701a      	strb	r2, [r3, #0]
 8009da4:	e7c8      	b.n	8009d38 <keyb_proc+0xae0>
									bank = 2;
 8009da6:	2202      	movs	r2, #2
 8009da8:	4b05      	ldr	r3, [pc, #20]	; (8009dc0 <keyb_proc+0xb68>)
 8009daa:	701a      	strb	r2, [r3, #0]
 8009dac:	e7c4      	b.n	8009d38 <keyb_proc+0xae0>
								gEditModeStepNum = 0;
 8009dae:	2200      	movs	r2, #0
 8009db0:	4b01      	ldr	r3, [pc, #4]	; (8009db8 <keyb_proc+0xb60>)
 8009db2:	f883 2020 	strb.w	r2, [r3, #32]
 8009db6:	e7bf      	b.n	8009d38 <keyb_proc+0xae0>
 8009db8:	200006b4 	.word	0x200006b4
 8009dbc:	20000708 	.word	0x20000708
 8009dc0:	20000258 	.word	0x20000258
				};
			};
		}
		else 
		{
			counterR = 0;
 8009dc4:	2200      	movs	r2, #0
 8009dc6:	4bb4      	ldr	r3, [pc, #720]	; (800a098 <keyb_proc+0xe40>)
 8009dc8:	849a      	strh	r2, [r3, #36]	; 0x24
		};
	key_locked = 1;
 8009dca:	4bb3      	ldr	r3, [pc, #716]	; (800a098 <keyb_proc+0xe40>)
 8009dcc:	2201      	movs	r2, #1
 8009dce:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	
		
		//Sections 1/2
	if (gKeysNotValid == 0) {
 8009dd2:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8009dd6:	b9c3      	cbnz	r3, 8009e0a <keyb_proc+0xbb2>
		
	if (!key->b.StageAddress1Display) {
 8009dd8:	7963      	ldrb	r3, [r4, #5]
 8009dda:	f013 0f04 	tst.w	r3, #4
 8009dde:	d105      	bne.n	8009dec <keyb_proc+0xb94>
			if (gDisplayMode != DISPLAY_MODE_VIEW_1) {			
 8009de0:	4bad      	ldr	r3, [pc, #692]	; (800a098 <keyb_proc+0xe40>)
 8009de2:	79db      	ldrb	r3, [r3, #7]
 8009de4:	b113      	cbz	r3, 8009dec <keyb_proc+0xb94>
				gDisplayMode = DISPLAY_MODE_VIEW_1;
 8009de6:	2200      	movs	r2, #0
 8009de8:	4bab      	ldr	r3, [pc, #684]	; (800a098 <keyb_proc+0xe40>)
 8009dea:	71da      	strb	r2, [r3, #7]
			};		
		};
		

		if (!key->b.StageAddress2Display) {
 8009dec:	7923      	ldrb	r3, [r4, #4]
 8009dee:	f013 0f40 	tst.w	r3, #64	; 0x40
 8009df2:	d10a      	bne.n	8009e0a <keyb_proc+0xbb2>
			if (gDisplayMode != DISPLAY_MODE_VIEW_2) {			
 8009df4:	4ba8      	ldr	r3, [pc, #672]	; (800a098 <keyb_proc+0xe40>)
 8009df6:	79db      	ldrb	r3, [r3, #7]
 8009df8:	b2db      	uxtb	r3, r3
 8009dfa:	2b01      	cmp	r3, #1
 8009dfc:	d005      	beq.n	8009e0a <keyb_proc+0xbb2>
				gDisplayMode = DISPLAY_MODE_VIEW_2;
 8009dfe:	4ba6      	ldr	r3, [pc, #664]	; (800a098 <keyb_proc+0xe40>)
 8009e00:	2201      	movs	r2, #1
 8009e02:	71da      	strb	r2, [r3, #7]
				key_locked = 0;
 8009e04:	2200      	movs	r2, #0
 8009e06:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
		};
	};
		
	

		if ( (!key->b.StageAddress1Reset)  ) {
 8009e0a:	7963      	ldrb	r3, [r4, #5]
 8009e0c:	f013 0f02 	tst.w	r3, #2
 8009e10:	d11a      	bne.n	8009e48 <keyb_proc+0xbf0>
				if(gSequencerMode_1 != SEQUENCER_MODE_WAIT)
 8009e12:	4ba1      	ldr	r3, [pc, #644]	; (800a098 <keyb_proc+0xe40>)
 8009e14:	785b      	ldrb	r3, [r3, #1]
 8009e16:	b2db      	uxtb	r3, r3
 8009e18:	2b01      	cmp	r3, #1
 8009e1a:	d015      	beq.n	8009e48 <keyb_proc+0xbf0>
				{
				gSequenceStepNumber_1 = 0;
 8009e1c:	499e      	ldr	r1, [pc, #632]	; (800a098 <keyb_proc+0xe40>)
 8009e1e:	2300      	movs	r3, #0
 8009e20:	714b      	strb	r3, [r1, #5]
				DisplayUpdateFlags.b.MainDisplay = 1;
 8009e22:	4b9e      	ldr	r3, [pc, #632]	; (800a09c <keyb_proc+0xe44>)
 8009e24:	781a      	ldrb	r2, [r3, #0]
 8009e26:	f042 0201 	orr.w	r2, r2, #1
 8009e2a:	701a      	strb	r2, [r3, #0]
				DisplayUpdateFlags.b.StepsDisplay = 1;
 8009e2c:	781a      	ldrb	r2, [r3, #0]
 8009e2e:	f042 0202 	orr.w	r2, r2, #2
 8009e32:	701a      	strb	r2, [r3, #0]
				if (gSequencerMode_1 == SEQUENCER_MODE_WAIT_HI_Z || gSequencerMode_1 == SEQUENCER_MODE_STAY_HI_Z) {
 8009e34:	784b      	ldrb	r3, [r1, #1]
 8009e36:	b2db      	uxtb	r3, r3
 8009e38:	2b04      	cmp	r3, #4
 8009e3a:	f000 81ac 	beq.w	800a196 <keyb_proc+0xf3e>
 8009e3e:	784b      	ldrb	r3, [r1, #1]
 8009e40:	b2db      	uxtb	r3, r3
 8009e42:	2b05      	cmp	r3, #5
 8009e44:	f000 81a7 	beq.w	800a196 <keyb_proc+0xf3e>
				}
			};
		};
					

		if ( (!key->b.StageAddress2Reset)  ) {
 8009e48:	7923      	ldrb	r3, [r4, #4]
 8009e4a:	f013 0f20 	tst.w	r3, #32
 8009e4e:	d11a      	bne.n	8009e86 <keyb_proc+0xc2e>
				if(gSequencerMode_2 != SEQUENCER_MODE_WAIT)
 8009e50:	4a91      	ldr	r2, [pc, #580]	; (800a098 <keyb_proc+0xe40>)
 8009e52:	78d2      	ldrb	r2, [r2, #3]
 8009e54:	b2d2      	uxtb	r2, r2
 8009e56:	2a01      	cmp	r2, #1
 8009e58:	d015      	beq.n	8009e86 <keyb_proc+0xc2e>
				{						
					gSequenceStepNumber_2 = 0;
 8009e5a:	488f      	ldr	r0, [pc, #572]	; (800a098 <keyb_proc+0xe40>)
 8009e5c:	2200      	movs	r2, #0
 8009e5e:	7182      	strb	r2, [r0, #6]
					DisplayUpdateFlags.b.MainDisplay = 1;
 8009e60:	4a8e      	ldr	r2, [pc, #568]	; (800a09c <keyb_proc+0xe44>)
 8009e62:	7811      	ldrb	r1, [r2, #0]
 8009e64:	f041 0101 	orr.w	r1, r1, #1
 8009e68:	7011      	strb	r1, [r2, #0]
					DisplayUpdateFlags.b.StepsDisplay = 1;
 8009e6a:	7811      	ldrb	r1, [r2, #0]
 8009e6c:	f041 0102 	orr.w	r1, r1, #2
 8009e70:	7011      	strb	r1, [r2, #0]
					
					if (gSequencerMode_2 == SEQUENCER_MODE_WAIT_HI_Z || gSequencerMode_2 == SEQUENCER_MODE_STAY_HI_Z) {
 8009e72:	78c2      	ldrb	r2, [r0, #3]
 8009e74:	b2d2      	uxtb	r2, r2
 8009e76:	2a04      	cmp	r2, #4
 8009e78:	f000 8192 	beq.w	800a1a0 <keyb_proc+0xf48>
 8009e7c:	78c2      	ldrb	r2, [r0, #3]
 8009e7e:	b2d2      	uxtb	r2, r2
 8009e80:	2a05      	cmp	r2, #5
 8009e82:	f000 818d 	beq.w	800a1a0 <keyb_proc+0xf48>
					gSequencerMode_2 = gPrevSequencerMode_2;
				}
		};
		}
				
		if( key->b.Empty5 && strobe_banana_flag1 == 0)
 8009e86:	f013 0f10 	tst.w	r3, #16
 8009e8a:	d03b      	beq.n	8009f04 <keyb_proc+0xcac>
 8009e8c:	4b82      	ldr	r3, [pc, #520]	; (800a098 <keyb_proc+0xe40>)
 8009e8e:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8009e92:	2b00      	cmp	r3, #0
 8009e94:	d136      	bne.n	8009f04 <keyb_proc+0xcac>
		{
			strobe_banana_flag1 = 1;
 8009e96:	4a80      	ldr	r2, [pc, #512]	; (800a098 <keyb_proc+0xe40>)
 8009e98:	2301      	movs	r3, #1
 8009e9a:	f882 3027 	strb.w	r3, [r2, #39]	; 0x27
				gSequenceStepNumber_1 = (unsigned int) (pots_step[0]-1);
 8009e9e:	4b80      	ldr	r3, [pc, #512]	; (800a0a0 <keyb_proc+0xe48>)
 8009ea0:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8009ea4:	3b01      	subs	r3, #1
 8009ea6:	b2db      	uxtb	r3, r3
 8009ea8:	7153      	strb	r3, [r2, #5]
			
			if ( gDisplayMode == DISPLAY_MODE_VIEW_1 ) {
 8009eaa:	79d3      	ldrb	r3, [r2, #7]
 8009eac:	b943      	cbnz	r3, 8009ec0 <keyb_proc+0xc68>
				DisplayUpdateFlags.b.MainDisplay = 1;
 8009eae:	4b7b      	ldr	r3, [pc, #492]	; (800a09c <keyb_proc+0xe44>)
 8009eb0:	781a      	ldrb	r2, [r3, #0]
 8009eb2:	f042 0201 	orr.w	r2, r2, #1
 8009eb6:	701a      	strb	r2, [r3, #0]
				DisplayUpdateFlags.b.StepsDisplay = 1;
 8009eb8:	781a      	ldrb	r2, [r3, #0]
 8009eba:	f042 0202 	orr.w	r2, r2, #2
 8009ebe:	701a      	strb	r2, [r3, #0]
			};
			
				PULSE_LED_I_ALL_ON;
 8009ec0:	f44f 7100 	mov.w	r1, #512	; 0x200
 8009ec4:	4877      	ldr	r0, [pc, #476]	; (800a0a4 <keyb_proc+0xe4c>)
 8009ec6:	f7f9 fdc3 	bl	8003a50 <GPIO_ResetBits>
				
				if (Steps[0][gSequenceStepNumber_1].b.OutputPulse1) {
 8009eca:	4b73      	ldr	r3, [pc, #460]	; (800a098 <keyb_proc+0xe40>)
 8009ecc:	795a      	ldrb	r2, [r3, #5]
 8009ece:	4b76      	ldr	r3, [pc, #472]	; (800a0a8 <keyb_proc+0xe50>)
 8009ed0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8009ed4:	685b      	ldr	r3, [r3, #4]
 8009ed6:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8009eda:	f040 8166 	bne.w	800a1aa <keyb_proc+0xf52>
					PULSE_LED_I_1_ON;
				};
				if (Steps[0][gSequenceStepNumber_1].b.OutputPulse2) {
 8009ede:	4b6e      	ldr	r3, [pc, #440]	; (800a098 <keyb_proc+0xe40>)
 8009ee0:	795a      	ldrb	r2, [r3, #5]
 8009ee2:	4b71      	ldr	r3, [pc, #452]	; (800a0a8 <keyb_proc+0xe50>)
 8009ee4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8009ee8:	685b      	ldr	r3, [r3, #4]
 8009eea:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8009eee:	f040 8162 	bne.w	800a1b6 <keyb_proc+0xf5e>
					PULSE_LED_I_2_ON;
				};	
				
				TIM_Cmd(TIM14, ENABLE);
 8009ef2:	4e6e      	ldr	r6, [pc, #440]	; (800a0ac <keyb_proc+0xe54>)
 8009ef4:	2101      	movs	r1, #1
 8009ef6:	4630      	mov	r0, r6
 8009ef8:	f7fc f96c 	bl	80061d4 <TIM_Cmd>
				TIM_SetCounter(TIM14, 0x00);
 8009efc:	2100      	movs	r1, #0
 8009efe:	4630      	mov	r0, r6
 8009f00:	f7fc f91f 	bl	8006142 <TIM_SetCounter>
		}
		
		if(!key->b.Empty5) 
 8009f04:	7923      	ldrb	r3, [r4, #4]
 8009f06:	f013 0f10 	tst.w	r3, #16
 8009f0a:	d103      	bne.n	8009f14 <keyb_proc+0xcbc>
		{
			strobe_banana_flag1 = 0;
 8009f0c:	2200      	movs	r2, #0
 8009f0e:	4b62      	ldr	r3, [pc, #392]	; (800a098 <keyb_proc+0xe40>)
 8009f10:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27
		}
		if ( (!key->b.StageAddress1PulseSelect) ) {
 8009f14:	7963      	ldrb	r3, [r4, #5]
 8009f16:	f013 0f10 	tst.w	r3, #16
 8009f1a:	d133      	bne.n	8009f84 <keyb_proc+0xd2c>
				gSequenceStepNumber_1 = (unsigned int) (pots_step[0]-1);
 8009f1c:	4b60      	ldr	r3, [pc, #384]	; (800a0a0 <keyb_proc+0xe48>)
 8009f1e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8009f22:	3b01      	subs	r3, #1
 8009f24:	b2db      	uxtb	r3, r3
 8009f26:	4a5c      	ldr	r2, [pc, #368]	; (800a098 <keyb_proc+0xe40>)
 8009f28:	7153      	strb	r3, [r2, #5]
					if ( gDisplayMode == DISPLAY_MODE_VIEW_1 ) {
 8009f2a:	79d3      	ldrb	r3, [r2, #7]
 8009f2c:	b943      	cbnz	r3, 8009f40 <keyb_proc+0xce8>
		DisplayUpdateFlags.b.MainDisplay = 1;
 8009f2e:	4b5b      	ldr	r3, [pc, #364]	; (800a09c <keyb_proc+0xe44>)
 8009f30:	781a      	ldrb	r2, [r3, #0]
 8009f32:	f042 0201 	orr.w	r2, r2, #1
 8009f36:	701a      	strb	r2, [r3, #0]
		DisplayUpdateFlags.b.StepsDisplay = 1;
 8009f38:	781a      	ldrb	r2, [r3, #0]
 8009f3a:	f042 0202 	orr.w	r2, r2, #2
 8009f3e:	701a      	strb	r2, [r3, #0]
	};
			
				PULSE_LED_I_ALL_ON;
 8009f40:	f44f 7100 	mov.w	r1, #512	; 0x200
 8009f44:	4857      	ldr	r0, [pc, #348]	; (800a0a4 <keyb_proc+0xe4c>)
 8009f46:	f7f9 fd83 	bl	8003a50 <GPIO_ResetBits>
				
				if (Steps[0][gSequenceStepNumber_1].b.OutputPulse1) {
 8009f4a:	4b53      	ldr	r3, [pc, #332]	; (800a098 <keyb_proc+0xe40>)
 8009f4c:	795a      	ldrb	r2, [r3, #5]
 8009f4e:	4b56      	ldr	r3, [pc, #344]	; (800a0a8 <keyb_proc+0xe50>)
 8009f50:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8009f54:	685b      	ldr	r3, [r3, #4]
 8009f56:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8009f5a:	f040 8132 	bne.w	800a1c2 <keyb_proc+0xf6a>
					PULSE_LED_I_1_ON;
				};
				if (Steps[0][gSequenceStepNumber_1].b.OutputPulse2) {
 8009f5e:	4b4e      	ldr	r3, [pc, #312]	; (800a098 <keyb_proc+0xe40>)
 8009f60:	795a      	ldrb	r2, [r3, #5]
 8009f62:	4b51      	ldr	r3, [pc, #324]	; (800a0a8 <keyb_proc+0xe50>)
 8009f64:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8009f68:	685b      	ldr	r3, [r3, #4]
 8009f6a:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8009f6e:	f040 812e 	bne.w	800a1ce <keyb_proc+0xf76>
					PULSE_LED_I_2_ON;
				};	
				
				TIM_Cmd(TIM14, ENABLE);
 8009f72:	4e4e      	ldr	r6, [pc, #312]	; (800a0ac <keyb_proc+0xe54>)
 8009f74:	2101      	movs	r1, #1
 8009f76:	4630      	mov	r0, r6
 8009f78:	f7fc f92c 	bl	80061d4 <TIM_Cmd>
				TIM_SetCounter(TIM14, 0x00);
 8009f7c:	2100      	movs	r1, #0
 8009f7e:	4630      	mov	r0, r6
 8009f80:	f7fc f8df 	bl	8006142 <TIM_SetCounter>
		};
		
						
		if( key->b.Empty2 && strobe_banana_flag2 == 0)
 8009f84:	78e3      	ldrb	r3, [r4, #3]
 8009f86:	f013 0f08 	tst.w	r3, #8
 8009f8a:	d033      	beq.n	8009ff4 <keyb_proc+0xd9c>
 8009f8c:	4b42      	ldr	r3, [pc, #264]	; (800a098 <keyb_proc+0xe40>)
 8009f8e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8009f92:	bb7b      	cbnz	r3, 8009ff4 <keyb_proc+0xd9c>
		{
			strobe_banana_flag2 = 1;
 8009f94:	4a40      	ldr	r2, [pc, #256]	; (800a098 <keyb_proc+0xe40>)
 8009f96:	2301      	movs	r3, #1
 8009f98:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
				gSequenceStepNumber_2 = (unsigned int) (pots_step[1]-1);
 8009f9c:	4b40      	ldr	r3, [pc, #256]	; (800a0a0 <keyb_proc+0xe48>)
 8009f9e:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8009fa2:	3b01      	subs	r3, #1
 8009fa4:	b2db      	uxtb	r3, r3
 8009fa6:	7193      	strb	r3, [r2, #6]
					if ( gDisplayMode == DISPLAY_MODE_VIEW_2 ) {
 8009fa8:	79d3      	ldrb	r3, [r2, #7]
 8009faa:	b2db      	uxtb	r3, r3
 8009fac:	2b01      	cmp	r3, #1
 8009fae:	f000 8114 	beq.w	800a1da <keyb_proc+0xf82>
		DisplayUpdateFlags.b.MainDisplay = 1;
		DisplayUpdateFlags.b.StepsDisplay = 1;
	};
			
				PULSE_LED_II_ALL_ON;
 8009fb2:	2104      	movs	r1, #4
 8009fb4:	483e      	ldr	r0, [pc, #248]	; (800a0b0 <keyb_proc+0xe58>)
 8009fb6:	f7f9 fd4b 	bl	8003a50 <GPIO_ResetBits>
				
				if (Steps[0][gSequenceStepNumber_1].b.OutputPulse1) {
 8009fba:	4b37      	ldr	r3, [pc, #220]	; (800a098 <keyb_proc+0xe40>)
 8009fbc:	795a      	ldrb	r2, [r3, #5]
 8009fbe:	4b3a      	ldr	r3, [pc, #232]	; (800a0a8 <keyb_proc+0xe50>)
 8009fc0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8009fc4:	685b      	ldr	r3, [r3, #4]
 8009fc6:	f413 6f00 	tst.w	r3, #2048	; 0x800
 8009fca:	f040 8110 	bne.w	800a1ee <keyb_proc+0xf96>
					PULSE_LED_II_1_ON;
				};
				if (Steps[0][gSequenceStepNumber_1].b.OutputPulse2) {
 8009fce:	4b32      	ldr	r3, [pc, #200]	; (800a098 <keyb_proc+0xe40>)
 8009fd0:	795a      	ldrb	r2, [r3, #5]
 8009fd2:	4b35      	ldr	r3, [pc, #212]	; (800a0a8 <keyb_proc+0xe50>)
 8009fd4:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8009fd8:	685b      	ldr	r3, [r3, #4]
 8009fda:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 8009fde:	f040 810b 	bne.w	800a1f8 <keyb_proc+0xfa0>
					PULSE_LED_II_2_ON;
				};	
				
				TIM_Cmd(TIM8, ENABLE);
 8009fe2:	4e34      	ldr	r6, [pc, #208]	; (800a0b4 <keyb_proc+0xe5c>)
 8009fe4:	2101      	movs	r1, #1
 8009fe6:	4630      	mov	r0, r6
 8009fe8:	f7fc f8f4 	bl	80061d4 <TIM_Cmd>
			TIM_SetCounter(TIM8, 0x00);
 8009fec:	2100      	movs	r1, #0
 8009fee:	4630      	mov	r0, r6
 8009ff0:	f7fc f8a7 	bl	8006142 <TIM_SetCounter>
		}
		
		if(!key->b.Empty2) 
 8009ff4:	78e3      	ldrb	r3, [r4, #3]
 8009ff6:	f013 0f08 	tst.w	r3, #8
 8009ffa:	d103      	bne.n	800a004 <keyb_proc+0xdac>
		{
			strobe_banana_flag2 = 0;
 8009ffc:	2100      	movs	r1, #0
 8009ffe:	4a26      	ldr	r2, [pc, #152]	; (800a098 <keyb_proc+0xe40>)
 800a000:	f882 1028 	strb.w	r1, [r2, #40]	; 0x28
		}


		if ( (!key->b.StageAddress2PulseSelect)) {
 800a004:	f013 0f02 	tst.w	r3, #2
 800a008:	d130      	bne.n	800a06c <keyb_proc+0xe14>
				gSequenceStepNumber_2 = (unsigned int) (pots_step[1]-1);
 800a00a:	4b25      	ldr	r3, [pc, #148]	; (800a0a0 <keyb_proc+0xe48>)
 800a00c:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 800a010:	3b01      	subs	r3, #1
 800a012:	b2db      	uxtb	r3, r3
 800a014:	4a20      	ldr	r2, [pc, #128]	; (800a098 <keyb_proc+0xe40>)
 800a016:	7193      	strb	r3, [r2, #6]
					if ( gDisplayMode == DISPLAY_MODE_VIEW_2 ) {
 800a018:	79d3      	ldrb	r3, [r2, #7]
 800a01a:	b2db      	uxtb	r3, r3
 800a01c:	2b01      	cmp	r3, #1
 800a01e:	f000 80f1 	beq.w	800a204 <keyb_proc+0xfac>
		DisplayUpdateFlags.b.MainDisplay = 1;
		DisplayUpdateFlags.b.StepsDisplay = 1;
	};
			
				PULSE_LED_II_ALL_ON;
 800a022:	2104      	movs	r1, #4
 800a024:	4822      	ldr	r0, [pc, #136]	; (800a0b0 <keyb_proc+0xe58>)
 800a026:	f7f9 fd13 	bl	8003a50 <GPIO_ResetBits>
				
				if (Steps[1][gSequenceStepNumber_2].b.OutputPulse1) {
 800a02a:	4b1b      	ldr	r3, [pc, #108]	; (800a098 <keyb_proc+0xe40>)
 800a02c:	799b      	ldrb	r3, [r3, #6]
 800a02e:	f103 0220 	add.w	r2, r3, #32
 800a032:	4b1d      	ldr	r3, [pc, #116]	; (800a0a8 <keyb_proc+0xe50>)
 800a034:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800a038:	685b      	ldr	r3, [r3, #4]
 800a03a:	f413 6f00 	tst.w	r3, #2048	; 0x800
 800a03e:	f040 80eb 	bne.w	800a218 <keyb_proc+0xfc0>
					PULSE_LED_II_1_ON;
				};
				if (Steps[1][gSequenceStepNumber_2].b.OutputPulse2) {
 800a042:	4b15      	ldr	r3, [pc, #84]	; (800a098 <keyb_proc+0xe40>)
 800a044:	799b      	ldrb	r3, [r3, #6]
 800a046:	f103 0220 	add.w	r2, r3, #32
 800a04a:	4b17      	ldr	r3, [pc, #92]	; (800a0a8 <keyb_proc+0xe50>)
 800a04c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800a050:	685b      	ldr	r3, [r3, #4]
 800a052:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 800a056:	f040 80e4 	bne.w	800a222 <keyb_proc+0xfca>
					PULSE_LED_II_2_ON;
				};	
				
				TIM_Cmd(TIM8, ENABLE);
 800a05a:	4e16      	ldr	r6, [pc, #88]	; (800a0b4 <keyb_proc+0xe5c>)
 800a05c:	2101      	movs	r1, #1
 800a05e:	4630      	mov	r0, r6
 800a060:	f7fc f8b8 	bl	80061d4 <TIM_Cmd>
			TIM_SetCounter(TIM8, 0x00);
 800a064:	2100      	movs	r1, #0
 800a066:	4630      	mov	r0, r6
 800a068:	f7fc f86b 	bl	8006142 <TIM_SetCounter>
		};		
	
				
	/* Stage address ADVANCE 1 KEY*/
	if (!key->b.StageAddress1ContiniousSelect) {
 800a06c:	7963      	ldrb	r3, [r4, #5]
 800a06e:	f013 0f20 	tst.w	r3, #32
 800a072:	f040 80dc 	bne.w	800a22e <keyb_proc+0xfd6>
		if (gSequencerMode_1 != SEQUENCER_MODE_WAIT) {
 800a076:	4a08      	ldr	r2, [pc, #32]	; (800a098 <keyb_proc+0xe40>)
 800a078:	7852      	ldrb	r2, [r2, #1]
 800a07a:	b2d2      	uxtb	r2, r2
 800a07c:	2a01      	cmp	r2, #1
 800a07e:	d01e      	beq.n	800a0be <keyb_proc+0xe66>
			gPrevSequencerMode_1 = gSequencerMode_1;
 800a080:	4a05      	ldr	r2, [pc, #20]	; (800a098 <keyb_proc+0xe40>)
 800a082:	7851      	ldrb	r1, [r2, #1]
 800a084:	b2c9      	uxtb	r1, r1
 800a086:	7091      	strb	r1, [r2, #2]
			gSequencerMode_1 = SEQUENCER_MODE_WAIT;		
 800a088:	2101      	movs	r1, #1
 800a08a:	7051      	strb	r1, [r2, #1]
			DisplayUpdateFlags.b.MainDisplay = 1;
 800a08c:	4803      	ldr	r0, [pc, #12]	; (800a09c <keyb_proc+0xe44>)
 800a08e:	7801      	ldrb	r1, [r0, #0]
 800a090:	f041 0101 	orr.w	r1, r1, #1
 800a094:	7001      	strb	r1, [r0, #0]
 800a096:	e00f      	b.n	800a0b8 <keyb_proc+0xe60>
 800a098:	200006b4 	.word	0x200006b4
 800a09c:	20000708 	.word	0x20000708
 800a0a0:	20000258 	.word	0x20000258
 800a0a4:	40020400 	.word	0x40020400
 800a0a8:	20000cb4 	.word	0x20000cb4
 800a0ac:	40002000 	.word	0x40002000
 800a0b0:	40020000 	.word	0x40020000
 800a0b4:	40010400 	.word	0x40010400
			key_locked = 0;
 800a0b8:	2100      	movs	r1, #0
 800a0ba:	f882 1026 	strb.w	r1, [r2, #38]	; 0x26
			DisplayUpdateFlags.b.StepsDisplay = 1;
			key_locked = 0;
		};
	};
	
	if (!key->b.StageAddress2ContiniousSelect) {	
 800a0be:	78e2      	ldrb	r2, [r4, #3]
 800a0c0:	f012 0f04 	tst.w	r2, #4
 800a0c4:	f040 80ca 	bne.w	800a25c <keyb_proc+0x1004>
		if (gSequencerMode_2 != SEQUENCER_MODE_WAIT) {
 800a0c8:	4ab1      	ldr	r2, [pc, #708]	; (800a390 <keyb_proc+0x1138>)
 800a0ca:	78d2      	ldrb	r2, [r2, #3]
 800a0cc:	b2d2      	uxtb	r2, r2
 800a0ce:	2a01      	cmp	r2, #1
 800a0d0:	d00d      	beq.n	800a0ee <keyb_proc+0xe96>
			gPrevSequencerMode_2 = gSequencerMode_2;
 800a0d2:	4aaf      	ldr	r2, [pc, #700]	; (800a390 <keyb_proc+0x1138>)
 800a0d4:	78d1      	ldrb	r1, [r2, #3]
 800a0d6:	b2c9      	uxtb	r1, r1
 800a0d8:	7111      	strb	r1, [r2, #4]
			gSequencerMode_2 = SEQUENCER_MODE_WAIT;
 800a0da:	2101      	movs	r1, #1
 800a0dc:	70d1      	strb	r1, [r2, #3]
			DisplayUpdateFlags.b.MainDisplay = 1;
 800a0de:	48ad      	ldr	r0, [pc, #692]	; (800a394 <keyb_proc+0x113c>)
 800a0e0:	7801      	ldrb	r1, [r0, #0]
 800a0e2:	f041 0101 	orr.w	r1, r1, #1
 800a0e6:	7001      	strb	r1, [r0, #0]
			key_locked = 0;
 800a0e8:	2100      	movs	r1, #0
 800a0ea:	f882 1026 	strb.w	r1, [r2, #38]	; 0x26
			DisplayUpdateFlags.b.StepsDisplay = 1;			
			key_locked = 0;
		};
	};
	
	if (!key->b.StageAddress1Advance) {
 800a0ee:	f013 0f01 	tst.w	r3, #1
 800a0f2:	f040 80e4 	bne.w	800a2be <keyb_proc+0x1066>
		
		advanced_counter_1++;
 800a0f6:	4aa6      	ldr	r2, [pc, #664]	; (800a390 <keyb_proc+0x1138>)
 800a0f8:	f892 3029 	ldrb.w	r3, [r2, #41]	; 0x29
 800a0fc:	3301      	adds	r3, #1
 800a0fe:	b2db      	uxtb	r3, r3
 800a100:	f882 3029 	strb.w	r3, [r2, #41]	; 0x29
		if(advanced_counter_1 == 10)
 800a104:	f892 3029 	ldrb.w	r3, [r2, #41]	; 0x29
 800a108:	b2db      	uxtb	r3, r3
 800a10a:	2b0a      	cmp	r3, #10
 800a10c:	f040 80db 	bne.w	800a2c6 <keyb_proc+0x106e>
		{
		if(gSequencerMode_1 != SEQUENCER_MODE_WAIT)
 800a110:	7853      	ldrb	r3, [r2, #1]
 800a112:	b2db      	uxtb	r3, r3
 800a114:	2b01      	cmp	r3, #1
 800a116:	f000 80d6 	beq.w	800a2c6 <keyb_proc+0x106e>
		{
		if(gSequencerMode_1 == SEQUENCER_MODE_ADVANCE) 
 800a11a:	7853      	ldrb	r3, [r2, #1]
 800a11c:	b2db      	uxtb	r3, r3
 800a11e:	2b06      	cmp	r3, #6
 800a120:	f000 80b3 	beq.w	800a28a <keyb_proc+0x1032>
			PreviousStep = GetStepVoltage(0, gSequenceStepNumber_1);
			gSequenceStepNumber_1 = GetNextStep(0, gSequenceStepNumber_1);
			gStepWidth_1 = 0;
		}
		else{
			if(gSequencerMode_1 != SEQUENCER_MODE_STAY_HI_Z && gSequencerMode_1 != SEQUENCER_MODE_WAIT_HI_Z )(gPrevSequencerMode_1 = gSequencerMode_1);
 800a124:	4b9a      	ldr	r3, [pc, #616]	; (800a390 <keyb_proc+0x1138>)
 800a126:	785b      	ldrb	r3, [r3, #1]
 800a128:	b2db      	uxtb	r3, r3
 800a12a:	2b05      	cmp	r3, #5
 800a12c:	d008      	beq.n	800a140 <keyb_proc+0xee8>
 800a12e:	4b98      	ldr	r3, [pc, #608]	; (800a390 <keyb_proc+0x1138>)
 800a130:	785b      	ldrb	r3, [r3, #1]
 800a132:	b2db      	uxtb	r3, r3
 800a134:	2b04      	cmp	r3, #4
 800a136:	d003      	beq.n	800a140 <keyb_proc+0xee8>
 800a138:	4a95      	ldr	r2, [pc, #596]	; (800a390 <keyb_proc+0x1138>)
 800a13a:	7853      	ldrb	r3, [r2, #1]
 800a13c:	b2db      	uxtb	r3, r3
 800a13e:	7093      	strb	r3, [r2, #2]
			
			gSequenceStepNumber_1 = GetNextStep(0, gSequenceStepNumber_1);
 800a140:	4e93      	ldr	r6, [pc, #588]	; (800a390 <keyb_proc+0x1138>)
 800a142:	7971      	ldrb	r1, [r6, #5]
 800a144:	2000      	movs	r0, #0
 800a146:	f7fe f8a3 	bl	8008290 <GetNextStep>
 800a14a:	7170      	strb	r0, [r6, #5]
		}
		gSequencerMode_1 = SEQUENCER_MODE_ADVANCE;
 800a14c:	4e90      	ldr	r6, [pc, #576]	; (800a390 <keyb_proc+0x1138>)
 800a14e:	2306      	movs	r3, #6
 800a150:	7073      	strb	r3, [r6, #1]
						PULSE_LED_I_ALL_ON;
 800a152:	f44f 7100 	mov.w	r1, #512	; 0x200
 800a156:	4890      	ldr	r0, [pc, #576]	; (800a398 <keyb_proc+0x1140>)
 800a158:	f7f9 fc7a 	bl	8003a50 <GPIO_ResetBits>
				
				if (Steps[0][gSequenceStepNumber_1].b.OutputPulse1) {
 800a15c:	7972      	ldrb	r2, [r6, #5]
 800a15e:	4b8f      	ldr	r3, [pc, #572]	; (800a39c <keyb_proc+0x1144>)
 800a160:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800a164:	685b      	ldr	r3, [r3, #4]
 800a166:	f413 6f00 	tst.w	r3, #2048	; 0x800
 800a16a:	f040 809c 	bne.w	800a2a6 <keyb_proc+0x104e>
					PULSE_LED_I_1_ON;
				};
				if (Steps[0][gSequenceStepNumber_1].b.OutputPulse2) {
 800a16e:	4b88      	ldr	r3, [pc, #544]	; (800a390 <keyb_proc+0x1138>)
 800a170:	795a      	ldrb	r2, [r3, #5]
 800a172:	4b8a      	ldr	r3, [pc, #552]	; (800a39c <keyb_proc+0x1144>)
 800a174:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800a178:	685b      	ldr	r3, [r3, #4]
 800a17a:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 800a17e:	f040 8098 	bne.w	800a2b2 <keyb_proc+0x105a>
					PULSE_LED_I_2_ON;
				};	
				
				TIM_Cmd(TIM14, ENABLE);
 800a182:	4e87      	ldr	r6, [pc, #540]	; (800a3a0 <keyb_proc+0x1148>)
 800a184:	2101      	movs	r1, #1
 800a186:	4630      	mov	r0, r6
 800a188:	f7fc f824 	bl	80061d4 <TIM_Cmd>
				TIM_SetCounter(TIM14, 0x00);
 800a18c:	2100      	movs	r1, #0
 800a18e:	4630      	mov	r0, r6
 800a190:	f7fb ffd7 	bl	8006142 <TIM_SetCounter>
 800a194:	e097      	b.n	800a2c6 <keyb_proc+0x106e>
				gSequencerMode_1 = gPrevSequencerMode_1;
 800a196:	4a7e      	ldr	r2, [pc, #504]	; (800a390 <keyb_proc+0x1138>)
 800a198:	7893      	ldrb	r3, [r2, #2]
 800a19a:	b2db      	uxtb	r3, r3
 800a19c:	7053      	strb	r3, [r2, #1]
 800a19e:	e653      	b.n	8009e48 <keyb_proc+0xbf0>
					gSequencerMode_2 = gPrevSequencerMode_2;
 800a1a0:	497b      	ldr	r1, [pc, #492]	; (800a390 <keyb_proc+0x1138>)
 800a1a2:	790a      	ldrb	r2, [r1, #4]
 800a1a4:	b2d2      	uxtb	r2, r2
 800a1a6:	70ca      	strb	r2, [r1, #3]
 800a1a8:	e66d      	b.n	8009e86 <keyb_proc+0xc2e>
					PULSE_LED_I_1_ON;
 800a1aa:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800a1ae:	487a      	ldr	r0, [pc, #488]	; (800a398 <keyb_proc+0x1140>)
 800a1b0:	f7f9 fc4e 	bl	8003a50 <GPIO_ResetBits>
 800a1b4:	e693      	b.n	8009ede <keyb_proc+0xc86>
					PULSE_LED_I_2_ON;
 800a1b6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800a1ba:	4877      	ldr	r0, [pc, #476]	; (800a398 <keyb_proc+0x1140>)
 800a1bc:	f7f9 fc48 	bl	8003a50 <GPIO_ResetBits>
 800a1c0:	e697      	b.n	8009ef2 <keyb_proc+0xc9a>
					PULSE_LED_I_1_ON;
 800a1c2:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800a1c6:	4874      	ldr	r0, [pc, #464]	; (800a398 <keyb_proc+0x1140>)
 800a1c8:	f7f9 fc42 	bl	8003a50 <GPIO_ResetBits>
 800a1cc:	e6c7      	b.n	8009f5e <keyb_proc+0xd06>
					PULSE_LED_I_2_ON;
 800a1ce:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800a1d2:	4871      	ldr	r0, [pc, #452]	; (800a398 <keyb_proc+0x1140>)
 800a1d4:	f7f9 fc3c 	bl	8003a50 <GPIO_ResetBits>
 800a1d8:	e6cb      	b.n	8009f72 <keyb_proc+0xd1a>
		DisplayUpdateFlags.b.MainDisplay = 1;
 800a1da:	4b6e      	ldr	r3, [pc, #440]	; (800a394 <keyb_proc+0x113c>)
 800a1dc:	781a      	ldrb	r2, [r3, #0]
 800a1de:	f042 0201 	orr.w	r2, r2, #1
 800a1e2:	701a      	strb	r2, [r3, #0]
		DisplayUpdateFlags.b.StepsDisplay = 1;
 800a1e4:	781a      	ldrb	r2, [r3, #0]
 800a1e6:	f042 0202 	orr.w	r2, r2, #2
 800a1ea:	701a      	strb	r2, [r3, #0]
 800a1ec:	e6e1      	b.n	8009fb2 <keyb_proc+0xd5a>
					PULSE_LED_II_1_ON;
 800a1ee:	2108      	movs	r1, #8
 800a1f0:	486c      	ldr	r0, [pc, #432]	; (800a3a4 <keyb_proc+0x114c>)
 800a1f2:	f7f9 fc2d 	bl	8003a50 <GPIO_ResetBits>
 800a1f6:	e6ea      	b.n	8009fce <keyb_proc+0xd76>
					PULSE_LED_II_2_ON;
 800a1f8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800a1fc:	4869      	ldr	r0, [pc, #420]	; (800a3a4 <keyb_proc+0x114c>)
 800a1fe:	f7f9 fc27 	bl	8003a50 <GPIO_ResetBits>
 800a202:	e6ee      	b.n	8009fe2 <keyb_proc+0xd8a>
		DisplayUpdateFlags.b.MainDisplay = 1;
 800a204:	4b63      	ldr	r3, [pc, #396]	; (800a394 <keyb_proc+0x113c>)
 800a206:	781a      	ldrb	r2, [r3, #0]
 800a208:	f042 0201 	orr.w	r2, r2, #1
 800a20c:	701a      	strb	r2, [r3, #0]
		DisplayUpdateFlags.b.StepsDisplay = 1;
 800a20e:	781a      	ldrb	r2, [r3, #0]
 800a210:	f042 0202 	orr.w	r2, r2, #2
 800a214:	701a      	strb	r2, [r3, #0]
 800a216:	e704      	b.n	800a022 <keyb_proc+0xdca>
					PULSE_LED_II_1_ON;
 800a218:	2108      	movs	r1, #8
 800a21a:	4862      	ldr	r0, [pc, #392]	; (800a3a4 <keyb_proc+0x114c>)
 800a21c:	f7f9 fc18 	bl	8003a50 <GPIO_ResetBits>
 800a220:	e70f      	b.n	800a042 <keyb_proc+0xdea>
					PULSE_LED_II_2_ON;
 800a222:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800a226:	485f      	ldr	r0, [pc, #380]	; (800a3a4 <keyb_proc+0x114c>)
 800a228:	f7f9 fc12 	bl	8003a50 <GPIO_ResetBits>
 800a22c:	e715      	b.n	800a05a <keyb_proc+0xe02>
		if (gSequencerMode_1 == SEQUENCER_MODE_WAIT) {
 800a22e:	4a58      	ldr	r2, [pc, #352]	; (800a390 <keyb_proc+0x1138>)
 800a230:	7852      	ldrb	r2, [r2, #1]
 800a232:	b2d2      	uxtb	r2, r2
 800a234:	2a01      	cmp	r2, #1
 800a236:	f47f af42 	bne.w	800a0be <keyb_proc+0xe66>
			gSequencerMode_1 = gPrevSequencerMode_1;
 800a23a:	4955      	ldr	r1, [pc, #340]	; (800a390 <keyb_proc+0x1138>)
 800a23c:	788a      	ldrb	r2, [r1, #2]
 800a23e:	b2d2      	uxtb	r2, r2
 800a240:	704a      	strb	r2, [r1, #1]
			DisplayUpdateFlags.b.MainDisplay = 1;
 800a242:	4a54      	ldr	r2, [pc, #336]	; (800a394 <keyb_proc+0x113c>)
 800a244:	7810      	ldrb	r0, [r2, #0]
 800a246:	f040 0001 	orr.w	r0, r0, #1
 800a24a:	7010      	strb	r0, [r2, #0]
			DisplayUpdateFlags.b.StepsDisplay = 1;
 800a24c:	7810      	ldrb	r0, [r2, #0]
 800a24e:	f040 0002 	orr.w	r0, r0, #2
 800a252:	7010      	strb	r0, [r2, #0]
			key_locked = 0;
 800a254:	2200      	movs	r2, #0
 800a256:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
 800a25a:	e730      	b.n	800a0be <keyb_proc+0xe66>
		if (gSequencerMode_2 == SEQUENCER_MODE_WAIT) {			
 800a25c:	4a4c      	ldr	r2, [pc, #304]	; (800a390 <keyb_proc+0x1138>)
 800a25e:	78d2      	ldrb	r2, [r2, #3]
 800a260:	b2d2      	uxtb	r2, r2
 800a262:	2a01      	cmp	r2, #1
 800a264:	f47f af43 	bne.w	800a0ee <keyb_proc+0xe96>
			gSequencerMode_2 = gPrevSequencerMode_2;
 800a268:	4949      	ldr	r1, [pc, #292]	; (800a390 <keyb_proc+0x1138>)
 800a26a:	790a      	ldrb	r2, [r1, #4]
 800a26c:	b2d2      	uxtb	r2, r2
 800a26e:	70ca      	strb	r2, [r1, #3]
			DisplayUpdateFlags.b.MainDisplay = 1;
 800a270:	4a48      	ldr	r2, [pc, #288]	; (800a394 <keyb_proc+0x113c>)
 800a272:	7810      	ldrb	r0, [r2, #0]
 800a274:	f040 0001 	orr.w	r0, r0, #1
 800a278:	7010      	strb	r0, [r2, #0]
			DisplayUpdateFlags.b.StepsDisplay = 1;			
 800a27a:	7810      	ldrb	r0, [r2, #0]
 800a27c:	f040 0002 	orr.w	r0, r0, #2
 800a280:	7010      	strb	r0, [r2, #0]
			key_locked = 0;
 800a282:	2200      	movs	r2, #0
 800a284:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
 800a288:	e731      	b.n	800a0ee <keyb_proc+0xe96>
			PreviousStep = GetStepVoltage(0, gSequenceStepNumber_1);
 800a28a:	4616      	mov	r6, r2
 800a28c:	7951      	ldrb	r1, [r2, #5]
 800a28e:	2000      	movs	r0, #0
 800a290:	f7fd fea6 	bl	8007fe0 <GetStepVoltage>
 800a294:	60b0      	str	r0, [r6, #8]
			gSequenceStepNumber_1 = GetNextStep(0, gSequenceStepNumber_1);
 800a296:	7971      	ldrb	r1, [r6, #5]
 800a298:	2000      	movs	r0, #0
 800a29a:	f7fd fff9 	bl	8008290 <GetNextStep>
 800a29e:	7170      	strb	r0, [r6, #5]
			gStepWidth_1 = 0;
 800a2a0:	2300      	movs	r3, #0
 800a2a2:	60f3      	str	r3, [r6, #12]
 800a2a4:	e752      	b.n	800a14c <keyb_proc+0xef4>
					PULSE_LED_I_1_ON;
 800a2a6:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800a2aa:	483b      	ldr	r0, [pc, #236]	; (800a398 <keyb_proc+0x1140>)
 800a2ac:	f7f9 fbd0 	bl	8003a50 <GPIO_ResetBits>
 800a2b0:	e75d      	b.n	800a16e <keyb_proc+0xf16>
					PULSE_LED_I_2_ON;
 800a2b2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800a2b6:	4838      	ldr	r0, [pc, #224]	; (800a398 <keyb_proc+0x1140>)
 800a2b8:	f7f9 fbca 	bl	8003a50 <GPIO_ResetBits>
 800a2bc:	e761      	b.n	800a182 <keyb_proc+0xf2a>
	}	}
	} else advanced_counter_1 = 0;
 800a2be:	2200      	movs	r2, #0
 800a2c0:	4b33      	ldr	r3, [pc, #204]	; (800a390 <keyb_proc+0x1138>)
 800a2c2:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
	
		if (!key->b.StageAddress2Advance) {
 800a2c6:	7963      	ldrb	r3, [r4, #5]
 800a2c8:	f013 0f08 	tst.w	r3, #8
 800a2cc:	d174      	bne.n	800a3b8 <keyb_proc+0x1160>
			
		advanced_counter_2++;
 800a2ce:	4a30      	ldr	r2, [pc, #192]	; (800a390 <keyb_proc+0x1138>)
 800a2d0:	f892 302a 	ldrb.w	r3, [r2, #42]	; 0x2a
 800a2d4:	3301      	adds	r3, #1
 800a2d6:	b2db      	uxtb	r3, r3
 800a2d8:	f882 302a 	strb.w	r3, [r2, #42]	; 0x2a
		if(advanced_counter_2 == 10)
 800a2dc:	f892 302a 	ldrb.w	r3, [r2, #42]	; 0x2a
 800a2e0:	b2db      	uxtb	r3, r3
 800a2e2:	2b0a      	cmp	r3, #10
 800a2e4:	d16c      	bne.n	800a3c0 <keyb_proc+0x1168>
		{
		if(gSequencerMode_2 != SEQUENCER_MODE_WAIT)
 800a2e6:	78d3      	ldrb	r3, [r2, #3]
 800a2e8:	b2db      	uxtb	r3, r3
 800a2ea:	2b01      	cmp	r3, #1
 800a2ec:	d068      	beq.n	800a3c0 <keyb_proc+0x1168>
				{
		if(gSequencerMode_2 == SEQUENCER_MODE_ADVANCE) 
 800a2ee:	78d3      	ldrb	r3, [r2, #3]
 800a2f0:	b2db      	uxtb	r3, r3
 800a2f2:	2b06      	cmp	r3, #6
 800a2f4:	d039      	beq.n	800a36a <keyb_proc+0x1112>
			gSequenceStepNumber_2 = GetNextStep(1, gSequenceStepNumber_2);
			gStepWidth_2 = 0;
		}
		else 
		{
			if(gSequencerMode_2 != SEQUENCER_MODE_STAY_HI_Z && gSequencerMode_2 != SEQUENCER_MODE_WAIT_HI_Z )(gPrevSequencerMode_2 = gSequencerMode_2);
 800a2f6:	4b26      	ldr	r3, [pc, #152]	; (800a390 <keyb_proc+0x1138>)
 800a2f8:	78db      	ldrb	r3, [r3, #3]
 800a2fa:	b2db      	uxtb	r3, r3
 800a2fc:	2b05      	cmp	r3, #5
 800a2fe:	d008      	beq.n	800a312 <keyb_proc+0x10ba>
 800a300:	4b23      	ldr	r3, [pc, #140]	; (800a390 <keyb_proc+0x1138>)
 800a302:	78db      	ldrb	r3, [r3, #3]
 800a304:	b2db      	uxtb	r3, r3
 800a306:	2b04      	cmp	r3, #4
 800a308:	d003      	beq.n	800a312 <keyb_proc+0x10ba>
 800a30a:	4a21      	ldr	r2, [pc, #132]	; (800a390 <keyb_proc+0x1138>)
 800a30c:	78d3      	ldrb	r3, [r2, #3]
 800a30e:	b2db      	uxtb	r3, r3
 800a310:	7113      	strb	r3, [r2, #4]
			gSequenceStepNumber_2 = GetNextStep(1, gSequenceStepNumber_2);
 800a312:	4c1f      	ldr	r4, [pc, #124]	; (800a390 <keyb_proc+0x1138>)
 800a314:	79a1      	ldrb	r1, [r4, #6]
 800a316:	2001      	movs	r0, #1
 800a318:	f7fd ffba 	bl	8008290 <GetNextStep>
 800a31c:	71a0      	strb	r0, [r4, #6]
		}
		gSequencerMode_2 = SEQUENCER_MODE_ADVANCE;
 800a31e:	4c1c      	ldr	r4, [pc, #112]	; (800a390 <keyb_proc+0x1138>)
 800a320:	2306      	movs	r3, #6
 800a322:	70e3      	strb	r3, [r4, #3]
				PULSE_LED_II_ALL_ON;
 800a324:	2104      	movs	r1, #4
 800a326:	481f      	ldr	r0, [pc, #124]	; (800a3a4 <keyb_proc+0x114c>)
 800a328:	f7f9 fb92 	bl	8003a50 <GPIO_ResetBits>
				
				if (Steps[1][gSequenceStepNumber_2].b.OutputPulse1) {
 800a32c:	79a3      	ldrb	r3, [r4, #6]
 800a32e:	f103 0220 	add.w	r2, r3, #32
 800a332:	4b1a      	ldr	r3, [pc, #104]	; (800a39c <keyb_proc+0x1144>)
 800a334:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800a338:	685b      	ldr	r3, [r3, #4]
 800a33a:	f413 6f00 	tst.w	r3, #2048	; 0x800
 800a33e:	d122      	bne.n	800a386 <keyb_proc+0x112e>
					PULSE_LED_II_1_ON;
				};
				if (Steps[1][gSequenceStepNumber_2].b.OutputPulse2) {
 800a340:	4b13      	ldr	r3, [pc, #76]	; (800a390 <keyb_proc+0x1138>)
 800a342:	799b      	ldrb	r3, [r3, #6]
 800a344:	f103 0220 	add.w	r2, r3, #32
 800a348:	4b14      	ldr	r3, [pc, #80]	; (800a39c <keyb_proc+0x1144>)
 800a34a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800a34e:	685b      	ldr	r3, [r3, #4]
 800a350:	f413 5f80 	tst.w	r3, #4096	; 0x1000
 800a354:	d12a      	bne.n	800a3ac <keyb_proc+0x1154>
					PULSE_LED_II_2_ON;
				};	
				
				TIM_Cmd(TIM8, ENABLE);
 800a356:	4c14      	ldr	r4, [pc, #80]	; (800a3a8 <keyb_proc+0x1150>)
 800a358:	2101      	movs	r1, #1
 800a35a:	4620      	mov	r0, r4
 800a35c:	f7fb ff3a 	bl	80061d4 <TIM_Cmd>
			TIM_SetCounter(TIM8, 0x00);
 800a360:	2100      	movs	r1, #0
 800a362:	4620      	mov	r0, r4
 800a364:	f7fb feed 	bl	8006142 <TIM_SetCounter>
 800a368:	e02a      	b.n	800a3c0 <keyb_proc+0x1168>
			PreviousStep_2 = GetStepVoltage(1, gSequenceStepNumber_2);
 800a36a:	4614      	mov	r4, r2
 800a36c:	7991      	ldrb	r1, [r2, #6]
 800a36e:	2001      	movs	r0, #1
 800a370:	f7fd fe36 	bl	8007fe0 <GetStepVoltage>
 800a374:	6120      	str	r0, [r4, #16]
			gSequenceStepNumber_2 = GetNextStep(1, gSequenceStepNumber_2);
 800a376:	79a1      	ldrb	r1, [r4, #6]
 800a378:	2001      	movs	r0, #1
 800a37a:	f7fd ff89 	bl	8008290 <GetNextStep>
 800a37e:	71a0      	strb	r0, [r4, #6]
			gStepWidth_2 = 0;
 800a380:	2300      	movs	r3, #0
 800a382:	6163      	str	r3, [r4, #20]
 800a384:	e7cb      	b.n	800a31e <keyb_proc+0x10c6>
					PULSE_LED_II_1_ON;
 800a386:	2108      	movs	r1, #8
 800a388:	4806      	ldr	r0, [pc, #24]	; (800a3a4 <keyb_proc+0x114c>)
 800a38a:	f7f9 fb61 	bl	8003a50 <GPIO_ResetBits>
 800a38e:	e7d7      	b.n	800a340 <keyb_proc+0x10e8>
 800a390:	200006b4 	.word	0x200006b4
 800a394:	20000708 	.word	0x20000708
 800a398:	40020400 	.word	0x40020400
 800a39c:	20000cb4 	.word	0x20000cb4
 800a3a0:	40002000 	.word	0x40002000
 800a3a4:	40020000 	.word	0x40020000
 800a3a8:	40010400 	.word	0x40010400
					PULSE_LED_II_2_ON;
 800a3ac:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800a3b0:	4811      	ldr	r0, [pc, #68]	; (800a3f8 <keyb_proc+0x11a0>)
 800a3b2:	f7f9 fb4d 	bl	8003a50 <GPIO_ResetBits>
 800a3b6:	e7ce      	b.n	800a356 <keyb_proc+0x10fe>
	
			}
	}
	}else advanced_counter_2 = 0;
 800a3b8:	2200      	movs	r2, #0
 800a3ba:	4b10      	ldr	r3, [pc, #64]	; (800a3fc <keyb_proc+0x11a4>)
 800a3bc:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
				
	if (gKeysNotValid == 0) {
 800a3c0:	4b0e      	ldr	r3, [pc, #56]	; (800a3fc <keyb_proc+0x11a4>)
 800a3c2:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 800a3c6:	b13b      	cbz	r3, 800a3d8 <keyb_proc+0x1180>
		Steps[Section][StepNum] = tmpStep;				
		DisplayUpdateFlags.b.MainDisplay = 1;	
	} else {
		gKeysNotValid = 0;
 800a3c8:	2200      	movs	r2, #0
 800a3ca:	4b0c      	ldr	r3, [pc, #48]	; (800a3fc <keyb_proc+0x11a4>)
 800a3cc:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
	};
				
	return 1;
}
 800a3d0:	2001      	movs	r0, #1
 800a3d2:	b002      	add	sp, #8
 800a3d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		Steps[Section][StepNum] = tmpStep;				
 800a3d8:	eb05 1547 	add.w	r5, r5, r7, lsl #5
 800a3dc:	4f08      	ldr	r7, [pc, #32]	; (800a400 <keyb_proc+0x11a8>)
 800a3de:	eb07 05c5 	add.w	r5, r7, r5, lsl #3
 800a3e2:	ab02      	add	r3, sp, #8
 800a3e4:	e913 0003 	ldmdb	r3, {r0, r1}
 800a3e8:	e885 0003 	stmia.w	r5, {r0, r1}
		DisplayUpdateFlags.b.MainDisplay = 1;	
 800a3ec:	4a05      	ldr	r2, [pc, #20]	; (800a404 <keyb_proc+0x11ac>)
 800a3ee:	7813      	ldrb	r3, [r2, #0]
 800a3f0:	f043 0301 	orr.w	r3, r3, #1
 800a3f4:	7013      	strb	r3, [r2, #0]
 800a3f6:	e7eb      	b.n	800a3d0 <keyb_proc+0x1178>
 800a3f8:	40020000 	.word	0x40020000
 800a3fc:	200006b4 	.word	0x200006b4
 800a400:	20000cb4 	.word	0x20000cb4
 800a404:	20000708 	.word	0x20000708

0800a408 <UpdateModeSection>:

/*
	Update leds function
*/
void UpdateModeSection(void)
{
 800a408:	b510      	push	{r4, lr}
 800a40a:	b082      	sub	sp, #8
	unsigned char StepNum = 0, Section = 0;
	uLeds mLeds;
	uStep *mStep;
	
	mLeds.value[0] = 0xFF;
 800a40c:	23ff      	movs	r3, #255	; 0xff
 800a40e:	f88d 3004 	strb.w	r3, [sp, #4]
	mLeds.value[1] = 0xFF;
 800a412:	f88d 3005 	strb.w	r3, [sp, #5]
	mLeds.value[2] = 0xFF;
 800a416:	f88d 3006 	strb.w	r3, [sp, #6]
	mLeds.value[3] = 0xFF;
 800a41a:	f88d 3007 	strb.w	r3, [sp, #7]

	if ((gSequencerMode_1 == SEQUENCER_MODE_RUN) ||
 800a41e:	4bbb      	ldr	r3, [pc, #748]	; (800a70c <UpdateModeSection+0x304>)
 800a420:	785b      	ldrb	r3, [r3, #1]
 800a422:	b123      	cbz	r3, 800a42e <UpdateModeSection+0x26>
			(gSequencerMode_1 == SEQUENCER_MODE_ADVANCE)) {
 800a424:	4bb9      	ldr	r3, [pc, #740]	; (800a70c <UpdateModeSection+0x304>)
 800a426:	785b      	ldrb	r3, [r3, #1]
 800a428:	b2db      	uxtb	r3, r3
	if ((gSequencerMode_1 == SEQUENCER_MODE_RUN) ||
 800a42a:	2b06      	cmp	r3, #6
 800a42c:	d105      	bne.n	800a43a <UpdateModeSection+0x32>
		mLeds.b.Seq1Run = 0;
 800a42e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a432:	f36f 0382 	bfc	r3, #2, #1
 800a436:	f88d 3004 	strb.w	r3, [sp, #4]
	};
	if ( (gSequencerMode_1 == SEQUENCER_MODE_WAIT) ||
 800a43a:	4bb4      	ldr	r3, [pc, #720]	; (800a70c <UpdateModeSection+0x304>)
 800a43c:	785b      	ldrb	r3, [r3, #1]
 800a43e:	b2db      	uxtb	r3, r3
 800a440:	2b01      	cmp	r3, #1
 800a442:	d009      	beq.n	800a458 <UpdateModeSection+0x50>
			(gSequencerMode_1 == SEQUENCER_MODE_WAIT_HI_Z ) ||
 800a444:	4bb1      	ldr	r3, [pc, #708]	; (800a70c <UpdateModeSection+0x304>)
 800a446:	785b      	ldrb	r3, [r3, #1]
 800a448:	b2db      	uxtb	r3, r3
	if ( (gSequencerMode_1 == SEQUENCER_MODE_WAIT) ||
 800a44a:	2b04      	cmp	r3, #4
 800a44c:	d004      	beq.n	800a458 <UpdateModeSection+0x50>
			(gSequencerMode_1 == SEQUENCER_MODE_STAY_HI_Z)  ) {
 800a44e:	4baf      	ldr	r3, [pc, #700]	; (800a70c <UpdateModeSection+0x304>)
 800a450:	785b      	ldrb	r3, [r3, #1]
 800a452:	b2db      	uxtb	r3, r3
			(gSequencerMode_1 == SEQUENCER_MODE_WAIT_HI_Z ) ||
 800a454:	2b05      	cmp	r3, #5
 800a456:	d105      	bne.n	800a464 <UpdateModeSection+0x5c>
		mLeds.b.Seq1Wait = 0;
 800a458:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a45c:	f36f 0341 	bfc	r3, #1, #1
 800a460:	f88d 3004 	strb.w	r3, [sp, #4]
	};
			
	if (gSequencerMode_1 == SEQUENCER_MODE_STOP) {
 800a464:	4ba9      	ldr	r3, [pc, #676]	; (800a70c <UpdateModeSection+0x304>)
 800a466:	785b      	ldrb	r3, [r3, #1]
 800a468:	b2db      	uxtb	r3, r3
 800a46a:	2b02      	cmp	r3, #2
 800a46c:	f000 8156 	beq.w	800a71c <UpdateModeSection+0x314>
		mLeds.b.Seq1Stop = 0;
	};
	
	if ((gSequencerMode_2 == SEQUENCER_MODE_RUN) ||
 800a470:	4ba6      	ldr	r3, [pc, #664]	; (800a70c <UpdateModeSection+0x304>)
 800a472:	78db      	ldrb	r3, [r3, #3]
 800a474:	b123      	cbz	r3, 800a480 <UpdateModeSection+0x78>
			(gSequencerMode_2 == SEQUENCER_MODE_ADVANCE) ) {
 800a476:	4ba5      	ldr	r3, [pc, #660]	; (800a70c <UpdateModeSection+0x304>)
 800a478:	78db      	ldrb	r3, [r3, #3]
 800a47a:	b2db      	uxtb	r3, r3
	if ((gSequencerMode_2 == SEQUENCER_MODE_RUN) ||
 800a47c:	2b06      	cmp	r3, #6
 800a47e:	d105      	bne.n	800a48c <UpdateModeSection+0x84>
		mLeds.b.Seq2Run = 0;
 800a480:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a484:	f36f 1345 	bfc	r3, #5, #1
 800a488:	f88d 3004 	strb.w	r3, [sp, #4]
	};
	if ((gSequencerMode_2 == SEQUENCER_MODE_WAIT) ||
 800a48c:	4b9f      	ldr	r3, [pc, #636]	; (800a70c <UpdateModeSection+0x304>)
 800a48e:	78db      	ldrb	r3, [r3, #3]
 800a490:	b2db      	uxtb	r3, r3
 800a492:	2b01      	cmp	r3, #1
 800a494:	d009      	beq.n	800a4aa <UpdateModeSection+0xa2>
			(gSequencerMode_2 == SEQUENCER_MODE_WAIT_HI_Z ) ||
 800a496:	4b9d      	ldr	r3, [pc, #628]	; (800a70c <UpdateModeSection+0x304>)
 800a498:	78db      	ldrb	r3, [r3, #3]
 800a49a:	b2db      	uxtb	r3, r3
	if ((gSequencerMode_2 == SEQUENCER_MODE_WAIT) ||
 800a49c:	2b04      	cmp	r3, #4
 800a49e:	d004      	beq.n	800a4aa <UpdateModeSection+0xa2>
			(gSequencerMode_2 == SEQUENCER_MODE_STAY_HI_Z) ) {
 800a4a0:	4b9a      	ldr	r3, [pc, #616]	; (800a70c <UpdateModeSection+0x304>)
 800a4a2:	78db      	ldrb	r3, [r3, #3]
 800a4a4:	b2db      	uxtb	r3, r3
			(gSequencerMode_2 == SEQUENCER_MODE_WAIT_HI_Z ) ||
 800a4a6:	2b05      	cmp	r3, #5
 800a4a8:	d105      	bne.n	800a4b6 <UpdateModeSection+0xae>
		mLeds.b.Seq2Wait = 0;
 800a4aa:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a4ae:	f36f 1304 	bfc	r3, #4, #1
 800a4b2:	f88d 3004 	strb.w	r3, [sp, #4]
	};
	if (gSequencerMode_2 == SEQUENCER_MODE_STOP) {
 800a4b6:	4b95      	ldr	r3, [pc, #596]	; (800a70c <UpdateModeSection+0x304>)
 800a4b8:	78db      	ldrb	r3, [r3, #3]
 800a4ba:	b2db      	uxtb	r3, r3
 800a4bc:	2b02      	cmp	r3, #2
 800a4be:	f000 8134 	beq.w	800a72a <UpdateModeSection+0x322>
		mLeds.b.Seq2Stop = 0;
	};
	
	
	/* Determine step num for different DisplayModes*/
	if ( gDisplayMode == DISPLAY_MODE_VIEW_1 ) {
 800a4c2:	4b92      	ldr	r3, [pc, #584]	; (800a70c <UpdateModeSection+0x304>)
 800a4c4:	79db      	ldrb	r3, [r3, #7]
 800a4c6:	2b00      	cmp	r3, #0
 800a4c8:	f040 8136 	bne.w	800a738 <UpdateModeSection+0x330>
		StepNum = gSequenceStepNumber_1;
 800a4cc:	4b8f      	ldr	r3, [pc, #572]	; (800a70c <UpdateModeSection+0x304>)
 800a4ce:	795b      	ldrb	r3, [r3, #5]
 800a4d0:	b2db      	uxtb	r3, r3
		Section = 0;
	}
	if ( gDisplayMode == DISPLAY_MODE_VIEW_2 ) {
 800a4d2:	4a8e      	ldr	r2, [pc, #568]	; (800a70c <UpdateModeSection+0x304>)
 800a4d4:	79d2      	ldrb	r2, [r2, #7]
 800a4d6:	b2d2      	uxtb	r2, r2
 800a4d8:	2a01      	cmp	r2, #1
 800a4da:	f000 812f 	beq.w	800a73c <UpdateModeSection+0x334>
 800a4de:	2100      	movs	r1, #0
		StepNum = gSequenceStepNumber_2;
		Section = 1;
	};
	if ( gDisplayMode == DISPLAY_MODE_EDIT_1 ) {
 800a4e0:	4a8a      	ldr	r2, [pc, #552]	; (800a70c <UpdateModeSection+0x304>)
 800a4e2:	79d2      	ldrb	r2, [r2, #7]
 800a4e4:	b2d2      	uxtb	r2, r2
 800a4e6:	2a02      	cmp	r2, #2
 800a4e8:	f000 812d 	beq.w	800a746 <UpdateModeSection+0x33e>
		StepNum = gEditModeStepNum;
		Section = 0;
	}
	if ( gDisplayMode == DISPLAY_MODE_EDIT_2 ) {
 800a4ec:	4a87      	ldr	r2, [pc, #540]	; (800a70c <UpdateModeSection+0x304>)
 800a4ee:	79d2      	ldrb	r2, [r2, #7]
 800a4f0:	b2d2      	uxtb	r2, r2
 800a4f2:	2a03      	cmp	r2, #3
 800a4f4:	f000 812c 	beq.w	800a750 <UpdateModeSection+0x348>
		Section = 1;
	};
	
	mStep = (uStep*) &Steps[Section][StepNum];
	
	mLeds.b.VoltageFull  	= ~mStep->b.FullRange;
 800a4f8:	eb03 1341 	add.w	r3, r3, r1, lsl #5
 800a4fc:	4a84      	ldr	r2, [pc, #528]	; (800a710 <UpdateModeSection+0x308>)
 800a4fe:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 800a502:	78da      	ldrb	r2, [r3, #3]
 800a504:	f3c2 0280 	ubfx	r2, r2, #2, #1
 800a508:	f082 0201 	eor.w	r2, r2, #1
 800a50c:	f89d 1007 	ldrb.w	r1, [sp, #7]
 800a510:	f362 0182 	bfi	r1, r2, #2, #1
 800a514:	f88d 1007 	strb.w	r1, [sp, #7]
  mLeds.b.Voltage0     	= ~mStep->b.Voltage0;
 800a518:	78da      	ldrb	r2, [r3, #3]
 800a51a:	f342 1200 	sbfx	r2, r2, #4, #1
 800a51e:	b2d2      	uxtb	r2, r2
 800a520:	43d2      	mvns	r2, r2
 800a522:	b2c9      	uxtb	r1, r1
 800a524:	f362 1104 	bfi	r1, r2, #4, #1
 800a528:	f88d 1007 	strb.w	r1, [sp, #7]
  mLeds.b.Voltage2     	= ~mStep->b.Voltage2;
 800a52c:	78da      	ldrb	r2, [r3, #3]
 800a52e:	f342 1240 	sbfx	r2, r2, #5, #1
 800a532:	b2d2      	uxtb	r2, r2
 800a534:	43d2      	mvns	r2, r2
 800a536:	b2c9      	uxtb	r1, r1
 800a538:	f362 1145 	bfi	r1, r2, #5, #1
 800a53c:	f88d 1007 	strb.w	r1, [sp, #7]
  mLeds.b.Voltage4     	= ~mStep->b.Voltage4;
 800a540:	78da      	ldrb	r2, [r3, #3]
 800a542:	f342 1280 	sbfx	r2, r2, #6, #1
 800a546:	b2d2      	uxtb	r2, r2
 800a548:	43d2      	mvns	r2, r2
 800a54a:	b2c9      	uxtb	r1, r1
 800a54c:	f362 1186 	bfi	r1, r2, #6, #1
 800a550:	f88d 1007 	strb.w	r1, [sp, #7]
  mLeds.b.Voltage6     	= ~mStep->b.Voltage6;
 800a554:	78da      	ldrb	r2, [r3, #3]
 800a556:	f342 12c0 	sbfx	r2, r2, #7, #1
 800a55a:	b2d2      	uxtb	r2, r2
 800a55c:	43d2      	mvns	r2, r2
 800a55e:	b2c9      	uxtb	r1, r1
 800a560:	f362 11c7 	bfi	r1, r2, #7, #1
 800a564:	f88d 1007 	strb.w	r1, [sp, #7]
  mLeds.b.Voltage8     	= ~mStep->b.Voltage8;
 800a568:	791a      	ldrb	r2, [r3, #4]
 800a56a:	f342 0200 	sbfx	r2, r2, #0, #1
 800a56e:	b2d2      	uxtb	r2, r2
 800a570:	43d2      	mvns	r2, r2
 800a572:	f89d 1006 	ldrb.w	r1, [sp, #6]
 800a576:	f362 0100 	bfi	r1, r2, #0, #1
 800a57a:	f88d 1006 	strb.w	r1, [sp, #6]
  mLeds.b.Pulse1       	= ~mStep->b.OutputPulse1; //hack for Gate1 Gate2 leds
 800a57e:	795a      	ldrb	r2, [r3, #5]
 800a580:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 800a584:	f082 0201 	eor.w	r2, r2, #1
 800a588:	f89d 1004 	ldrb.w	r1, [sp, #4]
 800a58c:	f362 1186 	bfi	r1, r2, #6, #1
 800a590:	f88d 1004 	strb.w	r1, [sp, #4]
  mLeds.b.Pulse2       	= ~mStep->b.OutputPulse2;
 800a594:	795a      	ldrb	r2, [r3, #5]
 800a596:	f3c2 1200 	ubfx	r2, r2, #4, #1
 800a59a:	f082 0201 	eor.w	r2, r2, #1
 800a59e:	b2c9      	uxtb	r1, r1
 800a5a0:	f362 11c7 	bfi	r1, r2, #7, #1
 800a5a4:	f88d 1004 	strb.w	r1, [sp, #4]
  mLeds.b.CycleFirst   	= ~mStep->b.CycleFirst;
 800a5a8:	791a      	ldrb	r2, [r3, #4]
 800a5aa:	f3c2 1200 	ubfx	r2, r2, #4, #1
 800a5ae:	f082 0201 	eor.w	r2, r2, #1
 800a5b2:	f89d 1006 	ldrb.w	r1, [sp, #6]
 800a5b6:	f362 1104 	bfi	r1, r2, #4, #1
 800a5ba:	f88d 1006 	strb.w	r1, [sp, #6]
  mLeds.b.CycleLast    	= ~mStep->b.CycleLast;
 800a5be:	791a      	ldrb	r2, [r3, #4]
 800a5c0:	f3c2 1240 	ubfx	r2, r2, #5, #1
 800a5c4:	f082 0201 	eor.w	r2, r2, #1
 800a5c8:	b2c9      	uxtb	r1, r1
 800a5ca:	f362 1145 	bfi	r1, r2, #5, #1
 800a5ce:	f88d 1006 	strb.w	r1, [sp, #6]
  mLeds.b.VoltageSource = ~mStep->b.VoltageSource;
 800a5d2:	78da      	ldrb	r2, [r3, #3]
 800a5d4:	f342 02c0 	sbfx	r2, r2, #3, #1
 800a5d8:	b2d2      	uxtb	r2, r2
 800a5da:	43d2      	mvns	r2, r2
 800a5dc:	f89d 1007 	ldrb.w	r1, [sp, #7]
 800a5e0:	f362 01c3 	bfi	r1, r2, #3, #1
 800a5e4:	f88d 1007 	strb.w	r1, [sp, #7]
  mLeds.b.Integration   = ~mStep->b.Sloped;
 800a5e8:	78da      	ldrb	r2, [r3, #3]
 800a5ea:	f3c2 0240 	ubfx	r2, r2, #1, #1
 800a5ee:	f082 0201 	eor.w	r2, r2, #1
 800a5f2:	b2c9      	uxtb	r1, r1
 800a5f4:	f362 0141 	bfi	r1, r2, #1, #1
 800a5f8:	f88d 1007 	strb.w	r1, [sp, #7]
  mLeds.b.Quantization  = ~mStep->b.Quantize;
 800a5fc:	78da      	ldrb	r2, [r3, #3]
 800a5fe:	f002 0201 	and.w	r2, r2, #1
 800a602:	f082 0201 	eor.w	r2, r2, #1
 800a606:	b2c9      	uxtb	r1, r1
 800a608:	f362 0100 	bfi	r1, r2, #0, #1
 800a60c:	f88d 1007 	strb.w	r1, [sp, #7]
  mLeds.b.TimeRange0   	= ~mStep->b.TimeRange_p03;
 800a610:	791a      	ldrb	r2, [r3, #4]
 800a612:	f3c2 1280 	ubfx	r2, r2, #6, #1
 800a616:	f082 0201 	eor.w	r2, r2, #1
 800a61a:	f89d 1006 	ldrb.w	r1, [sp, #6]
 800a61e:	f362 1186 	bfi	r1, r2, #6, #1
 800a622:	f88d 1006 	strb.w	r1, [sp, #6]
  mLeds.b.TimeRange1   	= ~mStep->b.TimeRange_p3;
 800a626:	791a      	ldrb	r2, [r3, #4]
 800a628:	ea6f 12d2 	mvn.w	r2, r2, lsr #7
 800a62c:	b2c9      	uxtb	r1, r1
 800a62e:	f362 11c7 	bfi	r1, r2, #7, #1
 800a632:	f88d 1006 	strb.w	r1, [sp, #6]
  mLeds.b.TimeRange2   	= ~mStep->b.TimeRange_3;
 800a636:	795a      	ldrb	r2, [r3, #5]
 800a638:	f002 0201 	and.w	r2, r2, #1
 800a63c:	f082 0201 	eor.w	r2, r2, #1
 800a640:	f89d 1005 	ldrb.w	r1, [sp, #5]
 800a644:	f362 0100 	bfi	r1, r2, #0, #1
 800a648:	f88d 1005 	strb.w	r1, [sp, #5]
  mLeds.b.TimeRange3   	= ~mStep->b.TimeRange_30;
 800a64c:	795a      	ldrb	r2, [r3, #5]
 800a64e:	f3c2 0240 	ubfx	r2, r2, #1, #1
 800a652:	f082 0201 	eor.w	r2, r2, #1
 800a656:	b2c9      	uxtb	r1, r1
 800a658:	f362 0141 	bfi	r1, r2, #1, #1
 800a65c:	f88d 1005 	strb.w	r1, [sp, #5]
  mLeds.b.TimeSource   	= ~mStep->b.TimeSource;
 800a660:	795a      	ldrb	r2, [r3, #5]
 800a662:	f3c2 0280 	ubfx	r2, r2, #2, #1
 800a666:	f082 0201 	eor.w	r2, r2, #1
 800a66a:	b2c9      	uxtb	r1, r1
 800a66c:	f362 0182 	bfi	r1, r2, #2, #1
 800a670:	f88d 1005 	strb.w	r1, [sp, #5]
  mLeds.b.OPStop       	= ~mStep->b.OpModeSTOP;
 800a674:	791a      	ldrb	r2, [r3, #4]
 800a676:	f3c2 0240 	ubfx	r2, r2, #1, #1
 800a67a:	f082 0201 	eor.w	r2, r2, #1
 800a67e:	f89d 1006 	ldrb.w	r1, [sp, #6]
 800a682:	f362 0141 	bfi	r1, r2, #1, #1
 800a686:	f88d 1006 	strb.w	r1, [sp, #6]
  mLeds.b.OPSustain    	= ~mStep->b.OpModeSUSTAIN;
 800a68a:	791a      	ldrb	r2, [r3, #4]
 800a68c:	f3c2 0280 	ubfx	r2, r2, #2, #1
 800a690:	f082 0201 	eor.w	r2, r2, #1
 800a694:	b2c9      	uxtb	r1, r1
 800a696:	f362 0182 	bfi	r1, r2, #2, #1
 800a69a:	f88d 1006 	strb.w	r1, [sp, #6]
  mLeds.b.OPEnable     	= ~mStep->b.OpModeENABLE;
 800a69e:	791b      	ldrb	r3, [r3, #4]
 800a6a0:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 800a6a4:	f083 0301 	eor.w	r3, r3, #1
 800a6a8:	b2ca      	uxtb	r2, r1
 800a6aa:	f363 02c3 	bfi	r2, r3, #3, #1
 800a6ae:	f88d 2006 	strb.w	r2, [sp, #6]
	
	if ( (gDisplayMode == DISPLAY_MODE_SAVE_1) || (gDisplayMode == DISPLAY_MODE_SAVE_2) ||
 800a6b2:	4b16      	ldr	r3, [pc, #88]	; (800a70c <UpdateModeSection+0x304>)
 800a6b4:	79db      	ldrb	r3, [r3, #7]
 800a6b6:	b2db      	uxtb	r3, r3
 800a6b8:	2b04      	cmp	r3, #4
 800a6ba:	d04e      	beq.n	800a75a <UpdateModeSection+0x352>
 800a6bc:	4b13      	ldr	r3, [pc, #76]	; (800a70c <UpdateModeSection+0x304>)
 800a6be:	79db      	ldrb	r3, [r3, #7]
 800a6c0:	b2db      	uxtb	r3, r3
 800a6c2:	2b05      	cmp	r3, #5
 800a6c4:	d049      	beq.n	800a75a <UpdateModeSection+0x352>
		(gDisplayMode == DISPLAY_MODE_LOAD_1) || (gDisplayMode == DISPLAY_MODE_LOAD_2) ) {
 800a6c6:	4b11      	ldr	r3, [pc, #68]	; (800a70c <UpdateModeSection+0x304>)
 800a6c8:	79db      	ldrb	r3, [r3, #7]
 800a6ca:	b2db      	uxtb	r3, r3
	if ( (gDisplayMode == DISPLAY_MODE_SAVE_1) || (gDisplayMode == DISPLAY_MODE_SAVE_2) ||
 800a6cc:	2b06      	cmp	r3, #6
 800a6ce:	d044      	beq.n	800a75a <UpdateModeSection+0x352>
		(gDisplayMode == DISPLAY_MODE_LOAD_1) || (gDisplayMode == DISPLAY_MODE_LOAD_2) ) {
 800a6d0:	4b0e      	ldr	r3, [pc, #56]	; (800a70c <UpdateModeSection+0x304>)
 800a6d2:	79db      	ldrb	r3, [r3, #7]
 800a6d4:	b2db      	uxtb	r3, r3
 800a6d6:	2b07      	cmp	r3, #7
 800a6d8:	d03f      	beq.n	800a75a <UpdateModeSection+0x352>
			else mLeds.value[0] &= ~(1 << 7);
		}
	};
	
	//Send data to leds
	LEDS_modes_SendStruct(&mLeds);
 800a6da:	a801      	add	r0, sp, #4
 800a6dc:	f7fd f85e 	bl	800779c <LEDS_modes_SendStruct>
	
	if ( (gDisplayMode == DISPLAY_MODE_VIEW_1) ||
 800a6e0:	4b0a      	ldr	r3, [pc, #40]	; (800a70c <UpdateModeSection+0x304>)
 800a6e2:	79db      	ldrb	r3, [r3, #7]
 800a6e4:	2b00      	cmp	r3, #0
 800a6e6:	f000 80ba 	beq.w	800a85e <UpdateModeSection+0x456>
			(gDisplayMode == DISPLAY_MODE_EDIT_1) ) {
 800a6ea:	4b08      	ldr	r3, [pc, #32]	; (800a70c <UpdateModeSection+0x304>)
 800a6ec:	79db      	ldrb	r3, [r3, #7]
 800a6ee:	b2db      	uxtb	r3, r3
	if ( (gDisplayMode == DISPLAY_MODE_VIEW_1) ||
 800a6f0:	2b02      	cmp	r3, #2
 800a6f2:	f000 80b4 	beq.w	800a85e <UpdateModeSection+0x456>
		DISPLAY_LED_I_ON;
		DISPLAY_LED_II_OFF;
	};
			
	if ( (gDisplayMode == DISPLAY_MODE_VIEW_2) ||
 800a6f6:	4b05      	ldr	r3, [pc, #20]	; (800a70c <UpdateModeSection+0x304>)
 800a6f8:	79db      	ldrb	r3, [r3, #7]
 800a6fa:	b2db      	uxtb	r3, r3
 800a6fc:	2b01      	cmp	r3, #1
 800a6fe:	f000 80b8 	beq.w	800a872 <UpdateModeSection+0x46a>
			(gDisplayMode == DISPLAY_MODE_EDIT_2) ) {
 800a702:	4b02      	ldr	r3, [pc, #8]	; (800a70c <UpdateModeSection+0x304>)
 800a704:	79db      	ldrb	r3, [r3, #7]
 800a706:	b2db      	uxtb	r3, r3
	if ( (gDisplayMode == DISPLAY_MODE_VIEW_2) ||
 800a708:	2b03      	cmp	r3, #3
 800a70a:	e003      	b.n	800a714 <UpdateModeSection+0x30c>
 800a70c:	200006b4 	.word	0x200006b4
 800a710:	20000cb4 	.word	0x20000cb4
 800a714:	f000 80ad 	beq.w	800a872 <UpdateModeSection+0x46a>
		DISPLAY_LED_II_ON;
		DISPLAY_LED_I_OFF;
	};
};
 800a718:	b002      	add	sp, #8
 800a71a:	bd10      	pop	{r4, pc}
		mLeds.b.Seq1Stop = 0;
 800a71c:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a720:	f36f 0300 	bfc	r3, #0, #1
 800a724:	f88d 3004 	strb.w	r3, [sp, #4]
 800a728:	e6a2      	b.n	800a470 <UpdateModeSection+0x68>
		mLeds.b.Seq2Stop = 0;
 800a72a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a72e:	f36f 03c3 	bfc	r3, #3, #1
 800a732:	f88d 3004 	strb.w	r3, [sp, #4]
 800a736:	e6c4      	b.n	800a4c2 <UpdateModeSection+0xba>
	unsigned char StepNum = 0, Section = 0;
 800a738:	2300      	movs	r3, #0
 800a73a:	e6ca      	b.n	800a4d2 <UpdateModeSection+0xca>
		StepNum = gSequenceStepNumber_2;
 800a73c:	4b52      	ldr	r3, [pc, #328]	; (800a888 <UpdateModeSection+0x480>)
 800a73e:	799b      	ldrb	r3, [r3, #6]
 800a740:	b2db      	uxtb	r3, r3
		Section = 1;
 800a742:	2101      	movs	r1, #1
 800a744:	e6cc      	b.n	800a4e0 <UpdateModeSection+0xd8>
		StepNum = gEditModeStepNum;
 800a746:	4b50      	ldr	r3, [pc, #320]	; (800a888 <UpdateModeSection+0x480>)
 800a748:	f893 3020 	ldrb.w	r3, [r3, #32]
		Section = 0;
 800a74c:	2100      	movs	r1, #0
 800a74e:	e6cd      	b.n	800a4ec <UpdateModeSection+0xe4>
		StepNum = gEditModeStepNum;
 800a750:	4b4d      	ldr	r3, [pc, #308]	; (800a888 <UpdateModeSection+0x480>)
 800a752:	f893 3020 	ldrb.w	r3, [r3, #32]
		Section = 1;
 800a756:	2101      	movs	r1, #1
 800a758:	e6ce      	b.n	800a4f8 <UpdateModeSection+0xf0>
		mLeds.value[0] = 0xFF;
 800a75a:	23ff      	movs	r3, #255	; 0xff
 800a75c:	f88d 3004 	strb.w	r3, [sp, #4]
		mLeds.value[1] = 0xFF;
 800a760:	f88d 3005 	strb.w	r3, [sp, #5]
		mLeds.value[2] = 0xFF;
 800a764:	f88d 3006 	strb.w	r3, [sp, #6]
		mLeds.value[3] = 0xFF;
 800a768:	f88d 3007 	strb.w	r3, [sp, #7]
		if((gDisplayMode == DISPLAY_MODE_SAVE_1) || (gDisplayMode == DISPLAY_MODE_SAVE_2))
 800a76c:	4b46      	ldr	r3, [pc, #280]	; (800a888 <UpdateModeSection+0x480>)
 800a76e:	79db      	ldrb	r3, [r3, #7]
 800a770:	b2db      	uxtb	r3, r3
 800a772:	2b04      	cmp	r3, #4
 800a774:	d01e      	beq.n	800a7b4 <UpdateModeSection+0x3ac>
 800a776:	4b44      	ldr	r3, [pc, #272]	; (800a888 <UpdateModeSection+0x480>)
 800a778:	79db      	ldrb	r3, [r3, #7]
 800a77a:	b2db      	uxtb	r3, r3
 800a77c:	2b05      	cmp	r3, #5
 800a77e:	d019      	beq.n	800a7b4 <UpdateModeSection+0x3ac>
		else if((gDisplayMode == DISPLAY_MODE_LOAD_1) || (gDisplayMode == DISPLAY_MODE_LOAD_2))
 800a780:	4b41      	ldr	r3, [pc, #260]	; (800a888 <UpdateModeSection+0x480>)
 800a782:	79db      	ldrb	r3, [r3, #7]
 800a784:	b2db      	uxtb	r3, r3
 800a786:	2b06      	cmp	r3, #6
 800a788:	d03b      	beq.n	800a802 <UpdateModeSection+0x3fa>
 800a78a:	4b3f      	ldr	r3, [pc, #252]	; (800a888 <UpdateModeSection+0x480>)
 800a78c:	79db      	ldrb	r3, [r3, #7]
 800a78e:	b2db      	uxtb	r3, r3
 800a790:	2b07      	cmp	r3, #7
 800a792:	d036      	beq.n	800a802 <UpdateModeSection+0x3fa>
		if(!Is_Expander_Present())
 800a794:	f7fc ff9a 	bl	80076cc <Is_Expander_Present>
 800a798:	2800      	cmp	r0, #0
 800a79a:	d19e      	bne.n	800a6da <UpdateModeSection+0x2d2>
			if(bank == 1) mLeds.value[0] &= ~(1 << 6);
 800a79c:	4b3b      	ldr	r3, [pc, #236]	; (800a88c <UpdateModeSection+0x484>)
 800a79e:	781b      	ldrb	r3, [r3, #0]
 800a7a0:	b2db      	uxtb	r3, r3
 800a7a2:	2b01      	cmp	r3, #1
 800a7a4:	d054      	beq.n	800a850 <UpdateModeSection+0x448>
			else mLeds.value[0] &= ~(1 << 7);
 800a7a6:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a7aa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800a7ae:	f88d 3004 	strb.w	r3, [sp, #4]
 800a7b2:	e792      	b.n	800a6da <UpdateModeSection+0x2d2>
			mLeds.b.Seq2Wait = 1;
 800a7b4:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a7b8:	f043 0310 	orr.w	r3, r3, #16
 800a7bc:	f88d 3004 	strb.w	r3, [sp, #4]
			save_counter++;
 800a7c0:	4b31      	ldr	r3, [pc, #196]	; (800a888 <UpdateModeSection+0x480>)
 800a7c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a7c4:	3201      	adds	r2, #1
 800a7c6:	62da      	str	r2, [r3, #44]	; 0x2c
			if(save_counter < 1500)
 800a7c8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a7ca:	f240 53db 	movw	r3, #1499	; 0x5db
 800a7ce:	429a      	cmp	r2, r3
 800a7d0:	d806      	bhi.n	800a7e0 <UpdateModeSection+0x3d8>
				 mLeds.b.Seq1Wait = 0;
 800a7d2:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a7d6:	f36f 0341 	bfc	r3, #1, #1
 800a7da:	f88d 3004 	strb.w	r3, [sp, #4]
 800a7de:	e7d9      	b.n	800a794 <UpdateModeSection+0x38c>
			else if(save_counter < 3000)
 800a7e0:	4b29      	ldr	r3, [pc, #164]	; (800a888 <UpdateModeSection+0x480>)
 800a7e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a7e4:	f640 33b7 	movw	r3, #2999	; 0xbb7
 800a7e8:	429a      	cmp	r2, r3
 800a7ea:	d806      	bhi.n	800a7fa <UpdateModeSection+0x3f2>
				 mLeds.b.Seq1Wait = 1;
 800a7ec:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a7f0:	f043 0302 	orr.w	r3, r3, #2
 800a7f4:	f88d 3004 	strb.w	r3, [sp, #4]
 800a7f8:	e7cc      	b.n	800a794 <UpdateModeSection+0x38c>
			else save_counter = 0;
 800a7fa:	2200      	movs	r2, #0
 800a7fc:	4b22      	ldr	r3, [pc, #136]	; (800a888 <UpdateModeSection+0x480>)
 800a7fe:	62da      	str	r2, [r3, #44]	; 0x2c
 800a800:	e7c8      	b.n	800a794 <UpdateModeSection+0x38c>
			mLeds.b.Seq1Wait = 1;
 800a802:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a806:	f043 0302 	orr.w	r3, r3, #2
 800a80a:	f88d 3004 	strb.w	r3, [sp, #4]
			load_counter++;
 800a80e:	4b1e      	ldr	r3, [pc, #120]	; (800a888 <UpdateModeSection+0x480>)
 800a810:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a812:	3201      	adds	r2, #1
 800a814:	631a      	str	r2, [r3, #48]	; 0x30
			if(load_counter < 1500)
 800a816:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a818:	f240 53db 	movw	r3, #1499	; 0x5db
 800a81c:	429a      	cmp	r2, r3
 800a81e:	d806      	bhi.n	800a82e <UpdateModeSection+0x426>
				 mLeds.b.Seq2Wait = 0;
 800a820:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a824:	f36f 1304 	bfc	r3, #4, #1
 800a828:	f88d 3004 	strb.w	r3, [sp, #4]
 800a82c:	e7b2      	b.n	800a794 <UpdateModeSection+0x38c>
			else if(load_counter < 3000)
 800a82e:	4b16      	ldr	r3, [pc, #88]	; (800a888 <UpdateModeSection+0x480>)
 800a830:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800a832:	f640 33b7 	movw	r3, #2999	; 0xbb7
 800a836:	429a      	cmp	r2, r3
 800a838:	d806      	bhi.n	800a848 <UpdateModeSection+0x440>
				 mLeds.b.Seq2Wait = 1;
 800a83a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a83e:	f043 0310 	orr.w	r3, r3, #16
 800a842:	f88d 3004 	strb.w	r3, [sp, #4]
 800a846:	e7a5      	b.n	800a794 <UpdateModeSection+0x38c>
			else load_counter = 0;
 800a848:	2200      	movs	r2, #0
 800a84a:	4b0f      	ldr	r3, [pc, #60]	; (800a888 <UpdateModeSection+0x480>)
 800a84c:	631a      	str	r2, [r3, #48]	; 0x30
 800a84e:	e7a1      	b.n	800a794 <UpdateModeSection+0x38c>
			if(bank == 1) mLeds.value[0] &= ~(1 << 6);
 800a850:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800a854:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a858:	f88d 3004 	strb.w	r3, [sp, #4]
 800a85c:	e73d      	b.n	800a6da <UpdateModeSection+0x2d2>
		DISPLAY_LED_I_ON;
 800a85e:	4c0c      	ldr	r4, [pc, #48]	; (800a890 <UpdateModeSection+0x488>)
 800a860:	2140      	movs	r1, #64	; 0x40
 800a862:	4620      	mov	r0, r4
 800a864:	f7f9 f8f2 	bl	8003a4c <GPIO_SetBits>
		DISPLAY_LED_II_OFF;
 800a868:	2180      	movs	r1, #128	; 0x80
 800a86a:	4620      	mov	r0, r4
 800a86c:	f7f9 f8f0 	bl	8003a50 <GPIO_ResetBits>
 800a870:	e741      	b.n	800a6f6 <UpdateModeSection+0x2ee>
		DISPLAY_LED_II_ON;
 800a872:	4c07      	ldr	r4, [pc, #28]	; (800a890 <UpdateModeSection+0x488>)
 800a874:	2180      	movs	r1, #128	; 0x80
 800a876:	4620      	mov	r0, r4
 800a878:	f7f9 f8e8 	bl	8003a4c <GPIO_SetBits>
		DISPLAY_LED_I_OFF;
 800a87c:	2140      	movs	r1, #64	; 0x40
 800a87e:	4620      	mov	r0, r4
 800a880:	f7f9 f8e6 	bl	8003a50 <GPIO_ResetBits>
};
 800a884:	e748      	b.n	800a718 <UpdateModeSection+0x310>
 800a886:	bf00      	nop
 800a888:	200006b4 	.word	0x200006b4
 800a88c:	20000258 	.word	0x20000258
 800a890:	40020000 	.word	0x40020000

0800a894 <UpdateStepSection>:

/*
	Steps section leds update function
*/
void UpdateStepSection(void)
{
 800a894:	b508      	push	{r3, lr}
	if ( gDisplayMode == DISPLAY_MODE_VIEW_1 ) {
 800a896:	4b1b      	ldr	r3, [pc, #108]	; (800a904 <UpdateStepSection+0x70>)
 800a898:	79db      	ldrb	r3, [r3, #7]
 800a89a:	b343      	cbz	r3, 800a8ee <UpdateStepSection+0x5a>
		LED_STEP_LightStep(gSequenceStepNumber_1);
	};
	if ( gDisplayMode == DISPLAY_MODE_VIEW_2 ) {
 800a89c:	4b19      	ldr	r3, [pc, #100]	; (800a904 <UpdateStepSection+0x70>)
 800a89e:	79db      	ldrb	r3, [r3, #7]
 800a8a0:	b2db      	uxtb	r3, r3
 800a8a2:	2b01      	cmp	r3, #1
 800a8a4:	d028      	beq.n	800a8f8 <UpdateStepSection+0x64>
		LED_STEP_LightStep(gSequenceStepNumber_2);
	};
	if ( ( gDisplayMode == DISPLAY_MODE_EDIT_1 ) ||
 800a8a6:	4b17      	ldr	r3, [pc, #92]	; (800a904 <UpdateStepSection+0x70>)
 800a8a8:	79db      	ldrb	r3, [r3, #7]
 800a8aa:	b2db      	uxtb	r3, r3
 800a8ac:	2b02      	cmp	r3, #2
 800a8ae:	d018      	beq.n	800a8e2 <UpdateStepSection+0x4e>
		( gDisplayMode == DISPLAY_MODE_EDIT_2 ) ||
 800a8b0:	4b14      	ldr	r3, [pc, #80]	; (800a904 <UpdateStepSection+0x70>)
 800a8b2:	79db      	ldrb	r3, [r3, #7]
 800a8b4:	b2db      	uxtb	r3, r3
	if ( ( gDisplayMode == DISPLAY_MODE_EDIT_1 ) ||
 800a8b6:	2b03      	cmp	r3, #3
 800a8b8:	d013      	beq.n	800a8e2 <UpdateStepSection+0x4e>
		( gDisplayMode == DISPLAY_MODE_SAVE_1 ) ||
 800a8ba:	4b12      	ldr	r3, [pc, #72]	; (800a904 <UpdateStepSection+0x70>)
 800a8bc:	79db      	ldrb	r3, [r3, #7]
 800a8be:	b2db      	uxtb	r3, r3
		( gDisplayMode == DISPLAY_MODE_EDIT_2 ) ||
 800a8c0:	2b04      	cmp	r3, #4
 800a8c2:	d00e      	beq.n	800a8e2 <UpdateStepSection+0x4e>
		( gDisplayMode == DISPLAY_MODE_SAVE_2 ) ||
 800a8c4:	4b0f      	ldr	r3, [pc, #60]	; (800a904 <UpdateStepSection+0x70>)
 800a8c6:	79db      	ldrb	r3, [r3, #7]
 800a8c8:	b2db      	uxtb	r3, r3
		( gDisplayMode == DISPLAY_MODE_SAVE_1 ) ||
 800a8ca:	2b05      	cmp	r3, #5
 800a8cc:	d009      	beq.n	800a8e2 <UpdateStepSection+0x4e>
		(gDisplayMode == DISPLAY_MODE_LOAD_1) || 
 800a8ce:	4b0d      	ldr	r3, [pc, #52]	; (800a904 <UpdateStepSection+0x70>)
 800a8d0:	79db      	ldrb	r3, [r3, #7]
 800a8d2:	b2db      	uxtb	r3, r3
		( gDisplayMode == DISPLAY_MODE_SAVE_2 ) ||
 800a8d4:	2b06      	cmp	r3, #6
 800a8d6:	d004      	beq.n	800a8e2 <UpdateStepSection+0x4e>
		(gDisplayMode == DISPLAY_MODE_LOAD_2)
 800a8d8:	4b0a      	ldr	r3, [pc, #40]	; (800a904 <UpdateStepSection+0x70>)
 800a8da:	79db      	ldrb	r3, [r3, #7]
 800a8dc:	b2db      	uxtb	r3, r3
		(gDisplayMode == DISPLAY_MODE_LOAD_1) || 
 800a8de:	2b07      	cmp	r3, #7
 800a8e0:	d104      	bne.n	800a8ec <UpdateStepSection+0x58>
		) {
		LED_STEP_LightStep(gEditModeStepNum);
 800a8e2:	4b08      	ldr	r3, [pc, #32]	; (800a904 <UpdateStepSection+0x70>)
 800a8e4:	f893 0020 	ldrb.w	r0, [r3, #32]
 800a8e8:	f7fc ffd0 	bl	800788c <LED_STEP_LightStep>
 800a8ec:	bd08      	pop	{r3, pc}
		LED_STEP_LightStep(gSequenceStepNumber_1);
 800a8ee:	4b05      	ldr	r3, [pc, #20]	; (800a904 <UpdateStepSection+0x70>)
 800a8f0:	7958      	ldrb	r0, [r3, #5]
 800a8f2:	f7fc ffcb 	bl	800788c <LED_STEP_LightStep>
 800a8f6:	e7d1      	b.n	800a89c <UpdateStepSection+0x8>
		LED_STEP_LightStep(gSequenceStepNumber_2);
 800a8f8:	4b02      	ldr	r3, [pc, #8]	; (800a904 <UpdateStepSection+0x70>)
 800a8fa:	7998      	ldrb	r0, [r3, #6]
 800a8fc:	f7fc ffc6 	bl	800788c <LED_STEP_LightStep>
 800a900:	e7d1      	b.n	800a8a6 <UpdateStepSection+0x12>
 800a902:	bf00      	nop
 800a904:	200006b4 	.word	0x200006b4

0800a908 <Calibration>:
	};
};


void Calibration(void)
{
 800a908:	b570      	push	{r4, r5, r6, lr}
 800a90a:	b082      	sub	sp, #8
	unsigned long i;
	uButtons myButtons;
	uLeds mLeds;	
	volatile unsigned long long int key_state;
	
	mLeds.value[0]  	= 0xFF;
 800a90c:	23ff      	movs	r3, #255	; 0xff
 800a90e:	f88d 3004 	strb.w	r3, [sp, #4]
	mLeds.value[1]  	= 0xFF;
 800a912:	f88d 3005 	strb.w	r3, [sp, #5]
	mLeds.value[2]  	= 0xFF;
 800a916:	f88d 3006 	strb.w	r3, [sp, #6]
	mLeds.value[3]  	= 0xFF;
 800a91a:	f88d 3007 	strb.w	r3, [sp, #7]
	DISPLAY_LED_II_OFF;
 800a91e:	4e54      	ldr	r6, [pc, #336]	; (800aa70 <Calibration+0x168>)
 800a920:	2180      	movs	r1, #128	; 0x80
 800a922:	4630      	mov	r0, r6
 800a924:	f7f9 f894 	bl	8003a50 <GPIO_ResetBits>
	DISPLAY_LED_I_OFF;
 800a928:	2140      	movs	r1, #64	; 0x40
 800a92a:	4630      	mov	r0, r6
 800a92c:	f7f9 f890 	bl	8003a50 <GPIO_ResetBits>
	
	while(myButtons.b.StageAddress2Advance)
 800a930:	e014      	b.n	800a95c <Calibration+0x54>
			mLeds.b.Seq1Stop = 0;
			mLeds.b.Seq2Run = 1;
			mLeds.b.Seq2Wait = 1;
			mLeds.b.Seq2Stop = 0;
		}
		else if(i < 4000)
 800a932:	f5b4 6f7a 	cmp.w	r4, #4000	; 0xfa0
 800a936:	d225      	bcs.n	800a984 <Calibration+0x7c>
		{
			mLeds.b.Seq1Run = 0;
 800a938:	f89d 3004 	ldrb.w	r3, [sp, #4]
			mLeds.b.Seq1Wait = 1;
 800a93c:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
			mLeds.b.Seq1Stop = 1;
			mLeds.b.Seq2Run = 0;
 800a940:	f043 0303 	orr.w	r3, r3, #3
			mLeds.b.Seq2Wait = 1;
 800a944:	f003 03df 	and.w	r3, r3, #223	; 0xdf
			mLeds.b.Seq2Stop = 1;
 800a948:	f043 0318 	orr.w	r3, r3, #24
 800a94c:	f88d 3004 	strb.w	r3, [sp, #4]
			mLeds.b.Seq2Wait = 0;
			mLeds.b.Seq2Stop = 1;
		}
		else i = 0;
		
		LEDS_modes_SendStruct(&mLeds);
 800a950:	a801      	add	r0, sp, #4
 800a952:	f7fc ff23 	bl	800779c <LEDS_modes_SendStruct>

		myButtons.value = GetButton();
 800a956:	f7fc fd1c 	bl	8007392 <GetButton>
 800a95a:	460d      	mov	r5, r1
	while(myButtons.b.StageAddress2Advance)
 800a95c:	f415 6f00 	tst.w	r5, #2048	; 0x800
 800a960:	d025      	beq.n	800a9ae <Calibration+0xa6>
		i++;
 800a962:	3401      	adds	r4, #1
		if(i < 2000)
 800a964:	f5b4 6ffa 	cmp.w	r4, #2000	; 0x7d0
 800a968:	d2e3      	bcs.n	800a932 <Calibration+0x2a>
			mLeds.b.Seq1Run = 1;
 800a96a:	f89d 3004 	ldrb.w	r3, [sp, #4]
			mLeds.b.Seq1Stop = 0;
 800a96e:	f043 0306 	orr.w	r3, r3, #6
			mLeds.b.Seq2Run = 1;
 800a972:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
			mLeds.b.Seq2Stop = 0;
 800a976:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 800a97a:	f36f 03c3 	bfc	r3, #3, #1
 800a97e:	f88d 3004 	strb.w	r3, [sp, #4]
 800a982:	e7e5      	b.n	800a950 <Calibration+0x48>
		else if(i < 6000)
 800a984:	f241 736f 	movw	r3, #5999	; 0x176f
 800a988:	429c      	cmp	r4, r3
 800a98a:	d80e      	bhi.n	800a9aa <Calibration+0xa2>
			mLeds.b.Seq1Run = 1;
 800a98c:	f89d 3004 	ldrb.w	r3, [sp, #4]
			mLeds.b.Seq1Wait = 0;
 800a990:	f043 0304 	orr.w	r3, r3, #4
			mLeds.b.Seq1Stop = 1;
 800a994:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
			mLeds.b.Seq2Wait = 0;
 800a998:	f043 0321 	orr.w	r3, r3, #33	; 0x21
			mLeds.b.Seq2Stop = 1;
 800a99c:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 800a9a0:	f043 0308 	orr.w	r3, r3, #8
 800a9a4:	f88d 3004 	strb.w	r3, [sp, #4]
 800a9a8:	e7d2      	b.n	800a950 <Calibration+0x48>
		else i = 0;
 800a9aa:	2400      	movs	r4, #0
 800a9ac:	e7d0      	b.n	800a950 <Calibration+0x48>
 800a9ae:	2400      	movs	r4, #0
 800a9b0:	e000      	b.n	800a9b4 <Calibration+0xac>
	}
	//Measure external inputs
	for(i = 0; i < 8; i++)
 800a9b2:	3401      	adds	r4, #1
 800a9b4:	2c07      	cmp	r4, #7
 800a9b6:	d810      	bhi.n	800a9da <Calibration+0xd2>
	{
		CalConstants[i] = AddData[i];
 800a9b8:	4b2e      	ldr	r3, [pc, #184]	; (800aa74 <Calibration+0x16c>)
 800a9ba:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
 800a9be:	4b2e      	ldr	r3, [pc, #184]	; (800aa78 <Calibration+0x170>)
 800a9c0:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 800a9c4:	605a      	str	r2, [r3, #4]
		if(CalConstants[i] < 100) CalConstants[i] = 4095;
 800a9c6:	685b      	ldr	r3, [r3, #4]
 800a9c8:	2b63      	cmp	r3, #99	; 0x63
 800a9ca:	d8f2      	bhi.n	800a9b2 <Calibration+0xaa>
 800a9cc:	4b2a      	ldr	r3, [pc, #168]	; (800aa78 <Calibration+0x170>)
 800a9ce:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 800a9d2:	f640 72ff 	movw	r2, #4095	; 0xfff
 800a9d6:	605a      	str	r2, [r3, #4]
 800a9d8:	e7eb      	b.n	800a9b2 <Calibration+0xaa>
	}
	ADCPause();
 800a9da:	f7fd f837 	bl	8007a4c <ADCPause>
	//Store calibration consstants
	CAT25512_write_block(100*sizeof(Steps), (unsigned char *) CalConstants, sizeof(CalConstants));
 800a9de:	2220      	movs	r2, #32
 800a9e0:	4926      	ldr	r1, [pc, #152]	; (800aa7c <Calibration+0x174>)
 800a9e2:	f44f 4048 	mov.w	r0, #51200	; 0xc800
 800a9e6:	f7fc fbb1 	bl	800714c <CAT25512_write_block>
	mADC_init();
 800a9ea:	f7fc ff81 	bl	80078f0 <mADC_init>
	while(!myButtons.b.StageAddress2Advance)
 800a9ee:	e014      	b.n	800aa1a <Calibration+0x112>
			mLeds.b.Seq1Stop = 0;
			mLeds.b.Seq2Run = 1;
			mLeds.b.Seq2Wait = 1;
			mLeds.b.Seq2Stop = 0;
		}
		else if(i < 4000)
 800a9f0:	f5b4 6f7a 	cmp.w	r4, #4000	; 0xfa0
 800a9f4:	d225      	bcs.n	800aa42 <Calibration+0x13a>
		{
			mLeds.b.Seq1Run = 0;
 800a9f6:	f89d 3004 	ldrb.w	r3, [sp, #4]
			mLeds.b.Seq1Wait = 1;
 800a9fa:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
			mLeds.b.Seq1Stop = 1;
			mLeds.b.Seq2Run = 0;
 800a9fe:	f043 0303 	orr.w	r3, r3, #3
			mLeds.b.Seq2Wait = 1;
 800aa02:	f003 03df 	and.w	r3, r3, #223	; 0xdf
			mLeds.b.Seq2Stop = 1;
 800aa06:	f043 0318 	orr.w	r3, r3, #24
 800aa0a:	f88d 3004 	strb.w	r3, [sp, #4]
			mLeds.b.Seq2Run = 1;
			mLeds.b.Seq2Wait = 0;
			mLeds.b.Seq2Stop = 1;
		}
		else i = 0;
		LEDS_modes_SendStruct(&mLeds);
 800aa0e:	a801      	add	r0, sp, #4
 800aa10:	f7fc fec4 	bl	800779c <LEDS_modes_SendStruct>
		myButtons.value = GetButton();
 800aa14:	f7fc fcbd 	bl	8007392 <GetButton>
 800aa18:	460d      	mov	r5, r1
	while(!myButtons.b.StageAddress2Advance)
 800aa1a:	f415 6f00 	tst.w	r5, #2048	; 0x800
 800aa1e:	d125      	bne.n	800aa6c <Calibration+0x164>
				i++;
 800aa20:	3401      	adds	r4, #1
		if(i < 2000)
 800aa22:	f5b4 6ffa 	cmp.w	r4, #2000	; 0x7d0
 800aa26:	d2e3      	bcs.n	800a9f0 <Calibration+0xe8>
			mLeds.b.Seq1Run = 1;
 800aa28:	f89d 3004 	ldrb.w	r3, [sp, #4]
			mLeds.b.Seq1Stop = 0;
 800aa2c:	f043 0306 	orr.w	r3, r3, #6
			mLeds.b.Seq2Run = 1;
 800aa30:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
			mLeds.b.Seq2Stop = 0;
 800aa34:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 800aa38:	f36f 03c3 	bfc	r3, #3, #1
 800aa3c:	f88d 3004 	strb.w	r3, [sp, #4]
 800aa40:	e7e5      	b.n	800aa0e <Calibration+0x106>
		else if(i < 6000)
 800aa42:	f241 736f 	movw	r3, #5999	; 0x176f
 800aa46:	429c      	cmp	r4, r3
 800aa48:	d80e      	bhi.n	800aa68 <Calibration+0x160>
			mLeds.b.Seq1Run = 1;
 800aa4a:	f89d 3004 	ldrb.w	r3, [sp, #4]
			mLeds.b.Seq1Wait = 0;
 800aa4e:	f043 0304 	orr.w	r3, r3, #4
			mLeds.b.Seq1Stop = 1;
 800aa52:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
			mLeds.b.Seq2Wait = 0;
 800aa56:	f043 0321 	orr.w	r3, r3, #33	; 0x21
			mLeds.b.Seq2Stop = 1;
 800aa5a:	f003 03ef 	and.w	r3, r3, #239	; 0xef
 800aa5e:	f043 0308 	orr.w	r3, r3, #8
 800aa62:	f88d 3004 	strb.w	r3, [sp, #4]
 800aa66:	e7d2      	b.n	800aa0e <Calibration+0x106>
		else i = 0;
 800aa68:	2400      	movs	r4, #0
 800aa6a:	e7d0      	b.n	800aa0e <Calibration+0x106>
	}
}
 800aa6c:	b002      	add	sp, #8
 800aa6e:	bd70      	pop	{r4, r5, r6, pc}
 800aa70:	40020000 	.word	0x40020000
 800aa74:	20000c0c 	.word	0x20000c0c
 800aa78:	20000258 	.word	0x20000258
 800aa7c:	2000025c 	.word	0x2000025c

0800aa80 <delay_ms>:




void delay_ms(unsigned int ms)
{
 800aa80:	b510      	push	{r4, lr}
 800aa82:	b086      	sub	sp, #24
 800aa84:	4604      	mov	r4, r0
	volatile uint32_t nCount;
	RCC_ClocksTypeDef RCC_Clocks;
	RCC_GetClocksFreq (&RCC_Clocks);
 800aa86:	a801      	add	r0, sp, #4
 800aa88:	f7f9 fe90 	bl	80047ac <RCC_GetClocksFreq>

	nCount=(RCC_Clocks.HCLK_Frequency/10000)*ms;
 800aa8c:	4a08      	ldr	r2, [pc, #32]	; (800aab0 <delay_ms+0x30>)
 800aa8e:	9b02      	ldr	r3, [sp, #8]
 800aa90:	fba2 2303 	umull	r2, r3, r2, r3
 800aa94:	0b5b      	lsrs	r3, r3, #13
 800aa96:	fb04 f303 	mul.w	r3, r4, r3
 800aa9a:	9305      	str	r3, [sp, #20]
	for (; nCount!=0; nCount--);
 800aa9c:	e002      	b.n	800aaa4 <delay_ms+0x24>
 800aa9e:	9b05      	ldr	r3, [sp, #20]
 800aaa0:	3b01      	subs	r3, #1
 800aaa2:	9305      	str	r3, [sp, #20]
 800aaa4:	9b05      	ldr	r3, [sp, #20]
 800aaa6:	2b00      	cmp	r3, #0
 800aaa8:	d1f9      	bne.n	800aa9e <delay_ms+0x1e>
}
 800aaaa:	b006      	add	sp, #24
 800aaac:	bd10      	pop	{r4, pc}
 800aaae:	bf00      	nop
 800aab0:	d1b71759 	.word	0xd1b71759

0800aab4 <TIM6_DAC_IRQHandler>:
{
 800aab4:	b538      	push	{r3, r4, r5, lr}
	TIM6->SR = (uint16_t) ~TIM_IT_Update;	
 800aab6:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 800aaba:	4b7e      	ldr	r3, [pc, #504]	; (800acb4 <TIM6_DAC_IRQHandler+0x200>)
 800aabc:	821a      	strh	r2, [r3, #16]
	myButtons.value = GetButton();
 800aabe:	f7fc fc68 	bl	8007392 <GetButton>
	if(clear_counter1 < 30 && clear_counter2 < 30)
 800aac2:	4b7d      	ldr	r3, [pc, #500]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800aac4:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800aac8:	2b1d      	cmp	r3, #29
 800aaca:	d833      	bhi.n	800ab34 <TIM6_DAC_IRQHandler+0x80>
 800aacc:	4a7a      	ldr	r2, [pc, #488]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800aace:	f892 2035 	ldrb.w	r2, [r2, #53]	; 0x35
 800aad2:	2a1d      	cmp	r2, #29
 800aad4:	d82e      	bhi.n	800ab34 <TIM6_DAC_IRQHandler+0x80>
		if(!myButtons.b.ClearUp || !myButtons.b.ClearDown) 
 800aad6:	b2c0      	uxtb	r0, r0
 800aad8:	f000 0103 	and.w	r1, r0, #3
 800aadc:	2903      	cmp	r1, #3
 800aade:	d018      	beq.n	800ab12 <TIM6_DAC_IRQHandler+0x5e>
			if(!myButtons.b.ClearUp) clear_counter1++;
 800aae0:	f010 0f01 	tst.w	r0, #1
 800aae4:	d10b      	bne.n	800aafe <TIM6_DAC_IRQHandler+0x4a>
 800aae6:	3301      	adds	r3, #1
 800aae8:	4973      	ldr	r1, [pc, #460]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800aaea:	f881 3034 	strb.w	r3, [r1, #52]	; 0x34
			if(!myButtons.b.ClearDown) clear_counter2++;
 800aaee:	f010 0f02 	tst.w	r0, #2
 800aaf2:	d109      	bne.n	800ab08 <TIM6_DAC_IRQHandler+0x54>
 800aaf4:	3201      	adds	r2, #1
 800aaf6:	4b70      	ldr	r3, [pc, #448]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800aaf8:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 800aafc:	bd38      	pop	{r3, r4, r5, pc}
			else clear_counter1 = 0;
 800aafe:	2100      	movs	r1, #0
 800ab00:	4b6d      	ldr	r3, [pc, #436]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800ab02:	f883 1034 	strb.w	r1, [r3, #52]	; 0x34
 800ab06:	e7f2      	b.n	800aaee <TIM6_DAC_IRQHandler+0x3a>
			else clear_counter2 = 0;
 800ab08:	2200      	movs	r2, #0
 800ab0a:	4b6b      	ldr	r3, [pc, #428]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800ab0c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 800ab10:	bd38      	pop	{r3, r4, r5, pc}
			clear_counter1 = 0;
 800ab12:	4b69      	ldr	r3, [pc, #420]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800ab14:	2100      	movs	r1, #0
 800ab16:	f883 1034 	strb.w	r1, [r3, #52]	; 0x34
			clear_counter2 = 0;
 800ab1a:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
			TIM_SetCounter(TIM6, 0x00);
 800ab1e:	4c65      	ldr	r4, [pc, #404]	; (800acb4 <TIM6_DAC_IRQHandler+0x200>)
 800ab20:	4620      	mov	r0, r4
 800ab22:	f7fb fb0e 	bl	8006142 <TIM_SetCounter>
			TIM6->CR1 &= ~TIM_CR1_CEN;
 800ab26:	8823      	ldrh	r3, [r4, #0]
 800ab28:	b29b      	uxth	r3, r3
 800ab2a:	f023 0301 	bic.w	r3, r3, #1
 800ab2e:	b29b      	uxth	r3, r3
 800ab30:	8023      	strh	r3, [r4, #0]
 800ab32:	bd38      	pop	{r3, r4, r5, pc}
	else if(clear_counter1 == 30 || clear_counter2 == 30)
 800ab34:	2b1e      	cmp	r3, #30
 800ab36:	d005      	beq.n	800ab44 <TIM6_DAC_IRQHandler+0x90>
 800ab38:	4b5f      	ldr	r3, [pc, #380]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800ab3a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 800ab3e:	2b1e      	cmp	r3, #30
 800ab40:	d000      	beq.n	800ab44 <TIM6_DAC_IRQHandler+0x90>
 800ab42:	bd38      	pop	{r3, r4, r5, pc}
		LED_STEP_SendWord(0x0000);
 800ab44:	2000      	movs	r0, #0
 800ab46:	f7fc fe89 	bl	800785c <LED_STEP_SendWord>
		delay_ms(500);
 800ab4a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800ab4e:	f7ff ff97 	bl	800aa80 <delay_ms>
		LED_STEP_SendWord(0xFFFF);
 800ab52:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800ab56:	f7fc fe81 	bl	800785c <LED_STEP_SendWord>
		delay_ms(500);
 800ab5a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800ab5e:	f7ff ff8f 	bl	800aa80 <delay_ms>
		LED_STEP_SendWord(0x0000);
 800ab62:	2000      	movs	r0, #0
 800ab64:	f7fc fe7a 	bl	800785c <LED_STEP_SendWord>
		delay_ms(500);
 800ab68:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800ab6c:	f7ff ff88 	bl	800aa80 <delay_ms>
		LED_STEP_SendWord(0xFFFF);
 800ab70:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800ab74:	f7fc fe72 	bl	800785c <LED_STEP_SendWord>
		delay_ms(500);
 800ab78:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800ab7c:	f7ff ff80 	bl	800aa80 <delay_ms>
		LED_STEP_SendWord(0x0000);
 800ab80:	2000      	movs	r0, #0
 800ab82:	f7fc fe6b 	bl	800785c <LED_STEP_SendWord>
		delay_ms(500);
 800ab86:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800ab8a:	f7ff ff79 	bl	800aa80 <delay_ms>
		LED_STEP_SendWord(0xFFFF);
 800ab8e:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800ab92:	f7fc fe63 	bl	800785c <LED_STEP_SendWord>
		TIM_SetCounter(TIM6, 0x00);
 800ab96:	4c47      	ldr	r4, [pc, #284]	; (800acb4 <TIM6_DAC_IRQHandler+0x200>)
 800ab98:	2100      	movs	r1, #0
 800ab9a:	4620      	mov	r0, r4
 800ab9c:	f7fb fad1 	bl	8006142 <TIM_SetCounter>
		TIM6->CR1 &= ~TIM_CR1_CEN;
 800aba0:	8823      	ldrh	r3, [r4, #0]
 800aba2:	b29b      	uxth	r3, r3
 800aba4:	f023 0301 	bic.w	r3, r3, #1
 800aba8:	b29b      	uxth	r3, r3
 800abaa:	8023      	strh	r3, [r4, #0]
		if(clear_counter1 == 30)
 800abac:	4b42      	ldr	r3, [pc, #264]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800abae:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800abb2:	2b1e      	cmp	r3, #30
 800abb4:	d021      	beq.n	800abfa <TIM6_DAC_IRQHandler+0x146>
		else if(clear_counter2 == 30)
 800abb6:	4b40      	ldr	r3, [pc, #256]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800abb8:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 800abbc:	2b1e      	cmp	r3, #30
 800abbe:	d043      	beq.n	800ac48 <TIM6_DAC_IRQHandler+0x194>
		clear_counter1 = 0;
 800abc0:	4b3d      	ldr	r3, [pc, #244]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800abc2:	2200      	movs	r2, #0
 800abc4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
		clear_counter2 = 0;
 800abc8:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
		if (gDisplayMode == DISPLAY_MODE_LOAD_1 || gDisplayMode == DISPLAY_MODE_SAVE_1) gDisplayMode = DISPLAY_MODE_VIEW_1;
 800abcc:	79db      	ldrb	r3, [r3, #7]
 800abce:	b2db      	uxtb	r3, r3
 800abd0:	2b06      	cmp	r3, #6
 800abd2:	d06b      	beq.n	800acac <TIM6_DAC_IRQHandler+0x1f8>
 800abd4:	4b38      	ldr	r3, [pc, #224]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800abd6:	79db      	ldrb	r3, [r3, #7]
 800abd8:	b2db      	uxtb	r3, r3
 800abda:	2b04      	cmp	r3, #4
 800abdc:	d066      	beq.n	800acac <TIM6_DAC_IRQHandler+0x1f8>
		if (gDisplayMode == DISPLAY_MODE_LOAD_2 || gDisplayMode == DISPLAY_MODE_SAVE_2) gDisplayMode = DISPLAY_MODE_VIEW_2; 		
 800abde:	4b36      	ldr	r3, [pc, #216]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800abe0:	79db      	ldrb	r3, [r3, #7]
 800abe2:	b2db      	uxtb	r3, r3
 800abe4:	2b07      	cmp	r3, #7
 800abe6:	d004      	beq.n	800abf2 <TIM6_DAC_IRQHandler+0x13e>
 800abe8:	4b33      	ldr	r3, [pc, #204]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800abea:	79db      	ldrb	r3, [r3, #7]
 800abec:	b2db      	uxtb	r3, r3
 800abee:	2b05      	cmp	r3, #5
 800abf0:	d1a7      	bne.n	800ab42 <TIM6_DAC_IRQHandler+0x8e>
 800abf2:	2201      	movs	r2, #1
 800abf4:	4b30      	ldr	r3, [pc, #192]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800abf6:	71da      	strb	r2, [r3, #7]
};
 800abf8:	e7a3      	b.n	800ab42 <TIM6_DAC_IRQHandler+0x8e>
			Steps[0][0].val[3] = 0x00;
 800abfa:	4a30      	ldr	r2, [pc, #192]	; (800acbc <TIM6_DAC_IRQHandler+0x208>)
 800abfc:	2300      	movs	r3, #0
 800abfe:	70d3      	strb	r3, [r2, #3]
			Steps[0][0].val[4] = 0x00;
 800ac00:	7113      	strb	r3, [r2, #4]
			Steps[0][0].val[5] = 0x00;
 800ac02:	7153      	strb	r3, [r2, #5]
			Steps[0][0].b.TimeRange_p3 = 1;
 800ac04:	6851      	ldr	r1, [r2, #4]
 800ac06:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 800ac0a:	6051      	str	r1, [r2, #4]
			Steps[0][0].b.FullRange = 1;
 800ac0c:	6811      	ldr	r1, [r2, #0]
 800ac0e:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
 800ac12:	6011      	str	r1, [r2, #0]
			for(i=0; i<16; i++)
 800ac14:	e010      	b.n	800ac38 <TIM6_DAC_IRQHandler+0x184>
				Steps[0][i] = Steps[0][0];
 800ac16:	4a29      	ldr	r2, [pc, #164]	; (800acbc <TIM6_DAC_IRQHandler+0x208>)
 800ac18:	eb02 04c3 	add.w	r4, r2, r3, lsl #3
 800ac1c:	e892 0003 	ldmia.w	r2, {r0, r1}
 800ac20:	e884 0003 	stmia.w	r4, {r0, r1}
				Steps[0][i+16] = Steps[0][0];
 800ac24:	f103 0410 	add.w	r4, r3, #16
 800ac28:	eb02 04c4 	add.w	r4, r2, r4, lsl #3
 800ac2c:	e892 0003 	ldmia.w	r2, {r0, r1}
 800ac30:	e884 0003 	stmia.w	r4, {r0, r1}
			for(i=0; i<16; i++)
 800ac34:	3301      	adds	r3, #1
 800ac36:	b2db      	uxtb	r3, r3
 800ac38:	2b0f      	cmp	r3, #15
 800ac3a:	d9ec      	bls.n	800ac16 <TIM6_DAC_IRQHandler+0x162>
			gSequencerMode_1 = SEQUENCER_MODE_STOP;
 800ac3c:	4b1e      	ldr	r3, [pc, #120]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800ac3e:	2202      	movs	r2, #2
 800ac40:	705a      	strb	r2, [r3, #1]
			gSequenceStepNumber_1 = 0;
 800ac42:	2200      	movs	r2, #0
 800ac44:	715a      	strb	r2, [r3, #5]
 800ac46:	e7bb      	b.n	800abc0 <TIM6_DAC_IRQHandler+0x10c>
			Steps[1][0].val[3] = 0x00;
 800ac48:	4a1c      	ldr	r2, [pc, #112]	; (800acbc <TIM6_DAC_IRQHandler+0x208>)
 800ac4a:	2300      	movs	r3, #0
 800ac4c:	f882 3103 	strb.w	r3, [r2, #259]	; 0x103
			Steps[1][0].val[4] = 0x00;
 800ac50:	f882 3104 	strb.w	r3, [r2, #260]	; 0x104
			Steps[1][0].val[5] = 0x00;
 800ac54:	f882 3105 	strb.w	r3, [r2, #261]	; 0x105
			Steps[1][0].b.TimeRange_p3 = 1;
 800ac58:	f8d2 1104 	ldr.w	r1, [r2, #260]	; 0x104
 800ac5c:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 800ac60:	f8c2 1104 	str.w	r1, [r2, #260]	; 0x104
			Steps[1][0].b.FullRange = 1;
 800ac64:	f8d2 1100 	ldr.w	r1, [r2, #256]	; 0x100
 800ac68:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
 800ac6c:	f8c2 1100 	str.w	r1, [r2, #256]	; 0x100
			for(i=0; i<16; i++)
 800ac70:	e014      	b.n	800ac9c <TIM6_DAC_IRQHandler+0x1e8>
				Steps[1][i] = Steps[1][0];
 800ac72:	4a12      	ldr	r2, [pc, #72]	; (800acbc <TIM6_DAC_IRQHandler+0x208>)
 800ac74:	f103 0520 	add.w	r5, r3, #32
 800ac78:	eb02 05c5 	add.w	r5, r2, r5, lsl #3
 800ac7c:	f502 7480 	add.w	r4, r2, #256	; 0x100
 800ac80:	e894 0003 	ldmia.w	r4, {r0, r1}
 800ac84:	e885 0003 	stmia.w	r5, {r0, r1}
				Steps[1][i+16] = Steps[1][0];
 800ac88:	f103 0130 	add.w	r1, r3, #48	; 0x30
 800ac8c:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 800ac90:	e894 0003 	ldmia.w	r4, {r0, r1}
 800ac94:	e882 0003 	stmia.w	r2, {r0, r1}
			for(i=0; i<16; i++)
 800ac98:	3301      	adds	r3, #1
 800ac9a:	b2db      	uxtb	r3, r3
 800ac9c:	2b0f      	cmp	r3, #15
 800ac9e:	d9e8      	bls.n	800ac72 <TIM6_DAC_IRQHandler+0x1be>
			gSequencerMode_2 = SEQUENCER_MODE_STOP;
 800aca0:	4b05      	ldr	r3, [pc, #20]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800aca2:	2202      	movs	r2, #2
 800aca4:	70da      	strb	r2, [r3, #3]
			gSequenceStepNumber_2 = 0;
 800aca6:	2200      	movs	r2, #0
 800aca8:	719a      	strb	r2, [r3, #6]
 800acaa:	e789      	b.n	800abc0 <TIM6_DAC_IRQHandler+0x10c>
		if (gDisplayMode == DISPLAY_MODE_LOAD_1 || gDisplayMode == DISPLAY_MODE_SAVE_1) gDisplayMode = DISPLAY_MODE_VIEW_1;
 800acac:	2200      	movs	r2, #0
 800acae:	4b02      	ldr	r3, [pc, #8]	; (800acb8 <TIM6_DAC_IRQHandler+0x204>)
 800acb0:	71da      	strb	r2, [r3, #7]
 800acb2:	e794      	b.n	800abde <TIM6_DAC_IRQHandler+0x12a>
 800acb4:	40001000 	.word	0x40001000
 800acb8:	200006b4 	.word	0x200006b4
 800acbc:	20000cb4 	.word	0x20000cb4

0800acc0 <main>:
{
 800acc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 800acc2:	b089      	sub	sp, #36	; 0x24
	DisplayUpdateFlags.value = 0x00;
 800acc4:	4ba6      	ldr	r3, [pc, #664]	; (800af60 <main+0x2a0>)
 800acc6:	2200      	movs	r2, #0
 800acc8:	701a      	strb	r2, [r3, #0]
	DisplayUpdateFlags.b.MainDisplay 	= 1;
 800acca:	781a      	ldrb	r2, [r3, #0]
 800accc:	f042 0201 	orr.w	r2, r2, #1
 800acd0:	701a      	strb	r2, [r3, #0]
	DisplayUpdateFlags.b.StepsDisplay = 1;
 800acd2:	781a      	ldrb	r2, [r3, #0]
 800acd4:	f042 0202 	orr.w	r2, r2, #2
 800acd8:	701a      	strb	r2, [r3, #0]
	Steps[0][0].b.TimeRange_p3 = 1;
 800acda:	4ba2      	ldr	r3, [pc, #648]	; (800af64 <main+0x2a4>)
 800acdc:	685a      	ldr	r2, [r3, #4]
 800acde:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800ace2:	605a      	str	r2, [r3, #4]
	Steps[0][0].b.FullRange = 1;
 800ace4:	681a      	ldr	r2, [r3, #0]
 800ace6:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 800acea:	601a      	str	r2, [r3, #0]
	Steps[1][0] = Steps[0][0];
 800acec:	f503 7280 	add.w	r2, r3, #256	; 0x100
 800acf0:	e893 0003 	ldmia.w	r3, {r0, r1}
 800acf4:	e882 0003 	stmia.w	r2, {r0, r1}
	for(_cnt=1;_cnt<=15;_cnt++) 
 800acf8:	2201      	movs	r2, #1
 800acfa:	e020      	b.n	800ad3e <main+0x7e>
		Steps[0][_cnt] = Steps[0][0];		
 800acfc:	4b99      	ldr	r3, [pc, #612]	; (800af64 <main+0x2a4>)
 800acfe:	eb03 04c2 	add.w	r4, r3, r2, lsl #3
 800ad02:	e893 0003 	ldmia.w	r3, {r0, r1}
 800ad06:	e884 0003 	stmia.w	r4, {r0, r1}
		Steps[1][_cnt] = Steps[0][0];
 800ad0a:	f102 0420 	add.w	r4, r2, #32
 800ad0e:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
 800ad12:	e893 0003 	ldmia.w	r3, {r0, r1}
 800ad16:	e884 0003 	stmia.w	r4, {r0, r1}
		Steps[0][_cnt+16] = Steps[0][0];		
 800ad1a:	f102 0410 	add.w	r4, r2, #16
 800ad1e:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
 800ad22:	e893 0003 	ldmia.w	r3, {r0, r1}
 800ad26:	e884 0003 	stmia.w	r4, {r0, r1}
		Steps[1][_cnt+16] = Steps[0][0];
 800ad2a:	f102 0430 	add.w	r4, r2, #48	; 0x30
 800ad2e:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
 800ad32:	e893 0003 	ldmia.w	r3, {r0, r1}
 800ad36:	e884 0003 	stmia.w	r4, {r0, r1}
	for(_cnt=1;_cnt<=15;_cnt++) 
 800ad3a:	3201      	adds	r2, #1
 800ad3c:	b2d2      	uxtb	r2, r2
 800ad3e:	2a0f      	cmp	r2, #15
 800ad40:	d9dc      	bls.n	800acfc <main+0x3c>
	RCC_GetClocksFreq(&RCC_Clocks);
 800ad42:	4889      	ldr	r0, [pc, #548]	; (800af68 <main+0x2a8>)
 800ad44:	f7f9 fd32 	bl	80047ac <RCC_GetClocksFreq>
	PulsesInit();
 800ad48:	f7fe f9e8 	bl	800911c <PulsesInit>
	DisplayLedsIOInit();
 800ad4c:	f7fe fa30 	bl	80091b0 <DisplayLedsIOInit>
	DipConfig_init();	
 800ad50:	f7fc fc66 	bl	8007620 <DipConfig_init>
	gDipConfig = GetDipConfig(); 
 800ad54:	f7fc fc7e 	bl	8007654 <GetDipConfig>
 800ad58:	4c84      	ldr	r4, [pc, #528]	; (800af6c <main+0x2ac>)
 800ad5a:	7020      	strb	r0, [r4, #0]
	LED_STEP_init();
 800ad5c:	f7fc fd38 	bl	80077d0 <LED_STEP_init>
	LED_STEP_SendWord(0xFFFF);
 800ad60:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800ad64:	f7fc fd7a 	bl	800785c <LED_STEP_SendWord>
	delay_ms(1000);
 800ad68:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800ad6c:	f7ff fe88 	bl	800aa80 <delay_ms>
	LED_STEP_SendWord(0xFFF0|(*((uint8_t*) (&gDipConfig))));
 800ad70:	7820      	ldrb	r0, [r4, #0]
 800ad72:	f440 407f 	orr.w	r0, r0, #65280	; 0xff00
 800ad76:	f040 00f0 	orr.w	r0, r0, #240	; 0xf0
 800ad7a:	f7fc fd6f 	bl	800785c <LED_STEP_SendWord>
	delay_ms(1000);
 800ad7e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800ad82:	f7ff fe7d 	bl	800aa80 <delay_ms>
	CAT25512_init();
 800ad86:	f7fc f8c7 	bl	8006f18 <CAT25512_init>
	LEDS_modes_init();	
 800ad8a:	f7fc fca9 	bl	80076e0 <LEDS_modes_init>
	mLeds.value[0] = 0xFF;
 800ad8e:	23ff      	movs	r3, #255	; 0xff
	mLeds.value[1] = 0xFF;
 800ad90:	f88d 3015 	strb.w	r3, [sp, #21]
	mLeds.value[2] = 0xFF;
 800ad94:	f88d 3016 	strb.w	r3, [sp, #22]
	mLeds.value[3] = 0xFF;
 800ad98:	f88d 3017 	strb.w	r3, [sp, #23]
	mLeds.b.Seq2Stop = 0;
 800ad9c:	a808      	add	r0, sp, #32
 800ad9e:	f06f 0309 	mvn.w	r3, #9
 800ada2:	f800 3d0c 	strb.w	r3, [r0, #-12]!
	LEDS_modes_SendStruct(&mLeds);
 800ada6:	f7fc fcf9 	bl	800779c <LEDS_modes_SendStruct>
	init_HC165();
 800adaa:	f7fc fa57 	bl	800725c <init_HC165>
	key_state = GetButton();
 800adae:	f7fc faf0 	bl	8007392 <GetButton>
 800adb2:	e9cd 0102 	strd	r0, r1, [sp, #8]
	prev_key_state = 0x7fbf67f7fffdff;//key_state;
 800adb6:	a368      	add	r3, pc, #416	; (adr r3, 800af58 <main+0x298>)
 800adb8:	e9d3 2300 	ldrd	r2, r3, [r3]
 800adbc:	e9cd 2300 	strd	r2, r3, [sp]
	MAX5135init();
 800adc0:	f7fc fb32 	bl	8007428 <MAX5135init>
	ADC_POTS_selector_init();
 800adc4:	f7fc fbc8 	bl	8007558 <ADC_POTS_selector_init>
	ADC_POTS_selector_Ch(0);
 800adc8:	2000      	movs	r0, #0
 800adca:	f7fc fc1d 	bl	8007608 <ADC_POTS_selector_Ch>
	mADC_init();
 800adce:	f7fc fd8f 	bl	80078f0 <mADC_init>
	mTimersInit();
 800add2:	f7fd ffe9 	bl	8008da8 <mTimersInit>
	mInterruptInit();
 800add6:	f7fc fe49 	bl	8007a6c <mInterruptInit>
	InternalDACInit();
 800adda:	f7fe fa03 	bl	80091e4 <InternalDACInit>
	Init_Expander_GPIO();
 800adde:	f7fc fc5b 	bl	8007698 <Init_Expander_GPIO>
	gSequencerMode_1 = SEQUENCER_MODE_STOP;
 800ade2:	4b63      	ldr	r3, [pc, #396]	; (800af70 <main+0x2b0>)
 800ade4:	2202      	movs	r2, #2
 800ade6:	705a      	strb	r2, [r3, #1]
	gSequencerMode_2 = SEQUENCER_MODE_STOP;
 800ade8:	70da      	strb	r2, [r3, #3]
	key_state == GetButton();
 800adea:	f7fc fad2 	bl	8007392 <GetButton>
 800adee:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
	myButtons.value = key_state;
 800adf2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800adf6:	e9cd 2306 	strd	r2, r3, [sp, #24]
	if(!myButtons.b.StageAddress1Advance) 
 800adfa:	f89d 301d 	ldrb.w	r3, [sp, #29]
 800adfe:	f013 0f01 	tst.w	r3, #1
 800ae02:	d12d      	bne.n	800ae60 <main+0x1a0>
		Calibration();
 800ae04:	f7ff fd80 	bl	800a908 <Calibration>
		for(i = 0; i < 8; i++)
 800ae08:	2500      	movs	r5, #0
		gDipConfig = GetDipConfig();
 800ae0a:	f7fc fc23 	bl	8007654 <GetDipConfig>
 800ae0e:	4b57      	ldr	r3, [pc, #348]	; (800af6c <main+0x2ac>)
 800ae10:	7018      	strb	r0, [r3, #0]
		if(gDipConfig.b.V_OUT_1V == 1) 
 800ae12:	781b      	ldrb	r3, [r3, #0]
 800ae14:	f013 0f02 	tst.w	r3, #2
 800ae18:	d139      	bne.n	800ae8e <main+0x1ce>
			if(gDipConfig.b.V_OUT_1V2 == 1)
 800ae1a:	4b54      	ldr	r3, [pc, #336]	; (800af6c <main+0x2ac>)
 800ae1c:	781b      	ldrb	r3, [r3, #0]
 800ae1e:	f013 0f01 	tst.w	r3, #1
 800ae22:	d13c      	bne.n	800ae9e <main+0x1de>
				offset = (4095.0/5.0);
 800ae24:	f240 3233 	movw	r2, #819	; 0x333
 800ae28:	4b52      	ldr	r3, [pc, #328]	; (800af74 <main+0x2b4>)
 800ae2a:	601a      	str	r2, [r3, #0]
				divider = 5.0;
 800ae2c:	4a52      	ldr	r2, [pc, #328]	; (800af78 <main+0x2b8>)
 800ae2e:	4b53      	ldr	r3, [pc, #332]	; (800af7c <main+0x2bc>)
 800ae30:	601a      	str	r2, [r3, #0]
		if (KeyThreshHoldCnt == 0) {
 800ae32:	2d00      	cmp	r5, #0
 800ae34:	d03b      	beq.n	800aeae <main+0x1ee>
		if (KeyThreshHoldCnt == 2) {
 800ae36:	2d02      	cmp	r5, #2
 800ae38:	d03e      	beq.n	800aeb8 <main+0x1f8>
		KeyThreshHoldCnt++;
 800ae3a:	3501      	adds	r5, #1
 800ae3c:	b2ed      	uxtb	r5, r5
		if (KeyThreshHoldCnt > 2) {
 800ae3e:	2d02      	cmp	r5, #2
 800ae40:	d900      	bls.n	800ae44 <main+0x184>
			KeyThreshHoldCnt = 0;
 800ae42:	2500      	movs	r5, #0
		if (DisplayUpdateFlags.b.MainDisplay) {
 800ae44:	4b46      	ldr	r3, [pc, #280]	; (800af60 <main+0x2a0>)
 800ae46:	781b      	ldrb	r3, [r3, #0]
 800ae48:	f013 0f01 	tst.w	r3, #1
 800ae4c:	f040 80a0 	bne.w	800af90 <main+0x2d0>
		if (DisplayUpdateFlags.b.StepsDisplay) {			
 800ae50:	4b43      	ldr	r3, [pc, #268]	; (800af60 <main+0x2a0>)
 800ae52:	781b      	ldrb	r3, [r3, #0]
 800ae54:	f013 0f02 	tst.w	r3, #2
 800ae58:	f040 80bc 	bne.w	800afd4 <main+0x314>
			for(i =0; i<10; i++)
 800ae5c:	2400      	movs	r4, #0
 800ae5e:	e155      	b.n	800b10c <main+0x44c>
		CAT25512_read_block(100*sizeof(Steps), (unsigned char *) CalConstants, sizeof(CalConstants));
 800ae60:	2220      	movs	r2, #32
 800ae62:	4947      	ldr	r1, [pc, #284]	; (800af80 <main+0x2c0>)
 800ae64:	f44f 4048 	mov.w	r0, #51200	; 0xc800
 800ae68:	f7fc f9d4 	bl	8007214 <CAT25512_read_block>
		for(i = 0; i < 8; i++)
 800ae6c:	2300      	movs	r3, #0
 800ae6e:	2b07      	cmp	r3, #7
 800ae70:	dcca      	bgt.n	800ae08 <main+0x148>
			if(CalConstants[i] < 100) CalConstants[i] = 4095;
 800ae72:	4a44      	ldr	r2, [pc, #272]	; (800af84 <main+0x2c4>)
 800ae74:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800ae78:	6852      	ldr	r2, [r2, #4]
 800ae7a:	2a63      	cmp	r2, #99	; 0x63
 800ae7c:	d805      	bhi.n	800ae8a <main+0x1ca>
 800ae7e:	4a41      	ldr	r2, [pc, #260]	; (800af84 <main+0x2c4>)
 800ae80:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 800ae84:	f640 71ff 	movw	r1, #4095	; 0xfff
 800ae88:	6051      	str	r1, [r2, #4]
		for(i = 0; i < 8; i++)
 800ae8a:	3301      	adds	r3, #1
 800ae8c:	e7ef      	b.n	800ae6e <main+0x1ae>
			offset = (4095.0/10.0);
 800ae8e:	f240 1299 	movw	r2, #409	; 0x199
 800ae92:	4b38      	ldr	r3, [pc, #224]	; (800af74 <main+0x2b4>)
 800ae94:	601a      	str	r2, [r3, #0]
			divider = 10.0;
 800ae96:	4a3c      	ldr	r2, [pc, #240]	; (800af88 <main+0x2c8>)
 800ae98:	4b38      	ldr	r3, [pc, #224]	; (800af7c <main+0x2bc>)
 800ae9a:	601a      	str	r2, [r3, #0]
 800ae9c:	e7c9      	b.n	800ae32 <main+0x172>
				offset = (4095.0/8.333);
 800ae9e:	f240 12eb 	movw	r2, #491	; 0x1eb
 800aea2:	4b34      	ldr	r3, [pc, #208]	; (800af74 <main+0x2b4>)
 800aea4:	601a      	str	r2, [r3, #0]
				divider = 8.333;
 800aea6:	4a39      	ldr	r2, [pc, #228]	; (800af8c <main+0x2cc>)
 800aea8:	4b34      	ldr	r3, [pc, #208]	; (800af7c <main+0x2bc>)
 800aeaa:	601a      	str	r2, [r3, #0]
 800aeac:	e7c1      	b.n	800ae32 <main+0x172>
			key_state = GetButton();
 800aeae:	f7fc fa70 	bl	8007392 <GetButton>
 800aeb2:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800aeb6:	e7be      	b.n	800ae36 <main+0x176>
			if (key_state == GetButton()) {	
 800aeb8:	f7fc fa6b 	bl	8007392 <GetButton>
 800aebc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800aec0:	4299      	cmp	r1, r3
 800aec2:	bf08      	it	eq
 800aec4:	4290      	cmpeq	r0, r2
 800aec6:	d1b8      	bne.n	800ae3a <main+0x17a>
				myButtons.value = key_state;			
 800aec8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800aecc:	e9cd 2306 	strd	r2, r3, [sp, #24]
							if ( 	(gDisplayMode != DISPLAY_MODE_SAVE_1) && (gDisplayMode != DISPLAY_MODE_SAVE_2) &&
 800aed0:	4b27      	ldr	r3, [pc, #156]	; (800af70 <main+0x2b0>)
 800aed2:	79db      	ldrb	r3, [r3, #7]
 800aed4:	b2db      	uxtb	r3, r3
 800aed6:	2b04      	cmp	r3, #4
 800aed8:	d025      	beq.n	800af26 <main+0x266>
 800aeda:	4b25      	ldr	r3, [pc, #148]	; (800af70 <main+0x2b0>)
 800aedc:	79db      	ldrb	r3, [r3, #7]
 800aede:	b2db      	uxtb	r3, r3
 800aee0:	2b05      	cmp	r3, #5
 800aee2:	d020      	beq.n	800af26 <main+0x266>
						(gDisplayMode != DISPLAY_MODE_LOAD_1) && (gDisplayMode != DISPLAY_MODE_LOAD_2) ) 
 800aee4:	4b22      	ldr	r3, [pc, #136]	; (800af70 <main+0x2b0>)
 800aee6:	79db      	ldrb	r3, [r3, #7]
 800aee8:	b2db      	uxtb	r3, r3
							if ( 	(gDisplayMode != DISPLAY_MODE_SAVE_1) && (gDisplayMode != DISPLAY_MODE_SAVE_2) &&
 800aeea:	2b06      	cmp	r3, #6
 800aeec:	d01b      	beq.n	800af26 <main+0x266>
						(gDisplayMode != DISPLAY_MODE_LOAD_1) && (gDisplayMode != DISPLAY_MODE_LOAD_2) ) 
 800aeee:	4b20      	ldr	r3, [pc, #128]	; (800af70 <main+0x2b0>)
 800aef0:	79db      	ldrb	r3, [r3, #7]
 800aef2:	b2db      	uxtb	r3, r3
 800aef4:	2b07      	cmp	r3, #7
 800aef6:	d016      	beq.n	800af26 <main+0x266>
				if (key_state != prev_key_state || myButtons.b.StepRight == 0 || myButtons.b.StepLeft == 0) {
 800aef8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800aefc:	e9dd 2300 	ldrd	r2, r3, [sp]
 800af00:	4299      	cmp	r1, r3
 800af02:	bf08      	it	eq
 800af04:	4290      	cmpeq	r0, r2
 800af06:	d007      	beq.n	800af18 <main+0x258>
						keyb_proc(&myButtons);
 800af08:	a806      	add	r0, sp, #24
 800af0a:	f7fe f9a5 	bl	8009258 <keyb_proc>
						prev_key_state = key_state;
 800af0e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800af12:	e9cd 2300 	strd	r2, r3, [sp]
 800af16:	e790      	b.n	800ae3a <main+0x17a>
				if (key_state != prev_key_state || myButtons.b.StepRight == 0 || myButtons.b.StepLeft == 0) {
 800af18:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800af1c:	f003 030c 	and.w	r3, r3, #12
 800af20:	2b0c      	cmp	r3, #12
 800af22:	d1f1      	bne.n	800af08 <main+0x248>
 800af24:	e789      	b.n	800ae3a <main+0x17a>
							if (key_state != prev_key_state || myButtons.b.StepRight == 0 || myButtons.b.StepLeft == 0) {
 800af26:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 800af2a:	e9dd 2300 	ldrd	r2, r3, [sp]
 800af2e:	4299      	cmp	r1, r3
 800af30:	bf08      	it	eq
 800af32:	4290      	cmpeq	r0, r2
 800af34:	d007      	beq.n	800af46 <main+0x286>
						keyb_proc(&myButtons);
 800af36:	a806      	add	r0, sp, #24
 800af38:	f7fe f98e 	bl	8009258 <keyb_proc>
						prev_key_state = key_state;
 800af3c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800af40:	e9cd 2300 	strd	r2, r3, [sp]
 800af44:	e779      	b.n	800ae3a <main+0x17a>
							if (key_state != prev_key_state || myButtons.b.StepRight == 0 || myButtons.b.StepLeft == 0) {
 800af46:	f89d 3018 	ldrb.w	r3, [sp, #24]
 800af4a:	f003 030c 	and.w	r3, r3, #12
 800af4e:	2b0c      	cmp	r3, #12
 800af50:	d1f1      	bne.n	800af36 <main+0x276>
 800af52:	e772      	b.n	800ae3a <main+0x17a>
 800af54:	f3af 8000 	nop.w
 800af58:	f7fffdff 	.word	0xf7fffdff
 800af5c:	007fbf67 	.word	0x007fbf67
 800af60:	20000708 	.word	0x20000708
 800af64:	20000cb4 	.word	0x20000cb4
 800af68:	20000eb4 	.word	0x20000eb4
 800af6c:	20000700 	.word	0x20000700
 800af70:	200006b4 	.word	0x200006b4
 800af74:	20000cb0 	.word	0x20000cb0
 800af78:	40a00000 	.word	0x40a00000
 800af7c:	20000cac 	.word	0x20000cac
 800af80:	2000025c 	.word	0x2000025c
 800af84:	20000258 	.word	0x20000258
 800af88:	41200000 	.word	0x41200000
 800af8c:	410553f8 	.word	0x410553f8
			UpdateModeSection();
 800af90:	f7ff fa3a 	bl	800a408 <UpdateModeSection>
			DisplayUpdateFlags.b.MainDisplay = 0;
 800af94:	4a69      	ldr	r2, [pc, #420]	; (800b13c <main+0x47c>)
 800af96:	7813      	ldrb	r3, [r2, #0]
 800af98:	f36f 0300 	bfc	r3, #0, #1
 800af9c:	7013      	strb	r3, [r2, #0]
			if ( 	(gDisplayMode == DISPLAY_MODE_SAVE_1) || (gDisplayMode == DISPLAY_MODE_SAVE_2) ||
 800af9e:	4b68      	ldr	r3, [pc, #416]	; (800b140 <main+0x480>)
 800afa0:	79db      	ldrb	r3, [r3, #7]
 800afa2:	b2db      	uxtb	r3, r3
 800afa4:	2b04      	cmp	r3, #4
 800afa6:	d00f      	beq.n	800afc8 <main+0x308>
 800afa8:	4b65      	ldr	r3, [pc, #404]	; (800b140 <main+0x480>)
 800afaa:	79db      	ldrb	r3, [r3, #7]
 800afac:	b2db      	uxtb	r3, r3
 800afae:	2b05      	cmp	r3, #5
 800afb0:	d00a      	beq.n	800afc8 <main+0x308>
						(gDisplayMode == DISPLAY_MODE_LOAD_1) || (gDisplayMode == DISPLAY_MODE_LOAD_2) ) 
 800afb2:	4b63      	ldr	r3, [pc, #396]	; (800b140 <main+0x480>)
 800afb4:	79db      	ldrb	r3, [r3, #7]
 800afb6:	b2db      	uxtb	r3, r3
			if ( 	(gDisplayMode == DISPLAY_MODE_SAVE_1) || (gDisplayMode == DISPLAY_MODE_SAVE_2) ||
 800afb8:	2b06      	cmp	r3, #6
 800afba:	d005      	beq.n	800afc8 <main+0x308>
						(gDisplayMode == DISPLAY_MODE_LOAD_1) || (gDisplayMode == DISPLAY_MODE_LOAD_2) ) 
 800afbc:	4b60      	ldr	r3, [pc, #384]	; (800b140 <main+0x480>)
 800afbe:	79db      	ldrb	r3, [r3, #7]
 800afc0:	b2db      	uxtb	r3, r3
 800afc2:	2b07      	cmp	r3, #7
 800afc4:	f47f af44 	bne.w	800ae50 <main+0x190>
				DisplayUpdateFlags.b.MainDisplay = 1;
 800afc8:	4a5c      	ldr	r2, [pc, #368]	; (800b13c <main+0x47c>)
 800afca:	7813      	ldrb	r3, [r2, #0]
 800afcc:	f043 0301 	orr.w	r3, r3, #1
 800afd0:	7013      	strb	r3, [r2, #0]
 800afd2:	e73d      	b.n	800ae50 <main+0x190>
			UpdateStepSection();
 800afd4:	f7ff fc5e 	bl	800a894 <UpdateStepSection>
			DisplayUpdateFlags.b.StepsDisplay = 0;
 800afd8:	4a58      	ldr	r2, [pc, #352]	; (800b13c <main+0x47c>)
 800afda:	7813      	ldrb	r3, [r2, #0]
 800afdc:	f36f 0341 	bfc	r3, #1, #1
 800afe0:	7013      	strb	r3, [r2, #0]
 800afe2:	e73b      	b.n	800ae5c <main+0x19c>
			if(Is_Expander_Present()) max_step = 31;
 800afe4:	f04f 0e1f 	mov.w	lr, #31
			previous_step[j] = pots_step[j];
 800afe8:	4b56      	ldr	r3, [pc, #344]	; (800b144 <main+0x484>)
 800afea:	4423      	add	r3, r4
 800afec:	f893 2024 	ldrb.w	r2, [r3, #36]	; 0x24
 800aff0:	b2d2      	uxtb	r2, r2
 800aff2:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
			if(pots_step[j] < (max_step+1)) next_step_tres = (pots_step[j])*CalConstants[ADC_STAGEADDRESS_Ch_1+j]/(max_step+1) + 20;
 800aff6:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800affa:	b2db      	uxtb	r3, r3
 800affc:	f10e 0e01 	add.w	lr, lr, #1
 800b000:	4573      	cmp	r3, lr
 800b002:	da2b      	bge.n	800b05c <main+0x39c>
 800b004:	4b4f      	ldr	r3, [pc, #316]	; (800b144 <main+0x484>)
 800b006:	191a      	adds	r2, r3, r4
 800b008:	f892 7024 	ldrb.w	r7, [r2, #36]	; 0x24
 800b00c:	1da2      	adds	r2, r4, #6
 800b00e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 800b012:	685b      	ldr	r3, [r3, #4]
 800b014:	fb07 f703 	mul.w	r7, r7, r3
 800b018:	fbb7 f7fe 	udiv	r7, r7, lr
 800b01c:	b2bf      	uxth	r7, r7
 800b01e:	3714      	adds	r7, #20
 800b020:	b2bf      	uxth	r7, r7
			if(pots_step[j] > 1) prev_step_tres = (pots_step[j]-1)*CalConstants[ADC_STAGEADDRESS_Ch_1+j]/(max_step+1) - 20;
 800b022:	4b48      	ldr	r3, [pc, #288]	; (800b144 <main+0x484>)
 800b024:	4423      	add	r3, r4
 800b026:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800b02a:	b2db      	uxtb	r3, r3
 800b02c:	2b01      	cmp	r3, #1
 800b02e:	d917      	bls.n	800b060 <main+0x3a0>
 800b030:	4b44      	ldr	r3, [pc, #272]	; (800b144 <main+0x484>)
 800b032:	191a      	adds	r2, r3, r4
 800b034:	f892 6024 	ldrb.w	r6, [r2, #36]	; 0x24
 800b038:	1e72      	subs	r2, r6, #1
 800b03a:	1da1      	adds	r1, r4, #6
 800b03c:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 800b040:	685e      	ldr	r6, [r3, #4]
 800b042:	fb06 f602 	mul.w	r6, r6, r2
 800b046:	fbb6 f6fe 	udiv	r6, r6, lr
 800b04a:	b2b6      	uxth	r6, r6
 800b04c:	3e14      	subs	r6, #20
 800b04e:	b2b6      	uxth	r6, r6
			acc = 0;
 800b050:	2100      	movs	r1, #0
			for(i =0; i<10; i++)
 800b052:	460a      	mov	r2, r1
 800b054:	e018      	b.n	800b088 <main+0x3c8>
				max_step = 15;
 800b056:	f04f 0e0f 	mov.w	lr, #15
 800b05a:	e7c5      	b.n	800afe8 <main+0x328>
			next_step_tres = 0;
 800b05c:	2700      	movs	r7, #0
 800b05e:	e7e0      	b.n	800b022 <main+0x362>
			prev_step_tres = 0;
 800b060:	2600      	movs	r6, #0
 800b062:	e7f5      	b.n	800b050 <main+0x390>
					temp = (AddData[ADC_STAGEADDRESS_Ch_1]*4095/CalConstants[ADC_STAGEADDRESS_Ch_1]);
 800b064:	4b38      	ldr	r3, [pc, #224]	; (800b148 <main+0x488>)
 800b066:	699b      	ldr	r3, [r3, #24]
 800b068:	ebc3 3303 	rsb	r3, r3, r3, lsl #12
 800b06c:	4835      	ldr	r0, [pc, #212]	; (800b144 <main+0x484>)
 800b06e:	69c0      	ldr	r0, [r0, #28]
 800b070:	fbb3 f3f0 	udiv	r3, r3, r0
 800b074:	b29b      	uxth	r3, r3
					if(temp > 4095) temp = 4095; 
 800b076:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800b07a:	d301      	bcc.n	800b080 <main+0x3c0>
 800b07c:	f640 73ff 	movw	r3, #4095	; 0xfff
					acc += temp;
 800b080:	4419      	add	r1, r3
 800b082:	e000      	b.n	800b086 <main+0x3c6>
					acc += temp;
 800b084:	4419      	add	r1, r3
			for(i =0; i<10; i++)
 800b086:	3201      	adds	r2, #1
 800b088:	2a09      	cmp	r2, #9
 800b08a:	dc10      	bgt.n	800b0ae <main+0x3ee>
				if(j == 0) 
 800b08c:	2c00      	cmp	r4, #0
 800b08e:	d0e9      	beq.n	800b064 <main+0x3a4>
					temp = (AddData[ADC_STAGEADDRESS_Ch_2]*4095/CalConstants[ADC_STAGEADDRESS_Ch_2]);
 800b090:	4b2d      	ldr	r3, [pc, #180]	; (800b148 <main+0x488>)
 800b092:	69db      	ldr	r3, [r3, #28]
 800b094:	ebc3 3303 	rsb	r3, r3, r3, lsl #12
 800b098:	482a      	ldr	r0, [pc, #168]	; (800b144 <main+0x484>)
 800b09a:	6a00      	ldr	r0, [r0, #32]
 800b09c:	fbb3 f3f0 	udiv	r3, r3, r0
 800b0a0:	b29b      	uxth	r3, r3
					if(temp > 4095) temp = 4095; 
 800b0a2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800b0a6:	d3ed      	bcc.n	800b084 <main+0x3c4>
 800b0a8:	f640 73ff 	movw	r3, #4095	; 0xfff
 800b0ac:	e7ea      	b.n	800b084 <main+0x3c4>
			if(pots_step[j] < (max_step+1)) {if(acc/10 > next_step_tres) 
 800b0ae:	4b25      	ldr	r3, [pc, #148]	; (800b144 <main+0x484>)
 800b0b0:	4423      	add	r3, r4
 800b0b2:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800b0b6:	b2db      	uxtb	r3, r3
 800b0b8:	459e      	cmp	lr, r3
 800b0ba:	dd0f      	ble.n	800b0dc <main+0x41c>
 800b0bc:	4a23      	ldr	r2, [pc, #140]	; (800b14c <main+0x48c>)
 800b0be:	fb82 3201 	smull	r3, r2, r2, r1
 800b0c2:	17cb      	asrs	r3, r1, #31
 800b0c4:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 800b0c8:	42bb      	cmp	r3, r7
 800b0ca:	dd07      	ble.n	800b0dc <main+0x41c>
				pots_step[j]++;
 800b0cc:	4a1d      	ldr	r2, [pc, #116]	; (800b144 <main+0x484>)
 800b0ce:	4422      	add	r2, r4
 800b0d0:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 800b0d4:	3301      	adds	r3, #1
 800b0d6:	b2db      	uxtb	r3, r3
 800b0d8:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
			if(pots_step[j] > 1) {if(acc/10 < prev_step_tres) 
 800b0dc:	4b19      	ldr	r3, [pc, #100]	; (800b144 <main+0x484>)
 800b0de:	4423      	add	r3, r4
 800b0e0:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800b0e4:	b2db      	uxtb	r3, r3
 800b0e6:	2b01      	cmp	r3, #1
 800b0e8:	d90f      	bls.n	800b10a <main+0x44a>
 800b0ea:	4b18      	ldr	r3, [pc, #96]	; (800b14c <main+0x48c>)
 800b0ec:	fb83 2301 	smull	r2, r3, r3, r1
 800b0f0:	17c9      	asrs	r1, r1, #31
 800b0f2:	ebc1 01a3 	rsb	r1, r1, r3, asr #2
 800b0f6:	42b1      	cmp	r1, r6
 800b0f8:	da07      	bge.n	800b10a <main+0x44a>
				pots_step[j]--;
 800b0fa:	4a12      	ldr	r2, [pc, #72]	; (800b144 <main+0x484>)
 800b0fc:	4422      	add	r2, r4
 800b0fe:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 800b102:	3b01      	subs	r3, #1
 800b104:	b2db      	uxtb	r3, r3
 800b106:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
	for(j = 0; j < 2; j++)
 800b10a:	3401      	adds	r4, #1
 800b10c:	2c01      	cmp	r4, #1
 800b10e:	f73f ae7c 	bgt.w	800ae0a <main+0x14a>
			if(Is_Expander_Present()) max_step = 31;
 800b112:	f7fc fadb 	bl	80076cc <Is_Expander_Present>
 800b116:	2800      	cmp	r0, #0
 800b118:	f47f af64 	bne.w	800afe4 <main+0x324>
				if(pots_step[j] > 16) pots_step[j] = 1;
 800b11c:	4b09      	ldr	r3, [pc, #36]	; (800b144 <main+0x484>)
 800b11e:	4423      	add	r3, r4
 800b120:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800b124:	b2db      	uxtb	r3, r3
 800b126:	2b10      	cmp	r3, #16
 800b128:	d995      	bls.n	800b056 <main+0x396>
 800b12a:	4b06      	ldr	r3, [pc, #24]	; (800b144 <main+0x484>)
 800b12c:	4423      	add	r3, r4
 800b12e:	2201      	movs	r2, #1
 800b130:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
				max_step = 15;
 800b134:	f04f 0e0f 	mov.w	lr, #15
 800b138:	e756      	b.n	800afe8 <main+0x328>
 800b13a:	bf00      	nop
 800b13c:	20000708 	.word	0x20000708
 800b140:	200006b4 	.word	0x200006b4
 800b144:	20000258 	.word	0x20000258
 800b148:	20000c0c 	.word	0x20000c0c
 800b14c:	66666667 	.word	0x66666667

0800b150 <delay_us>:

void delay_us(unsigned int us)
{
 800b150:	b510      	push	{r4, lr}
 800b152:	b086      	sub	sp, #24
 800b154:	4604      	mov	r4, r0
	volatile uint32_t nCount;
	RCC_ClocksTypeDef RCC_Clocks;
	RCC_GetClocksFreq (&RCC_Clocks);
 800b156:	a801      	add	r0, sp, #4
 800b158:	f7f9 fb28 	bl	80047ac <RCC_GetClocksFreq>

	nCount=(RCC_Clocks.HCLK_Frequency/10000000)*us;
 800b15c:	4a08      	ldr	r2, [pc, #32]	; (800b180 <delay_us+0x30>)
 800b15e:	9b02      	ldr	r3, [sp, #8]
 800b160:	fba2 2303 	umull	r2, r3, r2, r3
 800b164:	0d9b      	lsrs	r3, r3, #22
 800b166:	fb04 f303 	mul.w	r3, r4, r3
 800b16a:	9305      	str	r3, [sp, #20]
	for (; nCount!=0; nCount--);
 800b16c:	e002      	b.n	800b174 <delay_us+0x24>
 800b16e:	9b05      	ldr	r3, [sp, #20]
 800b170:	3b01      	subs	r3, #1
 800b172:	9305      	str	r3, [sp, #20]
 800b174:	9b05      	ldr	r3, [sp, #20]
 800b176:	2b00      	cmp	r3, #0
 800b178:	d1f9      	bne.n	800b16e <delay_us+0x1e>
}
 800b17a:	b006      	add	sp, #24
 800b17c:	bd10      	pop	{r4, pc}
 800b17e:	bf00      	nop
 800b180:	6b5fca6b 	.word	0x6b5fca6b

0800b184 <ADC_IRQHandler>:
{
 800b184:	b538      	push	{r3, r4, r5, lr}
	if(Is_Expander_Present())
 800b186:	f7fc faa1 	bl	80076cc <Is_Expander_Present>
 800b18a:	2800      	cmp	r0, #0
 800b18c:	d032      	beq.n	800b1f4 <ADC_IRQHandler+0x70>
		if (ADC_POT_sel_cnt >= 71) {
 800b18e:	4ba3      	ldr	r3, [pc, #652]	; (800b41c <ADC_IRQHandler+0x298>)
 800b190:	781b      	ldrb	r3, [r3, #0]
 800b192:	b2db      	uxtb	r3, r3
 800b194:	2b46      	cmp	r3, #70	; 0x46
 800b196:	d926      	bls.n	800b1e6 <ADC_IRQHandler+0x62>
			ADC_POTS_selector_Ch(0);
 800b198:	2000      	movs	r0, #0
 800b19a:	f7fc fa35 	bl	8007608 <ADC_POTS_selector_Ch>
	if ( ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == SET) {				
 800b19e:	2102      	movs	r1, #2
 800b1a0:	489f      	ldr	r0, [pc, #636]	; (800b420 <ADC_IRQHandler+0x29c>)
 800b1a2:	f7f5 fa47 	bl	8000634 <ADC_GetFlagStatus>
 800b1a6:	2801      	cmp	r0, #1
 800b1a8:	d034      	beq.n	800b214 <ADC_IRQHandler+0x90>
	unsigned char NeedInc = 0, i;
 800b1aa:	2400      	movs	r4, #0
		if ( ADC_GetFlagStatus(ADC2, ADC_FLAG_EOC) == SET ) {
 800b1ac:	2102      	movs	r1, #2
 800b1ae:	489d      	ldr	r0, [pc, #628]	; (800b424 <ADC_IRQHandler+0x2a0>)
 800b1b0:	f7f5 fa40 	bl	8000634 <ADC_GetFlagStatus>
 800b1b4:	2801      	cmp	r0, #1
 800b1b6:	f000 822e 	beq.w	800b616 <ADC_IRQHandler+0x492>
	if(Is_Expander_Present())
 800b1ba:	f7fc fa87 	bl	80076cc <Is_Expander_Present>
 800b1be:	2800      	cmp	r0, #0
 800b1c0:	f000 8241 	beq.w	800b646 <ADC_IRQHandler+0x4c2>
	if (NeedInc) {
 800b1c4:	2c00      	cmp	r4, #0
 800b1c6:	f000 8248 	beq.w	800b65a <ADC_IRQHandler+0x4d6>
		ADC_POT_sel_cnt++;
 800b1ca:	4a94      	ldr	r2, [pc, #592]	; (800b41c <ADC_IRQHandler+0x298>)
 800b1cc:	7813      	ldrb	r3, [r2, #0]
 800b1ce:	3301      	adds	r3, #1
 800b1d0:	b2db      	uxtb	r3, r3
 800b1d2:	7013      	strb	r3, [r2, #0]
		if (ADC_POT_sel_cnt >= 72) {//40
 800b1d4:	7813      	ldrb	r3, [r2, #0]
 800b1d6:	b2db      	uxtb	r3, r3
 800b1d8:	2b47      	cmp	r3, #71	; 0x47
 800b1da:	f240 823e 	bls.w	800b65a <ADC_IRQHandler+0x4d6>
			ADC_POT_sel_cnt = 0;
 800b1de:	2200      	movs	r2, #0
 800b1e0:	4b8e      	ldr	r3, [pc, #568]	; (800b41c <ADC_IRQHandler+0x298>)
 800b1e2:	701a      	strb	r2, [r3, #0]
 800b1e4:	bd38      	pop	{r3, r4, r5, pc}
			ADC_POTS_selector_Ch(ADC_POT_sel_cnt+1);
 800b1e6:	4b8d      	ldr	r3, [pc, #564]	; (800b41c <ADC_IRQHandler+0x298>)
 800b1e8:	7818      	ldrb	r0, [r3, #0]
 800b1ea:	3001      	adds	r0, #1
 800b1ec:	b2c0      	uxtb	r0, r0
 800b1ee:	f7fc fa0b 	bl	8007608 <ADC_POTS_selector_Ch>
 800b1f2:	e7d4      	b.n	800b19e <ADC_IRQHandler+0x1a>
		if (ADC_POT_sel_cnt >= 39) {
 800b1f4:	4b89      	ldr	r3, [pc, #548]	; (800b41c <ADC_IRQHandler+0x298>)
 800b1f6:	781b      	ldrb	r3, [r3, #0]
 800b1f8:	b2db      	uxtb	r3, r3
 800b1fa:	2b26      	cmp	r3, #38	; 0x26
 800b1fc:	d903      	bls.n	800b206 <ADC_IRQHandler+0x82>
			ADC_POTS_selector_Ch(0);
 800b1fe:	2000      	movs	r0, #0
 800b200:	f7fc fa02 	bl	8007608 <ADC_POTS_selector_Ch>
 800b204:	e7cb      	b.n	800b19e <ADC_IRQHandler+0x1a>
			ADC_POTS_selector_Ch(ADC_POT_sel_cnt+1);
 800b206:	4b85      	ldr	r3, [pc, #532]	; (800b41c <ADC_IRQHandler+0x298>)
 800b208:	7818      	ldrb	r0, [r3, #0]
 800b20a:	3001      	adds	r0, #1
 800b20c:	b2c0      	uxtb	r0, r0
 800b20e:	f7fc f9fb 	bl	8007608 <ADC_POTS_selector_Ch>
 800b212:	e7c4      	b.n	800b19e <ADC_IRQHandler+0x1a>
		if (  (ADC_POT_sel_cnt<=15)) {
 800b214:	4b81      	ldr	r3, [pc, #516]	; (800b41c <ADC_IRQHandler+0x298>)
 800b216:	781b      	ldrb	r3, [r3, #0]
 800b218:	b2db      	uxtb	r3, r3
 800b21a:	2b0f      	cmp	r3, #15
 800b21c:	f200 810c 	bhi.w	800b438 <ADC_IRQHandler+0x2b4>
			if ( (Steps[1][ADC_POT_sel_cnt].b.WaitVoltageSlider == 1) ) {
 800b220:	4b7e      	ldr	r3, [pc, #504]	; (800b41c <ADC_IRQHandler+0x298>)
 800b222:	781b      	ldrb	r3, [r3, #0]
 800b224:	f103 0220 	add.w	r2, r3, #32
 800b228:	4b7f      	ldr	r3, [pc, #508]	; (800b428 <ADC_IRQHandler+0x2a4>)
 800b22a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800b22e:	685b      	ldr	r3, [r3, #4]
 800b230:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 800b234:	d12a      	bne.n	800b28c <ADC_IRQHandler+0x108>
				average_array[1][ADC_POT_sel_cnt][average_index[1][ADC_POT_sel_cnt]] = (uint16_t) (ADC1->DR);
 800b236:	4879      	ldr	r0, [pc, #484]	; (800b41c <ADC_IRQHandler+0x298>)
 800b238:	7802      	ldrb	r2, [r0, #0]
 800b23a:	7803      	ldrb	r3, [r0, #0]
 800b23c:	497b      	ldr	r1, [pc, #492]	; (800b42c <ADC_IRQHandler+0x2a8>)
 800b23e:	3320      	adds	r3, #32
 800b240:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 800b244:	4c76      	ldr	r4, [pc, #472]	; (800b420 <ADC_IRQHandler+0x29c>)
 800b246:	6ce4      	ldr	r4, [r4, #76]	; 0x4c
 800b248:	b2a4      	uxth	r4, r4
 800b24a:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800b24e:	0055      	lsls	r5, r2, #1
 800b250:	fa15 f383 	uxtah	r3, r5, r3
 800b254:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 800b258:	4a75      	ldr	r2, [pc, #468]	; (800b430 <ADC_IRQHandler+0x2ac>)
 800b25a:	f822 4013 	strh.w	r4, [r2, r3, lsl #1]
				average_index[1][ADC_POT_sel_cnt]++;
 800b25e:	7802      	ldrb	r2, [r0, #0]
 800b260:	3220      	adds	r2, #32
 800b262:	f831 3012 	ldrh.w	r3, [r1, r2, lsl #1]
 800b266:	b29b      	uxth	r3, r3
 800b268:	3301      	adds	r3, #1
 800b26a:	b29b      	uxth	r3, r3
 800b26c:	f821 3012 	strh.w	r3, [r1, r2, lsl #1]
				if(average_index[1][ADC_POT_sel_cnt] == NUMS) average_index[1][ADC_POT_sel_cnt] = 0;
 800b270:	7803      	ldrb	r3, [r0, #0]
 800b272:	3320      	adds	r3, #32
 800b274:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 800b278:	b29b      	uxth	r3, r3
 800b27a:	2b0a      	cmp	r3, #10
 800b27c:	d01d      	beq.n	800b2ba <ADC_IRQHandler+0x136>
				acc = 0;
 800b27e:	2000      	movs	r0, #0
 800b280:	2100      	movs	r1, #0
 800b282:	4b6c      	ldr	r3, [pc, #432]	; (800b434 <ADC_IRQHandler+0x2b0>)
 800b284:	e9c3 0100 	strd	r0, r1, [r3]
				for(i = 0; i < NUMS; i++)
 800b288:	2200      	movs	r2, #0
 800b28a:	e033      	b.n	800b2f4 <ADC_IRQHandler+0x170>
					if ( (unsigned int) (ADC1->DR) == (unsigned int) Steps[1][ADC_POT_sel_cnt].b.VLevel ) {
 800b28c:	4b64      	ldr	r3, [pc, #400]	; (800b420 <ADC_IRQHandler+0x29c>)
 800b28e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800b290:	4b62      	ldr	r3, [pc, #392]	; (800b41c <ADC_IRQHandler+0x298>)
 800b292:	781b      	ldrb	r3, [r3, #0]
 800b294:	3320      	adds	r3, #32
 800b296:	4964      	ldr	r1, [pc, #400]	; (800b428 <ADC_IRQHandler+0x2a4>)
 800b298:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
 800b29c:	f343 030b 	sbfx	r3, r3, #0, #12
 800b2a0:	429a      	cmp	r2, r3
 800b2a2:	d13f      	bne.n	800b324 <ADC_IRQHandler+0x1a0>
						Steps[1][ADC_POT_sel_cnt].b.WaitVoltageSlider = 0;
 800b2a4:	4b5d      	ldr	r3, [pc, #372]	; (800b41c <ADC_IRQHandler+0x298>)
 800b2a6:	781b      	ldrb	r3, [r3, #0]
 800b2a8:	f103 0220 	add.w	r2, r3, #32
 800b2ac:	eb01 03c2 	add.w	r3, r1, r2, lsl #3
 800b2b0:	685a      	ldr	r2, [r3, #4]
 800b2b2:	f36f 324d 	bfc	r2, #13, #1
 800b2b6:	605a      	str	r2, [r3, #4]
 800b2b8:	e034      	b.n	800b324 <ADC_IRQHandler+0x1a0>
				if(average_index[1][ADC_POT_sel_cnt] == NUMS) average_index[1][ADC_POT_sel_cnt] = 0;
 800b2ba:	7803      	ldrb	r3, [r0, #0]
 800b2bc:	3320      	adds	r3, #32
 800b2be:	2100      	movs	r1, #0
 800b2c0:	4a5a      	ldr	r2, [pc, #360]	; (800b42c <ADC_IRQHandler+0x2a8>)
 800b2c2:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
 800b2c6:	e7da      	b.n	800b27e <ADC_IRQHandler+0xfa>
					acc += average_array[1][ADC_POT_sel_cnt][i];
 800b2c8:	4b54      	ldr	r3, [pc, #336]	; (800b41c <ADC_IRQHandler+0x298>)
 800b2ca:	7819      	ldrb	r1, [r3, #0]
 800b2cc:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 800b2d0:	004b      	lsls	r3, r1, #1
 800b2d2:	4413      	add	r3, r2
 800b2d4:	f503 73a0 	add.w	r3, r3, #320	; 0x140
 800b2d8:	4955      	ldr	r1, [pc, #340]	; (800b430 <ADC_IRQHandler+0x2ac>)
 800b2da:	f831 0013 	ldrh.w	r0, [r1, r3, lsl #1]
 800b2de:	b280      	uxth	r0, r0
 800b2e0:	2100      	movs	r1, #0
 800b2e2:	4b54      	ldr	r3, [pc, #336]	; (800b434 <ADC_IRQHandler+0x2b0>)
 800b2e4:	e9d3 4500 	ldrd	r4, r5, [r3]
 800b2e8:	1900      	adds	r0, r0, r4
 800b2ea:	4169      	adcs	r1, r5
 800b2ec:	e9c3 0100 	strd	r0, r1, [r3]
				for(i = 0; i < NUMS; i++)
 800b2f0:	3201      	adds	r2, #1
 800b2f2:	b2d2      	uxtb	r2, r2
 800b2f4:	2a09      	cmp	r2, #9
 800b2f6:	d9e7      	bls.n	800b2c8 <ADC_IRQHandler+0x144>
				Steps[1][ADC_POT_sel_cnt].b.VLevel = acc/NUMS;
 800b2f8:	4b48      	ldr	r3, [pc, #288]	; (800b41c <ADC_IRQHandler+0x298>)
 800b2fa:	781b      	ldrb	r3, [r3, #0]
 800b2fc:	b2dc      	uxtb	r4, r3
 800b2fe:	220a      	movs	r2, #10
 800b300:	2300      	movs	r3, #0
 800b302:	494c      	ldr	r1, [pc, #304]	; (800b434 <ADC_IRQHandler+0x2b0>)
 800b304:	e9d1 0100 	ldrd	r0, r1, [r1]
 800b308:	f001 f82a 	bl	800c360 <__aeabi_ldivmod>
 800b30c:	f340 000b 	sbfx	r0, r0, #0, #12
 800b310:	4a45      	ldr	r2, [pc, #276]	; (800b428 <ADC_IRQHandler+0x2a4>)
 800b312:	f104 0320 	add.w	r3, r4, #32
 800b316:	b280      	uxth	r0, r0
 800b318:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
 800b31c:	f360 010b 	bfi	r1, r0, #0, #12
 800b320:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
			if ( (Steps[0][ADC_POT_sel_cnt].b.WaitVoltageSlider == 1) ) {
 800b324:	4b3d      	ldr	r3, [pc, #244]	; (800b41c <ADC_IRQHandler+0x298>)
 800b326:	781a      	ldrb	r2, [r3, #0]
 800b328:	4b3f      	ldr	r3, [pc, #252]	; (800b428 <ADC_IRQHandler+0x2a4>)
 800b32a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800b32e:	685b      	ldr	r3, [r3, #4]
 800b330:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 800b334:	d128      	bne.n	800b388 <ADC_IRQHandler+0x204>
								average_array[0][ADC_POT_sel_cnt][average_index[0][ADC_POT_sel_cnt]] = (uint16_t) (ADC1->DR);
 800b336:	4939      	ldr	r1, [pc, #228]	; (800b41c <ADC_IRQHandler+0x298>)
 800b338:	780b      	ldrb	r3, [r1, #0]
 800b33a:	7808      	ldrb	r0, [r1, #0]
 800b33c:	b2c0      	uxtb	r0, r0
 800b33e:	4a3b      	ldr	r2, [pc, #236]	; (800b42c <ADC_IRQHandler+0x2a8>)
 800b340:	f832 0010 	ldrh.w	r0, [r2, r0, lsl #1]
 800b344:	4c36      	ldr	r4, [pc, #216]	; (800b420 <ADC_IRQHandler+0x29c>)
 800b346:	6ce4      	ldr	r4, [r4, #76]	; 0x4c
 800b348:	b2a4      	uxth	r4, r4
 800b34a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800b34e:	005d      	lsls	r5, r3, #1
 800b350:	fa15 f380 	uxtah	r3, r5, r0
 800b354:	4836      	ldr	r0, [pc, #216]	; (800b430 <ADC_IRQHandler+0x2ac>)
 800b356:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
				average_index[0][ADC_POT_sel_cnt]++;
 800b35a:	7808      	ldrb	r0, [r1, #0]
 800b35c:	b2c0      	uxtb	r0, r0
 800b35e:	f832 3010 	ldrh.w	r3, [r2, r0, lsl #1]
 800b362:	b29b      	uxth	r3, r3
 800b364:	3301      	adds	r3, #1
 800b366:	b29b      	uxth	r3, r3
 800b368:	f822 3010 	strh.w	r3, [r2, r0, lsl #1]
				if(average_index[0][ADC_POT_sel_cnt] == NUMS) average_index[0][ADC_POT_sel_cnt] = 0;
 800b36c:	780b      	ldrb	r3, [r1, #0]
 800b36e:	b2db      	uxtb	r3, r3
 800b370:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800b374:	b29b      	uxth	r3, r3
 800b376:	2b0a      	cmp	r3, #10
 800b378:	d01e      	beq.n	800b3b8 <ADC_IRQHandler+0x234>
				acc = 0;
 800b37a:	2000      	movs	r0, #0
 800b37c:	2100      	movs	r1, #0
 800b37e:	4b2d      	ldr	r3, [pc, #180]	; (800b434 <ADC_IRQHandler+0x2b0>)
 800b380:	e9c3 0100 	strd	r0, r1, [r3]
				for(i = 0; i < NUMS; i++)
 800b384:	2300      	movs	r3, #0
 800b386:	e031      	b.n	800b3ec <ADC_IRQHandler+0x268>
			if ( (unsigned int) (ADC1->DR) == (unsigned int) Steps[0][ADC_POT_sel_cnt].b.VLevel ) {
 800b388:	4b25      	ldr	r3, [pc, #148]	; (800b420 <ADC_IRQHandler+0x29c>)
 800b38a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800b38c:	4b23      	ldr	r3, [pc, #140]	; (800b41c <ADC_IRQHandler+0x298>)
 800b38e:	781b      	ldrb	r3, [r3, #0]
 800b390:	b2db      	uxtb	r3, r3
 800b392:	4925      	ldr	r1, [pc, #148]	; (800b428 <ADC_IRQHandler+0x2a4>)
 800b394:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
 800b398:	f343 030b 	sbfx	r3, r3, #0, #12
 800b39c:	429a      	cmp	r2, r3
 800b39e:	d001      	beq.n	800b3a4 <ADC_IRQHandler+0x220>
			NeedInc = 1;
 800b3a0:	2401      	movs	r4, #1
 800b3a2:	e04a      	b.n	800b43a <ADC_IRQHandler+0x2b6>
						Steps[0][ADC_POT_sel_cnt].b.WaitVoltageSlider = 0;
 800b3a4:	4b1d      	ldr	r3, [pc, #116]	; (800b41c <ADC_IRQHandler+0x298>)
 800b3a6:	781a      	ldrb	r2, [r3, #0]
 800b3a8:	eb01 03c2 	add.w	r3, r1, r2, lsl #3
 800b3ac:	685a      	ldr	r2, [r3, #4]
 800b3ae:	f36f 324d 	bfc	r2, #13, #1
 800b3b2:	605a      	str	r2, [r3, #4]
			NeedInc = 1;
 800b3b4:	2401      	movs	r4, #1
 800b3b6:	e040      	b.n	800b43a <ADC_IRQHandler+0x2b6>
				if(average_index[0][ADC_POT_sel_cnt] == NUMS) average_index[0][ADC_POT_sel_cnt] = 0;
 800b3b8:	780b      	ldrb	r3, [r1, #0]
 800b3ba:	b2db      	uxtb	r3, r3
 800b3bc:	2100      	movs	r1, #0
 800b3be:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
 800b3c2:	e7da      	b.n	800b37a <ADC_IRQHandler+0x1f6>
					acc += average_array[0][ADC_POT_sel_cnt][i];
 800b3c4:	4a15      	ldr	r2, [pc, #84]	; (800b41c <ADC_IRQHandler+0x298>)
 800b3c6:	7812      	ldrb	r2, [r2, #0]
 800b3c8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 800b3cc:	0051      	lsls	r1, r2, #1
 800b3ce:	4419      	add	r1, r3
 800b3d0:	4a17      	ldr	r2, [pc, #92]	; (800b430 <ADC_IRQHandler+0x2ac>)
 800b3d2:	f832 0011 	ldrh.w	r0, [r2, r1, lsl #1]
 800b3d6:	b280      	uxth	r0, r0
 800b3d8:	2100      	movs	r1, #0
 800b3da:	4a16      	ldr	r2, [pc, #88]	; (800b434 <ADC_IRQHandler+0x2b0>)
 800b3dc:	e9d2 4500 	ldrd	r4, r5, [r2]
 800b3e0:	1900      	adds	r0, r0, r4
 800b3e2:	4169      	adcs	r1, r5
 800b3e4:	e9c2 0100 	strd	r0, r1, [r2]
				for(i = 0; i < NUMS; i++)
 800b3e8:	3301      	adds	r3, #1
 800b3ea:	b2db      	uxtb	r3, r3
 800b3ec:	2b09      	cmp	r3, #9
 800b3ee:	d9e9      	bls.n	800b3c4 <ADC_IRQHandler+0x240>
				Steps[0][ADC_POT_sel_cnt].b.VLevel = acc/NUMS;
 800b3f0:	4b0a      	ldr	r3, [pc, #40]	; (800b41c <ADC_IRQHandler+0x298>)
 800b3f2:	781c      	ldrb	r4, [r3, #0]
 800b3f4:	b2e4      	uxtb	r4, r4
 800b3f6:	220a      	movs	r2, #10
 800b3f8:	2300      	movs	r3, #0
 800b3fa:	490e      	ldr	r1, [pc, #56]	; (800b434 <ADC_IRQHandler+0x2b0>)
 800b3fc:	e9d1 0100 	ldrd	r0, r1, [r1]
 800b400:	f000 ffae 	bl	800c360 <__aeabi_ldivmod>
 800b404:	f340 000b 	sbfx	r0, r0, #0, #12
 800b408:	4b07      	ldr	r3, [pc, #28]	; (800b428 <ADC_IRQHandler+0x2a4>)
 800b40a:	b280      	uxth	r0, r0
 800b40c:	f853 2034 	ldr.w	r2, [r3, r4, lsl #3]
 800b410:	f360 020b 	bfi	r2, r0, #0, #12
 800b414:	f843 2034 	str.w	r2, [r3, r4, lsl #3]
			NeedInc = 1;
 800b418:	2401      	movs	r4, #1
 800b41a:	e00e      	b.n	800b43a <ADC_IRQHandler+0x2b6>
 800b41c:	200006b4 	.word	0x200006b4
 800b420:	40012000 	.word	0x40012000
 800b424:	40012100 	.word	0x40012100
 800b428:	20000cb4 	.word	0x20000cb4
 800b42c:	20000c2c 	.word	0x20000c2c
 800b430:	2000070c 	.word	0x2000070c
 800b434:	200006f8 	.word	0x200006f8
	unsigned char NeedInc = 0, i;
 800b438:	2400      	movs	r4, #0
			if (  (ADC_POT_sel_cnt>=40 && (ADC_POT_sel_cnt<=55))) {
 800b43a:	4b8c      	ldr	r3, [pc, #560]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b43c:	781b      	ldrb	r3, [r3, #0]
 800b43e:	b2db      	uxtb	r3, r3
 800b440:	2b27      	cmp	r3, #39	; 0x27
 800b442:	d949      	bls.n	800b4d8 <ADC_IRQHandler+0x354>
 800b444:	4b89      	ldr	r3, [pc, #548]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b446:	781b      	ldrb	r3, [r3, #0]
 800b448:	b2db      	uxtb	r3, r3
 800b44a:	2b37      	cmp	r3, #55	; 0x37
 800b44c:	d844      	bhi.n	800b4d8 <ADC_IRQHandler+0x354>
				if ( (Steps[1][ADC_POT_sel_cnt-24].b.WaitVoltageSlider == 1) ) {
 800b44e:	4b87      	ldr	r3, [pc, #540]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b450:	781b      	ldrb	r3, [r3, #0]
 800b452:	f103 0208 	add.w	r2, r3, #8
 800b456:	4b86      	ldr	r3, [pc, #536]	; (800b670 <ADC_IRQHandler+0x4ec>)
 800b458:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800b45c:	685b      	ldr	r3, [r3, #4]
 800b45e:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 800b462:	f040 80a6 	bne.w	800b5b2 <ADC_IRQHandler+0x42e>
					Steps[1][ADC_POT_sel_cnt-24].b.VLevel = ((unsigned int) (ADC1->DR)+(unsigned int) Steps[1][ADC_POT_sel_cnt-24].b.VLevel)/2;
 800b466:	4981      	ldr	r1, [pc, #516]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b468:	780a      	ldrb	r2, [r1, #0]
 800b46a:	4b82      	ldr	r3, [pc, #520]	; (800b674 <ADC_IRQHandler+0x4f0>)
 800b46c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800b46e:	7808      	ldrb	r0, [r1, #0]
 800b470:	497f      	ldr	r1, [pc, #508]	; (800b670 <ADC_IRQHandler+0x4ec>)
 800b472:	3008      	adds	r0, #8
 800b474:	f851 0030 	ldr.w	r0, [r1, r0, lsl #3]
 800b478:	f340 000b 	sbfx	r0, r0, #0, #12
 800b47c:	4403      	add	r3, r0
 800b47e:	f343 034b 	sbfx	r3, r3, #1, #12
 800b482:	3208      	adds	r2, #8
 800b484:	b29b      	uxth	r3, r3
 800b486:	f851 0032 	ldr.w	r0, [r1, r2, lsl #3]
 800b48a:	f363 000b 	bfi	r0, r3, #0, #12
 800b48e:	f841 0032 	str.w	r0, [r1, r2, lsl #3]
				if ( (Steps[0][ADC_POT_sel_cnt-24].b.WaitVoltageSlider == 1) ) {
 800b492:	4b76      	ldr	r3, [pc, #472]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b494:	781b      	ldrb	r3, [r3, #0]
 800b496:	f1a3 0218 	sub.w	r2, r3, #24
 800b49a:	4b75      	ldr	r3, [pc, #468]	; (800b670 <ADC_IRQHandler+0x4ec>)
 800b49c:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800b4a0:	685b      	ldr	r3, [r3, #4]
 800b4a2:	f413 5f00 	tst.w	r3, #8192	; 0x2000
 800b4a6:	f040 809c 	bne.w	800b5e2 <ADC_IRQHandler+0x45e>
					Steps[0][ADC_POT_sel_cnt-24].b.VLevel = ((unsigned int) (ADC1->DR)+(unsigned int) Steps[0][ADC_POT_sel_cnt-24].b.VLevel)/2;
 800b4aa:	4970      	ldr	r1, [pc, #448]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b4ac:	780a      	ldrb	r2, [r1, #0]
 800b4ae:	3a18      	subs	r2, #24
 800b4b0:	4b70      	ldr	r3, [pc, #448]	; (800b674 <ADC_IRQHandler+0x4f0>)
 800b4b2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800b4b4:	7808      	ldrb	r0, [r1, #0]
 800b4b6:	3818      	subs	r0, #24
 800b4b8:	496d      	ldr	r1, [pc, #436]	; (800b670 <ADC_IRQHandler+0x4ec>)
 800b4ba:	f851 0030 	ldr.w	r0, [r1, r0, lsl #3]
 800b4be:	f340 000b 	sbfx	r0, r0, #0, #12
 800b4c2:	4403      	add	r3, r0
 800b4c4:	f343 034b 	sbfx	r3, r3, #1, #12
 800b4c8:	b29b      	uxth	r3, r3
 800b4ca:	f851 0032 	ldr.w	r0, [r1, r2, lsl #3]
 800b4ce:	f363 000b 	bfi	r0, r3, #0, #12
 800b4d2:	f841 0032 	str.w	r0, [r1, r2, lsl #3]
				NeedInc = 1;
 800b4d6:	2401      	movs	r4, #1
				if ((ADC_POT_sel_cnt>=56) && (ADC_POT_sel_cnt<=71)) {
 800b4d8:	4b64      	ldr	r3, [pc, #400]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b4da:	781b      	ldrb	r3, [r3, #0]
 800b4dc:	b2db      	uxtb	r3, r3
 800b4de:	2b37      	cmp	r3, #55	; 0x37
 800b4e0:	d92e      	bls.n	800b540 <ADC_IRQHandler+0x3bc>
 800b4e2:	4b62      	ldr	r3, [pc, #392]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b4e4:	781b      	ldrb	r3, [r3, #0]
 800b4e6:	b2db      	uxtb	r3, r3
 800b4e8:	2b47      	cmp	r3, #71	; 0x47
 800b4ea:	d829      	bhi.n	800b540 <ADC_IRQHandler+0x3bc>
				Steps[0][ADC_POT_sel_cnt-40].b.TLevel = (Steps[0][ADC_POT_sel_cnt-40].b.TLevel+(unsigned int)(ADC1->DR))/2;
 800b4ec:	485f      	ldr	r0, [pc, #380]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b4ee:	7801      	ldrb	r1, [r0, #0]
 800b4f0:	3928      	subs	r1, #40	; 0x28
 800b4f2:	7803      	ldrb	r3, [r0, #0]
 800b4f4:	3b28      	subs	r3, #40	; 0x28
 800b4f6:	4a5e      	ldr	r2, [pc, #376]	; (800b670 <ADC_IRQHandler+0x4ec>)
 800b4f8:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 800b4fc:	f343 330b 	sbfx	r3, r3, #12, #12
 800b500:	4c5c      	ldr	r4, [pc, #368]	; (800b674 <ADC_IRQHandler+0x4f0>)
 800b502:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
 800b504:	442b      	add	r3, r5
 800b506:	f343 034b 	sbfx	r3, r3, #1, #12
 800b50a:	b29b      	uxth	r3, r3
 800b50c:	f852 5031 	ldr.w	r5, [r2, r1, lsl #3]
 800b510:	f363 3517 	bfi	r5, r3, #12, #12
 800b514:	f842 5031 	str.w	r5, [r2, r1, lsl #3]
				Steps[1][ADC_POT_sel_cnt-40].b.TLevel = (Steps[1][ADC_POT_sel_cnt-40].b.TLevel+(unsigned int)(ADC1->DR))/2;			
 800b518:	7801      	ldrb	r1, [r0, #0]
 800b51a:	7803      	ldrb	r3, [r0, #0]
 800b51c:	3b08      	subs	r3, #8
 800b51e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 800b522:	f343 330b 	sbfx	r3, r3, #12, #12
 800b526:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 800b528:	4403      	add	r3, r0
 800b52a:	f343 034b 	sbfx	r3, r3, #1, #12
 800b52e:	3908      	subs	r1, #8
 800b530:	b29b      	uxth	r3, r3
 800b532:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]
 800b536:	f363 3017 	bfi	r0, r3, #12, #12
 800b53a:	f842 0031 	str.w	r0, [r2, r1, lsl #3]
				NeedInc = 1;
 800b53e:	2401      	movs	r4, #1
		if ((ADC_POT_sel_cnt>=24) && (ADC_POT_sel_cnt<=39)) {
 800b540:	4b4a      	ldr	r3, [pc, #296]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b542:	781b      	ldrb	r3, [r3, #0]
 800b544:	b2db      	uxtb	r3, r3
 800b546:	2b17      	cmp	r3, #23
 800b548:	d92e      	bls.n	800b5a8 <ADC_IRQHandler+0x424>
 800b54a:	4b48      	ldr	r3, [pc, #288]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b54c:	781b      	ldrb	r3, [r3, #0]
 800b54e:	b2db      	uxtb	r3, r3
 800b550:	2b27      	cmp	r3, #39	; 0x27
 800b552:	d829      	bhi.n	800b5a8 <ADC_IRQHandler+0x424>
			Steps[0][ADC_POT_sel_cnt-24].b.TLevel = (Steps[0][ADC_POT_sel_cnt-24].b.TLevel+(unsigned int)(ADC1->DR))/2;
 800b554:	4845      	ldr	r0, [pc, #276]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b556:	7801      	ldrb	r1, [r0, #0]
 800b558:	3918      	subs	r1, #24
 800b55a:	7803      	ldrb	r3, [r0, #0]
 800b55c:	3b18      	subs	r3, #24
 800b55e:	4a44      	ldr	r2, [pc, #272]	; (800b670 <ADC_IRQHandler+0x4ec>)
 800b560:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 800b564:	f343 330b 	sbfx	r3, r3, #12, #12
 800b568:	4c42      	ldr	r4, [pc, #264]	; (800b674 <ADC_IRQHandler+0x4f0>)
 800b56a:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
 800b56c:	442b      	add	r3, r5
 800b56e:	f343 034b 	sbfx	r3, r3, #1, #12
 800b572:	b29b      	uxth	r3, r3
 800b574:	f852 5031 	ldr.w	r5, [r2, r1, lsl #3]
 800b578:	f363 3517 	bfi	r5, r3, #12, #12
 800b57c:	f842 5031 	str.w	r5, [r2, r1, lsl #3]
			Steps[1][ADC_POT_sel_cnt-24].b.TLevel = (Steps[1][ADC_POT_sel_cnt-24].b.TLevel+(unsigned int)(ADC1->DR))/2;			
 800b580:	7801      	ldrb	r1, [r0, #0]
 800b582:	7803      	ldrb	r3, [r0, #0]
 800b584:	3308      	adds	r3, #8
 800b586:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 800b58a:	f343 330b 	sbfx	r3, r3, #12, #12
 800b58e:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 800b590:	4403      	add	r3, r0
 800b592:	f343 034b 	sbfx	r3, r3, #1, #12
 800b596:	3108      	adds	r1, #8
 800b598:	b29b      	uxth	r3, r3
 800b59a:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]
 800b59e:	f363 3017 	bfi	r0, r3, #12, #12
 800b5a2:	f842 0031 	str.w	r0, [r2, r1, lsl #3]
			NeedInc = 1;
 800b5a6:	2401      	movs	r4, #1
		ADC_ClearFlag(ADC1, ADC_FLAG_EOC);
 800b5a8:	2102      	movs	r1, #2
 800b5aa:	4832      	ldr	r0, [pc, #200]	; (800b674 <ADC_IRQHandler+0x4f0>)
 800b5ac:	f7f5 f849 	bl	8000642 <ADC_ClearFlag>
 800b5b0:	e5fc      	b.n	800b1ac <ADC_IRQHandler+0x28>
						if ( (unsigned int) (ADC1->DR) == (unsigned int) Steps[1][ADC_POT_sel_cnt-24].b.VLevel ) {
 800b5b2:	4b30      	ldr	r3, [pc, #192]	; (800b674 <ADC_IRQHandler+0x4f0>)
 800b5b4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800b5b6:	4b2d      	ldr	r3, [pc, #180]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b5b8:	781b      	ldrb	r3, [r3, #0]
 800b5ba:	3308      	adds	r3, #8
 800b5bc:	492c      	ldr	r1, [pc, #176]	; (800b670 <ADC_IRQHandler+0x4ec>)
 800b5be:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
 800b5c2:	f343 030b 	sbfx	r3, r3, #0, #12
 800b5c6:	429a      	cmp	r2, r3
 800b5c8:	f47f af63 	bne.w	800b492 <ADC_IRQHandler+0x30e>
							Steps[1][ADC_POT_sel_cnt-24].b.WaitVoltageSlider = 0;
 800b5cc:	4b27      	ldr	r3, [pc, #156]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b5ce:	781b      	ldrb	r3, [r3, #0]
 800b5d0:	f103 0208 	add.w	r2, r3, #8
 800b5d4:	eb01 03c2 	add.w	r3, r1, r2, lsl #3
 800b5d8:	685a      	ldr	r2, [r3, #4]
 800b5da:	f36f 324d 	bfc	r2, #13, #1
 800b5de:	605a      	str	r2, [r3, #4]
 800b5e0:	e757      	b.n	800b492 <ADC_IRQHandler+0x30e>
				if ( (unsigned int) (ADC1->DR) == (unsigned int) Steps[0][ADC_POT_sel_cnt-24].b.VLevel ) {
 800b5e2:	4b24      	ldr	r3, [pc, #144]	; (800b674 <ADC_IRQHandler+0x4f0>)
 800b5e4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800b5e6:	4b21      	ldr	r3, [pc, #132]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b5e8:	781b      	ldrb	r3, [r3, #0]
 800b5ea:	3b18      	subs	r3, #24
 800b5ec:	4920      	ldr	r1, [pc, #128]	; (800b670 <ADC_IRQHandler+0x4ec>)
 800b5ee:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
 800b5f2:	f343 030b 	sbfx	r3, r3, #0, #12
 800b5f6:	429a      	cmp	r2, r3
 800b5f8:	d001      	beq.n	800b5fe <ADC_IRQHandler+0x47a>
				NeedInc = 1;
 800b5fa:	2401      	movs	r4, #1
 800b5fc:	e76c      	b.n	800b4d8 <ADC_IRQHandler+0x354>
							Steps[0][ADC_POT_sel_cnt-24].b.WaitVoltageSlider = 0;
 800b5fe:	4b1b      	ldr	r3, [pc, #108]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b600:	781b      	ldrb	r3, [r3, #0]
 800b602:	f1a3 0218 	sub.w	r2, r3, #24
 800b606:	eb01 03c2 	add.w	r3, r1, r2, lsl #3
 800b60a:	685a      	ldr	r2, [r3, #4]
 800b60c:	f36f 324d 	bfc	r2, #13, #1
 800b610:	605a      	str	r2, [r3, #4]
				NeedInc = 1;
 800b612:	2401      	movs	r4, #1
 800b614:	e760      	b.n	800b4d8 <ADC_IRQHandler+0x354>
		if ((ADC_POT_sel_cnt>=16) && (ADC_POT_sel_cnt<=23)) {
 800b616:	4b15      	ldr	r3, [pc, #84]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b618:	781b      	ldrb	r3, [r3, #0]
 800b61a:	b2db      	uxtb	r3, r3
 800b61c:	2b0f      	cmp	r3, #15
 800b61e:	d90d      	bls.n	800b63c <ADC_IRQHandler+0x4b8>
 800b620:	4b12      	ldr	r3, [pc, #72]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b622:	781b      	ldrb	r3, [r3, #0]
 800b624:	b2db      	uxtb	r3, r3
 800b626:	2b17      	cmp	r3, #23
 800b628:	d808      	bhi.n	800b63c <ADC_IRQHandler+0x4b8>
 			AddData[ADC_POT_sel_cnt-16] = (unsigned int)(ADC2->DR);
 800b62a:	4b10      	ldr	r3, [pc, #64]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b62c:	781b      	ldrb	r3, [r3, #0]
 800b62e:	3b10      	subs	r3, #16
 800b630:	4a11      	ldr	r2, [pc, #68]	; (800b678 <ADC_IRQHandler+0x4f4>)
 800b632:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 800b634:	4a11      	ldr	r2, [pc, #68]	; (800b67c <ADC_IRQHandler+0x4f8>)
 800b636:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
			NeedInc = 1;			
 800b63a:	2401      	movs	r4, #1
		ADC_ClearFlag(ADC2, ADC_FLAG_EOC);
 800b63c:	2102      	movs	r1, #2
 800b63e:	480e      	ldr	r0, [pc, #56]	; (800b678 <ADC_IRQHandler+0x4f4>)
 800b640:	f7f4 ffff 	bl	8000642 <ADC_ClearFlag>
 800b644:	e5b9      	b.n	800b1ba <ADC_IRQHandler+0x36>
			if (NeedInc) {
 800b646:	b144      	cbz	r4, 800b65a <ADC_IRQHandler+0x4d6>
		ADC_POT_sel_cnt++;
 800b648:	4a08      	ldr	r2, [pc, #32]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b64a:	7813      	ldrb	r3, [r2, #0]
 800b64c:	3301      	adds	r3, #1
 800b64e:	b2db      	uxtb	r3, r3
 800b650:	7013      	strb	r3, [r2, #0]
		if (ADC_POT_sel_cnt >= 40) {//40
 800b652:	7813      	ldrb	r3, [r2, #0]
 800b654:	b2db      	uxtb	r3, r3
 800b656:	2b27      	cmp	r3, #39	; 0x27
 800b658:	d800      	bhi.n	800b65c <ADC_IRQHandler+0x4d8>
 800b65a:	bd38      	pop	{r3, r4, r5, pc}
			ADC_POT_sel_cnt = 0;
 800b65c:	2200      	movs	r2, #0
 800b65e:	4b03      	ldr	r3, [pc, #12]	; (800b66c <ADC_IRQHandler+0x4e8>)
 800b660:	701a      	strb	r2, [r3, #0]
			delay_us(10);
 800b662:	200a      	movs	r0, #10
 800b664:	f7ff fd74 	bl	800b150 <delay_us>
};
 800b668:	e7f7      	b.n	800b65a <ADC_IRQHandler+0x4d6>
 800b66a:	bf00      	nop
 800b66c:	200006b4 	.word	0x200006b4
 800b670:	20000cb4 	.word	0x20000cb4
 800b674:	40012000 	.word	0x40012000
 800b678:	40012100 	.word	0x40012100
 800b67c:	20000c0c 	.word	0x20000c0c

0800b680 <delay_ns>:

void delay_ns(unsigned int ns)
{
 800b680:	b510      	push	{r4, lr}
 800b682:	b086      	sub	sp, #24
 800b684:	4604      	mov	r4, r0
	volatile uint32_t nCount;
	RCC_ClocksTypeDef RCC_Clocks;
	RCC_GetClocksFreq (&RCC_Clocks);
 800b686:	a801      	add	r0, sp, #4
 800b688:	f7f9 f890 	bl	80047ac <RCC_GetClocksFreq>

	nCount=(RCC_Clocks.HCLK_Frequency/10000000000)*ns;
 800b68c:	a30a      	add	r3, pc, #40	; (adr r3, 800b6b8 <delay_ns+0x38>)
 800b68e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800b692:	9802      	ldr	r0, [sp, #8]
 800b694:	2100      	movs	r1, #0
 800b696:	f000 fe63 	bl	800c360 <__aeabi_ldivmod>
 800b69a:	fb04 f000 	mul.w	r0, r4, r0
 800b69e:	9005      	str	r0, [sp, #20]
	for (; nCount!=0; nCount--);
 800b6a0:	e002      	b.n	800b6a8 <delay_ns+0x28>
 800b6a2:	9b05      	ldr	r3, [sp, #20]
 800b6a4:	3b01      	subs	r3, #1
 800b6a6:	9305      	str	r3, [sp, #20]
 800b6a8:	9b05      	ldr	r3, [sp, #20]
 800b6aa:	2b00      	cmp	r3, #0
 800b6ac:	d1f9      	bne.n	800b6a2 <delay_ns+0x22>
}
 800b6ae:	b006      	add	sp, #24
 800b6b0:	bd10      	pop	{r4, pc}
 800b6b2:	bf00      	nop
 800b6b4:	f3af 8000 	nop.w
 800b6b8:	540be400 	.word	0x540be400
 800b6bc:	00000002 	.word	0x00000002
 800b6c0:	0800c7bc 	.word	0x0800c7bc
 800b6c4:	20000000 	.word	0x20000000
 800b6c8:	20000698 	.word	0x20000698
 800b6cc:	20000698 	.word	0x20000698
 800b6d0:	20000ec8 	.word	0x20000ec8

0800b6d4 <NMI_Handler>:
  * @brief   This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 800b6d4:	4770      	bx	lr

0800b6d6 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 800b6d6:	e7fe      	b.n	800b6d6 <HardFault_Handler>

0800b6d8 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 800b6d8:	e7fe      	b.n	800b6d8 <MemManage_Handler>

0800b6da <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 800b6da:	e7fe      	b.n	800b6da <BusFault_Handler>

0800b6dc <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 800b6dc:	e7fe      	b.n	800b6dc <UsageFault_Handler>

0800b6de <SVC_Handler>:
  * @brief  This function handles SVCall exception.
  * @param  None
  * @retval None
  */
void SVC_Handler(void)
{
 800b6de:	4770      	bx	lr

0800b6e0 <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 800b6e0:	4770      	bx	lr

0800b6e2 <PendSV_Handler>:
  * @brief  This function handles PendSVC exception.
  * @param  None
  * @retval None
  */
void PendSV_Handler(void)
{
 800b6e2:	4770      	bx	lr

0800b6e4 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 800b6e4:	4770      	bx	lr
	...

0800b6e8 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).   
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 800b6e8:	b082      	sub	sp, #8
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 800b6ea:	2300      	movs	r3, #0
 800b6ec:	9301      	str	r3, [sp, #4]
 800b6ee:	9300      	str	r3, [sp, #0]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 800b6f0:	4a2a      	ldr	r2, [pc, #168]	; (800b79c <SetSysClock+0xb4>)
 800b6f2:	6813      	ldr	r3, [r2, #0]
 800b6f4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800b6f8:	6013      	str	r3, [r2, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 800b6fa:	4b28      	ldr	r3, [pc, #160]	; (800b79c <SetSysClock+0xb4>)
 800b6fc:	681b      	ldr	r3, [r3, #0]
 800b6fe:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800b702:	9300      	str	r3, [sp, #0]
    StartUpCounter++;
 800b704:	9b01      	ldr	r3, [sp, #4]
 800b706:	3301      	adds	r3, #1
 800b708:	9301      	str	r3, [sp, #4]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 800b70a:	9b00      	ldr	r3, [sp, #0]
 800b70c:	b91b      	cbnz	r3, 800b716 <SetSysClock+0x2e>
 800b70e:	9b01      	ldr	r3, [sp, #4]
 800b710:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800b714:	d1f1      	bne.n	800b6fa <SetSysClock+0x12>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 800b716:	4b21      	ldr	r3, [pc, #132]	; (800b79c <SetSysClock+0xb4>)
 800b718:	681b      	ldr	r3, [r3, #0]
 800b71a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 800b71e:	d006      	beq.n	800b72e <SetSysClock+0x46>
  {
    HSEStatus = (uint32_t)0x01;
 800b720:	2301      	movs	r3, #1
 800b722:	9300      	str	r3, [sp, #0]
  else
  {
    HSEStatus = (uint32_t)0x00;
  }

  if (HSEStatus == (uint32_t)0x01)
 800b724:	9b00      	ldr	r3, [sp, #0]
 800b726:	2b01      	cmp	r3, #1
 800b728:	d004      	beq.n	800b734 <SetSysClock+0x4c>
  else
  { /* If HSE fails to start-up, the application will have wrong clock
         configuration. User can add here some code to deal with this error */
  }

}
 800b72a:	b002      	add	sp, #8
 800b72c:	4770      	bx	lr
    HSEStatus = (uint32_t)0x00;
 800b72e:	2300      	movs	r3, #0
 800b730:	9300      	str	r3, [sp, #0]
 800b732:	e7f7      	b.n	800b724 <SetSysClock+0x3c>
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 800b734:	4b19      	ldr	r3, [pc, #100]	; (800b79c <SetSysClock+0xb4>)
 800b736:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800b738:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800b73c:	641a      	str	r2, [r3, #64]	; 0x40
    PWR->CR |= PWR_CR_VOS;
 800b73e:	4918      	ldr	r1, [pc, #96]	; (800b7a0 <SetSysClock+0xb8>)
 800b740:	680a      	ldr	r2, [r1, #0]
 800b742:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 800b746:	600a      	str	r2, [r1, #0]
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 800b748:	689a      	ldr	r2, [r3, #8]
 800b74a:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 800b74c:	689a      	ldr	r2, [r3, #8]
 800b74e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800b752:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
 800b754:	689a      	ldr	r2, [r3, #8]
 800b756:	f442 52a0 	orr.w	r2, r2, #5120	; 0x1400
 800b75a:	609a      	str	r2, [r3, #8]
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 800b75c:	4a11      	ldr	r2, [pc, #68]	; (800b7a4 <SetSysClock+0xbc>)
 800b75e:	605a      	str	r2, [r3, #4]
    RCC->CR |= RCC_CR_PLLON;
 800b760:	681a      	ldr	r2, [r3, #0]
 800b762:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800b766:	601a      	str	r2, [r3, #0]
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800b768:	4b0c      	ldr	r3, [pc, #48]	; (800b79c <SetSysClock+0xb4>)
 800b76a:	681b      	ldr	r3, [r3, #0]
 800b76c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 800b770:	d0fa      	beq.n	800b768 <SetSysClock+0x80>
    FLASH->ACR = FLASH_ACR_PRFTEN |FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_5WS;
 800b772:	f240 7205 	movw	r2, #1797	; 0x705
 800b776:	4b0c      	ldr	r3, [pc, #48]	; (800b7a8 <SetSysClock+0xc0>)
 800b778:	601a      	str	r2, [r3, #0]
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 800b77a:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 800b77e:	689a      	ldr	r2, [r3, #8]
 800b780:	f022 0203 	bic.w	r2, r2, #3
 800b784:	609a      	str	r2, [r3, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 800b786:	689a      	ldr	r2, [r3, #8]
 800b788:	f042 0202 	orr.w	r2, r2, #2
 800b78c:	609a      	str	r2, [r3, #8]
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 800b78e:	4b03      	ldr	r3, [pc, #12]	; (800b79c <SetSysClock+0xb4>)
 800b790:	689b      	ldr	r3, [r3, #8]
 800b792:	f003 030c 	and.w	r3, r3, #12
 800b796:	2b08      	cmp	r3, #8
 800b798:	d1f9      	bne.n	800b78e <SetSysClock+0xa6>
 800b79a:	e7c6      	b.n	800b72a <SetSysClock+0x42>
 800b79c:	40023800 	.word	0x40023800
 800b7a0:	40007000 	.word	0x40007000
 800b7a4:	07405419 	.word	0x07405419
 800b7a8:	40023c00 	.word	0x40023c00

0800b7ac <SystemInit>:
{
 800b7ac:	b510      	push	{r4, lr}
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800b7ae:	4c10      	ldr	r4, [pc, #64]	; (800b7f0 <SystemInit+0x44>)
 800b7b0:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 800b7b4:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800b7b8:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  RCC->CR |= (uint32_t)0x00000001;
 800b7bc:	4b0d      	ldr	r3, [pc, #52]	; (800b7f4 <SystemInit+0x48>)
 800b7be:	681a      	ldr	r2, [r3, #0]
 800b7c0:	f042 0201 	orr.w	r2, r2, #1
 800b7c4:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 800b7c6:	2100      	movs	r1, #0
 800b7c8:	6099      	str	r1, [r3, #8]
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800b7ca:	681a      	ldr	r2, [r3, #0]
 800b7cc:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 800b7d0:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800b7d4:	601a      	str	r2, [r3, #0]
  RCC->PLLCFGR = 0x24003010;
 800b7d6:	4a08      	ldr	r2, [pc, #32]	; (800b7f8 <SystemInit+0x4c>)
 800b7d8:	605a      	str	r2, [r3, #4]
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800b7da:	681a      	ldr	r2, [r3, #0]
 800b7dc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800b7e0:	601a      	str	r2, [r3, #0]
  RCC->CIR = 0x00000000;
 800b7e2:	60d9      	str	r1, [r3, #12]
  SetSysClock();
 800b7e4:	f7ff ff80 	bl	800b6e8 <SetSysClock>
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800b7e8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800b7ec:	60a3      	str	r3, [r4, #8]
 800b7ee:	bd10      	pop	{r4, pc}
 800b7f0:	e000ed00 	.word	0xe000ed00
 800b7f4:	40023800 	.word	0x40023800
 800b7f8:	24003010 	.word	0x24003010

0800b7fc <SystemCoreClockUpdate>:
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 800b7fc:	4b22      	ldr	r3, [pc, #136]	; (800b888 <SystemCoreClockUpdate+0x8c>)
 800b7fe:	689b      	ldr	r3, [r3, #8]
 800b800:	f003 030c 	and.w	r3, r3, #12
  switch (tmp)
 800b804:	2b04      	cmp	r3, #4
 800b806:	d015      	beq.n	800b834 <SystemCoreClockUpdate+0x38>
 800b808:	2b08      	cmp	r3, #8
 800b80a:	d017      	beq.n	800b83c <SystemCoreClockUpdate+0x40>
 800b80c:	b11b      	cbz	r3, 800b816 <SystemCoreClockUpdate+0x1a>
      SystemCoreClock = HSI_VALUE;
 800b80e:	4a1f      	ldr	r2, [pc, #124]	; (800b88c <SystemCoreClockUpdate+0x90>)
 800b810:	4b1f      	ldr	r3, [pc, #124]	; (800b890 <SystemCoreClockUpdate+0x94>)
 800b812:	601a      	str	r2, [r3, #0]
      break;
 800b814:	e002      	b.n	800b81c <SystemCoreClockUpdate+0x20>
      SystemCoreClock = HSI_VALUE;
 800b816:	4a1d      	ldr	r2, [pc, #116]	; (800b88c <SystemCoreClockUpdate+0x90>)
 800b818:	4b1d      	ldr	r3, [pc, #116]	; (800b890 <SystemCoreClockUpdate+0x94>)
 800b81a:	601a      	str	r2, [r3, #0]
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 800b81c:	4b1a      	ldr	r3, [pc, #104]	; (800b888 <SystemCoreClockUpdate+0x8c>)
 800b81e:	689b      	ldr	r3, [r3, #8]
 800b820:	f3c3 1303 	ubfx	r3, r3, #4, #4
 800b824:	4a1a      	ldr	r2, [pc, #104]	; (800b890 <SystemCoreClockUpdate+0x94>)
 800b826:	4413      	add	r3, r2
 800b828:	791b      	ldrb	r3, [r3, #4]
 800b82a:	b2d9      	uxtb	r1, r3
  SystemCoreClock >>= tmp;
 800b82c:	6813      	ldr	r3, [r2, #0]
 800b82e:	40cb      	lsrs	r3, r1
 800b830:	6013      	str	r3, [r2, #0]
 800b832:	4770      	bx	lr
      SystemCoreClock = HSE_VALUE;
 800b834:	4a17      	ldr	r2, [pc, #92]	; (800b894 <SystemCoreClockUpdate+0x98>)
 800b836:	4b16      	ldr	r3, [pc, #88]	; (800b890 <SystemCoreClockUpdate+0x94>)
 800b838:	601a      	str	r2, [r3, #0]
      break;
 800b83a:	e7ef      	b.n	800b81c <SystemCoreClockUpdate+0x20>
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 800b83c:	4b12      	ldr	r3, [pc, #72]	; (800b888 <SystemCoreClockUpdate+0x8c>)
 800b83e:	685a      	ldr	r2, [r3, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 800b840:	685b      	ldr	r3, [r3, #4]
 800b842:	f003 033f 	and.w	r3, r3, #63	; 0x3f
      if (pllsource != 0)
 800b846:	f412 0f80 	tst.w	r2, #4194304	; 0x400000
 800b84a:	d013      	beq.n	800b874 <SystemCoreClockUpdate+0x78>
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800b84c:	4a11      	ldr	r2, [pc, #68]	; (800b894 <SystemCoreClockUpdate+0x98>)
 800b84e:	fbb2 f2f3 	udiv	r2, r2, r3
 800b852:	4b0d      	ldr	r3, [pc, #52]	; (800b888 <SystemCoreClockUpdate+0x8c>)
 800b854:	685b      	ldr	r3, [r3, #4]
 800b856:	f3c3 1388 	ubfx	r3, r3, #6, #9
 800b85a:	fb03 f302 	mul.w	r3, r3, r2
      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 800b85e:	4a0a      	ldr	r2, [pc, #40]	; (800b888 <SystemCoreClockUpdate+0x8c>)
 800b860:	6852      	ldr	r2, [r2, #4]
 800b862:	f3c2 4201 	ubfx	r2, r2, #16, #2
 800b866:	3201      	adds	r2, #1
 800b868:	0052      	lsls	r2, r2, #1
      SystemCoreClock = pllvco/pllp;
 800b86a:	fbb3 f3f2 	udiv	r3, r3, r2
 800b86e:	4a08      	ldr	r2, [pc, #32]	; (800b890 <SystemCoreClockUpdate+0x94>)
 800b870:	6013      	str	r3, [r2, #0]
      break;
 800b872:	e7d3      	b.n	800b81c <SystemCoreClockUpdate+0x20>
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 800b874:	4a05      	ldr	r2, [pc, #20]	; (800b88c <SystemCoreClockUpdate+0x90>)
 800b876:	fbb2 f2f3 	udiv	r2, r2, r3
 800b87a:	4b03      	ldr	r3, [pc, #12]	; (800b888 <SystemCoreClockUpdate+0x8c>)
 800b87c:	685b      	ldr	r3, [r3, #4]
 800b87e:	f3c3 1388 	ubfx	r3, r3, #6, #9
 800b882:	fb03 f302 	mul.w	r3, r3, r2
 800b886:	e7ea      	b.n	800b85e <SystemCoreClockUpdate+0x62>
 800b888:	40023800 	.word	0x40023800
 800b88c:	00f42400 	.word	0x00f42400
 800b890:	20000684 	.word	0x20000684
 800b894:	017d7840 	.word	0x017d7840

0800b898 <ts_itoa>:
**  Abstract: Convert integer to ascii
**  Returns:  void
**---------------------------------------------------------------------------
*/
void ts_itoa(char **buf, unsigned int d, int base)
{
 800b898:	b470      	push	{r4, r5, r6}
	int div = 1;
 800b89a:	2301      	movs	r3, #1
	while (d/div >= base)
 800b89c:	e001      	b.n	800b8a2 <ts_itoa+0xa>
		div *= base;
 800b89e:	fb02 f303 	mul.w	r3, r2, r3
	while (d/div >= base)
 800b8a2:	fbb1 f4f3 	udiv	r4, r1, r3
 800b8a6:	4294      	cmp	r4, r2
 800b8a8:	d2f9      	bcs.n	800b89e <ts_itoa+0x6>
 800b8aa:	e004      	b.n	800b8b6 <ts_itoa+0x1e>
		d = d%div;
		div /= base;
		if (num > 9)
			*((*buf)++) = (num-10) + 'A';
		else
			*((*buf)++) = num + '0';
 800b8ac:	6805      	ldr	r5, [r0, #0]
 800b8ae:	1c6e      	adds	r6, r5, #1
 800b8b0:	6006      	str	r6, [r0, #0]
 800b8b2:	3430      	adds	r4, #48	; 0x30
 800b8b4:	702c      	strb	r4, [r5, #0]
	while (div != 0)
 800b8b6:	b16b      	cbz	r3, 800b8d4 <ts_itoa+0x3c>
		int num = d/div;
 800b8b8:	fbb1 f4f3 	udiv	r4, r1, r3
		d = d%div;
 800b8bc:	fb03 1114 	mls	r1, r3, r4, r1
		div /= base;
 800b8c0:	fb93 f3f2 	sdiv	r3, r3, r2
		if (num > 9)
 800b8c4:	2c09      	cmp	r4, #9
 800b8c6:	ddf1      	ble.n	800b8ac <ts_itoa+0x14>
			*((*buf)++) = (num-10) + 'A';
 800b8c8:	6805      	ldr	r5, [r0, #0]
 800b8ca:	1c6e      	adds	r6, r5, #1
 800b8cc:	6006      	str	r6, [r0, #0]
 800b8ce:	3437      	adds	r4, #55	; 0x37
 800b8d0:	702c      	strb	r4, [r5, #0]
 800b8d2:	e7f0      	b.n	800b8b6 <ts_itoa+0x1e>
	}
}
 800b8d4:	bc70      	pop	{r4, r5, r6}
 800b8d6:	4770      	bx	lr

0800b8d8 <ts_formatstring>:
**  Abstract: Writes arguments va to buffer buf according to format fmt
**  Returns:  Length of string
**---------------------------------------------------------------------------
*/
int ts_formatstring(char *buf, const char *fmt, va_list va)
{
 800b8d8:	b530      	push	{r4, r5, lr}
 800b8da:	b083      	sub	sp, #12
 800b8dc:	9001      	str	r0, [sp, #4]
 800b8de:	460c      	mov	r4, r1
 800b8e0:	9200      	str	r2, [sp, #0]
	char *start_buf = buf;
 800b8e2:	4605      	mov	r5, r0
	while(*fmt)
 800b8e4:	e03e      	b.n	800b964 <ts_formatstring+0x8c>
	{
		/* Character needs formating? */
		if (*fmt == '%')
		{
			switch (*(++fmt))
 800b8e6:	7863      	ldrb	r3, [r4, #1]
 800b8e8:	2b64      	cmp	r3, #100	; 0x64
 800b8ea:	d01c      	beq.n	800b926 <ts_formatstring+0x4e>
 800b8ec:	d90d      	bls.n	800b90a <ts_formatstring+0x32>
 800b8ee:	2b73      	cmp	r3, #115	; 0x73
 800b8f0:	d04a      	beq.n	800b988 <ts_formatstring+0xb0>
 800b8f2:	d916      	bls.n	800b922 <ts_formatstring+0x4a>
 800b8f4:	2b75      	cmp	r3, #117	; 0x75
 800b8f6:	d121      	bne.n	800b93c <ts_formatstring+0x64>
						*buf++ = *arg++;
					}
				}
				break;
			  case 'u':
					ts_itoa(&buf, va_arg(va, unsigned int), 10);
 800b8f8:	9b00      	ldr	r3, [sp, #0]
 800b8fa:	1d1a      	adds	r2, r3, #4
 800b8fc:	9200      	str	r2, [sp, #0]
 800b8fe:	220a      	movs	r2, #10
 800b900:	6819      	ldr	r1, [r3, #0]
 800b902:	a801      	add	r0, sp, #4
 800b904:	f7ff ffc8 	bl	800b898 <ts_itoa>
				break;
 800b908:	e02b      	b.n	800b962 <ts_formatstring+0x8a>
			switch (*(++fmt))
 800b90a:	2b58      	cmp	r3, #88	; 0x58
 800b90c:	d018      	beq.n	800b940 <ts_formatstring+0x68>
 800b90e:	2b63      	cmp	r3, #99	; 0x63
 800b910:	d01f      	beq.n	800b952 <ts_formatstring+0x7a>
 800b912:	2b25      	cmp	r3, #37	; 0x25
 800b914:	d125      	bne.n	800b962 <ts_formatstring+0x8a>
			  case 'x':
			  case 'X':
					ts_itoa(&buf, va_arg(va, int), 16);
				break;
			  case '%':
				  *buf++ = '%';
 800b916:	9b01      	ldr	r3, [sp, #4]
 800b918:	1c5a      	adds	r2, r3, #1
 800b91a:	9201      	str	r2, [sp, #4]
 800b91c:	2225      	movs	r2, #37	; 0x25
 800b91e:	701a      	strb	r2, [r3, #0]
				  break;
 800b920:	e01f      	b.n	800b962 <ts_formatstring+0x8a>
			switch (*(++fmt))
 800b922:	2b69      	cmp	r3, #105	; 0x69
 800b924:	d11d      	bne.n	800b962 <ts_formatstring+0x8a>
					signed int val = va_arg(va, signed int);
 800b926:	9b00      	ldr	r3, [sp, #0]
 800b928:	1d1a      	adds	r2, r3, #4
 800b92a:	9200      	str	r2, [sp, #0]
 800b92c:	6819      	ldr	r1, [r3, #0]
					if (val < 0)
 800b92e:	2900      	cmp	r1, #0
 800b930:	db23      	blt.n	800b97a <ts_formatstring+0xa2>
					ts_itoa(&buf, val, 10);
 800b932:	220a      	movs	r2, #10
 800b934:	a801      	add	r0, sp, #4
 800b936:	f7ff ffaf 	bl	800b898 <ts_itoa>
				break;
 800b93a:	e012      	b.n	800b962 <ts_formatstring+0x8a>
			switch (*(++fmt))
 800b93c:	2b78      	cmp	r3, #120	; 0x78
 800b93e:	d110      	bne.n	800b962 <ts_formatstring+0x8a>
					ts_itoa(&buf, va_arg(va, int), 16);
 800b940:	9b00      	ldr	r3, [sp, #0]
 800b942:	1d1a      	adds	r2, r3, #4
 800b944:	9200      	str	r2, [sp, #0]
 800b946:	2210      	movs	r2, #16
 800b948:	6819      	ldr	r1, [r3, #0]
 800b94a:	a801      	add	r0, sp, #4
 800b94c:	f7ff ffa4 	bl	800b898 <ts_itoa>
				break;
 800b950:	e007      	b.n	800b962 <ts_formatstring+0x8a>
				*buf++ = va_arg(va, int);
 800b952:	9b01      	ldr	r3, [sp, #4]
 800b954:	1c5a      	adds	r2, r3, #1
 800b956:	9201      	str	r2, [sp, #4]
 800b958:	9a00      	ldr	r2, [sp, #0]
 800b95a:	1d11      	adds	r1, r2, #4
 800b95c:	9100      	str	r1, [sp, #0]
 800b95e:	6812      	ldr	r2, [r2, #0]
 800b960:	701a      	strb	r2, [r3, #0]
			}
			fmt++;
 800b962:	3402      	adds	r4, #2
	while(*fmt)
 800b964:	7823      	ldrb	r3, [r4, #0]
 800b966:	b1f3      	cbz	r3, 800b9a6 <ts_formatstring+0xce>
		if (*fmt == '%')
 800b968:	2b25      	cmp	r3, #37	; 0x25
 800b96a:	d0bc      	beq.n	800b8e6 <ts_formatstring+0xe>
		}
		/* Else just copy */
		else
		{
			*buf++ = *fmt++;
 800b96c:	9b01      	ldr	r3, [sp, #4]
 800b96e:	1c5a      	adds	r2, r3, #1
 800b970:	9201      	str	r2, [sp, #4]
 800b972:	7822      	ldrb	r2, [r4, #0]
 800b974:	701a      	strb	r2, [r3, #0]
 800b976:	3401      	adds	r4, #1
 800b978:	e7f4      	b.n	800b964 <ts_formatstring+0x8c>
						val *= -1;
 800b97a:	4249      	negs	r1, r1
						*buf++ = '-';
 800b97c:	9b01      	ldr	r3, [sp, #4]
 800b97e:	1c5a      	adds	r2, r3, #1
 800b980:	9201      	str	r2, [sp, #4]
 800b982:	222d      	movs	r2, #45	; 0x2d
 800b984:	701a      	strb	r2, [r3, #0]
 800b986:	e7d4      	b.n	800b932 <ts_formatstring+0x5a>
					char * arg = va_arg(va, char *);
 800b988:	9b00      	ldr	r3, [sp, #0]
 800b98a:	1d1a      	adds	r2, r3, #4
 800b98c:	9200      	str	r2, [sp, #0]
 800b98e:	681b      	ldr	r3, [r3, #0]
					while (*arg)
 800b990:	e005      	b.n	800b99e <ts_formatstring+0xc6>
						*buf++ = *arg++;
 800b992:	9a01      	ldr	r2, [sp, #4]
 800b994:	1c51      	adds	r1, r2, #1
 800b996:	9101      	str	r1, [sp, #4]
 800b998:	7819      	ldrb	r1, [r3, #0]
 800b99a:	7011      	strb	r1, [r2, #0]
 800b99c:	3301      	adds	r3, #1
					while (*arg)
 800b99e:	781a      	ldrb	r2, [r3, #0]
 800b9a0:	2a00      	cmp	r2, #0
 800b9a2:	d1f6      	bne.n	800b992 <ts_formatstring+0xba>
 800b9a4:	e7dd      	b.n	800b962 <ts_formatstring+0x8a>
		}
	}
	*buf = 0;
 800b9a6:	2200      	movs	r2, #0
 800b9a8:	9b01      	ldr	r3, [sp, #4]
 800b9aa:	701a      	strb	r2, [r3, #0]

	return (int)(buf - start_buf);
}
 800b9ac:	9801      	ldr	r0, [sp, #4]
 800b9ae:	1b40      	subs	r0, r0, r5
 800b9b0:	b003      	add	sp, #12
 800b9b2:	bd30      	pop	{r4, r5, pc}

0800b9b4 <ts_formatlength>:
**            format string and va_list va
**  Returns:  Maximum length
**---------------------------------------------------------------------------
*/
int ts_formatlength(const char *fmt, va_list va)
{
 800b9b4:	b082      	sub	sp, #8
 800b9b6:	4603      	mov	r3, r0
 800b9b8:	9101      	str	r1, [sp, #4]
	int length = 0;
 800b9ba:	2000      	movs	r0, #0
	while (*fmt)
 800b9bc:	e01d      	b.n	800b9fa <ts_formatlength+0x46>
	{
		if (*fmt == '%')
		{
			++fmt;
 800b9be:	1c59      	adds	r1, r3, #1
			switch (*fmt)
 800b9c0:	785b      	ldrb	r3, [r3, #1]
 800b9c2:	3b58      	subs	r3, #88	; 0x58
 800b9c4:	2b20      	cmp	r3, #32
 800b9c6:	d837      	bhi.n	800ba38 <ts_formatlength+0x84>
 800b9c8:	e8df f003 	tbb	[pc, r3]
 800b9cc:	36363630 	.word	0x36363630
 800b9d0:	36363636 	.word	0x36363636
 800b9d4:	11363636 	.word	0x11363636
 800b9d8:	3636361d 	.word	0x3636361d
 800b9dc:	36361d36 	.word	0x36361d36
 800b9e0:	36363636 	.word	0x36363636
 800b9e4:	23363636 	.word	0x23363636
 800b9e8:	36361d36 	.word	0x36361d36
 800b9ec:	30          	.byte	0x30
 800b9ed:	00          	.byte	0x00
			{
			  case 'c':
		  		  va_arg(va, int);
 800b9ee:	9b01      	ldr	r3, [sp, #4]
 800b9f0:	3304      	adds	r3, #4
 800b9f2:	9301      	str	r3, [sp, #4]
				  ++length;
 800b9f4:	3001      	adds	r0, #1
			++fmt;
 800b9f6:	460b      	mov	r3, r1
		}
		else
		{
			++length;
		}
		++fmt;
 800b9f8:	3301      	adds	r3, #1
	while (*fmt)
 800b9fa:	781a      	ldrb	r2, [r3, #0]
 800b9fc:	b1fa      	cbz	r2, 800ba3e <ts_formatlength+0x8a>
		if (*fmt == '%')
 800b9fe:	2a25      	cmp	r2, #37	; 0x25
 800ba00:	d0dd      	beq.n	800b9be <ts_formatlength+0xa>
			++length;
 800ba02:	3001      	adds	r0, #1
 800ba04:	e7f8      	b.n	800b9f8 <ts_formatlength+0x44>
				  length += 11;
 800ba06:	300b      	adds	r0, #11
				  va_arg(va, int);
 800ba08:	9b01      	ldr	r3, [sp, #4]
 800ba0a:	3304      	adds	r3, #4
 800ba0c:	9301      	str	r3, [sp, #4]
			++fmt;
 800ba0e:	460b      	mov	r3, r1
 800ba10:	e7f2      	b.n	800b9f8 <ts_formatlength+0x44>
			  		  char * str = va_arg(va, char *);
 800ba12:	9b01      	ldr	r3, [sp, #4]
 800ba14:	1d1a      	adds	r2, r3, #4
 800ba16:	9201      	str	r2, [sp, #4]
 800ba18:	681b      	ldr	r3, [r3, #0]
			  		  while (*str++)
 800ba1a:	e001      	b.n	800ba20 <ts_formatlength+0x6c>
			  			  ++length;
 800ba1c:	3001      	adds	r0, #1
			  		  while (*str++)
 800ba1e:	4613      	mov	r3, r2
 800ba20:	1c5a      	adds	r2, r3, #1
 800ba22:	781b      	ldrb	r3, [r3, #0]
 800ba24:	2b00      	cmp	r3, #0
 800ba26:	d1f9      	bne.n	800ba1c <ts_formatlength+0x68>
			++fmt;
 800ba28:	460b      	mov	r3, r1
 800ba2a:	e7e5      	b.n	800b9f8 <ts_formatlength+0x44>
				  length += 8;
 800ba2c:	3008      	adds	r0, #8
				  va_arg(va, unsigned int);
 800ba2e:	9b01      	ldr	r3, [sp, #4]
 800ba30:	3304      	adds	r3, #4
 800ba32:	9301      	str	r3, [sp, #4]
			++fmt;
 800ba34:	460b      	mov	r3, r1
 800ba36:	e7df      	b.n	800b9f8 <ts_formatlength+0x44>
				  ++length;
 800ba38:	3001      	adds	r0, #1
			++fmt;
 800ba3a:	460b      	mov	r3, r1
				  break;
 800ba3c:	e7dc      	b.n	800b9f8 <ts_formatlength+0x44>
	}
	return length;
}
 800ba3e:	b002      	add	sp, #8
 800ba40:	4770      	bx	lr

0800ba42 <siprintf>:
**            given character string according to the format parameter.
**  Returns:  Number of bytes written
**===========================================================================
*/
int siprintf(char *buf, const char *fmt, ...)
{
 800ba42:	b40e      	push	{r1, r2, r3}
 800ba44:	b500      	push	{lr}
 800ba46:	b082      	sub	sp, #8
 800ba48:	aa03      	add	r2, sp, #12
 800ba4a:	f852 1b04 	ldr.w	r1, [r2], #4
	int length;
	va_list va;
	va_start(va, fmt);
 800ba4e:	9201      	str	r2, [sp, #4]
	length = ts_formatstring(buf, fmt, va);
 800ba50:	f7ff ff42 	bl	800b8d8 <ts_formatstring>
	va_end(va);
	return length;
}
 800ba54:	b002      	add	sp, #8
 800ba56:	f85d eb04 	ldr.w	lr, [sp], #4
 800ba5a:	b003      	add	sp, #12
 800ba5c:	4770      	bx	lr

0800ba5e <fiprintf>:
**            given file stream according to the format parameter.
**  Returns:  Number of bytes written
**===========================================================================
*/
int fiprintf(FILE * stream, const char *fmt, ...)
{
 800ba5e:	b40e      	push	{r1, r2, r3}
 800ba60:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ba62:	b082      	sub	sp, #8
 800ba64:	af00      	add	r7, sp, #0
 800ba66:	4606      	mov	r6, r0
 800ba68:	f107 041c 	add.w	r4, r7, #28
 800ba6c:	f854 5b04 	ldr.w	r5, [r4], #4
	int length = 0;
	va_list va;
	va_start(va, fmt);
 800ba70:	607c      	str	r4, [r7, #4]
	length = ts_formatlength(fmt, va);
 800ba72:	4621      	mov	r1, r4
 800ba74:	4628      	mov	r0, r5
 800ba76:	f7ff ff9d 	bl	800b9b4 <ts_formatlength>
	va_end(va);
	{
		char buf[length];
 800ba7a:	3007      	adds	r0, #7
 800ba7c:	f020 0007 	bic.w	r0, r0, #7
 800ba80:	ebad 0d00 	sub.w	sp, sp, r0
		va_start(va, fmt);
 800ba84:	607c      	str	r4, [r7, #4]
		length = ts_formatstring(buf, fmt, va);
 800ba86:	4622      	mov	r2, r4
 800ba88:	4629      	mov	r1, r5
 800ba8a:	4668      	mov	r0, sp
 800ba8c:	f7ff ff24 	bl	800b8d8 <ts_formatstring>
		length = _write(stream->_file, buf, length);
 800ba90:	4602      	mov	r2, r0
 800ba92:	4669      	mov	r1, sp
 800ba94:	f9b6 000e 	ldrsh.w	r0, [r6, #14]
 800ba98:	f000 fe70 	bl	800c77c <_write>
		va_end(va);
	}
	return length;
}
 800ba9c:	3708      	adds	r7, #8
 800ba9e:	46bd      	mov	sp, r7
 800baa0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 800baa4:	b003      	add	sp, #12
 800baa6:	4770      	bx	lr

0800baa8 <iprintf>:
**  Returns:  Number of bytes written
**
**===========================================================================
*/
int iprintf(const char *fmt, ...)
{
 800baa8:	b40f      	push	{r0, r1, r2, r3}
 800baaa:	b5b0      	push	{r4, r5, r7, lr}
 800baac:	b082      	sub	sp, #8
 800baae:	af00      	add	r7, sp, #0
 800bab0:	f107 0418 	add.w	r4, r7, #24
 800bab4:	f854 5b04 	ldr.w	r5, [r4], #4
	int length = 0;
	va_list va;
	va_start(va, fmt);
 800bab8:	607c      	str	r4, [r7, #4]
	length = ts_formatlength(fmt, va);
 800baba:	4621      	mov	r1, r4
 800babc:	4628      	mov	r0, r5
 800babe:	f7ff ff79 	bl	800b9b4 <ts_formatlength>
	va_end(va);
	{
		char buf[length];
 800bac2:	3007      	adds	r0, #7
 800bac4:	f020 0007 	bic.w	r0, r0, #7
 800bac8:	ebad 0d00 	sub.w	sp, sp, r0
		va_start(va, fmt);
 800bacc:	607c      	str	r4, [r7, #4]
		length = ts_formatstring(buf, fmt, va);
 800bace:	4622      	mov	r2, r4
 800bad0:	4629      	mov	r1, r5
 800bad2:	4668      	mov	r0, sp
 800bad4:	f7ff ff00 	bl	800b8d8 <ts_formatstring>
		length = _write(1, buf, length);
 800bad8:	4602      	mov	r2, r0
 800bada:	4669      	mov	r1, sp
 800badc:	2001      	movs	r0, #1
 800bade:	f000 fe4d 	bl	800c77c <_write>
		va_end(va);
	}
	return length;
}
 800bae2:	3708      	adds	r7, #8
 800bae4:	46bd      	mov	sp, r7
 800bae6:	e8bd 40b0 	ldmia.w	sp!, {r4, r5, r7, lr}
 800baea:	b004      	add	sp, #16
 800baec:	4770      	bx	lr

0800baee <fputs>:
**  Returns:  If successful, the result is 0; otherwise, the result is EOF.
**
**===========================================================================
*/
int fputs(const char *s, FILE *fp)
{
 800baee:	b570      	push	{r4, r5, r6, lr}
 800baf0:	4605      	mov	r5, r0
 800baf2:	460e      	mov	r6, r1
	int length = strlen(s);
 800baf4:	f000 f842 	bl	800bb7c <strlen>
 800baf8:	4604      	mov	r4, r0
	int wlen = 0;
	int res;

	wlen = _write((fp->_file), (char*)s, length);
 800bafa:	4602      	mov	r2, r0
 800bafc:	4629      	mov	r1, r5
 800bafe:	f9b6 000e 	ldrsh.w	r0, [r6, #14]
 800bb02:	f000 fe3b 	bl	800c77c <_write>
 800bb06:	4605      	mov	r5, r0
	wlen += _write((fp->_file), "\n", 1);
 800bb08:	2201      	movs	r2, #1
 800bb0a:	4907      	ldr	r1, [pc, #28]	; (800bb28 <fputs+0x3a>)
 800bb0c:	f9b6 000e 	ldrsh.w	r0, [r6, #14]
 800bb10:	f000 fe34 	bl	800c77c <_write>
 800bb14:	4428      	add	r0, r5

	if (wlen == (length+1))
 800bb16:	3401      	adds	r4, #1
 800bb18:	42a0      	cmp	r0, r4
 800bb1a:	d101      	bne.n	800bb20 <fputs+0x32>
	{
		res = 0;
 800bb1c:	2000      	movs	r0, #0
 800bb1e:	bd70      	pop	{r4, r5, r6, pc}
	}
	else
	{
		res = EOF;
 800bb20:	f04f 30ff 	mov.w	r0, #4294967295
	}

	return res;
}
 800bb24:	bd70      	pop	{r4, r5, r6, pc}
 800bb26:	bf00      	nop
 800bb28:	0800c7a8 	.word	0x0800c7a8

0800bb2c <puts>:
**  the result is EOF.
**
**===========================================================================
*/
int puts(const char *s)
{
 800bb2c:	b538      	push	{r3, r4, r5, lr}
 800bb2e:	4605      	mov	r5, r0
	int length = strlen(s);
 800bb30:	f000 f824 	bl	800bb7c <strlen>
 800bb34:	4604      	mov	r4, r0
	int numbytes = 0;
	int res;

	numbytes = _write(1, (char*)s, length);
 800bb36:	4602      	mov	r2, r0
 800bb38:	4629      	mov	r1, r5
 800bb3a:	2001      	movs	r0, #1
 800bb3c:	f000 fe1e 	bl	800c77c <_write>
 800bb40:	4605      	mov	r5, r0
	numbytes += _write(1, "\n", 1);
 800bb42:	2201      	movs	r2, #1
 800bb44:	4906      	ldr	r1, [pc, #24]	; (800bb60 <puts+0x34>)
 800bb46:	4610      	mov	r0, r2
 800bb48:	f000 fe18 	bl	800c77c <_write>
 800bb4c:	4428      	add	r0, r5

	if (numbytes == (length+1))
 800bb4e:	3401      	adds	r4, #1
 800bb50:	42a0      	cmp	r0, r4
 800bb52:	d101      	bne.n	800bb58 <puts+0x2c>
	{
		res = 0;
 800bb54:	2000      	movs	r0, #0
 800bb56:	bd38      	pop	{r3, r4, r5, pc}
	}
	else
	{
		res = EOF;
 800bb58:	f04f 30ff 	mov.w	r0, #4294967295
	}

	return res;
}
 800bb5c:	bd38      	pop	{r3, r4, r5, pc}
 800bb5e:	bf00      	nop
 800bb60:	0800c7a8 	.word	0x0800c7a8

0800bb64 <fwrite>:
**  Returns:  Number of elements written
**
**===========================================================================
*/
size_t fwrite(const void * buf, size_t size, size_t count, FILE * fp)
{
 800bb64:	b510      	push	{r4, lr}
 800bb66:	460c      	mov	r4, r1
	return (_write((fp->_file), (char*)buf, size * count) / size);
 800bb68:	fb02 f201 	mul.w	r2, r2, r1
 800bb6c:	4601      	mov	r1, r0
 800bb6e:	f9b3 000e 	ldrsh.w	r0, [r3, #14]
 800bb72:	f000 fe03 	bl	800c77c <_write>
}
 800bb76:	fbb0 f0f4 	udiv	r0, r0, r4
 800bb7a:	bd10      	pop	{r4, pc}

0800bb7c <strlen>:
 800bb7c:	4603      	mov	r3, r0
 800bb7e:	f813 2b01 	ldrb.w	r2, [r3], #1
 800bb82:	2a00      	cmp	r2, #0
 800bb84:	d1fb      	bne.n	800bb7e <strlen+0x2>
 800bb86:	1a18      	subs	r0, r3, r0
 800bb88:	3801      	subs	r0, #1
 800bb8a:	4770      	bx	lr

0800bb8c <__aeabi_drsub>:
 800bb8c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 800bb90:	e002      	b.n	800bb98 <__adddf3>
 800bb92:	bf00      	nop

0800bb94 <__aeabi_dsub>:
 800bb94:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800bb98 <__adddf3>:
 800bb98:	b530      	push	{r4, r5, lr}
 800bb9a:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800bb9e:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800bba2:	ea94 0f05 	teq	r4, r5
 800bba6:	bf08      	it	eq
 800bba8:	ea90 0f02 	teqeq	r0, r2
 800bbac:	bf1f      	itttt	ne
 800bbae:	ea54 0c00 	orrsne.w	ip, r4, r0
 800bbb2:	ea55 0c02 	orrsne.w	ip, r5, r2
 800bbb6:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800bbba:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800bbbe:	f000 80e2 	beq.w	800bd86 <__adddf3+0x1ee>
 800bbc2:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800bbc6:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800bbca:	bfb8      	it	lt
 800bbcc:	426d      	neglt	r5, r5
 800bbce:	dd0c      	ble.n	800bbea <__adddf3+0x52>
 800bbd0:	442c      	add	r4, r5
 800bbd2:	ea80 0202 	eor.w	r2, r0, r2
 800bbd6:	ea81 0303 	eor.w	r3, r1, r3
 800bbda:	ea82 0000 	eor.w	r0, r2, r0
 800bbde:	ea83 0101 	eor.w	r1, r3, r1
 800bbe2:	ea80 0202 	eor.w	r2, r0, r2
 800bbe6:	ea81 0303 	eor.w	r3, r1, r3
 800bbea:	2d36      	cmp	r5, #54	; 0x36
 800bbec:	bf88      	it	hi
 800bbee:	bd30      	pophi	{r4, r5, pc}
 800bbf0:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800bbf4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800bbf8:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 800bbfc:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800bc00:	d002      	beq.n	800bc08 <__adddf3+0x70>
 800bc02:	4240      	negs	r0, r0
 800bc04:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800bc08:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 800bc0c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800bc10:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 800bc14:	d002      	beq.n	800bc1c <__adddf3+0x84>
 800bc16:	4252      	negs	r2, r2
 800bc18:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800bc1c:	ea94 0f05 	teq	r4, r5
 800bc20:	f000 80a7 	beq.w	800bd72 <__adddf3+0x1da>
 800bc24:	f1a4 0401 	sub.w	r4, r4, #1
 800bc28:	f1d5 0e20 	rsbs	lr, r5, #32
 800bc2c:	db0d      	blt.n	800bc4a <__adddf3+0xb2>
 800bc2e:	fa02 fc0e 	lsl.w	ip, r2, lr
 800bc32:	fa22 f205 	lsr.w	r2, r2, r5
 800bc36:	1880      	adds	r0, r0, r2
 800bc38:	f141 0100 	adc.w	r1, r1, #0
 800bc3c:	fa03 f20e 	lsl.w	r2, r3, lr
 800bc40:	1880      	adds	r0, r0, r2
 800bc42:	fa43 f305 	asr.w	r3, r3, r5
 800bc46:	4159      	adcs	r1, r3
 800bc48:	e00e      	b.n	800bc68 <__adddf3+0xd0>
 800bc4a:	f1a5 0520 	sub.w	r5, r5, #32
 800bc4e:	f10e 0e20 	add.w	lr, lr, #32
 800bc52:	2a01      	cmp	r2, #1
 800bc54:	fa03 fc0e 	lsl.w	ip, r3, lr
 800bc58:	bf28      	it	cs
 800bc5a:	f04c 0c02 	orrcs.w	ip, ip, #2
 800bc5e:	fa43 f305 	asr.w	r3, r3, r5
 800bc62:	18c0      	adds	r0, r0, r3
 800bc64:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800bc68:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800bc6c:	d507      	bpl.n	800bc7e <__adddf3+0xe6>
 800bc6e:	f04f 0e00 	mov.w	lr, #0
 800bc72:	f1dc 0c00 	rsbs	ip, ip, #0
 800bc76:	eb7e 0000 	sbcs.w	r0, lr, r0
 800bc7a:	eb6e 0101 	sbc.w	r1, lr, r1
 800bc7e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800bc82:	d31b      	bcc.n	800bcbc <__adddf3+0x124>
 800bc84:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800bc88:	d30c      	bcc.n	800bca4 <__adddf3+0x10c>
 800bc8a:	0849      	lsrs	r1, r1, #1
 800bc8c:	ea5f 0030 	movs.w	r0, r0, rrx
 800bc90:	ea4f 0c3c 	mov.w	ip, ip, rrx
 800bc94:	f104 0401 	add.w	r4, r4, #1
 800bc98:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800bc9c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 800bca0:	f080 809a 	bcs.w	800bdd8 <__adddf3+0x240>
 800bca4:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800bca8:	bf08      	it	eq
 800bcaa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800bcae:	f150 0000 	adcs.w	r0, r0, #0
 800bcb2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800bcb6:	ea41 0105 	orr.w	r1, r1, r5
 800bcba:	bd30      	pop	{r4, r5, pc}
 800bcbc:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800bcc0:	4140      	adcs	r0, r0
 800bcc2:	eb41 0101 	adc.w	r1, r1, r1
 800bcc6:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800bcca:	f1a4 0401 	sub.w	r4, r4, #1
 800bcce:	d1e9      	bne.n	800bca4 <__adddf3+0x10c>
 800bcd0:	f091 0f00 	teq	r1, #0
 800bcd4:	bf04      	itt	eq
 800bcd6:	4601      	moveq	r1, r0
 800bcd8:	2000      	moveq	r0, #0
 800bcda:	fab1 f381 	clz	r3, r1
 800bcde:	bf08      	it	eq
 800bce0:	3320      	addeq	r3, #32
 800bce2:	f1a3 030b 	sub.w	r3, r3, #11
 800bce6:	f1b3 0220 	subs.w	r2, r3, #32
 800bcea:	da0c      	bge.n	800bd06 <__adddf3+0x16e>
 800bcec:	320c      	adds	r2, #12
 800bcee:	dd08      	ble.n	800bd02 <__adddf3+0x16a>
 800bcf0:	f102 0c14 	add.w	ip, r2, #20
 800bcf4:	f1c2 020c 	rsb	r2, r2, #12
 800bcf8:	fa01 f00c 	lsl.w	r0, r1, ip
 800bcfc:	fa21 f102 	lsr.w	r1, r1, r2
 800bd00:	e00c      	b.n	800bd1c <__adddf3+0x184>
 800bd02:	f102 0214 	add.w	r2, r2, #20
 800bd06:	bfd8      	it	le
 800bd08:	f1c2 0c20 	rsble	ip, r2, #32
 800bd0c:	fa01 f102 	lsl.w	r1, r1, r2
 800bd10:	fa20 fc0c 	lsr.w	ip, r0, ip
 800bd14:	bfdc      	itt	le
 800bd16:	ea41 010c 	orrle.w	r1, r1, ip
 800bd1a:	4090      	lslle	r0, r2
 800bd1c:	1ae4      	subs	r4, r4, r3
 800bd1e:	bfa2      	ittt	ge
 800bd20:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 800bd24:	4329      	orrge	r1, r5
 800bd26:	bd30      	popge	{r4, r5, pc}
 800bd28:	ea6f 0404 	mvn.w	r4, r4
 800bd2c:	3c1f      	subs	r4, #31
 800bd2e:	da1c      	bge.n	800bd6a <__adddf3+0x1d2>
 800bd30:	340c      	adds	r4, #12
 800bd32:	dc0e      	bgt.n	800bd52 <__adddf3+0x1ba>
 800bd34:	f104 0414 	add.w	r4, r4, #20
 800bd38:	f1c4 0220 	rsb	r2, r4, #32
 800bd3c:	fa20 f004 	lsr.w	r0, r0, r4
 800bd40:	fa01 f302 	lsl.w	r3, r1, r2
 800bd44:	ea40 0003 	orr.w	r0, r0, r3
 800bd48:	fa21 f304 	lsr.w	r3, r1, r4
 800bd4c:	ea45 0103 	orr.w	r1, r5, r3
 800bd50:	bd30      	pop	{r4, r5, pc}
 800bd52:	f1c4 040c 	rsb	r4, r4, #12
 800bd56:	f1c4 0220 	rsb	r2, r4, #32
 800bd5a:	fa20 f002 	lsr.w	r0, r0, r2
 800bd5e:	fa01 f304 	lsl.w	r3, r1, r4
 800bd62:	ea40 0003 	orr.w	r0, r0, r3
 800bd66:	4629      	mov	r1, r5
 800bd68:	bd30      	pop	{r4, r5, pc}
 800bd6a:	fa21 f004 	lsr.w	r0, r1, r4
 800bd6e:	4629      	mov	r1, r5
 800bd70:	bd30      	pop	{r4, r5, pc}
 800bd72:	f094 0f00 	teq	r4, #0
 800bd76:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800bd7a:	bf06      	itte	eq
 800bd7c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 800bd80:	3401      	addeq	r4, #1
 800bd82:	3d01      	subne	r5, #1
 800bd84:	e74e      	b.n	800bc24 <__adddf3+0x8c>
 800bd86:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800bd8a:	bf18      	it	ne
 800bd8c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800bd90:	d029      	beq.n	800bde6 <__adddf3+0x24e>
 800bd92:	ea94 0f05 	teq	r4, r5
 800bd96:	bf08      	it	eq
 800bd98:	ea90 0f02 	teqeq	r0, r2
 800bd9c:	d005      	beq.n	800bdaa <__adddf3+0x212>
 800bd9e:	ea54 0c00 	orrs.w	ip, r4, r0
 800bda2:	bf04      	itt	eq
 800bda4:	4619      	moveq	r1, r3
 800bda6:	4610      	moveq	r0, r2
 800bda8:	bd30      	pop	{r4, r5, pc}
 800bdaa:	ea91 0f03 	teq	r1, r3
 800bdae:	bf1e      	ittt	ne
 800bdb0:	2100      	movne	r1, #0
 800bdb2:	2000      	movne	r0, #0
 800bdb4:	bd30      	popne	{r4, r5, pc}
 800bdb6:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800bdba:	d105      	bne.n	800bdc8 <__adddf3+0x230>
 800bdbc:	0040      	lsls	r0, r0, #1
 800bdbe:	4149      	adcs	r1, r1
 800bdc0:	bf28      	it	cs
 800bdc2:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800bdc6:	bd30      	pop	{r4, r5, pc}
 800bdc8:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 800bdcc:	bf3c      	itt	cc
 800bdce:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800bdd2:	bd30      	popcc	{r4, r5, pc}
 800bdd4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800bdd8:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 800bddc:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800bde0:	f04f 0000 	mov.w	r0, #0
 800bde4:	bd30      	pop	{r4, r5, pc}
 800bde6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800bdea:	bf1a      	itte	ne
 800bdec:	4619      	movne	r1, r3
 800bdee:	4610      	movne	r0, r2
 800bdf0:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 800bdf4:	bf1c      	itt	ne
 800bdf6:	460b      	movne	r3, r1
 800bdf8:	4602      	movne	r2, r0
 800bdfa:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800bdfe:	bf06      	itte	eq
 800be00:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 800be04:	ea91 0f03 	teqeq	r1, r3
 800be08:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 800be0c:	bd30      	pop	{r4, r5, pc}
 800be0e:	bf00      	nop

0800be10 <__aeabi_ui2d>:
 800be10:	f090 0f00 	teq	r0, #0
 800be14:	bf04      	itt	eq
 800be16:	2100      	moveq	r1, #0
 800be18:	4770      	bxeq	lr
 800be1a:	b530      	push	{r4, r5, lr}
 800be1c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800be20:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800be24:	f04f 0500 	mov.w	r5, #0
 800be28:	f04f 0100 	mov.w	r1, #0
 800be2c:	e750      	b.n	800bcd0 <__adddf3+0x138>
 800be2e:	bf00      	nop

0800be30 <__aeabi_i2d>:
 800be30:	f090 0f00 	teq	r0, #0
 800be34:	bf04      	itt	eq
 800be36:	2100      	moveq	r1, #0
 800be38:	4770      	bxeq	lr
 800be3a:	b530      	push	{r4, r5, lr}
 800be3c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800be40:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800be44:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800be48:	bf48      	it	mi
 800be4a:	4240      	negmi	r0, r0
 800be4c:	f04f 0100 	mov.w	r1, #0
 800be50:	e73e      	b.n	800bcd0 <__adddf3+0x138>
 800be52:	bf00      	nop

0800be54 <__aeabi_f2d>:
 800be54:	0042      	lsls	r2, r0, #1
 800be56:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800be5a:	ea4f 0131 	mov.w	r1, r1, rrx
 800be5e:	ea4f 7002 	mov.w	r0, r2, lsl #28
 800be62:	bf1f      	itttt	ne
 800be64:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800be68:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800be6c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 800be70:	4770      	bxne	lr
 800be72:	f092 0f00 	teq	r2, #0
 800be76:	bf14      	ite	ne
 800be78:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 800be7c:	4770      	bxeq	lr
 800be7e:	b530      	push	{r4, r5, lr}
 800be80:	f44f 7460 	mov.w	r4, #896	; 0x380
 800be84:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800be88:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800be8c:	e720      	b.n	800bcd0 <__adddf3+0x138>
 800be8e:	bf00      	nop

0800be90 <__aeabi_ul2d>:
 800be90:	ea50 0201 	orrs.w	r2, r0, r1
 800be94:	bf08      	it	eq
 800be96:	4770      	bxeq	lr
 800be98:	b530      	push	{r4, r5, lr}
 800be9a:	f04f 0500 	mov.w	r5, #0
 800be9e:	e00a      	b.n	800beb6 <__aeabi_l2d+0x16>

0800bea0 <__aeabi_l2d>:
 800bea0:	ea50 0201 	orrs.w	r2, r0, r1
 800bea4:	bf08      	it	eq
 800bea6:	4770      	bxeq	lr
 800bea8:	b530      	push	{r4, r5, lr}
 800beaa:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800beae:	d502      	bpl.n	800beb6 <__aeabi_l2d+0x16>
 800beb0:	4240      	negs	r0, r0
 800beb2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800beb6:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800beba:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800bebe:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800bec2:	f43f aedc 	beq.w	800bc7e <__adddf3+0xe6>
 800bec6:	f04f 0203 	mov.w	r2, #3
 800beca:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800bece:	bf18      	it	ne
 800bed0:	3203      	addne	r2, #3
 800bed2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800bed6:	bf18      	it	ne
 800bed8:	3203      	addne	r2, #3
 800beda:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800bede:	f1c2 0320 	rsb	r3, r2, #32
 800bee2:	fa00 fc03 	lsl.w	ip, r0, r3
 800bee6:	fa20 f002 	lsr.w	r0, r0, r2
 800beea:	fa01 fe03 	lsl.w	lr, r1, r3
 800beee:	ea40 000e 	orr.w	r0, r0, lr
 800bef2:	fa21 f102 	lsr.w	r1, r1, r2
 800bef6:	4414      	add	r4, r2
 800bef8:	e6c1      	b.n	800bc7e <__adddf3+0xe6>
 800befa:	bf00      	nop

0800befc <__aeabi_dmul>:
 800befc:	b570      	push	{r4, r5, r6, lr}
 800befe:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800bf02:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800bf06:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800bf0a:	bf1d      	ittte	ne
 800bf0c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800bf10:	ea94 0f0c 	teqne	r4, ip
 800bf14:	ea95 0f0c 	teqne	r5, ip
 800bf18:	f000 f8de 	bleq	800c0d8 <__aeabi_dmul+0x1dc>
 800bf1c:	442c      	add	r4, r5
 800bf1e:	ea81 0603 	eor.w	r6, r1, r3
 800bf22:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800bf26:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800bf2a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800bf2e:	bf18      	it	ne
 800bf30:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 800bf34:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800bf38:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800bf3c:	d038      	beq.n	800bfb0 <__aeabi_dmul+0xb4>
 800bf3e:	fba0 ce02 	umull	ip, lr, r0, r2
 800bf42:	f04f 0500 	mov.w	r5, #0
 800bf46:	fbe1 e502 	umlal	lr, r5, r1, r2
 800bf4a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800bf4e:	fbe0 e503 	umlal	lr, r5, r0, r3
 800bf52:	f04f 0600 	mov.w	r6, #0
 800bf56:	fbe1 5603 	umlal	r5, r6, r1, r3
 800bf5a:	f09c 0f00 	teq	ip, #0
 800bf5e:	bf18      	it	ne
 800bf60:	f04e 0e01 	orrne.w	lr, lr, #1
 800bf64:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800bf68:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 800bf6c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800bf70:	d204      	bcs.n	800bf7c <__aeabi_dmul+0x80>
 800bf72:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800bf76:	416d      	adcs	r5, r5
 800bf78:	eb46 0606 	adc.w	r6, r6, r6
 800bf7c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800bf80:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 800bf84:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800bf88:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 800bf8c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800bf90:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800bf94:	bf88      	it	hi
 800bf96:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800bf9a:	d81e      	bhi.n	800bfda <__aeabi_dmul+0xde>
 800bf9c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800bfa0:	bf08      	it	eq
 800bfa2:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800bfa6:	f150 0000 	adcs.w	r0, r0, #0
 800bfaa:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800bfae:	bd70      	pop	{r4, r5, r6, pc}
 800bfb0:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 800bfb4:	ea46 0101 	orr.w	r1, r6, r1
 800bfb8:	ea40 0002 	orr.w	r0, r0, r2
 800bfbc:	ea81 0103 	eor.w	r1, r1, r3
 800bfc0:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800bfc4:	bfc2      	ittt	gt
 800bfc6:	ebd4 050c 	rsbsgt	r5, r4, ip
 800bfca:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800bfce:	bd70      	popgt	{r4, r5, r6, pc}
 800bfd0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800bfd4:	f04f 0e00 	mov.w	lr, #0
 800bfd8:	3c01      	subs	r4, #1
 800bfda:	f300 80ab 	bgt.w	800c134 <__aeabi_dmul+0x238>
 800bfde:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800bfe2:	bfde      	ittt	le
 800bfe4:	2000      	movle	r0, #0
 800bfe6:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800bfea:	bd70      	pople	{r4, r5, r6, pc}
 800bfec:	f1c4 0400 	rsb	r4, r4, #0
 800bff0:	3c20      	subs	r4, #32
 800bff2:	da35      	bge.n	800c060 <__aeabi_dmul+0x164>
 800bff4:	340c      	adds	r4, #12
 800bff6:	dc1b      	bgt.n	800c030 <__aeabi_dmul+0x134>
 800bff8:	f104 0414 	add.w	r4, r4, #20
 800bffc:	f1c4 0520 	rsb	r5, r4, #32
 800c000:	fa00 f305 	lsl.w	r3, r0, r5
 800c004:	fa20 f004 	lsr.w	r0, r0, r4
 800c008:	fa01 f205 	lsl.w	r2, r1, r5
 800c00c:	ea40 0002 	orr.w	r0, r0, r2
 800c010:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800c014:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800c018:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800c01c:	fa21 f604 	lsr.w	r6, r1, r4
 800c020:	eb42 0106 	adc.w	r1, r2, r6
 800c024:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c028:	bf08      	it	eq
 800c02a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c02e:	bd70      	pop	{r4, r5, r6, pc}
 800c030:	f1c4 040c 	rsb	r4, r4, #12
 800c034:	f1c4 0520 	rsb	r5, r4, #32
 800c038:	fa00 f304 	lsl.w	r3, r0, r4
 800c03c:	fa20 f005 	lsr.w	r0, r0, r5
 800c040:	fa01 f204 	lsl.w	r2, r1, r4
 800c044:	ea40 0002 	orr.w	r0, r0, r2
 800c048:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c04c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800c050:	f141 0100 	adc.w	r1, r1, #0
 800c054:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c058:	bf08      	it	eq
 800c05a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c05e:	bd70      	pop	{r4, r5, r6, pc}
 800c060:	f1c4 0520 	rsb	r5, r4, #32
 800c064:	fa00 f205 	lsl.w	r2, r0, r5
 800c068:	ea4e 0e02 	orr.w	lr, lr, r2
 800c06c:	fa20 f304 	lsr.w	r3, r0, r4
 800c070:	fa01 f205 	lsl.w	r2, r1, r5
 800c074:	ea43 0302 	orr.w	r3, r3, r2
 800c078:	fa21 f004 	lsr.w	r0, r1, r4
 800c07c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c080:	fa21 f204 	lsr.w	r2, r1, r4
 800c084:	ea20 0002 	bic.w	r0, r0, r2
 800c088:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800c08c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800c090:	bf08      	it	eq
 800c092:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800c096:	bd70      	pop	{r4, r5, r6, pc}
 800c098:	f094 0f00 	teq	r4, #0
 800c09c:	d10f      	bne.n	800c0be <__aeabi_dmul+0x1c2>
 800c09e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800c0a2:	0040      	lsls	r0, r0, #1
 800c0a4:	eb41 0101 	adc.w	r1, r1, r1
 800c0a8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c0ac:	bf08      	it	eq
 800c0ae:	3c01      	subeq	r4, #1
 800c0b0:	d0f7      	beq.n	800c0a2 <__aeabi_dmul+0x1a6>
 800c0b2:	ea41 0106 	orr.w	r1, r1, r6
 800c0b6:	f095 0f00 	teq	r5, #0
 800c0ba:	bf18      	it	ne
 800c0bc:	4770      	bxne	lr
 800c0be:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800c0c2:	0052      	lsls	r2, r2, #1
 800c0c4:	eb43 0303 	adc.w	r3, r3, r3
 800c0c8:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800c0cc:	bf08      	it	eq
 800c0ce:	3d01      	subeq	r5, #1
 800c0d0:	d0f7      	beq.n	800c0c2 <__aeabi_dmul+0x1c6>
 800c0d2:	ea43 0306 	orr.w	r3, r3, r6
 800c0d6:	4770      	bx	lr
 800c0d8:	ea94 0f0c 	teq	r4, ip
 800c0dc:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800c0e0:	bf18      	it	ne
 800c0e2:	ea95 0f0c 	teqne	r5, ip
 800c0e6:	d00c      	beq.n	800c102 <__aeabi_dmul+0x206>
 800c0e8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c0ec:	bf18      	it	ne
 800c0ee:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c0f2:	d1d1      	bne.n	800c098 <__aeabi_dmul+0x19c>
 800c0f4:	ea81 0103 	eor.w	r1, r1, r3
 800c0f8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c0fc:	f04f 0000 	mov.w	r0, #0
 800c100:	bd70      	pop	{r4, r5, r6, pc}
 800c102:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c106:	bf06      	itte	eq
 800c108:	4610      	moveq	r0, r2
 800c10a:	4619      	moveq	r1, r3
 800c10c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c110:	d019      	beq.n	800c146 <__aeabi_dmul+0x24a>
 800c112:	ea94 0f0c 	teq	r4, ip
 800c116:	d102      	bne.n	800c11e <__aeabi_dmul+0x222>
 800c118:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800c11c:	d113      	bne.n	800c146 <__aeabi_dmul+0x24a>
 800c11e:	ea95 0f0c 	teq	r5, ip
 800c122:	d105      	bne.n	800c130 <__aeabi_dmul+0x234>
 800c124:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800c128:	bf1c      	itt	ne
 800c12a:	4610      	movne	r0, r2
 800c12c:	4619      	movne	r1, r3
 800c12e:	d10a      	bne.n	800c146 <__aeabi_dmul+0x24a>
 800c130:	ea81 0103 	eor.w	r1, r1, r3
 800c134:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800c138:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800c13c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800c140:	f04f 0000 	mov.w	r0, #0
 800c144:	bd70      	pop	{r4, r5, r6, pc}
 800c146:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800c14a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800c14e:	bd70      	pop	{r4, r5, r6, pc}

0800c150 <__aeabi_ddiv>:
 800c150:	b570      	push	{r4, r5, r6, lr}
 800c152:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800c156:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800c15a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800c15e:	bf1d      	ittte	ne
 800c160:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800c164:	ea94 0f0c 	teqne	r4, ip
 800c168:	ea95 0f0c 	teqne	r5, ip
 800c16c:	f000 f8a7 	bleq	800c2be <__aeabi_ddiv+0x16e>
 800c170:	eba4 0405 	sub.w	r4, r4, r5
 800c174:	ea81 0e03 	eor.w	lr, r1, r3
 800c178:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800c17c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800c180:	f000 8088 	beq.w	800c294 <__aeabi_ddiv+0x144>
 800c184:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800c188:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800c18c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800c190:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800c194:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800c198:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800c19c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800c1a0:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800c1a4:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800c1a8:	429d      	cmp	r5, r3
 800c1aa:	bf08      	it	eq
 800c1ac:	4296      	cmpeq	r6, r2
 800c1ae:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800c1b2:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800c1b6:	d202      	bcs.n	800c1be <__aeabi_ddiv+0x6e>
 800c1b8:	085b      	lsrs	r3, r3, #1
 800c1ba:	ea4f 0232 	mov.w	r2, r2, rrx
 800c1be:	1ab6      	subs	r6, r6, r2
 800c1c0:	eb65 0503 	sbc.w	r5, r5, r3
 800c1c4:	085b      	lsrs	r3, r3, #1
 800c1c6:	ea4f 0232 	mov.w	r2, r2, rrx
 800c1ca:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800c1ce:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800c1d2:	ebb6 0e02 	subs.w	lr, r6, r2
 800c1d6:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c1da:	bf22      	ittt	cs
 800c1dc:	1ab6      	subcs	r6, r6, r2
 800c1de:	4675      	movcs	r5, lr
 800c1e0:	ea40 000c 	orrcs.w	r0, r0, ip
 800c1e4:	085b      	lsrs	r3, r3, #1
 800c1e6:	ea4f 0232 	mov.w	r2, r2, rrx
 800c1ea:	ebb6 0e02 	subs.w	lr, r6, r2
 800c1ee:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c1f2:	bf22      	ittt	cs
 800c1f4:	1ab6      	subcs	r6, r6, r2
 800c1f6:	4675      	movcs	r5, lr
 800c1f8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800c1fc:	085b      	lsrs	r3, r3, #1
 800c1fe:	ea4f 0232 	mov.w	r2, r2, rrx
 800c202:	ebb6 0e02 	subs.w	lr, r6, r2
 800c206:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c20a:	bf22      	ittt	cs
 800c20c:	1ab6      	subcs	r6, r6, r2
 800c20e:	4675      	movcs	r5, lr
 800c210:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800c214:	085b      	lsrs	r3, r3, #1
 800c216:	ea4f 0232 	mov.w	r2, r2, rrx
 800c21a:	ebb6 0e02 	subs.w	lr, r6, r2
 800c21e:	eb75 0e03 	sbcs.w	lr, r5, r3
 800c222:	bf22      	ittt	cs
 800c224:	1ab6      	subcs	r6, r6, r2
 800c226:	4675      	movcs	r5, lr
 800c228:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800c22c:	ea55 0e06 	orrs.w	lr, r5, r6
 800c230:	d018      	beq.n	800c264 <__aeabi_ddiv+0x114>
 800c232:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800c236:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800c23a:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800c23e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800c242:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800c246:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800c24a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800c24e:	d1c0      	bne.n	800c1d2 <__aeabi_ddiv+0x82>
 800c250:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c254:	d10b      	bne.n	800c26e <__aeabi_ddiv+0x11e>
 800c256:	ea41 0100 	orr.w	r1, r1, r0
 800c25a:	f04f 0000 	mov.w	r0, #0
 800c25e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800c262:	e7b6      	b.n	800c1d2 <__aeabi_ddiv+0x82>
 800c264:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800c268:	bf04      	itt	eq
 800c26a:	4301      	orreq	r1, r0
 800c26c:	2000      	moveq	r0, #0
 800c26e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800c272:	bf88      	it	hi
 800c274:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800c278:	f63f aeaf 	bhi.w	800bfda <__aeabi_dmul+0xde>
 800c27c:	ebb5 0c03 	subs.w	ip, r5, r3
 800c280:	bf04      	itt	eq
 800c282:	ebb6 0c02 	subseq.w	ip, r6, r2
 800c286:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800c28a:	f150 0000 	adcs.w	r0, r0, #0
 800c28e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800c292:	bd70      	pop	{r4, r5, r6, pc}
 800c294:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800c298:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800c29c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800c2a0:	bfc2      	ittt	gt
 800c2a2:	ebd4 050c 	rsbsgt	r5, r4, ip
 800c2a6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800c2aa:	bd70      	popgt	{r4, r5, r6, pc}
 800c2ac:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800c2b0:	f04f 0e00 	mov.w	lr, #0
 800c2b4:	3c01      	subs	r4, #1
 800c2b6:	e690      	b.n	800bfda <__aeabi_dmul+0xde>
 800c2b8:	ea45 0e06 	orr.w	lr, r5, r6
 800c2bc:	e68d      	b.n	800bfda <__aeabi_dmul+0xde>
 800c2be:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800c2c2:	ea94 0f0c 	teq	r4, ip
 800c2c6:	bf08      	it	eq
 800c2c8:	ea95 0f0c 	teqeq	r5, ip
 800c2cc:	f43f af3b 	beq.w	800c146 <__aeabi_dmul+0x24a>
 800c2d0:	ea94 0f0c 	teq	r4, ip
 800c2d4:	d10a      	bne.n	800c2ec <__aeabi_ddiv+0x19c>
 800c2d6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800c2da:	f47f af34 	bne.w	800c146 <__aeabi_dmul+0x24a>
 800c2de:	ea95 0f0c 	teq	r5, ip
 800c2e2:	f47f af25 	bne.w	800c130 <__aeabi_dmul+0x234>
 800c2e6:	4610      	mov	r0, r2
 800c2e8:	4619      	mov	r1, r3
 800c2ea:	e72c      	b.n	800c146 <__aeabi_dmul+0x24a>
 800c2ec:	ea95 0f0c 	teq	r5, ip
 800c2f0:	d106      	bne.n	800c300 <__aeabi_ddiv+0x1b0>
 800c2f2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800c2f6:	f43f aefd 	beq.w	800c0f4 <__aeabi_dmul+0x1f8>
 800c2fa:	4610      	mov	r0, r2
 800c2fc:	4619      	mov	r1, r3
 800c2fe:	e722      	b.n	800c146 <__aeabi_dmul+0x24a>
 800c300:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800c304:	bf18      	it	ne
 800c306:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800c30a:	f47f aec5 	bne.w	800c098 <__aeabi_dmul+0x19c>
 800c30e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800c312:	f47f af0d 	bne.w	800c130 <__aeabi_dmul+0x234>
 800c316:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800c31a:	f47f aeeb 	bne.w	800c0f4 <__aeabi_dmul+0x1f8>
 800c31e:	e712      	b.n	800c146 <__aeabi_dmul+0x24a>

0800c320 <__aeabi_d2uiz>:
 800c320:	004a      	lsls	r2, r1, #1
 800c322:	d211      	bcs.n	800c348 <__aeabi_d2uiz+0x28>
 800c324:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800c328:	d211      	bcs.n	800c34e <__aeabi_d2uiz+0x2e>
 800c32a:	d50d      	bpl.n	800c348 <__aeabi_d2uiz+0x28>
 800c32c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 800c330:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 800c334:	d40e      	bmi.n	800c354 <__aeabi_d2uiz+0x34>
 800c336:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800c33a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800c33e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 800c342:	fa23 f002 	lsr.w	r0, r3, r2
 800c346:	4770      	bx	lr
 800c348:	f04f 0000 	mov.w	r0, #0
 800c34c:	4770      	bx	lr
 800c34e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800c352:	d102      	bne.n	800c35a <__aeabi_d2uiz+0x3a>
 800c354:	f04f 30ff 	mov.w	r0, #4294967295
 800c358:	4770      	bx	lr
 800c35a:	f04f 0000 	mov.w	r0, #0
 800c35e:	4770      	bx	lr

0800c360 <__aeabi_ldivmod>:
 800c360:	b97b      	cbnz	r3, 800c382 <__aeabi_ldivmod+0x22>
 800c362:	b972      	cbnz	r2, 800c382 <__aeabi_ldivmod+0x22>
 800c364:	2900      	cmp	r1, #0
 800c366:	bfbe      	ittt	lt
 800c368:	2000      	movlt	r0, #0
 800c36a:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 800c36e:	e006      	blt.n	800c37e <__aeabi_ldivmod+0x1e>
 800c370:	bf08      	it	eq
 800c372:	2800      	cmpeq	r0, #0
 800c374:	bf1c      	itt	ne
 800c376:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 800c37a:	f04f 30ff 	movne.w	r0, #4294967295
 800c37e:	f000 b9ad 	b.w	800c6dc <__aeabi_idiv0>
 800c382:	f1ad 0c08 	sub.w	ip, sp, #8
 800c386:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 800c38a:	2900      	cmp	r1, #0
 800c38c:	db09      	blt.n	800c3a2 <__aeabi_ldivmod+0x42>
 800c38e:	2b00      	cmp	r3, #0
 800c390:	db1a      	blt.n	800c3c8 <__aeabi_ldivmod+0x68>
 800c392:	f000 f835 	bl	800c400 <__udivmoddi4>
 800c396:	f8dd e004 	ldr.w	lr, [sp, #4]
 800c39a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800c39e:	b004      	add	sp, #16
 800c3a0:	4770      	bx	lr
 800c3a2:	4240      	negs	r0, r0
 800c3a4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800c3a8:	2b00      	cmp	r3, #0
 800c3aa:	db1b      	blt.n	800c3e4 <__aeabi_ldivmod+0x84>
 800c3ac:	f000 f828 	bl	800c400 <__udivmoddi4>
 800c3b0:	f8dd e004 	ldr.w	lr, [sp, #4]
 800c3b4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800c3b8:	b004      	add	sp, #16
 800c3ba:	4240      	negs	r0, r0
 800c3bc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800c3c0:	4252      	negs	r2, r2
 800c3c2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800c3c6:	4770      	bx	lr
 800c3c8:	4252      	negs	r2, r2
 800c3ca:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800c3ce:	f000 f817 	bl	800c400 <__udivmoddi4>
 800c3d2:	f8dd e004 	ldr.w	lr, [sp, #4]
 800c3d6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800c3da:	b004      	add	sp, #16
 800c3dc:	4240      	negs	r0, r0
 800c3de:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800c3e2:	4770      	bx	lr
 800c3e4:	4252      	negs	r2, r2
 800c3e6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800c3ea:	f000 f809 	bl	800c400 <__udivmoddi4>
 800c3ee:	f8dd e004 	ldr.w	lr, [sp, #4]
 800c3f2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800c3f6:	b004      	add	sp, #16
 800c3f8:	4252      	negs	r2, r2
 800c3fa:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800c3fe:	4770      	bx	lr

0800c400 <__udivmoddi4>:
 800c400:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800c404:	468c      	mov	ip, r1
 800c406:	460d      	mov	r5, r1
 800c408:	4604      	mov	r4, r0
 800c40a:	9e08      	ldr	r6, [sp, #32]
 800c40c:	2b00      	cmp	r3, #0
 800c40e:	d151      	bne.n	800c4b4 <__udivmoddi4+0xb4>
 800c410:	428a      	cmp	r2, r1
 800c412:	4617      	mov	r7, r2
 800c414:	d96d      	bls.n	800c4f2 <__udivmoddi4+0xf2>
 800c416:	fab2 fe82 	clz	lr, r2
 800c41a:	f1be 0f00 	cmp.w	lr, #0
 800c41e:	d00b      	beq.n	800c438 <__udivmoddi4+0x38>
 800c420:	f1ce 0c20 	rsb	ip, lr, #32
 800c424:	fa01 f50e 	lsl.w	r5, r1, lr
 800c428:	fa20 fc0c 	lsr.w	ip, r0, ip
 800c42c:	fa02 f70e 	lsl.w	r7, r2, lr
 800c430:	ea4c 0c05 	orr.w	ip, ip, r5
 800c434:	fa00 f40e 	lsl.w	r4, r0, lr
 800c438:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 800c43c:	0c25      	lsrs	r5, r4, #16
 800c43e:	fbbc f8fa 	udiv	r8, ip, sl
 800c442:	fa1f f987 	uxth.w	r9, r7
 800c446:	fb0a cc18 	mls	ip, sl, r8, ip
 800c44a:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 800c44e:	fb08 f309 	mul.w	r3, r8, r9
 800c452:	42ab      	cmp	r3, r5
 800c454:	d90a      	bls.n	800c46c <__udivmoddi4+0x6c>
 800c456:	19ed      	adds	r5, r5, r7
 800c458:	f108 32ff 	add.w	r2, r8, #4294967295
 800c45c:	f080 8123 	bcs.w	800c6a6 <__udivmoddi4+0x2a6>
 800c460:	42ab      	cmp	r3, r5
 800c462:	f240 8120 	bls.w	800c6a6 <__udivmoddi4+0x2a6>
 800c466:	f1a8 0802 	sub.w	r8, r8, #2
 800c46a:	443d      	add	r5, r7
 800c46c:	1aed      	subs	r5, r5, r3
 800c46e:	b2a4      	uxth	r4, r4
 800c470:	fbb5 f0fa 	udiv	r0, r5, sl
 800c474:	fb0a 5510 	mls	r5, sl, r0, r5
 800c478:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 800c47c:	fb00 f909 	mul.w	r9, r0, r9
 800c480:	45a1      	cmp	r9, r4
 800c482:	d909      	bls.n	800c498 <__udivmoddi4+0x98>
 800c484:	19e4      	adds	r4, r4, r7
 800c486:	f100 33ff 	add.w	r3, r0, #4294967295
 800c48a:	f080 810a 	bcs.w	800c6a2 <__udivmoddi4+0x2a2>
 800c48e:	45a1      	cmp	r9, r4
 800c490:	f240 8107 	bls.w	800c6a2 <__udivmoddi4+0x2a2>
 800c494:	3802      	subs	r0, #2
 800c496:	443c      	add	r4, r7
 800c498:	eba4 0409 	sub.w	r4, r4, r9
 800c49c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 800c4a0:	2100      	movs	r1, #0
 800c4a2:	2e00      	cmp	r6, #0
 800c4a4:	d061      	beq.n	800c56a <__udivmoddi4+0x16a>
 800c4a6:	fa24 f40e 	lsr.w	r4, r4, lr
 800c4aa:	2300      	movs	r3, #0
 800c4ac:	6034      	str	r4, [r6, #0]
 800c4ae:	6073      	str	r3, [r6, #4]
 800c4b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800c4b4:	428b      	cmp	r3, r1
 800c4b6:	d907      	bls.n	800c4c8 <__udivmoddi4+0xc8>
 800c4b8:	2e00      	cmp	r6, #0
 800c4ba:	d054      	beq.n	800c566 <__udivmoddi4+0x166>
 800c4bc:	2100      	movs	r1, #0
 800c4be:	e886 0021 	stmia.w	r6, {r0, r5}
 800c4c2:	4608      	mov	r0, r1
 800c4c4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800c4c8:	fab3 f183 	clz	r1, r3
 800c4cc:	2900      	cmp	r1, #0
 800c4ce:	f040 808e 	bne.w	800c5ee <__udivmoddi4+0x1ee>
 800c4d2:	42ab      	cmp	r3, r5
 800c4d4:	d302      	bcc.n	800c4dc <__udivmoddi4+0xdc>
 800c4d6:	4282      	cmp	r2, r0
 800c4d8:	f200 80fa 	bhi.w	800c6d0 <__udivmoddi4+0x2d0>
 800c4dc:	1a84      	subs	r4, r0, r2
 800c4de:	eb65 0503 	sbc.w	r5, r5, r3
 800c4e2:	2001      	movs	r0, #1
 800c4e4:	46ac      	mov	ip, r5
 800c4e6:	2e00      	cmp	r6, #0
 800c4e8:	d03f      	beq.n	800c56a <__udivmoddi4+0x16a>
 800c4ea:	e886 1010 	stmia.w	r6, {r4, ip}
 800c4ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800c4f2:	b912      	cbnz	r2, 800c4fa <__udivmoddi4+0xfa>
 800c4f4:	2701      	movs	r7, #1
 800c4f6:	fbb7 f7f2 	udiv	r7, r7, r2
 800c4fa:	fab7 fe87 	clz	lr, r7
 800c4fe:	f1be 0f00 	cmp.w	lr, #0
 800c502:	d134      	bne.n	800c56e <__udivmoddi4+0x16e>
 800c504:	1beb      	subs	r3, r5, r7
 800c506:	0c3a      	lsrs	r2, r7, #16
 800c508:	fa1f fc87 	uxth.w	ip, r7
 800c50c:	2101      	movs	r1, #1
 800c50e:	fbb3 f8f2 	udiv	r8, r3, r2
 800c512:	0c25      	lsrs	r5, r4, #16
 800c514:	fb02 3318 	mls	r3, r2, r8, r3
 800c518:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 800c51c:	fb0c f308 	mul.w	r3, ip, r8
 800c520:	42ab      	cmp	r3, r5
 800c522:	d907      	bls.n	800c534 <__udivmoddi4+0x134>
 800c524:	19ed      	adds	r5, r5, r7
 800c526:	f108 30ff 	add.w	r0, r8, #4294967295
 800c52a:	d202      	bcs.n	800c532 <__udivmoddi4+0x132>
 800c52c:	42ab      	cmp	r3, r5
 800c52e:	f200 80d1 	bhi.w	800c6d4 <__udivmoddi4+0x2d4>
 800c532:	4680      	mov	r8, r0
 800c534:	1aed      	subs	r5, r5, r3
 800c536:	b2a3      	uxth	r3, r4
 800c538:	fbb5 f0f2 	udiv	r0, r5, r2
 800c53c:	fb02 5510 	mls	r5, r2, r0, r5
 800c540:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 800c544:	fb0c fc00 	mul.w	ip, ip, r0
 800c548:	45a4      	cmp	ip, r4
 800c54a:	d907      	bls.n	800c55c <__udivmoddi4+0x15c>
 800c54c:	19e4      	adds	r4, r4, r7
 800c54e:	f100 33ff 	add.w	r3, r0, #4294967295
 800c552:	d202      	bcs.n	800c55a <__udivmoddi4+0x15a>
 800c554:	45a4      	cmp	ip, r4
 800c556:	f200 80b8 	bhi.w	800c6ca <__udivmoddi4+0x2ca>
 800c55a:	4618      	mov	r0, r3
 800c55c:	eba4 040c 	sub.w	r4, r4, ip
 800c560:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 800c564:	e79d      	b.n	800c4a2 <__udivmoddi4+0xa2>
 800c566:	4631      	mov	r1, r6
 800c568:	4630      	mov	r0, r6
 800c56a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800c56e:	f1ce 0420 	rsb	r4, lr, #32
 800c572:	fa05 f30e 	lsl.w	r3, r5, lr
 800c576:	fa07 f70e 	lsl.w	r7, r7, lr
 800c57a:	fa20 f804 	lsr.w	r8, r0, r4
 800c57e:	0c3a      	lsrs	r2, r7, #16
 800c580:	fa25 f404 	lsr.w	r4, r5, r4
 800c584:	ea48 0803 	orr.w	r8, r8, r3
 800c588:	fbb4 f1f2 	udiv	r1, r4, r2
 800c58c:	ea4f 4518 	mov.w	r5, r8, lsr #16
 800c590:	fb02 4411 	mls	r4, r2, r1, r4
 800c594:	fa1f fc87 	uxth.w	ip, r7
 800c598:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 800c59c:	fb01 f30c 	mul.w	r3, r1, ip
 800c5a0:	42ab      	cmp	r3, r5
 800c5a2:	fa00 f40e 	lsl.w	r4, r0, lr
 800c5a6:	d909      	bls.n	800c5bc <__udivmoddi4+0x1bc>
 800c5a8:	19ed      	adds	r5, r5, r7
 800c5aa:	f101 30ff 	add.w	r0, r1, #4294967295
 800c5ae:	f080 808a 	bcs.w	800c6c6 <__udivmoddi4+0x2c6>
 800c5b2:	42ab      	cmp	r3, r5
 800c5b4:	f240 8087 	bls.w	800c6c6 <__udivmoddi4+0x2c6>
 800c5b8:	3902      	subs	r1, #2
 800c5ba:	443d      	add	r5, r7
 800c5bc:	1aeb      	subs	r3, r5, r3
 800c5be:	fa1f f588 	uxth.w	r5, r8
 800c5c2:	fbb3 f0f2 	udiv	r0, r3, r2
 800c5c6:	fb02 3310 	mls	r3, r2, r0, r3
 800c5ca:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 800c5ce:	fb00 f30c 	mul.w	r3, r0, ip
 800c5d2:	42ab      	cmp	r3, r5
 800c5d4:	d907      	bls.n	800c5e6 <__udivmoddi4+0x1e6>
 800c5d6:	19ed      	adds	r5, r5, r7
 800c5d8:	f100 38ff 	add.w	r8, r0, #4294967295
 800c5dc:	d26f      	bcs.n	800c6be <__udivmoddi4+0x2be>
 800c5de:	42ab      	cmp	r3, r5
 800c5e0:	d96d      	bls.n	800c6be <__udivmoddi4+0x2be>
 800c5e2:	3802      	subs	r0, #2
 800c5e4:	443d      	add	r5, r7
 800c5e6:	1aeb      	subs	r3, r5, r3
 800c5e8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 800c5ec:	e78f      	b.n	800c50e <__udivmoddi4+0x10e>
 800c5ee:	f1c1 0720 	rsb	r7, r1, #32
 800c5f2:	fa22 f807 	lsr.w	r8, r2, r7
 800c5f6:	408b      	lsls	r3, r1
 800c5f8:	fa05 f401 	lsl.w	r4, r5, r1
 800c5fc:	ea48 0303 	orr.w	r3, r8, r3
 800c600:	fa20 fe07 	lsr.w	lr, r0, r7
 800c604:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 800c608:	40fd      	lsrs	r5, r7
 800c60a:	ea4e 0e04 	orr.w	lr, lr, r4
 800c60e:	fbb5 f9fc 	udiv	r9, r5, ip
 800c612:	ea4f 441e 	mov.w	r4, lr, lsr #16
 800c616:	fb0c 5519 	mls	r5, ip, r9, r5
 800c61a:	fa1f f883 	uxth.w	r8, r3
 800c61e:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 800c622:	fb09 f408 	mul.w	r4, r9, r8
 800c626:	42ac      	cmp	r4, r5
 800c628:	fa02 f201 	lsl.w	r2, r2, r1
 800c62c:	fa00 fa01 	lsl.w	sl, r0, r1
 800c630:	d908      	bls.n	800c644 <__udivmoddi4+0x244>
 800c632:	18ed      	adds	r5, r5, r3
 800c634:	f109 30ff 	add.w	r0, r9, #4294967295
 800c638:	d243      	bcs.n	800c6c2 <__udivmoddi4+0x2c2>
 800c63a:	42ac      	cmp	r4, r5
 800c63c:	d941      	bls.n	800c6c2 <__udivmoddi4+0x2c2>
 800c63e:	f1a9 0902 	sub.w	r9, r9, #2
 800c642:	441d      	add	r5, r3
 800c644:	1b2d      	subs	r5, r5, r4
 800c646:	fa1f fe8e 	uxth.w	lr, lr
 800c64a:	fbb5 f0fc 	udiv	r0, r5, ip
 800c64e:	fb0c 5510 	mls	r5, ip, r0, r5
 800c652:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 800c656:	fb00 f808 	mul.w	r8, r0, r8
 800c65a:	45a0      	cmp	r8, r4
 800c65c:	d907      	bls.n	800c66e <__udivmoddi4+0x26e>
 800c65e:	18e4      	adds	r4, r4, r3
 800c660:	f100 35ff 	add.w	r5, r0, #4294967295
 800c664:	d229      	bcs.n	800c6ba <__udivmoddi4+0x2ba>
 800c666:	45a0      	cmp	r8, r4
 800c668:	d927      	bls.n	800c6ba <__udivmoddi4+0x2ba>
 800c66a:	3802      	subs	r0, #2
 800c66c:	441c      	add	r4, r3
 800c66e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800c672:	eba4 0408 	sub.w	r4, r4, r8
 800c676:	fba0 8902 	umull	r8, r9, r0, r2
 800c67a:	454c      	cmp	r4, r9
 800c67c:	46c6      	mov	lr, r8
 800c67e:	464d      	mov	r5, r9
 800c680:	d315      	bcc.n	800c6ae <__udivmoddi4+0x2ae>
 800c682:	d012      	beq.n	800c6aa <__udivmoddi4+0x2aa>
 800c684:	b156      	cbz	r6, 800c69c <__udivmoddi4+0x29c>
 800c686:	ebba 030e 	subs.w	r3, sl, lr
 800c68a:	eb64 0405 	sbc.w	r4, r4, r5
 800c68e:	fa04 f707 	lsl.w	r7, r4, r7
 800c692:	40cb      	lsrs	r3, r1
 800c694:	431f      	orrs	r7, r3
 800c696:	40cc      	lsrs	r4, r1
 800c698:	6037      	str	r7, [r6, #0]
 800c69a:	6074      	str	r4, [r6, #4]
 800c69c:	2100      	movs	r1, #0
 800c69e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800c6a2:	4618      	mov	r0, r3
 800c6a4:	e6f8      	b.n	800c498 <__udivmoddi4+0x98>
 800c6a6:	4690      	mov	r8, r2
 800c6a8:	e6e0      	b.n	800c46c <__udivmoddi4+0x6c>
 800c6aa:	45c2      	cmp	sl, r8
 800c6ac:	d2ea      	bcs.n	800c684 <__udivmoddi4+0x284>
 800c6ae:	ebb8 0e02 	subs.w	lr, r8, r2
 800c6b2:	eb69 0503 	sbc.w	r5, r9, r3
 800c6b6:	3801      	subs	r0, #1
 800c6b8:	e7e4      	b.n	800c684 <__udivmoddi4+0x284>
 800c6ba:	4628      	mov	r0, r5
 800c6bc:	e7d7      	b.n	800c66e <__udivmoddi4+0x26e>
 800c6be:	4640      	mov	r0, r8
 800c6c0:	e791      	b.n	800c5e6 <__udivmoddi4+0x1e6>
 800c6c2:	4681      	mov	r9, r0
 800c6c4:	e7be      	b.n	800c644 <__udivmoddi4+0x244>
 800c6c6:	4601      	mov	r1, r0
 800c6c8:	e778      	b.n	800c5bc <__udivmoddi4+0x1bc>
 800c6ca:	3802      	subs	r0, #2
 800c6cc:	443c      	add	r4, r7
 800c6ce:	e745      	b.n	800c55c <__udivmoddi4+0x15c>
 800c6d0:	4608      	mov	r0, r1
 800c6d2:	e708      	b.n	800c4e6 <__udivmoddi4+0xe6>
 800c6d4:	f1a8 0802 	sub.w	r8, r8, #2
 800c6d8:	443d      	add	r5, r7
 800c6da:	e72b      	b.n	800c534 <__udivmoddi4+0x134>

0800c6dc <__aeabi_idiv0>:
 800c6dc:	4770      	bx	lr
 800c6de:	bf00      	nop

0800c6e0 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800c6e0:	f8df d034 	ldr.w	sp, [pc, #52]	; 800c718 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800c6e4:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800c6e6:	e003      	b.n	800c6f0 <LoopCopyDataInit>

0800c6e8 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800c6e8:	4b0c      	ldr	r3, [pc, #48]	; (800c71c <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800c6ea:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800c6ec:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800c6ee:	3104      	adds	r1, #4

0800c6f0 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800c6f0:	480b      	ldr	r0, [pc, #44]	; (800c720 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800c6f2:	4b0c      	ldr	r3, [pc, #48]	; (800c724 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 800c6f4:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800c6f6:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800c6f8:	d3f6      	bcc.n	800c6e8 <CopyDataInit>
  ldr  r2, =_sbss
 800c6fa:	4a0b      	ldr	r2, [pc, #44]	; (800c728 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800c6fc:	e002      	b.n	800c704 <LoopFillZerobss>

0800c6fe <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800c6fe:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800c700:	f842 3b04 	str.w	r3, [r2], #4

0800c704 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800c704:	4b09      	ldr	r3, [pc, #36]	; (800c72c <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800c706:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800c708:	d3f9      	bcc.n	800c6fe <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800c70a:	f7ff f84f 	bl	800b7ac <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800c70e:	f000 f811 	bl	800c734 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800c712:	f7fe fad5 	bl	800acc0 <main>
  bx  lr    
 800c716:	4770      	bx	lr
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800c718:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 800c71c:	0800c7bc 	.word	0x0800c7bc
  ldr  r0, =_sdata
 800c720:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800c724:	20000698 	.word	0x20000698
  ldr  r2, =_sbss
 800c728:	20000698 	.word	0x20000698
  ldr  r3, = _ebss
 800c72c:	20000ec8 	.word	0x20000ec8

0800c730 <CAN1_RX0_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800c730:	e7fe      	b.n	800c730 <CAN1_RX0_IRQHandler>
	...

0800c734 <__libc_init_array>:
 800c734:	b570      	push	{r4, r5, r6, lr}
 800c736:	4e0d      	ldr	r6, [pc, #52]	; (800c76c <__libc_init_array+0x38>)
 800c738:	4c0d      	ldr	r4, [pc, #52]	; (800c770 <__libc_init_array+0x3c>)
 800c73a:	1ba4      	subs	r4, r4, r6
 800c73c:	10a4      	asrs	r4, r4, #2
 800c73e:	2500      	movs	r5, #0
 800c740:	42a5      	cmp	r5, r4
 800c742:	d109      	bne.n	800c758 <__libc_init_array+0x24>
 800c744:	4e0b      	ldr	r6, [pc, #44]	; (800c774 <__libc_init_array+0x40>)
 800c746:	4c0c      	ldr	r4, [pc, #48]	; (800c778 <__libc_init_array+0x44>)
 800c748:	f000 f822 	bl	800c790 <_init>
 800c74c:	1ba4      	subs	r4, r4, r6
 800c74e:	10a4      	asrs	r4, r4, #2
 800c750:	2500      	movs	r5, #0
 800c752:	42a5      	cmp	r5, r4
 800c754:	d105      	bne.n	800c762 <__libc_init_array+0x2e>
 800c756:	bd70      	pop	{r4, r5, r6, pc}
 800c758:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800c75c:	4798      	blx	r3
 800c75e:	3501      	adds	r5, #1
 800c760:	e7ee      	b.n	800c740 <__libc_init_array+0xc>
 800c762:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800c766:	4798      	blx	r3
 800c768:	3501      	adds	r5, #1
 800c76a:	e7f2      	b.n	800c752 <__libc_init_array+0x1e>
 800c76c:	0800c7b4 	.word	0x0800c7b4
 800c770:	0800c7b4 	.word	0x0800c7b4
 800c774:	0800c7b4 	.word	0x0800c7b4
 800c778:	0800c7b8 	.word	0x0800c7b8

0800c77c <_write>:
 800c77c:	4b02      	ldr	r3, [pc, #8]	; (800c788 <_write+0xc>)
 800c77e:	2258      	movs	r2, #88	; 0x58
 800c780:	601a      	str	r2, [r3, #0]
 800c782:	f04f 30ff 	mov.w	r0, #4294967295
 800c786:	4770      	bx	lr
 800c788:	20000ec4 	.word	0x20000ec4

0800c78c <__EH_FRAME_BEGIN__>:
 800c78c:	00000000                                ....

0800c790 <_init>:
 800c790:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c792:	bf00      	nop
 800c794:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c796:	bc08      	pop	{r3}
 800c798:	469e      	mov	lr, r3
 800c79a:	4770      	bx	lr

0800c79c <_fini>:
 800c79c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c79e:	bf00      	nop
 800c7a0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800c7a2:	bc08      	pop	{r3}
 800c7a4:	469e      	mov	lr, r3
 800c7a6:	4770      	bx	lr
